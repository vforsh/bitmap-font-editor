var Phaser = (function() {
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __require = /* @__PURE__ */ function(x) {
    return typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
      get: function(a, b) {
        return (typeof require !== "undefined" ? require : a)[b];
      }
    }) : x;
  }(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = function(cb, mod) {
    return function __require2() {
      return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    };
  };

  // ../../node_modules/phaser/src/polyfills/Array.forEach.js
  var require_Array_forEach = __commonJS({
    "../../node_modules/phaser/src/polyfills/Array.forEach.js": function() {
      if (!Array.prototype.forEach) {
        Array.prototype.forEach = function(fun) {
          "use strict";
          if (this === void 0 || this === null) {
            throw new TypeError();
          }
          var t = Object(this);
          var len = t.length >>> 0;
          if (typeof fun !== "function") {
            throw new TypeError();
          }
          var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
          for (var i = 0; i < len; i++) {
            if (i in t) {
              fun.call(thisArg, t[i], i, t);
            }
          }
        };
      }
    }
  });

  // ../../node_modules/phaser/src/polyfills/Array.isArray.js
  var require_Array_isArray = __commonJS({
    "../../node_modules/phaser/src/polyfills/Array.isArray.js": function() {
      if (!Array.isArray) {
        Array.isArray = function(arg) {
          return Object.prototype.toString.call(arg) === "[object Array]";
        };
      }
    }
  });

  // ../../node_modules/phaser/src/polyfills/AudioContextMonkeyPatch.js
  var require_AudioContextMonkeyPatch = __commonJS({
    "../../node_modules/phaser/src/polyfills/AudioContextMonkeyPatch.js": function() {
      (function() {
        function fixSetTarget(param) {
          if (!param)
            return;
          if (!param.setTargetAtTime)
            param.setTargetAtTime = param.setTargetValueAtTime;
        }
        if (window.hasOwnProperty("webkitAudioContext") && !window.hasOwnProperty("AudioContext")) {
          window.AudioContext = webkitAudioContext;
          if (!AudioContext.prototype.hasOwnProperty("createGain"))
            AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;
          if (!AudioContext.prototype.hasOwnProperty("createDelay"))
            AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;
          if (!AudioContext.prototype.hasOwnProperty("createScriptProcessor"))
            AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode;
          if (!AudioContext.prototype.hasOwnProperty("createPeriodicWave"))
            AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;
          AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain;
          AudioContext.prototype.createGain = function() {
            var node = this.internal_createGain();
            fixSetTarget(node.gain);
            return node;
          };
          AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay;
          AudioContext.prototype.createDelay = function(maxDelayTime) {
            var node = maxDelayTime ? this.internal_createDelay(maxDelayTime) : this.internal_createDelay();
            fixSetTarget(node.delayTime);
            return node;
          };
          AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource;
          AudioContext.prototype.createBufferSource = function() {
            var node = this.internal_createBufferSource();
            if (!node.start) {
              node.start = function(when, offset, duration) {
                if (offset || duration)
                  this.noteGrainOn(when || 0, offset, duration);
                else
                  this.noteOn(when || 0);
              };
            } else {
              node.internal_start = node.start;
              node.start = function(when, offset, duration) {
                if (typeof duration !== "undefined")
                  node.internal_start(when || 0, offset, duration);
                else
                  node.internal_start(when || 0, offset || 0);
              };
            }
            if (!node.stop) {
              node.stop = function(when) {
                this.noteOff(when || 0);
              };
            } else {
              node.internal_stop = node.stop;
              node.stop = function(when) {
                node.internal_stop(when || 0);
              };
            }
            fixSetTarget(node.playbackRate);
            return node;
          };
          AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor;
          AudioContext.prototype.createDynamicsCompressor = function() {
            var node = this.internal_createDynamicsCompressor();
            fixSetTarget(node.threshold);
            fixSetTarget(node.knee);
            fixSetTarget(node.ratio);
            fixSetTarget(node.reduction);
            fixSetTarget(node.attack);
            fixSetTarget(node.release);
            return node;
          };
          AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter;
          AudioContext.prototype.createBiquadFilter = function() {
            var node = this.internal_createBiquadFilter();
            fixSetTarget(node.frequency);
            fixSetTarget(node.detune);
            fixSetTarget(node.Q);
            fixSetTarget(node.gain);
            return node;
          };
          if (AudioContext.prototype.hasOwnProperty("createOscillator")) {
            AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator;
            AudioContext.prototype.createOscillator = function() {
              var node = this.internal_createOscillator();
              if (!node.start) {
                node.start = function(when) {
                  this.noteOn(when || 0);
                };
              } else {
                node.internal_start = node.start;
                node.start = function(when) {
                  node.internal_start(when || 0);
                };
              }
              if (!node.stop) {
                node.stop = function(when) {
                  this.noteOff(when || 0);
                };
              } else {
                node.internal_stop = node.stop;
                node.stop = function(when) {
                  node.internal_stop(when || 0);
                };
              }
              if (!node.setPeriodicWave)
                node.setPeriodicWave = node.setWaveTable;
              fixSetTarget(node.frequency);
              fixSetTarget(node.detune);
              return node;
            };
          }
        }
        if (window.hasOwnProperty("webkitOfflineAudioContext") && !window.hasOwnProperty("OfflineAudioContext")) {
          window.OfflineAudioContext = webkitOfflineAudioContext;
        }
      })();
    }
  });

  // ../../node_modules/phaser/src/polyfills/console.js
  var require_console = __commonJS({
    "../../node_modules/phaser/src/polyfills/console.js": function() {
      if (!window.console) {
        window.console = {};
        window.console.log = window.console.assert = function() {
        };
        window.console.warn = window.console.assert = function() {
        };
      }
    }
  });

  // ../../node_modules/phaser/src/polyfills/Math.trunc.js
  var require_Math_trunc = __commonJS({
    "../../node_modules/phaser/src/polyfills/Math.trunc.js": function() {
      if (!Math.trunc) {
        Math.trunc = function trunc(x) {
          return x < 0 ? Math.ceil(x) : Math.floor(x);
        };
      }
    }
  });

  // ../../node_modules/phaser/src/polyfills/performance.now.js
  var require_performance_now = __commonJS({
    "../../node_modules/phaser/src/polyfills/performance.now.js": function() {
      (function() {
        if ("performance" in window === false) {
          window.performance = {};
        }
        Date.now = Date.now || function() {
          return new Date().getTime();
        };
        if ("now" in window.performance === false) {
          var nowOffset = Date.now();
          if (performance.timing && performance.timing.navigationStart) {
            nowOffset = performance.timing.navigationStart;
          }
          window.performance.now = function now() {
            return Date.now() - nowOffset;
          };
        }
      })();
    }
  });

  // ../../node_modules/phaser/src/polyfills/requestAnimationFrame.js
  var require_requestAnimationFrame = __commonJS({
    "../../node_modules/phaser/src/polyfills/requestAnimationFrame.js": function() {
      var lastTime = Date.now();
      var vendors = ["ms", "moz", "webkit", "o"];
      for (x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {
        window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
        window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
      }
      var x;
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(callback) {
          if (typeof callback !== "function") {
            throw new TypeError(callback + "is not a function");
          }
          var currentTime = Date.now();
          var delay = 16 + lastTime - currentTime;
          if (delay < 0) {
            delay = 0;
          }
          lastTime = currentTime;
          return setTimeout(function() {
            lastTime = Date.now();
            callback(performance.now());
          }, delay);
        };
      }
      if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function(id) {
          clearTimeout(id);
        };
      }
    }
  });

  // ../../node_modules/phaser/src/polyfills/Uint32Array.js
  var require_Uint32Array = __commonJS({
    "../../node_modules/phaser/src/polyfills/Uint32Array.js": function() {
      if (typeof window.Uint32Array !== "function" && typeof window.Uint32Array !== "object") {
        CheapArray = function(fakeType) {
          var proto = new Array();
          window[fakeType] = function(arg) {
            if (typeof arg === "number") {
              Array.call(this, arg);
              this.length = arg;
              for (var i = 0; i < this.length; i++) {
                this[i] = 0;
              }
            } else {
              Array.call(this, arg.length);
              this.length = arg.length;
              for (var i = 0; i < this.length; i++) {
                this[i] = arg[i];
              }
            }
          };
          window[fakeType].prototype = proto;
          window[fakeType].constructor = window[fakeType];
        };
        CheapArray("Float32Array");
        CheapArray("Uint32Array");
        CheapArray("Uint16Array");
        CheapArray("Int16Array");
        CheapArray("ArrayBuffer");
        CheapArray("Int8Array");
        CheapArray("Uint8Array");
      }
      var CheapArray;
    }
  });

  // ../../node_modules/phaser/src/polyfills/index.js
  var require_polyfills = __commonJS({
    "../../node_modules/phaser/src/polyfills/index.js": function() {
      require_Array_forEach();
      require_Array_isArray();
      require_AudioContextMonkeyPatch();
      require_console();
      require_Math_trunc();
      require_performance_now();
      require_requestAnimationFrame();
      require_Uint32Array();
    }
  });

  // ../../node_modules/phaser/src/renderer/BlendModes.js
  var require_BlendModes = __commonJS({
    "../../node_modules/phaser/src/renderer/BlendModes.js": function(exports, module) {
      module.exports = {
        SKIP_CHECK: -1,
        NORMAL: 0,
        ADD: 1,
        MULTIPLY: 2,
        SCREEN: 3,
        OVERLAY: 4,
        DARKEN: 5,
        LIGHTEN: 6,
        COLOR_DODGE: 7,
        COLOR_BURN: 8,
        HARD_LIGHT: 9,
        SOFT_LIGHT: 10,
        DIFFERENCE: 11,
        EXCLUSION: 12,
        HUE: 13,
        SATURATION: 14,
        COLOR: 15,
        LUMINOSITY: 16,
        ERASE: 17,
        SOURCE_IN: 18,
        SOURCE_OUT: 19,
        SOURCE_ATOP: 20,
        DESTINATION_OVER: 21,
        DESTINATION_IN: 22,
        DESTINATION_OUT: 23,
        DESTINATION_ATOP: 24,
        LIGHTER: 25,
        COPY: 26,
        XOR: 27
      };
    }
  });

  // ../../node_modules/phaser/src/renderer/ScaleModes.js
  var require_ScaleModes = __commonJS({
    "../../node_modules/phaser/src/renderer/ScaleModes.js": function(exports, module) {
      var ScaleModes = {
        DEFAULT: 0,
        LINEAR: 0,
        NEAREST: 1
      };
      module.exports = ScaleModes;
    }
  });

  // ../../node_modules/phaser/src/const.js
  var require_const = __commonJS({
    "../../node_modules/phaser/src/const.js": function(exports, module) {
      var CONST = {
        VERSION: "3.60.0-beta.19",
        BlendModes: require_BlendModes(),
        ScaleModes: require_ScaleModes(),
        AUTO: 0,
        CANVAS: 1,
        WEBGL: 2,
        HEADLESS: 3,
        FOREVER: -1,
        NONE: 4,
        UP: 5,
        DOWN: 6,
        LEFT: 7,
        RIGHT: 8
      };
      module.exports = CONST;
    }
  });

  // ../../node_modules/phaser/src/utils/object/IsPlainObject.js
  var require_IsPlainObject = __commonJS({
    "../../node_modules/phaser/src/utils/object/IsPlainObject.js": function(exports, module) {
      var IsPlainObject = function(obj) {
        if (!obj || typeof obj !== "object" || obj.nodeType || obj === obj.window) {
          return false;
        }
        try {
          if (obj.constructor && !{}.hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf")) {
            return false;
          }
        } catch (e) {
          return false;
        }
        return true;
      };
      module.exports = IsPlainObject;
    }
  });

  // ../../node_modules/phaser/src/utils/object/Extend.js
  var require_Extend = __commonJS({
    "../../node_modules/phaser/src/utils/object/Extend.js": function(exports, module) {
      var IsPlainObject = require_IsPlainObject();
      var Extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[1] || {};
          i = 2;
        }
        if (length === i) {
          target = this;
          --i;
        }
        for (; i < length; i++) {
          if ((options = arguments[i]) != null) {
            for (name in options) {
              src = target[name];
              copy = options[name];
              if (target === copy) {
                continue;
              }
              if (deep && copy && (IsPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && Array.isArray(src) ? src : [];
                } else {
                  clone = src && IsPlainObject(src) ? src : {};
                }
                target[name] = Extend(deep, clone, copy);
              } else if (copy !== void 0) {
                target[name] = copy;
              }
            }
          }
        }
        return target;
      };
      module.exports = Extend;
    }
  });

  // ../../node_modules/phaser/src/display/align/const.js
  var require_const2 = __commonJS({
    "../../node_modules/phaser/src/display/align/const.js": function(exports, module) {
      var ALIGN_CONST = {
        TOP_LEFT: 0,
        TOP_CENTER: 1,
        TOP_RIGHT: 2,
        LEFT_TOP: 3,
        LEFT_CENTER: 4,
        LEFT_BOTTOM: 5,
        CENTER: 6,
        RIGHT_TOP: 7,
        RIGHT_CENTER: 8,
        RIGHT_BOTTOM: 9,
        BOTTOM_LEFT: 10,
        BOTTOM_CENTER: 11,
        BOTTOM_RIGHT: 12
      };
      module.exports = ALIGN_CONST;
    }
  });

  // ../../node_modules/phaser/src/display/bounds/GetBottom.js
  var require_GetBottom = __commonJS({
    "../../node_modules/phaser/src/display/bounds/GetBottom.js": function(exports, module) {
      var GetBottom = function(gameObject) {
        return gameObject.y + gameObject.height - gameObject.height * gameObject.originY;
      };
      module.exports = GetBottom;
    }
  });

  // ../../node_modules/phaser/src/display/bounds/GetCenterX.js
  var require_GetCenterX = __commonJS({
    "../../node_modules/phaser/src/display/bounds/GetCenterX.js": function(exports, module) {
      var GetCenterX = function(gameObject) {
        return gameObject.x - gameObject.width * gameObject.originX + gameObject.width * 0.5;
      };
      module.exports = GetCenterX;
    }
  });

  // ../../node_modules/phaser/src/display/bounds/SetBottom.js
  var require_SetBottom = __commonJS({
    "../../node_modules/phaser/src/display/bounds/SetBottom.js": function(exports, module) {
      var SetBottom = function(gameObject, value) {
        gameObject.y = value - gameObject.height + gameObject.height * gameObject.originY;
        return gameObject;
      };
      module.exports = SetBottom;
    }
  });

  // ../../node_modules/phaser/src/display/bounds/SetCenterX.js
  var require_SetCenterX = __commonJS({
    "../../node_modules/phaser/src/display/bounds/SetCenterX.js": function(exports, module) {
      var SetCenterX = function(gameObject, x) {
        var offsetX = gameObject.width * gameObject.originX;
        gameObject.x = x + offsetX - gameObject.width * 0.5;
        return gameObject;
      };
      module.exports = SetCenterX;
    }
  });

  // ../../node_modules/phaser/src/display/align/in/BottomCenter.js
  var require_BottomCenter = __commonJS({
    "../../node_modules/phaser/src/display/align/in/BottomCenter.js": function(exports, module) {
      var GetBottom = require_GetBottom();
      var GetCenterX = require_GetCenterX();
      var SetBottom = require_SetBottom();
      var SetCenterX = require_SetCenterX();
      var BottomCenter = function(gameObject, alignIn, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
        SetBottom(gameObject, GetBottom(alignIn) + offsetY);
        return gameObject;
      };
      module.exports = BottomCenter;
    }
  });

  // ../../node_modules/phaser/src/display/bounds/GetLeft.js
  var require_GetLeft = __commonJS({
    "../../node_modules/phaser/src/display/bounds/GetLeft.js": function(exports, module) {
      var GetLeft = function(gameObject) {
        return gameObject.x - gameObject.width * gameObject.originX;
      };
      module.exports = GetLeft;
    }
  });

  // ../../node_modules/phaser/src/display/bounds/SetLeft.js
  var require_SetLeft = __commonJS({
    "../../node_modules/phaser/src/display/bounds/SetLeft.js": function(exports, module) {
      var SetLeft = function(gameObject, value) {
        gameObject.x = value + gameObject.width * gameObject.originX;
        return gameObject;
      };
      module.exports = SetLeft;
    }
  });

  // ../../node_modules/phaser/src/display/align/in/BottomLeft.js
  var require_BottomLeft = __commonJS({
    "../../node_modules/phaser/src/display/align/in/BottomLeft.js": function(exports, module) {
      var GetBottom = require_GetBottom();
      var GetLeft = require_GetLeft();
      var SetBottom = require_SetBottom();
      var SetLeft = require_SetLeft();
      var BottomLeft = function(gameObject, alignIn, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetLeft(gameObject, GetLeft(alignIn) - offsetX);
        SetBottom(gameObject, GetBottom(alignIn) + offsetY);
        return gameObject;
      };
      module.exports = BottomLeft;
    }
  });

  // ../../node_modules/phaser/src/display/bounds/GetRight.js
  var require_GetRight = __commonJS({
    "../../node_modules/phaser/src/display/bounds/GetRight.js": function(exports, module) {
      var GetRight = function(gameObject) {
        return gameObject.x + gameObject.width - gameObject.width * gameObject.originX;
      };
      module.exports = GetRight;
    }
  });

  // ../../node_modules/phaser/src/display/bounds/SetRight.js
  var require_SetRight = __commonJS({
    "../../node_modules/phaser/src/display/bounds/SetRight.js": function(exports, module) {
      var SetRight = function(gameObject, value) {
        gameObject.x = value - gameObject.width + gameObject.width * gameObject.originX;
        return gameObject;
      };
      module.exports = SetRight;
    }
  });

  // ../../node_modules/phaser/src/display/align/in/BottomRight.js
  var require_BottomRight = __commonJS({
    "../../node_modules/phaser/src/display/align/in/BottomRight.js": function(exports, module) {
      var GetBottom = require_GetBottom();
      var GetRight = require_GetRight();
      var SetBottom = require_SetBottom();
      var SetRight = require_SetRight();
      var BottomRight = function(gameObject, alignIn, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetRight(gameObject, GetRight(alignIn) + offsetX);
        SetBottom(gameObject, GetBottom(alignIn) + offsetY);
        return gameObject;
      };
      module.exports = BottomRight;
    }
  });

  // ../../node_modules/phaser/src/display/bounds/SetCenterY.js
  var require_SetCenterY = __commonJS({
    "../../node_modules/phaser/src/display/bounds/SetCenterY.js": function(exports, module) {
      var SetCenterY = function(gameObject, y) {
        var offsetY = gameObject.height * gameObject.originY;
        gameObject.y = y + offsetY - gameObject.height * 0.5;
        return gameObject;
      };
      module.exports = SetCenterY;
    }
  });

  // ../../node_modules/phaser/src/display/bounds/CenterOn.js
  var require_CenterOn = __commonJS({
    "../../node_modules/phaser/src/display/bounds/CenterOn.js": function(exports, module) {
      var SetCenterX = require_SetCenterX();
      var SetCenterY = require_SetCenterY();
      var CenterOn = function(gameObject, x, y) {
        SetCenterX(gameObject, x);
        return SetCenterY(gameObject, y);
      };
      module.exports = CenterOn;
    }
  });

  // ../../node_modules/phaser/src/display/bounds/GetCenterY.js
  var require_GetCenterY = __commonJS({
    "../../node_modules/phaser/src/display/bounds/GetCenterY.js": function(exports, module) {
      var GetCenterY = function(gameObject) {
        return gameObject.y - gameObject.height * gameObject.originY + gameObject.height * 0.5;
      };
      module.exports = GetCenterY;
    }
  });

  // ../../node_modules/phaser/src/display/align/in/Center.js
  var require_Center = __commonJS({
    "../../node_modules/phaser/src/display/align/in/Center.js": function(exports, module) {
      var CenterOn = require_CenterOn();
      var GetCenterX = require_GetCenterX();
      var GetCenterY = require_GetCenterY();
      var Center = function(gameObject, alignIn, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        CenterOn(gameObject, GetCenterX(alignIn) + offsetX, GetCenterY(alignIn) + offsetY);
        return gameObject;
      };
      module.exports = Center;
    }
  });

  // ../../node_modules/phaser/src/display/align/in/LeftCenter.js
  var require_LeftCenter = __commonJS({
    "../../node_modules/phaser/src/display/align/in/LeftCenter.js": function(exports, module) {
      var GetCenterY = require_GetCenterY();
      var GetLeft = require_GetLeft();
      var SetCenterY = require_SetCenterY();
      var SetLeft = require_SetLeft();
      var LeftCenter = function(gameObject, alignIn, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetLeft(gameObject, GetLeft(alignIn) - offsetX);
        SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);
        return gameObject;
      };
      module.exports = LeftCenter;
    }
  });

  // ../../node_modules/phaser/src/display/align/in/RightCenter.js
  var require_RightCenter = __commonJS({
    "../../node_modules/phaser/src/display/align/in/RightCenter.js": function(exports, module) {
      var GetCenterY = require_GetCenterY();
      var GetRight = require_GetRight();
      var SetCenterY = require_SetCenterY();
      var SetRight = require_SetRight();
      var RightCenter = function(gameObject, alignIn, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetRight(gameObject, GetRight(alignIn) + offsetX);
        SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);
        return gameObject;
      };
      module.exports = RightCenter;
    }
  });

  // ../../node_modules/phaser/src/display/bounds/GetTop.js
  var require_GetTop = __commonJS({
    "../../node_modules/phaser/src/display/bounds/GetTop.js": function(exports, module) {
      var GetTop = function(gameObject) {
        return gameObject.y - gameObject.height * gameObject.originY;
      };
      module.exports = GetTop;
    }
  });

  // ../../node_modules/phaser/src/display/bounds/SetTop.js
  var require_SetTop = __commonJS({
    "../../node_modules/phaser/src/display/bounds/SetTop.js": function(exports, module) {
      var SetTop = function(gameObject, value) {
        gameObject.y = value + gameObject.height * gameObject.originY;
        return gameObject;
      };
      module.exports = SetTop;
    }
  });

  // ../../node_modules/phaser/src/display/align/in/TopCenter.js
  var require_TopCenter = __commonJS({
    "../../node_modules/phaser/src/display/align/in/TopCenter.js": function(exports, module) {
      var GetCenterX = require_GetCenterX();
      var GetTop = require_GetTop();
      var SetCenterX = require_SetCenterX();
      var SetTop = require_SetTop();
      var TopCenter = function(gameObject, alignIn, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
        SetTop(gameObject, GetTop(alignIn) - offsetY);
        return gameObject;
      };
      module.exports = TopCenter;
    }
  });

  // ../../node_modules/phaser/src/display/align/in/TopLeft.js
  var require_TopLeft = __commonJS({
    "../../node_modules/phaser/src/display/align/in/TopLeft.js": function(exports, module) {
      var GetLeft = require_GetLeft();
      var GetTop = require_GetTop();
      var SetLeft = require_SetLeft();
      var SetTop = require_SetTop();
      var TopLeft = function(gameObject, alignIn, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetLeft(gameObject, GetLeft(alignIn) - offsetX);
        SetTop(gameObject, GetTop(alignIn) - offsetY);
        return gameObject;
      };
      module.exports = TopLeft;
    }
  });

  // ../../node_modules/phaser/src/display/align/in/TopRight.js
  var require_TopRight = __commonJS({
    "../../node_modules/phaser/src/display/align/in/TopRight.js": function(exports, module) {
      var GetRight = require_GetRight();
      var GetTop = require_GetTop();
      var SetRight = require_SetRight();
      var SetTop = require_SetTop();
      var TopRight = function(gameObject, alignIn, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetRight(gameObject, GetRight(alignIn) + offsetX);
        SetTop(gameObject, GetTop(alignIn) - offsetY);
        return gameObject;
      };
      module.exports = TopRight;
    }
  });

  // ../../node_modules/phaser/src/display/align/in/QuickSet.js
  var require_QuickSet = __commonJS({
    "../../node_modules/phaser/src/display/align/in/QuickSet.js": function(exports, module) {
      var ALIGN_CONST = require_const2();
      var AlignInMap = [];
      AlignInMap[ALIGN_CONST.BOTTOM_CENTER] = require_BottomCenter();
      AlignInMap[ALIGN_CONST.BOTTOM_LEFT] = require_BottomLeft();
      AlignInMap[ALIGN_CONST.BOTTOM_RIGHT] = require_BottomRight();
      AlignInMap[ALIGN_CONST.CENTER] = require_Center();
      AlignInMap[ALIGN_CONST.LEFT_CENTER] = require_LeftCenter();
      AlignInMap[ALIGN_CONST.RIGHT_CENTER] = require_RightCenter();
      AlignInMap[ALIGN_CONST.TOP_CENTER] = require_TopCenter();
      AlignInMap[ALIGN_CONST.TOP_LEFT] = require_TopLeft();
      AlignInMap[ALIGN_CONST.TOP_RIGHT] = require_TopRight();
      AlignInMap[ALIGN_CONST.LEFT_BOTTOM] = AlignInMap[ALIGN_CONST.BOTTOM_LEFT];
      AlignInMap[ALIGN_CONST.LEFT_TOP] = AlignInMap[ALIGN_CONST.TOP_LEFT];
      AlignInMap[ALIGN_CONST.RIGHT_BOTTOM] = AlignInMap[ALIGN_CONST.BOTTOM_RIGHT];
      AlignInMap[ALIGN_CONST.RIGHT_TOP] = AlignInMap[ALIGN_CONST.TOP_RIGHT];
      var QuickSet = function(child, alignIn, position, offsetX, offsetY) {
        return AlignInMap[position](child, alignIn, offsetX, offsetY);
      };
      module.exports = QuickSet;
    }
  });

  // ../../node_modules/phaser/src/utils/object/GetFastValue.js
  var require_GetFastValue = __commonJS({
    "../../node_modules/phaser/src/utils/object/GetFastValue.js": function(exports, module) {
      var GetFastValue = function(source, key, defaultValue) {
        var t = typeof source;
        if (!source || t === "number" || t === "string") {
          return defaultValue;
        } else if (source.hasOwnProperty(key) && source[key] !== void 0) {
          return source[key];
        } else {
          return defaultValue;
        }
      };
      module.exports = GetFastValue;
    }
  });

  // ../../node_modules/phaser/src/utils/NOOP.js
  var require_NOOP = __commonJS({
    "../../node_modules/phaser/src/utils/NOOP.js": function(exports, module) {
      var NOOP = function() {
      };
      module.exports = NOOP;
    }
  });

  // ../../node_modules/phaser/src/utils/Class.js
  var require_Class = __commonJS({
    "../../node_modules/phaser/src/utils/Class.js": function(exports, module) {
      function hasGetterOrSetter(def) {
        return !!def.get && typeof def.get === "function" || !!def.set && typeof def.set === "function";
      }
      function getProperty(definition, k, isClassDescriptor) {
        var def = isClassDescriptor ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);
        if (!isClassDescriptor && def.value && typeof def.value === "object") {
          def = def.value;
        }
        if (def && hasGetterOrSetter(def)) {
          if (typeof def.enumerable === "undefined") {
            def.enumerable = true;
          }
          if (typeof def.configurable === "undefined") {
            def.configurable = true;
          }
          return def;
        } else {
          return false;
        }
      }
      function hasNonConfigurable(obj, k) {
        var prop = Object.getOwnPropertyDescriptor(obj, k);
        if (!prop) {
          return false;
        }
        if (prop.value && typeof prop.value === "object") {
          prop = prop.value;
        }
        if (prop.configurable === false) {
          return true;
        }
        return false;
      }
      function extend(ctor, definition, isClassDescriptor, extend2) {
        for (var k in definition) {
          if (!definition.hasOwnProperty(k)) {
            continue;
          }
          var def = getProperty(definition, k, isClassDescriptor);
          if (def !== false) {
            var parent = extend2 || ctor;
            if (hasNonConfigurable(parent.prototype, k)) {
              if (Class.ignoreFinals) {
                continue;
              }
              throw new Error("cannot override final property '" + k + "', set Class.ignoreFinals = true to skip");
            }
            Object.defineProperty(ctor.prototype, k, def);
          } else {
            ctor.prototype[k] = definition[k];
          }
        }
      }
      function mixin(myClass, mixins) {
        if (!mixins) {
          return;
        }
        if (!Array.isArray(mixins)) {
          mixins = [mixins];
        }
        for (var i = 0; i < mixins.length; i++) {
          extend(myClass, mixins[i].prototype || mixins[i]);
        }
      }
      function Class(definition) {
        if (!definition) {
          definition = {};
        }
        var initialize;
        var Extends;
        if (definition.initialize) {
          if (typeof definition.initialize !== "function") {
            throw new Error("initialize must be a function");
          }
          initialize = definition.initialize;
          delete definition.initialize;
        } else if (definition.Extends) {
          var base = definition.Extends;
          initialize = function() {
            base.apply(this, arguments);
          };
        } else {
          initialize = function() {
          };
        }
        if (definition.Extends) {
          initialize.prototype = Object.create(definition.Extends.prototype);
          initialize.prototype.constructor = initialize;
          Extends = definition.Extends;
          delete definition.Extends;
        } else {
          initialize.prototype.constructor = initialize;
        }
        var mixins = null;
        if (definition.Mixins) {
          mixins = definition.Mixins;
          delete definition.Mixins;
        }
        mixin(initialize, mixins);
        extend(initialize, definition, true, Extends);
        return initialize;
      }
      Class.extend = extend;
      Class.mixin = mixin;
      Class.ignoreFinals = false;
      module.exports = Class;
    }
  });

  // ../../node_modules/phaser/src/geom/circle/Contains.js
  var require_Contains = __commonJS({
    "../../node_modules/phaser/src/geom/circle/Contains.js": function(exports, module) {
      var Contains = function(circle, x, y) {
        if (circle.radius > 0 && x >= circle.left && x <= circle.right && y >= circle.top && y <= circle.bottom) {
          var dx = (circle.x - x) * (circle.x - x);
          var dy = (circle.y - y) * (circle.y - y);
          return dx + dy <= circle.radius * circle.radius;
        } else {
          return false;
        }
      };
      module.exports = Contains;
    }
  });

  // ../../node_modules/phaser/src/geom/const.js
  var require_const3 = __commonJS({
    "../../node_modules/phaser/src/geom/const.js": function(exports, module) {
      var GEOM_CONST = {
        CIRCLE: 0,
        ELLIPSE: 1,
        LINE: 2,
        POINT: 3,
        POLYGON: 4,
        RECTANGLE: 5,
        TRIANGLE: 6
      };
      module.exports = GEOM_CONST;
    }
  });

  // ../../node_modules/phaser/src/geom/point/Point.js
  var require_Point = __commonJS({
    "../../node_modules/phaser/src/geom/point/Point.js": function(exports, module) {
      var Class = require_Class();
      var GEOM_CONST = require_const3();
      var Point = new Class({
        initialize: function Point2(x, y) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = x;
          }
          this.type = GEOM_CONST.POINT;
          this.x = x;
          this.y = y;
        },
        setTo: function(x, y) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = x;
          }
          this.x = x;
          this.y = y;
          return this;
        }
      });
      module.exports = Point;
    }
  });

  // ../../node_modules/phaser/src/geom/circle/CircumferencePoint.js
  var require_CircumferencePoint = __commonJS({
    "../../node_modules/phaser/src/geom/circle/CircumferencePoint.js": function(exports, module) {
      var Point = require_Point();
      var CircumferencePoint = function(circle, angle, out) {
        if (out === void 0) {
          out = new Point();
        }
        out.x = circle.x + circle.radius * Math.cos(angle);
        out.y = circle.y + circle.radius * Math.sin(angle);
        return out;
      };
      module.exports = CircumferencePoint;
    }
  });

  // ../../node_modules/phaser/src/math/Clamp.js
  var require_Clamp = __commonJS({
    "../../node_modules/phaser/src/math/Clamp.js": function(exports, module) {
      var Clamp = function(value, min, max) {
        return Math.max(min, Math.min(max, value));
      };
      module.exports = Clamp;
    }
  });

  // ../../node_modules/phaser/src/math/FromPercent.js
  var require_FromPercent = __commonJS({
    "../../node_modules/phaser/src/math/FromPercent.js": function(exports, module) {
      var Clamp = require_Clamp();
      var FromPercent = function(percent, min, max) {
        percent = Clamp(percent, 0, 1);
        return (max - min) * percent + min;
      };
      module.exports = FromPercent;
    }
  });

  // ../../node_modules/phaser/src/math/const.js
  var require_const4 = __commonJS({
    "../../node_modules/phaser/src/math/const.js": function(exports, module) {
      var MATH_CONST = {
        PI2: Math.PI * 2,
        TAU: Math.PI * 0.5,
        EPSILON: 1e-6,
        DEG_TO_RAD: Math.PI / 180,
        RAD_TO_DEG: 180 / Math.PI,
        RND: null,
        MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991,
        MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991
      };
      module.exports = MATH_CONST;
    }
  });

  // ../../node_modules/phaser/src/geom/circle/GetPoint.js
  var require_GetPoint = __commonJS({
    "../../node_modules/phaser/src/geom/circle/GetPoint.js": function(exports, module) {
      var CircumferencePoint = require_CircumferencePoint();
      var FromPercent = require_FromPercent();
      var MATH_CONST = require_const4();
      var Point = require_Point();
      var GetPoint = function(circle, position, out) {
        if (out === void 0) {
          out = new Point();
        }
        var angle = FromPercent(position, 0, MATH_CONST.PI2);
        return CircumferencePoint(circle, angle, out);
      };
      module.exports = GetPoint;
    }
  });

  // ../../node_modules/phaser/src/geom/circle/Circumference.js
  var require_Circumference = __commonJS({
    "../../node_modules/phaser/src/geom/circle/Circumference.js": function(exports, module) {
      var Circumference = function(circle) {
        return 2 * (Math.PI * circle.radius);
      };
      module.exports = Circumference;
    }
  });

  // ../../node_modules/phaser/src/geom/circle/GetPoints.js
  var require_GetPoints = __commonJS({
    "../../node_modules/phaser/src/geom/circle/GetPoints.js": function(exports, module) {
      var Circumference = require_Circumference();
      var CircumferencePoint = require_CircumferencePoint();
      var FromPercent = require_FromPercent();
      var MATH_CONST = require_const4();
      var GetPoints = function(circle, quantity, stepRate, out) {
        if (out === void 0) {
          out = [];
        }
        if (!quantity && stepRate > 0) {
          quantity = Circumference(circle) / stepRate;
        }
        for (var i = 0; i < quantity; i++) {
          var angle = FromPercent(i / quantity, 0, MATH_CONST.PI2);
          out.push(CircumferencePoint(circle, angle));
        }
        return out;
      };
      module.exports = GetPoints;
    }
  });

  // ../../node_modules/phaser/src/geom/circle/Random.js
  var require_Random = __commonJS({
    "../../node_modules/phaser/src/geom/circle/Random.js": function(exports, module) {
      var Point = require_Point();
      var Random = function(circle, out) {
        if (out === void 0) {
          out = new Point();
        }
        var t = 2 * Math.PI * Math.random();
        var u = Math.random() + Math.random();
        var r = u > 1 ? 2 - u : u;
        var x = r * Math.cos(t);
        var y = r * Math.sin(t);
        out.x = circle.x + x * circle.radius;
        out.y = circle.y + y * circle.radius;
        return out;
      };
      module.exports = Random;
    }
  });

  // ../../node_modules/phaser/src/geom/circle/Circle.js
  var require_Circle = __commonJS({
    "../../node_modules/phaser/src/geom/circle/Circle.js": function(exports, module) {
      var Class = require_Class();
      var Contains = require_Contains();
      var GetPoint = require_GetPoint();
      var GetPoints = require_GetPoints();
      var GEOM_CONST = require_const3();
      var Random = require_Random();
      var Circle = new Class({
        initialize: function Circle2(x, y, radius) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (radius === void 0) {
            radius = 0;
          }
          this.type = GEOM_CONST.CIRCLE;
          this.x = x;
          this.y = y;
          this._radius = radius;
          this._diameter = radius * 2;
        },
        contains: function(x, y) {
          return Contains(this, x, y);
        },
        getPoint: function(position, point) {
          return GetPoint(this, position, point);
        },
        getPoints: function(quantity, stepRate, output) {
          return GetPoints(this, quantity, stepRate, output);
        },
        getRandomPoint: function(point) {
          return Random(this, point);
        },
        setTo: function(x, y, radius) {
          this.x = x;
          this.y = y;
          this._radius = radius;
          this._diameter = radius * 2;
          return this;
        },
        setEmpty: function() {
          this._radius = 0;
          this._diameter = 0;
          return this;
        },
        setPosition: function(x, y) {
          if (y === void 0) {
            y = x;
          }
          this.x = x;
          this.y = y;
          return this;
        },
        isEmpty: function() {
          return this._radius <= 0;
        },
        radius: {
          get: function() {
            return this._radius;
          },
          set: function(value) {
            this._radius = value;
            this._diameter = value * 2;
          }
        },
        diameter: {
          get: function() {
            return this._diameter;
          },
          set: function(value) {
            this._diameter = value;
            this._radius = value * 0.5;
          }
        },
        left: {
          get: function() {
            return this.x - this._radius;
          },
          set: function(value) {
            this.x = value + this._radius;
          }
        },
        right: {
          get: function() {
            return this.x + this._radius;
          },
          set: function(value) {
            this.x = value - this._radius;
          }
        },
        top: {
          get: function() {
            return this.y - this._radius;
          },
          set: function(value) {
            this.y = value + this._radius;
          }
        },
        bottom: {
          get: function() {
            return this.y + this._radius;
          },
          set: function(value) {
            this.y = value - this._radius;
          }
        }
      });
      module.exports = Circle;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/Alpha.js
  var require_Alpha = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/Alpha.js": function(exports, module) {
      var Clamp = require_Clamp();
      var _FLAG = 2;
      var Alpha = {
        _alpha: 1,
        _alphaTL: 1,
        _alphaTR: 1,
        _alphaBL: 1,
        _alphaBR: 1,
        clearAlpha: function() {
          return this.setAlpha(1);
        },
        setAlpha: function(topLeft, topRight, bottomLeft, bottomRight) {
          if (topLeft === void 0) {
            topLeft = 1;
          }
          if (topRight === void 0) {
            this.alpha = topLeft;
          } else {
            this._alphaTL = Clamp(topLeft, 0, 1);
            this._alphaTR = Clamp(topRight, 0, 1);
            this._alphaBL = Clamp(bottomLeft, 0, 1);
            this._alphaBR = Clamp(bottomRight, 0, 1);
          }
          return this;
        },
        alpha: {
          get: function() {
            return this._alpha;
          },
          set: function(value) {
            var v = Clamp(value, 0, 1);
            this._alpha = v;
            this._alphaTL = v;
            this._alphaTR = v;
            this._alphaBL = v;
            this._alphaBR = v;
            if (v === 0) {
              this.renderFlags &= ~_FLAG;
            } else {
              this.renderFlags |= _FLAG;
            }
          }
        },
        alphaTopLeft: {
          get: function() {
            return this._alphaTL;
          },
          set: function(value) {
            var v = Clamp(value, 0, 1);
            this._alphaTL = v;
            if (v !== 0) {
              this.renderFlags |= _FLAG;
            }
          }
        },
        alphaTopRight: {
          get: function() {
            return this._alphaTR;
          },
          set: function(value) {
            var v = Clamp(value, 0, 1);
            this._alphaTR = v;
            if (v !== 0) {
              this.renderFlags |= _FLAG;
            }
          }
        },
        alphaBottomLeft: {
          get: function() {
            return this._alphaBL;
          },
          set: function(value) {
            var v = Clamp(value, 0, 1);
            this._alphaBL = v;
            if (v !== 0) {
              this.renderFlags |= _FLAG;
            }
          }
        },
        alphaBottomRight: {
          get: function() {
            return this._alphaBR;
          },
          set: function(value) {
            var v = Clamp(value, 0, 1);
            this._alphaBR = v;
            if (v !== 0) {
              this.renderFlags |= _FLAG;
            }
          }
        }
      };
      module.exports = Alpha;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/AlphaSingle.js
  var require_AlphaSingle = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/AlphaSingle.js": function(exports, module) {
      var Clamp = require_Clamp();
      var _FLAG = 2;
      var AlphaSingle = {
        _alpha: 1,
        clearAlpha: function() {
          return this.setAlpha(1);
        },
        setAlpha: function(value) {
          if (value === void 0) {
            value = 1;
          }
          this.alpha = value;
          return this;
        },
        alpha: {
          get: function() {
            return this._alpha;
          },
          set: function(value) {
            var v = Clamp(value, 0, 1);
            this._alpha = v;
            if (v === 0) {
              this.renderFlags &= ~_FLAG;
            } else {
              this.renderFlags |= _FLAG;
            }
          }
        }
      };
      module.exports = AlphaSingle;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/BlendMode.js
  var require_BlendMode = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/BlendMode.js": function(exports, module) {
      var BlendModes = require_BlendModes();
      var BlendMode = {
        _blendMode: BlendModes.NORMAL,
        blendMode: {
          get: function() {
            return this._blendMode;
          },
          set: function(value) {
            if (typeof value === "string") {
              value = BlendModes[value];
            }
            value |= 0;
            if (value >= -1) {
              this._blendMode = value;
            }
          }
        },
        setBlendMode: function(value) {
          this.blendMode = value;
          return this;
        }
      };
      module.exports = BlendMode;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/ComputedSize.js
  var require_ComputedSize = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/ComputedSize.js": function(exports, module) {
      var ComputedSize = {
        width: 0,
        height: 0,
        displayWidth: {
          get: function() {
            return this.scaleX * this.width;
          },
          set: function(value) {
            this.scaleX = value / this.width;
          }
        },
        displayHeight: {
          get: function() {
            return this.scaleY * this.height;
          },
          set: function(value) {
            this.scaleY = value / this.height;
          }
        },
        setSize: function(width, height) {
          this.width = width;
          this.height = height;
          return this;
        },
        setDisplaySize: function(width, height) {
          this.displayWidth = width;
          this.displayHeight = height;
          return this;
        }
      };
      module.exports = ComputedSize;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/Crop.js
  var require_Crop = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/Crop.js": function(exports, module) {
      var Crop = {
        texture: null,
        frame: null,
        isCropped: false,
        setCrop: function(x, y, width, height) {
          if (x === void 0) {
            this.isCropped = false;
          } else if (this.frame) {
            if (typeof x === "number") {
              this.frame.setCropUVs(this._crop, x, y, width, height, this.flipX, this.flipY);
            } else {
              var rect = x;
              this.frame.setCropUVs(this._crop, rect.x, rect.y, rect.width, rect.height, this.flipX, this.flipY);
            }
            this.isCropped = true;
          }
          return this;
        },
        resetCropObject: function() {
          return { u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: false, flipY: false, cx: 0, cy: 0, cw: 0, ch: 0 };
        }
      };
      module.exports = Crop;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/Depth.js
  var require_Depth = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/Depth.js": function(exports, module) {
      var Depth = {
        _depth: 0,
        depth: {
          get: function() {
            return this._depth;
          },
          set: function(value) {
            if (this.displayList) {
              this.displayList.queueDepthSort();
            }
            this._depth = value;
          }
        },
        setDepth: function(value) {
          if (value === void 0) {
            value = 0;
          }
          this.depth = value;
          return this;
        }
      };
      module.exports = Depth;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/Flip.js
  var require_Flip = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/Flip.js": function(exports, module) {
      var Flip = {
        flipX: false,
        flipY: false,
        toggleFlipX: function() {
          this.flipX = !this.flipX;
          return this;
        },
        toggleFlipY: function() {
          this.flipY = !this.flipY;
          return this;
        },
        setFlipX: function(value) {
          this.flipX = value;
          return this;
        },
        setFlipY: function(value) {
          this.flipY = value;
          return this;
        },
        setFlip: function(x, y) {
          this.flipX = x;
          this.flipY = y;
          return this;
        },
        resetFlip: function() {
          this.flipX = false;
          this.flipY = false;
          return this;
        }
      };
      module.exports = Flip;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/FX.js
  var require_FX = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/FX.js": function(exports, module) {
      var FX = {
        fxPadding: 0,
        setFXPadding: function(padding) {
          if (padding === void 0) {
            padding = 0;
          }
          this.fxPadding = padding;
          return this;
        },
        onFXCopy: function() {
        },
        onFX: function() {
        }
      };
      module.exports = FX;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/Contains.js
  var require_Contains2 = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/Contains.js": function(exports, module) {
      var Contains = function(rect, x, y) {
        if (rect.width <= 0 || rect.height <= 0) {
          return false;
        }
        return rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y;
      };
      module.exports = Contains;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/Perimeter.js
  var require_Perimeter = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/Perimeter.js": function(exports, module) {
      var Perimeter = function(rect) {
        return 2 * (rect.width + rect.height);
      };
      module.exports = Perimeter;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/GetPoint.js
  var require_GetPoint2 = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/GetPoint.js": function(exports, module) {
      var Perimeter = require_Perimeter();
      var Point = require_Point();
      var GetPoint = function(rectangle, position, out) {
        if (out === void 0) {
          out = new Point();
        }
        if (position <= 0 || position >= 1) {
          out.x = rectangle.x;
          out.y = rectangle.y;
          return out;
        }
        var p = Perimeter(rectangle) * position;
        if (position > 0.5) {
          p -= rectangle.width + rectangle.height;
          if (p <= rectangle.width) {
            out.x = rectangle.right - p;
            out.y = rectangle.bottom;
          } else {
            out.x = rectangle.x;
            out.y = rectangle.bottom - (p - rectangle.width);
          }
        } else if (p <= rectangle.width) {
          out.x = rectangle.x + p;
          out.y = rectangle.y;
        } else {
          out.x = rectangle.right;
          out.y = rectangle.y + (p - rectangle.width);
        }
        return out;
      };
      module.exports = GetPoint;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/GetPoints.js
  var require_GetPoints2 = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/GetPoints.js": function(exports, module) {
      var GetPoint = require_GetPoint2();
      var Perimeter = require_Perimeter();
      var GetPoints = function(rectangle, quantity, stepRate, out) {
        if (out === void 0) {
          out = [];
        }
        if (!quantity && stepRate > 0) {
          quantity = Perimeter(rectangle) / stepRate;
        }
        for (var i = 0; i < quantity; i++) {
          var position = i / quantity;
          out.push(GetPoint(rectangle, position));
        }
        return out;
      };
      module.exports = GetPoints;
    }
  });

  // ../../node_modules/phaser/src/geom/line/GetPoint.js
  var require_GetPoint3 = __commonJS({
    "../../node_modules/phaser/src/geom/line/GetPoint.js": function(exports, module) {
      var Point = require_Point();
      var GetPoint = function(line, position, out) {
        if (out === void 0) {
          out = new Point();
        }
        out.x = line.x1 + (line.x2 - line.x1) * position;
        out.y = line.y1 + (line.y2 - line.y1) * position;
        return out;
      };
      module.exports = GetPoint;
    }
  });

  // ../../node_modules/phaser/src/geom/line/Length.js
  var require_Length = __commonJS({
    "../../node_modules/phaser/src/geom/line/Length.js": function(exports, module) {
      var Length = function(line) {
        return Math.sqrt((line.x2 - line.x1) * (line.x2 - line.x1) + (line.y2 - line.y1) * (line.y2 - line.y1));
      };
      module.exports = Length;
    }
  });

  // ../../node_modules/phaser/src/geom/line/GetPoints.js
  var require_GetPoints3 = __commonJS({
    "../../node_modules/phaser/src/geom/line/GetPoints.js": function(exports, module) {
      var Length = require_Length();
      var Point = require_Point();
      var GetPoints = function(line, quantity, stepRate, out) {
        if (out === void 0) {
          out = [];
        }
        if (!quantity && stepRate > 0) {
          quantity = Length(line) / stepRate;
        }
        var x1 = line.x1;
        var y1 = line.y1;
        var x2 = line.x2;
        var y2 = line.y2;
        for (var i = 0; i < quantity; i++) {
          var position = i / quantity;
          var x = x1 + (x2 - x1) * position;
          var y = y1 + (y2 - y1) * position;
          out.push(new Point(x, y));
        }
        return out;
      };
      module.exports = GetPoints;
    }
  });

  // ../../node_modules/phaser/src/geom/line/Random.js
  var require_Random2 = __commonJS({
    "../../node_modules/phaser/src/geom/line/Random.js": function(exports, module) {
      var Point = require_Point();
      var Random = function(line, out) {
        if (out === void 0) {
          out = new Point();
        }
        var t = Math.random();
        out.x = line.x1 + t * (line.x2 - line.x1);
        out.y = line.y1 + t * (line.y2 - line.y1);
        return out;
      };
      module.exports = Random;
    }
  });

  // ../../node_modules/phaser/src/math/fuzzy/Equal.js
  var require_Equal = __commonJS({
    "../../node_modules/phaser/src/math/fuzzy/Equal.js": function(exports, module) {
      var Equal = function(a, b, epsilon) {
        if (epsilon === void 0) {
          epsilon = 1e-4;
        }
        return Math.abs(a - b) < epsilon;
      };
      module.exports = Equal;
    }
  });

  // ../../node_modules/phaser/src/math/Vector2.js
  var require_Vector2 = __commonJS({
    "../../node_modules/phaser/src/math/Vector2.js": function(exports, module) {
      var Class = require_Class();
      var FuzzyEqual = require_Equal();
      var Vector2 = new Class({
        initialize: function Vector22(x, y) {
          this.x = 0;
          this.y = 0;
          if (typeof x === "object") {
            this.x = x.x || 0;
            this.y = x.y || 0;
          } else {
            if (y === void 0) {
              y = x;
            }
            this.x = x || 0;
            this.y = y || 0;
          }
        },
        clone: function() {
          return new Vector2(this.x, this.y);
        },
        copy: function(src) {
          this.x = src.x || 0;
          this.y = src.y || 0;
          return this;
        },
        setFromObject: function(obj) {
          this.x = obj.x || 0;
          this.y = obj.y || 0;
          return this;
        },
        set: function(x, y) {
          if (y === void 0) {
            y = x;
          }
          this.x = x;
          this.y = y;
          return this;
        },
        setTo: function(x, y) {
          return this.set(x, y);
        },
        setToPolar: function(azimuth, radius) {
          if (radius == null) {
            radius = 1;
          }
          this.x = Math.cos(azimuth) * radius;
          this.y = Math.sin(azimuth) * radius;
          return this;
        },
        equals: function(v) {
          return this.x === v.x && this.y === v.y;
        },
        fuzzyEquals: function(v, epsilon) {
          return FuzzyEqual(this.x, v.x, epsilon) && FuzzyEqual(this.y, v.y, epsilon);
        },
        angle: function() {
          var angle = Math.atan2(this.y, this.x);
          if (angle < 0) {
            angle += 2 * Math.PI;
          }
          return angle;
        },
        setAngle: function(angle) {
          return this.setToPolar(angle, this.length());
        },
        add: function(src) {
          this.x += src.x;
          this.y += src.y;
          return this;
        },
        subtract: function(src) {
          this.x -= src.x;
          this.y -= src.y;
          return this;
        },
        multiply: function(src) {
          this.x *= src.x;
          this.y *= src.y;
          return this;
        },
        scale: function(value) {
          if (isFinite(value)) {
            this.x *= value;
            this.y *= value;
          } else {
            this.x = 0;
            this.y = 0;
          }
          return this;
        },
        divide: function(src) {
          this.x /= src.x;
          this.y /= src.y;
          return this;
        },
        negate: function() {
          this.x = -this.x;
          this.y = -this.y;
          return this;
        },
        distance: function(src) {
          var dx = src.x - this.x;
          var dy = src.y - this.y;
          return Math.sqrt(dx * dx + dy * dy);
        },
        distanceSq: function(src) {
          var dx = src.x - this.x;
          var dy = src.y - this.y;
          return dx * dx + dy * dy;
        },
        length: function() {
          var x = this.x;
          var y = this.y;
          return Math.sqrt(x * x + y * y);
        },
        setLength: function(length) {
          return this.normalize().scale(length);
        },
        lengthSq: function() {
          var x = this.x;
          var y = this.y;
          return x * x + y * y;
        },
        normalize: function() {
          var x = this.x;
          var y = this.y;
          var len = x * x + y * y;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            this.x = x * len;
            this.y = y * len;
          }
          return this;
        },
        normalizeRightHand: function() {
          var x = this.x;
          this.x = this.y * -1;
          this.y = x;
          return this;
        },
        normalizeLeftHand: function() {
          var x = this.x;
          this.x = this.y;
          this.y = x * -1;
          return this;
        },
        dot: function(src) {
          return this.x * src.x + this.y * src.y;
        },
        cross: function(src) {
          return this.x * src.y - this.y * src.x;
        },
        lerp: function(src, t) {
          if (t === void 0) {
            t = 0;
          }
          var ax = this.x;
          var ay = this.y;
          this.x = ax + t * (src.x - ax);
          this.y = ay + t * (src.y - ay);
          return this;
        },
        transformMat3: function(mat) {
          var x = this.x;
          var y = this.y;
          var m = mat.val;
          this.x = m[0] * x + m[3] * y + m[6];
          this.y = m[1] * x + m[4] * y + m[7];
          return this;
        },
        transformMat4: function(mat) {
          var x = this.x;
          var y = this.y;
          var m = mat.val;
          this.x = m[0] * x + m[4] * y + m[12];
          this.y = m[1] * x + m[5] * y + m[13];
          return this;
        },
        reset: function() {
          this.x = 0;
          this.y = 0;
          return this;
        },
        limit: function(max) {
          var len = this.length();
          if (len && len > max) {
            this.scale(max / len);
          }
          return this;
        },
        reflect: function(normal) {
          normal = normal.clone().normalize();
          return this.subtract(normal.scale(2 * this.dot(normal)));
        },
        mirror: function(axis) {
          return this.reflect(axis).negate();
        },
        rotate: function(delta) {
          var cos = Math.cos(delta);
          var sin = Math.sin(delta);
          return this.set(cos * this.x - sin * this.y, sin * this.x + cos * this.y);
        },
        project: function(src) {
          var scalar = this.dot(src) / src.dot(src);
          return this.copy(src).scale(scalar);
        }
      });
      Vector2.ZERO = new Vector2();
      Vector2.RIGHT = new Vector2(1, 0);
      Vector2.LEFT = new Vector2(-1, 0);
      Vector2.UP = new Vector2(0, -1);
      Vector2.DOWN = new Vector2(0, 1);
      Vector2.ONE = new Vector2(1, 1);
      module.exports = Vector2;
    }
  });

  // ../../node_modules/phaser/src/geom/line/Line.js
  var require_Line = __commonJS({
    "../../node_modules/phaser/src/geom/line/Line.js": function(exports, module) {
      var Class = require_Class();
      var GetPoint = require_GetPoint3();
      var GetPoints = require_GetPoints3();
      var GEOM_CONST = require_const3();
      var Random = require_Random2();
      var Vector2 = require_Vector2();
      var Line = new Class({
        initialize: function Line2(x1, y1, x2, y2) {
          if (x1 === void 0) {
            x1 = 0;
          }
          if (y1 === void 0) {
            y1 = 0;
          }
          if (x2 === void 0) {
            x2 = 0;
          }
          if (y2 === void 0) {
            y2 = 0;
          }
          this.type = GEOM_CONST.LINE;
          this.x1 = x1;
          this.y1 = y1;
          this.x2 = x2;
          this.y2 = y2;
        },
        getPoint: function(position, output) {
          return GetPoint(this, position, output);
        },
        getPoints: function(quantity, stepRate, output) {
          return GetPoints(this, quantity, stepRate, output);
        },
        getRandomPoint: function(point) {
          return Random(this, point);
        },
        setTo: function(x1, y1, x2, y2) {
          if (x1 === void 0) {
            x1 = 0;
          }
          if (y1 === void 0) {
            y1 = 0;
          }
          if (x2 === void 0) {
            x2 = 0;
          }
          if (y2 === void 0) {
            y2 = 0;
          }
          this.x1 = x1;
          this.y1 = y1;
          this.x2 = x2;
          this.y2 = y2;
          return this;
        },
        getPointA: function(vec2) {
          if (vec2 === void 0) {
            vec2 = new Vector2();
          }
          vec2.set(this.x1, this.y1);
          return vec2;
        },
        getPointB: function(vec2) {
          if (vec2 === void 0) {
            vec2 = new Vector2();
          }
          vec2.set(this.x2, this.y2);
          return vec2;
        },
        left: {
          get: function() {
            return Math.min(this.x1, this.x2);
          },
          set: function(value) {
            if (this.x1 <= this.x2) {
              this.x1 = value;
            } else {
              this.x2 = value;
            }
          }
        },
        right: {
          get: function() {
            return Math.max(this.x1, this.x2);
          },
          set: function(value) {
            if (this.x1 > this.x2) {
              this.x1 = value;
            } else {
              this.x2 = value;
            }
          }
        },
        top: {
          get: function() {
            return Math.min(this.y1, this.y2);
          },
          set: function(value) {
            if (this.y1 <= this.y2) {
              this.y1 = value;
            } else {
              this.y2 = value;
            }
          }
        },
        bottom: {
          get: function() {
            return Math.max(this.y1, this.y2);
          },
          set: function(value) {
            if (this.y1 > this.y2) {
              this.y1 = value;
            } else {
              this.y2 = value;
            }
          }
        }
      });
      module.exports = Line;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/Random.js
  var require_Random3 = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/Random.js": function(exports, module) {
      var Point = require_Point();
      var Random = function(rect, out) {
        if (out === void 0) {
          out = new Point();
        }
        out.x = rect.x + Math.random() * rect.width;
        out.y = rect.y + Math.random() * rect.height;
        return out;
      };
      module.exports = Random;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/Rectangle.js
  var require_Rectangle = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/Rectangle.js": function(exports, module) {
      var Class = require_Class();
      var Contains = require_Contains2();
      var GetPoint = require_GetPoint2();
      var GetPoints = require_GetPoints2();
      var GEOM_CONST = require_const3();
      var Line = require_Line();
      var Random = require_Random3();
      var Rectangle = new Class({
        initialize: function Rectangle2(x, y, width, height) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (width === void 0) {
            width = 0;
          }
          if (height === void 0) {
            height = 0;
          }
          this.type = GEOM_CONST.RECTANGLE;
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
        },
        contains: function(x, y) {
          return Contains(this, x, y);
        },
        getPoint: function(position, output) {
          return GetPoint(this, position, output);
        },
        getPoints: function(quantity, stepRate, output) {
          return GetPoints(this, quantity, stepRate, output);
        },
        getRandomPoint: function(point) {
          return Random(this, point);
        },
        setTo: function(x, y, width, height) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
          return this;
        },
        setEmpty: function() {
          return this.setTo(0, 0, 0, 0);
        },
        setPosition: function(x, y) {
          if (y === void 0) {
            y = x;
          }
          this.x = x;
          this.y = y;
          return this;
        },
        setSize: function(width, height) {
          if (height === void 0) {
            height = width;
          }
          this.width = width;
          this.height = height;
          return this;
        },
        isEmpty: function() {
          return this.width <= 0 || this.height <= 0;
        },
        getLineA: function(line) {
          if (line === void 0) {
            line = new Line();
          }
          line.setTo(this.x, this.y, this.right, this.y);
          return line;
        },
        getLineB: function(line) {
          if (line === void 0) {
            line = new Line();
          }
          line.setTo(this.right, this.y, this.right, this.bottom);
          return line;
        },
        getLineC: function(line) {
          if (line === void 0) {
            line = new Line();
          }
          line.setTo(this.right, this.bottom, this.x, this.bottom);
          return line;
        },
        getLineD: function(line) {
          if (line === void 0) {
            line = new Line();
          }
          line.setTo(this.x, this.bottom, this.x, this.y);
          return line;
        },
        left: {
          get: function() {
            return this.x;
          },
          set: function(value) {
            if (value >= this.right) {
              this.width = 0;
            } else {
              this.width = this.right - value;
            }
            this.x = value;
          }
        },
        right: {
          get: function() {
            return this.x + this.width;
          },
          set: function(value) {
            if (value <= this.x) {
              this.width = 0;
            } else {
              this.width = value - this.x;
            }
          }
        },
        top: {
          get: function() {
            return this.y;
          },
          set: function(value) {
            if (value >= this.bottom) {
              this.height = 0;
            } else {
              this.height = this.bottom - value;
            }
            this.y = value;
          }
        },
        bottom: {
          get: function() {
            return this.y + this.height;
          },
          set: function(value) {
            if (value <= this.y) {
              this.height = 0;
            } else {
              this.height = value - this.y;
            }
          }
        },
        centerX: {
          get: function() {
            return this.x + this.width / 2;
          },
          set: function(value) {
            this.x = value - this.width / 2;
          }
        },
        centerY: {
          get: function() {
            return this.y + this.height / 2;
          },
          set: function(value) {
            this.y = value - this.height / 2;
          }
        }
      });
      module.exports = Rectangle;
    }
  });

  // ../../node_modules/phaser/src/math/RotateAround.js
  var require_RotateAround = __commonJS({
    "../../node_modules/phaser/src/math/RotateAround.js": function(exports, module) {
      var RotateAround = function(point, x, y, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var tx = point.x - x;
        var ty = point.y - y;
        point.x = tx * c - ty * s + x;
        point.y = tx * s + ty * c + y;
        return point;
      };
      module.exports = RotateAround;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/GetBounds.js
  var require_GetBounds = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/GetBounds.js": function(exports, module) {
      var Rectangle = require_Rectangle();
      var RotateAround = require_RotateAround();
      var Vector2 = require_Vector2();
      var GetBounds = {
        prepareBoundsOutput: function(output, includeParent) {
          if (includeParent === void 0) {
            includeParent = false;
          }
          if (this.rotation !== 0) {
            RotateAround(output, this.x, this.y, this.rotation);
          }
          if (includeParent && this.parentContainer) {
            var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
            parentMatrix.transformPoint(output.x, output.y, output);
          }
          return output;
        },
        getCenter: function(output) {
          if (output === void 0) {
            output = new Vector2();
          }
          output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
          output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;
          return output;
        },
        getTopLeft: function(output, includeParent) {
          if (!output) {
            output = new Vector2();
          }
          output.x = this.x - this.displayWidth * this.originX;
          output.y = this.y - this.displayHeight * this.originY;
          return this.prepareBoundsOutput(output, includeParent);
        },
        getTopCenter: function(output, includeParent) {
          if (!output) {
            output = new Vector2();
          }
          output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
          output.y = this.y - this.displayHeight * this.originY;
          return this.prepareBoundsOutput(output, includeParent);
        },
        getTopRight: function(output, includeParent) {
          if (!output) {
            output = new Vector2();
          }
          output.x = this.x - this.displayWidth * this.originX + this.displayWidth;
          output.y = this.y - this.displayHeight * this.originY;
          return this.prepareBoundsOutput(output, includeParent);
        },
        getLeftCenter: function(output, includeParent) {
          if (!output) {
            output = new Vector2();
          }
          output.x = this.x - this.displayWidth * this.originX;
          output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;
          return this.prepareBoundsOutput(output, includeParent);
        },
        getRightCenter: function(output, includeParent) {
          if (!output) {
            output = new Vector2();
          }
          output.x = this.x - this.displayWidth * this.originX + this.displayWidth;
          output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;
          return this.prepareBoundsOutput(output, includeParent);
        },
        getBottomLeft: function(output, includeParent) {
          if (!output) {
            output = new Vector2();
          }
          output.x = this.x - this.displayWidth * this.originX;
          output.y = this.y - this.displayHeight * this.originY + this.displayHeight;
          return this.prepareBoundsOutput(output, includeParent);
        },
        getBottomCenter: function(output, includeParent) {
          if (!output) {
            output = new Vector2();
          }
          output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
          output.y = this.y - this.displayHeight * this.originY + this.displayHeight;
          return this.prepareBoundsOutput(output, includeParent);
        },
        getBottomRight: function(output, includeParent) {
          if (!output) {
            output = new Vector2();
          }
          output.x = this.x - this.displayWidth * this.originX + this.displayWidth;
          output.y = this.y - this.displayHeight * this.originY + this.displayHeight;
          return this.prepareBoundsOutput(output, includeParent);
        },
        getBounds: function(output) {
          if (output === void 0) {
            output = new Rectangle();
          }
          var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy;
          if (this.parentContainer) {
            var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
            this.getTopLeft(output);
            parentMatrix.transformPoint(output.x, output.y, output);
            TLx = output.x;
            TLy = output.y;
            this.getTopRight(output);
            parentMatrix.transformPoint(output.x, output.y, output);
            TRx = output.x;
            TRy = output.y;
            this.getBottomLeft(output);
            parentMatrix.transformPoint(output.x, output.y, output);
            BLx = output.x;
            BLy = output.y;
            this.getBottomRight(output);
            parentMatrix.transformPoint(output.x, output.y, output);
            BRx = output.x;
            BRy = output.y;
          } else {
            this.getTopLeft(output);
            TLx = output.x;
            TLy = output.y;
            this.getTopRight(output);
            TRx = output.x;
            TRy = output.y;
            this.getBottomLeft(output);
            BLx = output.x;
            BLy = output.y;
            this.getBottomRight(output);
            BRx = output.x;
            BRy = output.y;
          }
          output.x = Math.min(TLx, TRx, BLx, BRx);
          output.y = Math.min(TLy, TRy, BLy, BRy);
          output.width = Math.max(TLx, TRx, BLx, BRx) - output.x;
          output.height = Math.max(TLy, TRy, BLy, BRy) - output.y;
          return output;
        }
      };
      module.exports = GetBounds;
    }
  });

  // ../../node_modules/phaser/src/plugins/PluginCache.js
  var require_PluginCache = __commonJS({
    "../../node_modules/phaser/src/plugins/PluginCache.js": function(exports, module) {
      var corePlugins = {};
      var customPlugins = {};
      var PluginCache = {};
      PluginCache.register = function(key, plugin, mapping, custom) {
        if (custom === void 0) {
          custom = false;
        }
        corePlugins[key] = { plugin: plugin, mapping: mapping, custom: custom };
      };
      PluginCache.registerCustom = function(key, plugin, mapping, data) {
        customPlugins[key] = { plugin: plugin, mapping: mapping, data: data };
      };
      PluginCache.hasCore = function(key) {
        return corePlugins.hasOwnProperty(key);
      };
      PluginCache.hasCustom = function(key) {
        return customPlugins.hasOwnProperty(key);
      };
      PluginCache.getCore = function(key) {
        return corePlugins[key];
      };
      PluginCache.getCustom = function(key) {
        return customPlugins[key];
      };
      PluginCache.getCustomClass = function(key) {
        return customPlugins.hasOwnProperty(key) ? customPlugins[key].plugin : null;
      };
      PluginCache.remove = function(key) {
        if (corePlugins.hasOwnProperty(key)) {
          delete corePlugins[key];
        }
      };
      PluginCache.removeCustom = function(key) {
        if (customPlugins.hasOwnProperty(key)) {
          delete customPlugins[key];
        }
      };
      PluginCache.destroyCorePlugins = function() {
        for (var key in corePlugins) {
          if (corePlugins.hasOwnProperty(key)) {
            delete corePlugins[key];
          }
        }
      };
      PluginCache.destroyCustomPlugins = function() {
        for (var key in customPlugins) {
          if (customPlugins.hasOwnProperty(key)) {
            delete customPlugins[key];
          }
        }
      };
      module.exports = PluginCache;
    }
  });

  // ../../node_modules/phaser/src/scene/events/ADDED_TO_SCENE_EVENT.js
  var require_ADDED_TO_SCENE_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/ADDED_TO_SCENE_EVENT.js": function(exports, module) {
      module.exports = "addedtoscene";
    }
  });

  // ../../node_modules/phaser/src/scene/events/BOOT_EVENT.js
  var require_BOOT_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/BOOT_EVENT.js": function(exports, module) {
      module.exports = "boot";
    }
  });

  // ../../node_modules/phaser/src/scene/events/CREATE_EVENT.js
  var require_CREATE_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/CREATE_EVENT.js": function(exports, module) {
      module.exports = "create";
    }
  });

  // ../../node_modules/phaser/src/scene/events/DESTROY_EVENT.js
  var require_DESTROY_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/DESTROY_EVENT.js": function(exports, module) {
      module.exports = "destroy";
    }
  });

  // ../../node_modules/phaser/src/scene/events/PAUSE_EVENT.js
  var require_PAUSE_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/PAUSE_EVENT.js": function(exports, module) {
      module.exports = "pause";
    }
  });

  // ../../node_modules/phaser/src/scene/events/POST_UPDATE_EVENT.js
  var require_POST_UPDATE_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/POST_UPDATE_EVENT.js": function(exports, module) {
      module.exports = "postupdate";
    }
  });

  // ../../node_modules/phaser/src/scene/events/PRE_RENDER_EVENT.js
  var require_PRE_RENDER_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/PRE_RENDER_EVENT.js": function(exports, module) {
      module.exports = "prerender";
    }
  });

  // ../../node_modules/phaser/src/scene/events/PRE_UPDATE_EVENT.js
  var require_PRE_UPDATE_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/PRE_UPDATE_EVENT.js": function(exports, module) {
      module.exports = "preupdate";
    }
  });

  // ../../node_modules/phaser/src/scene/events/READY_EVENT.js
  var require_READY_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/READY_EVENT.js": function(exports, module) {
      module.exports = "ready";
    }
  });

  // ../../node_modules/phaser/src/scene/events/REMOVED_FROM_SCENE_EVENT.js
  var require_REMOVED_FROM_SCENE_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/REMOVED_FROM_SCENE_EVENT.js": function(exports, module) {
      module.exports = "removedfromscene";
    }
  });

  // ../../node_modules/phaser/src/scene/events/RENDER_EVENT.js
  var require_RENDER_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/RENDER_EVENT.js": function(exports, module) {
      module.exports = "render";
    }
  });

  // ../../node_modules/phaser/src/scene/events/RESUME_EVENT.js
  var require_RESUME_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/RESUME_EVENT.js": function(exports, module) {
      module.exports = "resume";
    }
  });

  // ../../node_modules/phaser/src/scene/events/SHUTDOWN_EVENT.js
  var require_SHUTDOWN_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/SHUTDOWN_EVENT.js": function(exports, module) {
      module.exports = "shutdown";
    }
  });

  // ../../node_modules/phaser/src/scene/events/SLEEP_EVENT.js
  var require_SLEEP_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/SLEEP_EVENT.js": function(exports, module) {
      module.exports = "sleep";
    }
  });

  // ../../node_modules/phaser/src/scene/events/START_EVENT.js
  var require_START_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/START_EVENT.js": function(exports, module) {
      module.exports = "start";
    }
  });

  // ../../node_modules/phaser/src/scene/events/TRANSITION_COMPLETE_EVENT.js
  var require_TRANSITION_COMPLETE_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/TRANSITION_COMPLETE_EVENT.js": function(exports, module) {
      module.exports = "transitioncomplete";
    }
  });

  // ../../node_modules/phaser/src/scene/events/TRANSITION_INIT_EVENT.js
  var require_TRANSITION_INIT_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/TRANSITION_INIT_EVENT.js": function(exports, module) {
      module.exports = "transitioninit";
    }
  });

  // ../../node_modules/phaser/src/scene/events/TRANSITION_OUT_EVENT.js
  var require_TRANSITION_OUT_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/TRANSITION_OUT_EVENT.js": function(exports, module) {
      module.exports = "transitionout";
    }
  });

  // ../../node_modules/phaser/src/scene/events/TRANSITION_START_EVENT.js
  var require_TRANSITION_START_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/TRANSITION_START_EVENT.js": function(exports, module) {
      module.exports = "transitionstart";
    }
  });

  // ../../node_modules/phaser/src/scene/events/TRANSITION_WAKE_EVENT.js
  var require_TRANSITION_WAKE_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/TRANSITION_WAKE_EVENT.js": function(exports, module) {
      module.exports = "transitionwake";
    }
  });

  // ../../node_modules/phaser/src/scene/events/UPDATE_EVENT.js
  var require_UPDATE_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/UPDATE_EVENT.js": function(exports, module) {
      module.exports = "update";
    }
  });

  // ../../node_modules/phaser/src/scene/events/WAKE_EVENT.js
  var require_WAKE_EVENT = __commonJS({
    "../../node_modules/phaser/src/scene/events/WAKE_EVENT.js": function(exports, module) {
      module.exports = "wake";
    }
  });

  // ../../node_modules/phaser/src/scene/events/index.js
  var require_events = __commonJS({
    "../../node_modules/phaser/src/scene/events/index.js": function(exports, module) {
      module.exports = {
        ADDED_TO_SCENE: require_ADDED_TO_SCENE_EVENT(),
        BOOT: require_BOOT_EVENT(),
        CREATE: require_CREATE_EVENT(),
        DESTROY: require_DESTROY_EVENT(),
        PAUSE: require_PAUSE_EVENT(),
        POST_UPDATE: require_POST_UPDATE_EVENT(),
        PRE_RENDER: require_PRE_RENDER_EVENT(),
        PRE_UPDATE: require_PRE_UPDATE_EVENT(),
        READY: require_READY_EVENT(),
        REMOVED_FROM_SCENE: require_REMOVED_FROM_SCENE_EVENT(),
        RENDER: require_RENDER_EVENT(),
        RESUME: require_RESUME_EVENT(),
        SHUTDOWN: require_SHUTDOWN_EVENT(),
        SLEEP: require_SLEEP_EVENT(),
        START: require_START_EVENT(),
        TRANSITION_COMPLETE: require_TRANSITION_COMPLETE_EVENT(),
        TRANSITION_INIT: require_TRANSITION_INIT_EVENT(),
        TRANSITION_OUT: require_TRANSITION_OUT_EVENT(),
        TRANSITION_START: require_TRANSITION_START_EVENT(),
        TRANSITION_WAKE: require_TRANSITION_WAKE_EVENT(),
        UPDATE: require_UPDATE_EVENT(),
        WAKE: require_WAKE_EVENT()
      };
    }
  });

  // ../../node_modules/phaser/src/gameobjects/GameObjectFactory.js
  var require_GameObjectFactory = __commonJS({
    "../../node_modules/phaser/src/gameobjects/GameObjectFactory.js": function(exports, module) {
      var Class = require_Class();
      var PluginCache = require_PluginCache();
      var SceneEvents = require_events();
      var GameObjectFactory = new Class({
        initialize: function GameObjectFactory2(scene) {
          this.scene = scene;
          this.systems = scene.sys;
          this.events = scene.sys.events;
          this.displayList;
          this.updateList;
          this.events.once(SceneEvents.BOOT, this.boot, this);
          this.events.on(SceneEvents.START, this.start, this);
        },
        boot: function() {
          this.displayList = this.systems.displayList;
          this.updateList = this.systems.updateList;
          this.events.once(SceneEvents.DESTROY, this.destroy, this);
        },
        start: function() {
          this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        existing: function(child) {
          if (child.renderCanvas || child.renderWebGL) {
            this.displayList.add(child);
          }
          if (child.preUpdate) {
            this.updateList.add(child);
          }
          return child;
        },
        shutdown: function() {
          this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        destroy: function() {
          this.shutdown();
          this.events.off(SceneEvents.START, this.start, this);
          this.scene = null;
          this.systems = null;
          this.events = null;
          this.displayList = null;
          this.updateList = null;
        }
      });
      GameObjectFactory.register = function(factoryType, factoryFunction) {
        if (!GameObjectFactory.prototype.hasOwnProperty(factoryType)) {
          GameObjectFactory.prototype[factoryType] = factoryFunction;
        }
      };
      GameObjectFactory.remove = function(factoryType) {
        if (GameObjectFactory.prototype.hasOwnProperty(factoryType)) {
          delete GameObjectFactory.prototype[factoryType];
        }
      };
      PluginCache.register("GameObjectFactory", GameObjectFactory, "add");
      module.exports = GameObjectFactory;
    }
  });

  // ../../node_modules/phaser/src/display/mask/BitmapMask.js
  var require_BitmapMask = __commonJS({
    "../../node_modules/phaser/src/display/mask/BitmapMask.js": function(exports, module) {
      var Class = require_Class();
      var GameObjectFactory = require_GameObjectFactory();
      var BitmapMask = new Class({
        initialize: function BitmapMask2(scene, maskObject, x, y, texture, frame) {
          if (!maskObject) {
            maskObject = scene.sys.make.image({ x: x, y: y, key: texture, frame: frame, add: false });
          }
          this.bitmapMask = maskObject;
          this.invertAlpha = false;
          this.isStencil = false;
        },
        setBitmap: function(maskObject) {
          this.bitmapMask = maskObject;
        },
        preRenderWebGL: function(renderer, maskedObject, camera) {
          renderer.pipelines.BITMAPMASK_PIPELINE.beginMask(this, maskedObject, camera);
        },
        postRenderWebGL: function(renderer, camera, renderTarget) {
          renderer.pipelines.BITMAPMASK_PIPELINE.endMask(this, camera, renderTarget);
        },
        preRenderCanvas: function() {
        },
        postRenderCanvas: function() {
        },
        destroy: function() {
          this.bitmapMask = null;
        }
      });
      GameObjectFactory.register("bitmapMask", function(maskObject, x, y, key, frame) {
        return new BitmapMask(this.scene, maskObject, x, y, key, frame);
      });
      module.exports = BitmapMask;
    }
  });

  // ../../node_modules/phaser/src/display/mask/GeometryMask.js
  var require_GeometryMask = __commonJS({
    "../../node_modules/phaser/src/display/mask/GeometryMask.js": function(exports, module) {
      var Class = require_Class();
      var GeometryMask = new Class({
        initialize: function GeometryMask2(scene, graphicsGeometry) {
          this.geometryMask = graphicsGeometry;
          this.invertAlpha = false;
          this.isStencil = true;
          this.level = 0;
        },
        setShape: function(graphicsGeometry) {
          this.geometryMask = graphicsGeometry;
          return this;
        },
        setInvertAlpha: function(value) {
          if (value === void 0) {
            value = true;
          }
          this.invertAlpha = value;
          return this;
        },
        preRenderWebGL: function(renderer, child, camera) {
          var gl = renderer.gl;
          renderer.flush();
          if (renderer.maskStack.length === 0) {
            gl.enable(gl.STENCIL_TEST);
            gl.clear(gl.STENCIL_BUFFER_BIT);
            renderer.maskCount = 0;
          }
          if (renderer.currentCameraMask.mask !== this) {
            renderer.currentMask.mask = this;
          }
          renderer.maskStack.push({ mask: this, camera: camera });
          this.applyStencil(renderer, camera, true);
          renderer.maskCount++;
        },
        applyStencil: function(renderer, camera, inc) {
          var gl = renderer.gl;
          var geometryMask = this.geometryMask;
          var level = renderer.maskCount;
          gl.colorMask(false, false, false, false);
          if (inc) {
            gl.stencilFunc(gl.EQUAL, level, 255);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
          } else {
            gl.stencilFunc(gl.EQUAL, level + 1, 255);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
          }
          geometryMask.renderWebGL(renderer, geometryMask, camera);
          renderer.flush();
          gl.colorMask(true, true, true, true);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
          if (inc) {
            if (this.invertAlpha) {
              gl.stencilFunc(gl.NOTEQUAL, level + 1, 255);
            } else {
              gl.stencilFunc(gl.EQUAL, level + 1, 255);
            }
          } else if (this.invertAlpha) {
            gl.stencilFunc(gl.NOTEQUAL, level, 255);
          } else {
            gl.stencilFunc(gl.EQUAL, level, 255);
          }
        },
        postRenderWebGL: function(renderer) {
          var gl = renderer.gl;
          renderer.maskStack.pop();
          renderer.maskCount--;
          renderer.flush();
          var current = renderer.currentMask;
          if (renderer.maskStack.length === 0) {
            current.mask = null;
            gl.disable(gl.STENCIL_TEST);
          } else {
            var prev = renderer.maskStack[renderer.maskStack.length - 1];
            prev.mask.applyStencil(renderer, prev.camera, false);
            if (renderer.currentCameraMask.mask !== prev.mask) {
              current.mask = prev.mask;
              current.camera = prev.camera;
            } else {
              current.mask = null;
            }
          }
        },
        preRenderCanvas: function(renderer, mask, camera) {
          var geometryMask = this.geometryMask;
          renderer.currentContext.save();
          geometryMask.renderCanvas(renderer, geometryMask, camera, null, null, true);
          renderer.currentContext.clip();
        },
        postRenderCanvas: function(renderer) {
          renderer.currentContext.restore();
        },
        destroy: function() {
          this.geometryMask = null;
        }
      });
      module.exports = GeometryMask;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/Mask.js
  var require_Mask = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/Mask.js": function(exports, module) {
      var BitmapMask = require_BitmapMask();
      var GeometryMask = require_GeometryMask();
      var Mask = {
        mask: null,
        setMask: function(mask) {
          this.mask = mask;
          return this;
        },
        clearMask: function(destroyMask) {
          if (destroyMask === void 0) {
            destroyMask = false;
          }
          if (destroyMask && this.mask) {
            this.mask.destroy();
          }
          this.mask = null;
          return this;
        },
        createBitmapMask: function(maskObject, x, y, texture, frame) {
          if (maskObject === void 0 && (this.texture || this.shader || this.geom)) {
            maskObject = this;
          }
          return new BitmapMask(this.scene, maskObject, x, y, texture, frame);
        },
        createGeometryMask: function(graphics) {
          if (graphics === void 0 && (this.type === "Graphics" || this.geom)) {
            graphics = this;
          }
          return new GeometryMask(this.scene, graphics);
        }
      };
      module.exports = Mask;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/Origin.js
  var require_Origin = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/Origin.js": function(exports, module) {
      var Origin = {
        _originComponent: true,
        originX: 0.5,
        originY: 0.5,
        _displayOriginX: 0,
        _displayOriginY: 0,
        displayOriginX: {
          get: function() {
            return this._displayOriginX;
          },
          set: function(value) {
            this._displayOriginX = value;
            this.originX = value / this.width;
          }
        },
        displayOriginY: {
          get: function() {
            return this._displayOriginY;
          },
          set: function(value) {
            this._displayOriginY = value;
            this.originY = value / this.height;
          }
        },
        setOrigin: function(x, y) {
          if (x === void 0) {
            x = 0.5;
          }
          if (y === void 0) {
            y = x;
          }
          this.originX = x;
          this.originY = y;
          return this.updateDisplayOrigin();
        },
        setOriginFromFrame: function() {
          if (!this.frame || !this.frame.customPivot) {
            return this.setOrigin();
          } else {
            this.originX = this.frame.pivotX;
            this.originY = this.frame.pivotY;
          }
          return this.updateDisplayOrigin();
        },
        setDisplayOrigin: function(x, y) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = x;
          }
          this.displayOriginX = x;
          this.displayOriginY = y;
          return this;
        },
        updateDisplayOrigin: function() {
          this._displayOriginX = this.originX * this.width;
          this._displayOriginY = this.originY * this.height;
          return this;
        }
      };
      module.exports = Origin;
    }
  });

  // ../../node_modules/phaser/src/math/DegToRad.js
  var require_DegToRad = __commonJS({
    "../../node_modules/phaser/src/math/DegToRad.js": function(exports, module) {
      var CONST = require_const4();
      var DegToRad = function(degrees) {
        return degrees * CONST.DEG_TO_RAD;
      };
      module.exports = DegToRad;
    }
  });

  // ../../node_modules/phaser/src/tweens/builders/GetBoolean.js
  var require_GetBoolean = __commonJS({
    "../../node_modules/phaser/src/tweens/builders/GetBoolean.js": function(exports, module) {
      var GetBoolean = function(source, key, defaultValue) {
        if (!source) {
          return defaultValue;
        } else if (source.hasOwnProperty(key)) {
          return source[key];
        } else {
          return defaultValue;
        }
      };
      module.exports = GetBoolean;
    }
  });

  // ../../node_modules/phaser/src/utils/object/GetValue.js
  var require_GetValue = __commonJS({
    "../../node_modules/phaser/src/utils/object/GetValue.js": function(exports, module) {
      var GetValue = function(source, key, defaultValue, altSource) {
        if (!source && !altSource || typeof source === "number") {
          return defaultValue;
        } else if (source && source.hasOwnProperty(key)) {
          return source[key];
        } else if (altSource && altSource.hasOwnProperty(key)) {
          return altSource[key];
        } else if (key.indexOf(".") !== -1) {
          var keys = key.split(".");
          var parentA = source;
          var parentB = altSource;
          var valueA = defaultValue;
          var valueB = defaultValue;
          var valueAFound = true;
          var valueBFound = true;
          for (var i = 0; i < keys.length; i++) {
            if (parentA && parentA.hasOwnProperty(keys[i])) {
              valueA = parentA[keys[i]];
              parentA = parentA[keys[i]];
            } else {
              valueAFound = false;
            }
            if (parentB && parentB.hasOwnProperty(keys[i])) {
              valueB = parentB[keys[i]];
              parentB = parentB[keys[i]];
            } else {
              valueBFound = false;
            }
          }
          if (valueAFound) {
            return valueA;
          } else if (valueBFound) {
            return valueB;
          } else {
            return defaultValue;
          }
        } else {
          return defaultValue;
        }
      };
      module.exports = GetValue;
    }
  });

  // ../../node_modules/phaser/src/tweens/tween/const.js
  var require_const5 = __commonJS({
    "../../node_modules/phaser/src/tweens/tween/const.js": function(exports, module) {
      var TWEEN_CONST = {
        CREATED: 0,
        DELAY: 2,
        PENDING_RENDER: 4,
        PLAYING_FORWARD: 5,
        PLAYING_BACKWARD: 6,
        HOLD_DELAY: 7,
        REPEAT_DELAY: 8,
        COMPLETE: 9,
        PENDING: 20,
        ACTIVE: 21,
        LOOP_DELAY: 22,
        COMPLETE_DELAY: 23,
        START_DELAY: 24,
        PENDING_REMOVE: 25,
        REMOVED: 26,
        FINISHED: 27,
        DESTROYED: 28,
        MAX: 999999999999
      };
      module.exports = TWEEN_CONST;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/PathFollower.js
  var require_PathFollower = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/PathFollower.js": function(exports, module) {
      var DegToRad = require_DegToRad();
      var GetBoolean = require_GetBoolean();
      var GetValue = require_GetValue();
      var TWEEN_CONST = require_const5();
      var Vector2 = require_Vector2();
      var PathFollower = {
        path: null,
        rotateToPath: false,
        pathRotationOffset: 0,
        pathOffset: null,
        pathVector: null,
        pathDelta: null,
        pathTween: null,
        pathConfig: null,
        _prevDirection: TWEEN_CONST.PLAYING_FORWARD,
        setPath: function(path, config) {
          if (config === void 0) {
            config = this.pathConfig;
          }
          var tween = this.pathTween;
          if (tween && tween.isPlaying()) {
            tween.stop();
          }
          this.path = path;
          if (config) {
            this.startFollow(config);
          }
          return this;
        },
        setRotateToPath: function(value, offset) {
          if (offset === void 0) {
            offset = 0;
          }
          this.rotateToPath = value;
          this.pathRotationOffset = offset;
          return this;
        },
        isFollowing: function() {
          var tween = this.pathTween;
          return tween && tween.isPlaying();
        },
        startFollow: function(config, startAt) {
          if (config === void 0) {
            config = {};
          }
          if (startAt === void 0) {
            startAt = 0;
          }
          var tween = this.pathTween;
          if (tween && tween.isPlaying()) {
            tween.stop();
          }
          if (typeof config === "number") {
            config = { duration: config };
          }
          config.from = GetValue(config, "from", 0);
          config.to = GetValue(config, "to", 1);
          var positionOnPath = GetBoolean(config, "positionOnPath", false);
          this.rotateToPath = GetBoolean(config, "rotateToPath", false);
          this.pathRotationOffset = GetValue(config, "rotationOffset", 0);
          var seek = GetValue(config, "startAt", startAt);
          if (seek) {
            config.onStart = function(tween2) {
              var tweenData = tween2.data[0];
              tweenData.progress = seek;
              tweenData.elapsed = tweenData.duration * seek;
              var v = tweenData.ease(tweenData.progress);
              tweenData.current = tweenData.start + (tweenData.end - tweenData.start) * v;
              tweenData.setTargetValue();
            };
          }
          if (!this.pathOffset) {
            this.pathOffset = new Vector2(this.x, this.y);
          }
          if (!this.pathVector) {
            this.pathVector = new Vector2();
          }
          if (!this.pathDelta) {
            this.pathDelta = new Vector2();
          }
          this.pathDelta.reset();
          config.persist = true;
          this.pathTween = this.scene.sys.tweens.addCounter(config);
          this.path.getStartPoint(this.pathOffset);
          if (positionOnPath) {
            this.x = this.pathOffset.x;
            this.y = this.pathOffset.y;
          }
          this.pathOffset.x = this.x - this.pathOffset.x;
          this.pathOffset.y = this.y - this.pathOffset.y;
          this._prevDirection = TWEEN_CONST.PLAYING_FORWARD;
          if (this.rotateToPath) {
            var nextPoint = this.path.getPoint(0.1);
            this.rotation = Math.atan2(nextPoint.y - this.y, nextPoint.x - this.x) + DegToRad(this.pathRotationOffset);
          }
          this.pathConfig = config;
          return this;
        },
        pauseFollow: function() {
          var tween = this.pathTween;
          if (tween && tween.isPlaying()) {
            tween.pause();
          }
          return this;
        },
        resumeFollow: function() {
          var tween = this.pathTween;
          if (tween && tween.isPaused()) {
            tween.resume();
          }
          return this;
        },
        stopFollow: function() {
          var tween = this.pathTween;
          if (tween && tween.isPlaying()) {
            tween.stop();
          }
          return this;
        },
        pathUpdate: function() {
          var tween = this.pathTween;
          if (tween) {
            var tweenData = tween.data[0];
            var pathDelta = this.pathDelta;
            var pathVector = this.pathVector;
            pathDelta.copy(pathVector).negate();
            if (tweenData.state === TWEEN_CONST.COMPLETE) {
              this.path.getPoint(tweenData.end, pathVector);
              pathDelta.add(pathVector);
              pathVector.add(this.pathOffset);
              this.setPosition(pathVector.x, pathVector.y);
              return;
            } else if (tweenData.state !== TWEEN_CONST.PLAYING_FORWARD && tweenData.state !== TWEEN_CONST.PLAYING_BACKWARD) {
              return;
            }
            this.path.getPoint(tween.getValue(), pathVector);
            pathDelta.add(pathVector);
            pathVector.add(this.pathOffset);
            var oldX = this.x;
            var oldY = this.y;
            this.setPosition(pathVector.x, pathVector.y);
            var speedX = this.x - oldX;
            var speedY = this.y - oldY;
            if (speedX === 0 && speedY === 0) {
              return;
            }
            if (tweenData.state !== this._prevDirection) {
              this._prevDirection = tweenData.state;
              return;
            }
            if (this.rotateToPath) {
              this.rotation = Math.atan2(speedY, speedX) + DegToRad(this.pathRotationOffset);
            }
          }
        }
      };
      module.exports = PathFollower;
    }
  });

  // ../../node_modules/phaser/src/utils/object/DeepCopy.js
  var require_DeepCopy = __commonJS({
    "../../node_modules/phaser/src/utils/object/DeepCopy.js": function(exports, module) {
      var DeepCopy = function(inObject) {
        var outObject;
        var value;
        var key;
        if (typeof inObject !== "object" || inObject === null) {
          return inObject;
        }
        outObject = Array.isArray(inObject) ? [] : {};
        for (key in inObject) {
          value = inObject[key];
          outObject[key] = DeepCopy(value);
        }
        return outObject;
      };
      module.exports = DeepCopy;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/Pipeline.js
  var require_Pipeline = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/Pipeline.js": function(exports, module) {
      var DeepCopy = require_DeepCopy();
      var Pipeline = {
        defaultPipeline: null,
        pipeline: null,
        pipelineData: null,
        initPipeline: function(pipeline) {
          this.pipelineData = {};
          var renderer = this.scene.sys.renderer;
          if (!renderer) {
            return false;
          }
          var pipelines = renderer.pipelines;
          if (pipelines) {
            if (pipeline === void 0) {
              pipeline = pipelines.default;
            }
            var instance = pipelines.get(pipeline);
            if (instance) {
              this.defaultPipeline = instance;
              this.pipeline = instance;
              return true;
            }
          }
          return false;
        },
        setPipeline: function(pipeline, pipelineData, copyData) {
          var renderer = this.scene.sys.renderer;
          if (!renderer) {
            return this;
          }
          var pipelines = renderer.pipelines;
          if (pipelines) {
            var instance = pipelines.get(pipeline);
            if (instance) {
              this.pipeline = instance;
            }
            if (pipelineData) {
              this.pipelineData = copyData ? DeepCopy(pipelineData) : pipelineData;
            }
          }
          return this;
        },
        setPipelineData: function(key, value) {
          var data = this.pipelineData;
          if (value === void 0) {
            delete data[key];
          } else {
            data[key] = value;
          }
          return this;
        },
        resetPipeline: function(resetData) {
          if (resetData === void 0) {
            resetData = false;
          }
          this.pipeline = this.defaultPipeline;
          if (resetData) {
            this.pipelineData = {};
          }
          return this.pipeline !== null;
        },
        getPipelineName: function() {
          return this.pipeline.name;
        }
      };
      module.exports = Pipeline;
    }
  });

  // ../../node_modules/phaser/src/utils/array/SpliceOne.js
  var require_SpliceOne = __commonJS({
    "../../node_modules/phaser/src/utils/array/SpliceOne.js": function(exports, module) {
      var SpliceOne = function(array, index) {
        if (index >= array.length) {
          return;
        }
        var len = array.length - 1;
        var item = array[index];
        for (var i = index; i < len; i++) {
          array[i] = array[i + 1];
        }
        array.length = len;
        return item;
      };
      module.exports = SpliceOne;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/PostPipeline.js
  var require_PostPipeline = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/PostPipeline.js": function(exports, module) {
      var DeepCopy = require_DeepCopy();
      var SpliceOne = require_SpliceOne();
      var PostPipeline = {
        hasPostPipeline: false,
        postPipelines: null,
        postPipelineData: null,
        initPostPipeline: function() {
          this.postPipelines = [];
          this.postPipelineData = {};
        },
        setPostPipeline: function(pipelines, pipelineData, copyData) {
          var renderer = this.scene.sys.renderer;
          if (!renderer) {
            return this;
          }
          var pipelineManager = renderer.pipelines;
          if (pipelineManager) {
            if (!Array.isArray(pipelines)) {
              pipelines = [pipelines];
            }
            for (var i = 0; i < pipelines.length; i++) {
              var instance = pipelineManager.getPostPipeline(pipelines[i], this);
              if (instance) {
                this.postPipelines.push(instance);
              }
            }
            if (pipelineData) {
              this.postPipelineData = copyData ? DeepCopy(pipelineData) : pipelineData;
            }
          }
          this.hasPostPipeline = this.postPipelines.length > 0;
          return this;
        },
        setPostPipelineData: function(key, value) {
          var data = this.postPipelineData;
          if (value === void 0) {
            delete data[key];
          } else {
            data[key] = value;
          }
          return this;
        },
        getPostPipeline: function(pipeline) {
          var isString = typeof pipeline === "string";
          var pipelines = this.postPipelines;
          var results = [];
          for (var i = 0; i < pipelines.length; i++) {
            var instance = pipelines[i];
            if (isString && instance.name === pipeline || !isString && instance instanceof pipeline) {
              results.push(instance);
            }
          }
          return results.length === 1 ? results[0] : results;
        },
        resetPostPipeline: function(resetData) {
          if (resetData === void 0) {
            resetData = false;
          }
          var pipelines = this.postPipelines;
          for (var i = 0; i < pipelines.length; i++) {
            pipelines[i].destroy();
          }
          this.postPipelines = [];
          this.hasPostPipeline = false;
          if (resetData) {
            this.postPipelineData = {};
          }
        },
        removePostPipeline: function(pipeline) {
          var pipelines = this.postPipelines;
          for (var i = pipelines.length - 1; i >= 0; i--) {
            var instance = pipelines[i];
            if (typeof pipeline === "string" && instance.name === pipeline || typeof pipeline !== "string" && instance instanceof pipeline) {
              instance.destroy();
              SpliceOne(pipelines, i);
            }
          }
          this.hasPostPipeline = this.postPipelines.length > 0;
          return this;
        }
      };
      module.exports = PostPipeline;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/ScrollFactor.js
  var require_ScrollFactor = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/ScrollFactor.js": function(exports, module) {
      var ScrollFactor = {
        scrollFactorX: 1,
        scrollFactorY: 1,
        setScrollFactor: function(x, y) {
          if (y === void 0) {
            y = x;
          }
          this.scrollFactorX = x;
          this.scrollFactorY = y;
          return this;
        }
      };
      module.exports = ScrollFactor;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/Size.js
  var require_Size = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/Size.js": function(exports, module) {
      var Size = {
        _sizeComponent: true,
        width: 0,
        height: 0,
        displayWidth: {
          get: function() {
            return Math.abs(this.scaleX * this.frame.realWidth);
          },
          set: function(value) {
            this.scaleX = value / this.frame.realWidth;
          }
        },
        displayHeight: {
          get: function() {
            return Math.abs(this.scaleY * this.frame.realHeight);
          },
          set: function(value) {
            this.scaleY = value / this.frame.realHeight;
          }
        },
        setSizeToFrame: function(frame) {
          if (frame === void 0) {
            frame = this.frame;
          }
          this.width = frame.realWidth;
          this.height = frame.realHeight;
          var input = this.input;
          if (input && !input.customHitArea) {
            input.hitArea.width = this.width;
            input.hitArea.height = this.height;
          }
          return this;
        },
        setSize: function(width, height) {
          this.width = width;
          this.height = height;
          return this;
        },
        setDisplaySize: function(width, height) {
          this.displayWidth = width;
          this.displayHeight = height;
          return this;
        }
      };
      module.exports = Size;
    }
  });

  // ../../node_modules/phaser/src/textures/Frame.js
  var require_Frame = __commonJS({
    "../../node_modules/phaser/src/textures/Frame.js": function(exports, module) {
      var Class = require_Class();
      var Clamp = require_Clamp();
      var Extend = require_Extend();
      var Frame = new Class({
        initialize: function Frame2(texture, name, sourceIndex, x, y, width, height) {
          this.texture = texture;
          this.name = name;
          this.source = texture.source[sourceIndex];
          this.sourceIndex = sourceIndex;
          this.glTexture = this.source.glTexture;
          this.cutX;
          this.cutY;
          this.cutWidth;
          this.cutHeight;
          this.x = 0;
          this.y = 0;
          this.width;
          this.height;
          this.halfWidth;
          this.halfHeight;
          this.centerX;
          this.centerY;
          this.pivotX = 0;
          this.pivotY = 0;
          this.customPivot = false;
          this.rotated = false;
          this.autoRound = -1;
          this.customData = {};
          this.u0 = 0;
          this.v0 = 0;
          this.u1 = 0;
          this.v1 = 0;
          this.data = {
            cut: {
              x: 0,
              y: 0,
              w: 0,
              h: 0,
              r: 0,
              b: 0
            },
            trim: false,
            sourceSize: {
              w: 0,
              h: 0
            },
            spriteSourceSize: {
              x: 0,
              y: 0,
              w: 0,
              h: 0,
              r: 0,
              b: 0
            },
            radius: 0,
            drawImage: {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            }
          };
          this.setSize(width, height, x, y);
        },
        setSize: function(width, height, x, y) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          this.cutX = x;
          this.cutY = y;
          this.cutWidth = width;
          this.cutHeight = height;
          this.width = width;
          this.height = height;
          this.halfWidth = Math.floor(width * 0.5);
          this.halfHeight = Math.floor(height * 0.5);
          this.centerX = Math.floor(width / 2);
          this.centerY = Math.floor(height / 2);
          var data = this.data;
          var cut = data.cut;
          cut.x = x;
          cut.y = y;
          cut.w = width;
          cut.h = height;
          cut.r = x + width;
          cut.b = y + height;
          data.sourceSize.w = width;
          data.sourceSize.h = height;
          data.spriteSourceSize.w = width;
          data.spriteSourceSize.h = height;
          data.radius = 0.5 * Math.sqrt(width * width + height * height);
          var drawImage = data.drawImage;
          drawImage.x = x;
          drawImage.y = y;
          drawImage.width = width;
          drawImage.height = height;
          return this.updateUVs();
        },
        setTrim: function(actualWidth, actualHeight, destX, destY, destWidth, destHeight) {
          var data = this.data;
          var ss = data.spriteSourceSize;
          data.trim = true;
          data.sourceSize.w = actualWidth;
          data.sourceSize.h = actualHeight;
          ss.x = destX;
          ss.y = destY;
          ss.w = destWidth;
          ss.h = destHeight;
          ss.r = destX + destWidth;
          ss.b = destY + destHeight;
          this.x = destX;
          this.y = destY;
          this.width = destWidth;
          this.height = destHeight;
          this.halfWidth = destWidth * 0.5;
          this.halfHeight = destHeight * 0.5;
          this.centerX = Math.floor(destWidth / 2);
          this.centerY = Math.floor(destHeight / 2);
          return this.updateUVs();
        },
        setCropUVs: function(crop, x, y, width, height, flipX, flipY) {
          var cx = this.cutX;
          var cy = this.cutY;
          var cw = this.cutWidth;
          var ch = this.cutHeight;
          var rw = this.realWidth;
          var rh = this.realHeight;
          x = Clamp(x, 0, rw);
          y = Clamp(y, 0, rh);
          width = Clamp(width, 0, rw - x);
          height = Clamp(height, 0, rh - y);
          var ox = cx + x;
          var oy = cy + y;
          var ow = width;
          var oh = height;
          var data = this.data;
          if (data.trim) {
            var ss = data.spriteSourceSize;
            width = Clamp(width, 0, cw - x);
            height = Clamp(height, 0, ch - y);
            var cropRight = x + width;
            var cropBottom = y + height;
            var intersects = !(ss.r < x || ss.b < y || ss.x > cropRight || ss.y > cropBottom);
            if (intersects) {
              var ix = Math.max(ss.x, x);
              var iy = Math.max(ss.y, y);
              var iw = Math.min(ss.r, cropRight) - ix;
              var ih = Math.min(ss.b, cropBottom) - iy;
              ow = iw;
              oh = ih;
              if (flipX) {
                ox = cx + (cw - (ix - ss.x) - iw);
              } else {
                ox = cx + (ix - ss.x);
              }
              if (flipY) {
                oy = cy + (ch - (iy - ss.y) - ih);
              } else {
                oy = cy + (iy - ss.y);
              }
              x = ix;
              y = iy;
              width = iw;
              height = ih;
            } else {
              ox = 0;
              oy = 0;
              ow = 0;
              oh = 0;
            }
          } else {
            if (flipX) {
              ox = cx + (cw - x - width);
            }
            if (flipY) {
              oy = cy + (ch - y - height);
            }
          }
          var tw = this.source.width;
          var th = this.source.height;
          crop.u0 = Math.max(0, ox / tw);
          crop.v0 = Math.max(0, oy / th);
          crop.u1 = Math.min(1, (ox + ow) / tw);
          crop.v1 = Math.min(1, (oy + oh) / th);
          crop.x = x;
          crop.y = y;
          crop.cx = ox;
          crop.cy = oy;
          crop.cw = ow;
          crop.ch = oh;
          crop.width = width;
          crop.height = height;
          crop.flipX = flipX;
          crop.flipY = flipY;
          return crop;
        },
        updateCropUVs: function(crop, flipX, flipY) {
          return this.setCropUVs(crop, crop.x, crop.y, crop.width, crop.height, flipX, flipY);
        },
        setUVs: function(width, height, u0, v0, u1, v1) {
          var cd = this.data.drawImage;
          cd.width = width;
          cd.height = height;
          this.u0 = u0;
          this.v0 = v0;
          this.u1 = u1;
          this.v1 = v1;
          return this;
        },
        updateUVs: function() {
          var cx = this.cutX;
          var cy = this.cutY;
          var cw = this.cutWidth;
          var ch = this.cutHeight;
          var cd = this.data.drawImage;
          cd.width = cw;
          cd.height = ch;
          var tw = this.source.width;
          var th = this.source.height;
          this.u0 = cx / tw;
          this.v0 = cy / th;
          this.u1 = (cx + cw) / tw;
          this.v1 = (cy + ch) / th;
          return this;
        },
        updateUVsInverted: function() {
          var tw = this.source.width;
          var th = this.source.height;
          this.u0 = (this.cutX + this.cutHeight) / tw;
          this.v0 = this.cutY / th;
          this.u1 = this.cutX / tw;
          this.v1 = (this.cutY + this.cutWidth) / th;
          return this;
        },
        clone: function() {
          var clone = new Frame(this.texture, this.name, this.sourceIndex);
          clone.cutX = this.cutX;
          clone.cutY = this.cutY;
          clone.cutWidth = this.cutWidth;
          clone.cutHeight = this.cutHeight;
          clone.x = this.x;
          clone.y = this.y;
          clone.width = this.width;
          clone.height = this.height;
          clone.halfWidth = this.halfWidth;
          clone.halfHeight = this.halfHeight;
          clone.centerX = this.centerX;
          clone.centerY = this.centerY;
          clone.rotated = this.rotated;
          clone.data = Extend(true, clone.data, this.data);
          clone.updateUVs();
          return clone;
        },
        destroy: function() {
          this.source = null;
          this.texture = null;
          this.glTexture = null;
          this.customData = null;
          this.data = null;
        },
        realWidth: {
          get: function() {
            return this.data.sourceSize.w;
          }
        },
        realHeight: {
          get: function() {
            return this.data.sourceSize.h;
          }
        },
        radius: {
          get: function() {
            return this.data.radius;
          }
        },
        trimmed: {
          get: function() {
            return this.data.trim;
          }
        },
        canvasData: {
          get: function() {
            return this.data.drawImage;
          }
        }
      });
      module.exports = Frame;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/Texture.js
  var require_Texture = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/Texture.js": function(exports, module) {
      var Frame = require_Frame();
      var _FLAG = 8;
      var Texture = {
        texture: null,
        frame: null,
        isCropped: false,
        setTexture: function(key, frame) {
          this.texture = this.scene.sys.textures.get(key);
          return this.setFrame(frame);
        },
        setFrame: function(frame, updateSize, updateOrigin) {
          if (updateSize === void 0) {
            updateSize = true;
          }
          if (updateOrigin === void 0) {
            updateOrigin = true;
          }
          if (frame instanceof Frame) {
            this.texture = this.scene.sys.textures.get(frame.texture.key);
            this.frame = frame;
          } else {
            this.frame = this.texture.get(frame);
          }
          if (!this.frame.cutWidth || !this.frame.cutHeight) {
            this.renderFlags &= ~_FLAG;
          } else {
            this.renderFlags |= _FLAG;
          }
          if (this._sizeComponent && updateSize) {
            this.setSizeToFrame();
          }
          if (this._originComponent && updateOrigin) {
            if (this.frame.customPivot) {
              this.setOrigin(this.frame.pivotX, this.frame.pivotY);
            } else {
              this.updateDisplayOrigin();
            }
          }
          return this;
        }
      };
      module.exports = Texture;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/TextureCrop.js
  var require_TextureCrop = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/TextureCrop.js": function(exports, module) {
      var Frame = require_Frame();
      var _FLAG = 8;
      var TextureCrop = {
        texture: null,
        frame: null,
        isCropped: false,
        setCrop: function(x, y, width, height) {
          if (x === void 0) {
            this.isCropped = false;
          } else if (this.frame) {
            if (typeof x === "number") {
              this.frame.setCropUVs(this._crop, x, y, width, height, this.flipX, this.flipY);
            } else {
              var rect = x;
              this.frame.setCropUVs(this._crop, rect.x, rect.y, rect.width, rect.height, this.flipX, this.flipY);
            }
            this.isCropped = true;
          }
          return this;
        },
        setTexture: function(key, frame) {
          this.texture = this.scene.sys.textures.get(key);
          return this.setFrame(frame);
        },
        setFrame: function(frame, updateSize, updateOrigin) {
          if (updateSize === void 0) {
            updateSize = true;
          }
          if (updateOrigin === void 0) {
            updateOrigin = true;
          }
          if (frame instanceof Frame) {
            this.texture = this.scene.sys.textures.get(frame.texture.key);
            this.frame = frame;
          } else {
            this.frame = this.texture.get(frame);
          }
          if (!this.frame.cutWidth || !this.frame.cutHeight) {
            this.renderFlags &= ~_FLAG;
          } else {
            this.renderFlags |= _FLAG;
          }
          if (this._sizeComponent && updateSize) {
            this.setSizeToFrame();
          }
          if (this._originComponent && updateOrigin) {
            if (this.frame.customPivot) {
              this.setOrigin(this.frame.pivotX, this.frame.pivotY);
            } else {
              this.updateDisplayOrigin();
            }
          }
          if (this.isCropped) {
            this.frame.updateCropUVs(this._crop, this.flipX, this.flipY);
          }
          return this;
        },
        resetCropObject: function() {
          return { u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: false, flipY: false, cx: 0, cy: 0, cw: 0, ch: 0 };
        }
      };
      module.exports = TextureCrop;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/Tint.js
  var require_Tint = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/Tint.js": function(exports, module) {
      var Tint = {
        tintTopLeft: 16777215,
        tintTopRight: 16777215,
        tintBottomLeft: 16777215,
        tintBottomRight: 16777215,
        tintFill: false,
        clearTint: function() {
          this.setTint(16777215);
          return this;
        },
        setTint: function(topLeft, topRight, bottomLeft, bottomRight) {
          if (topLeft === void 0) {
            topLeft = 16777215;
          }
          if (topRight === void 0) {
            topRight = topLeft;
            bottomLeft = topLeft;
            bottomRight = topLeft;
          }
          this.tintTopLeft = topLeft;
          this.tintTopRight = topRight;
          this.tintBottomLeft = bottomLeft;
          this.tintBottomRight = bottomRight;
          this.tintFill = false;
          return this;
        },
        setTintFill: function(topLeft, topRight, bottomLeft, bottomRight) {
          this.setTint(topLeft, topRight, bottomLeft, bottomRight);
          this.tintFill = true;
          return this;
        },
        tint: {
          set: function(value) {
            this.setTint(value, value, value, value);
          }
        },
        isTinted: {
          get: function() {
            var white = 16777215;
            return this.tintFill || this.tintTopLeft !== white || this.tintTopRight !== white || this.tintBottomLeft !== white || this.tintBottomRight !== white;
          }
        }
      };
      module.exports = Tint;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/ToJSON.js
  var require_ToJSON = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/ToJSON.js": function(exports, module) {
      var ToJSON = function(gameObject) {
        var out = {
          name: gameObject.name,
          type: gameObject.type,
          x: gameObject.x,
          y: gameObject.y,
          depth: gameObject.depth,
          scale: {
            x: gameObject.scaleX,
            y: gameObject.scaleY
          },
          origin: {
            x: gameObject.originX,
            y: gameObject.originY
          },
          flipX: gameObject.flipX,
          flipY: gameObject.flipY,
          rotation: gameObject.rotation,
          alpha: gameObject.alpha,
          visible: gameObject.visible,
          blendMode: gameObject.blendMode,
          textureKey: "",
          frameKey: "",
          data: {}
        };
        if (gameObject.texture) {
          out.textureKey = gameObject.texture.key;
          out.frameKey = gameObject.frame.name;
        }
        return out;
      };
      module.exports = ToJSON;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/TransformMatrix.js
  var require_TransformMatrix = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/TransformMatrix.js": function(exports, module) {
      var Class = require_Class();
      var MATH_CONST = require_const4();
      var Vector2 = require_Vector2();
      var TransformMatrix = new Class({
        initialize: function TransformMatrix2(a, b, c, d, tx, ty) {
          if (a === void 0) {
            a = 1;
          }
          if (b === void 0) {
            b = 0;
          }
          if (c === void 0) {
            c = 0;
          }
          if (d === void 0) {
            d = 1;
          }
          if (tx === void 0) {
            tx = 0;
          }
          if (ty === void 0) {
            ty = 0;
          }
          this.matrix = new Float32Array([a, b, c, d, tx, ty, 0, 0, 1]);
          this.decomposedMatrix = {
            translateX: 0,
            translateY: 0,
            scaleX: 1,
            scaleY: 1,
            rotation: 0
          };
          this.quad = new Float32Array(8);
        },
        a: {
          get: function() {
            return this.matrix[0];
          },
          set: function(value) {
            this.matrix[0] = value;
          }
        },
        b: {
          get: function() {
            return this.matrix[1];
          },
          set: function(value) {
            this.matrix[1] = value;
          }
        },
        c: {
          get: function() {
            return this.matrix[2];
          },
          set: function(value) {
            this.matrix[2] = value;
          }
        },
        d: {
          get: function() {
            return this.matrix[3];
          },
          set: function(value) {
            this.matrix[3] = value;
          }
        },
        e: {
          get: function() {
            return this.matrix[4];
          },
          set: function(value) {
            this.matrix[4] = value;
          }
        },
        f: {
          get: function() {
            return this.matrix[5];
          },
          set: function(value) {
            this.matrix[5] = value;
          }
        },
        tx: {
          get: function() {
            return this.matrix[4];
          },
          set: function(value) {
            this.matrix[4] = value;
          }
        },
        ty: {
          get: function() {
            return this.matrix[5];
          },
          set: function(value) {
            this.matrix[5] = value;
          }
        },
        rotation: {
          get: function() {
            return Math.acos(this.a / this.scaleX) * (Math.atan(-this.c / this.a) < 0 ? -1 : 1);
          }
        },
        rotationNormalized: {
          get: function() {
            var matrix = this.matrix;
            var a = matrix[0];
            var b = matrix[1];
            var c = matrix[2];
            var d = matrix[3];
            if (a || b) {
              return b > 0 ? Math.acos(a / this.scaleX) : -Math.acos(a / this.scaleX);
            } else if (c || d) {
              return MATH_CONST.TAU - (d > 0 ? Math.acos(-c / this.scaleY) : -Math.acos(c / this.scaleY));
            } else {
              return 0;
            }
          }
        },
        scaleX: {
          get: function() {
            return Math.sqrt(this.a * this.a + this.b * this.b);
          }
        },
        scaleY: {
          get: function() {
            return Math.sqrt(this.c * this.c + this.d * this.d);
          }
        },
        loadIdentity: function() {
          var matrix = this.matrix;
          matrix[0] = 1;
          matrix[1] = 0;
          matrix[2] = 0;
          matrix[3] = 1;
          matrix[4] = 0;
          matrix[5] = 0;
          return this;
        },
        translate: function(x, y) {
          var matrix = this.matrix;
          matrix[4] = matrix[0] * x + matrix[2] * y + matrix[4];
          matrix[5] = matrix[1] * x + matrix[3] * y + matrix[5];
          return this;
        },
        scale: function(x, y) {
          var matrix = this.matrix;
          matrix[0] *= x;
          matrix[1] *= x;
          matrix[2] *= y;
          matrix[3] *= y;
          return this;
        },
        rotate: function(angle) {
          var sin = Math.sin(angle);
          var cos = Math.cos(angle);
          var matrix = this.matrix;
          var a = matrix[0];
          var b = matrix[1];
          var c = matrix[2];
          var d = matrix[3];
          matrix[0] = a * cos + c * sin;
          matrix[1] = b * cos + d * sin;
          matrix[2] = a * -sin + c * cos;
          matrix[3] = b * -sin + d * cos;
          return this;
        },
        multiply: function(rhs, out) {
          var matrix = this.matrix;
          var source = rhs.matrix;
          var localA = matrix[0];
          var localB = matrix[1];
          var localC = matrix[2];
          var localD = matrix[3];
          var localE = matrix[4];
          var localF = matrix[5];
          var sourceA = source[0];
          var sourceB = source[1];
          var sourceC = source[2];
          var sourceD = source[3];
          var sourceE = source[4];
          var sourceF = source[5];
          var destinationMatrix = out === void 0 ? matrix : out.matrix;
          destinationMatrix[0] = sourceA * localA + sourceB * localC;
          destinationMatrix[1] = sourceA * localB + sourceB * localD;
          destinationMatrix[2] = sourceC * localA + sourceD * localC;
          destinationMatrix[3] = sourceC * localB + sourceD * localD;
          destinationMatrix[4] = sourceE * localA + sourceF * localC + localE;
          destinationMatrix[5] = sourceE * localB + sourceF * localD + localF;
          return destinationMatrix;
        },
        multiplyWithOffset: function(src, offsetX, offsetY) {
          var matrix = this.matrix;
          var otherMatrix = src.matrix;
          var a0 = matrix[0];
          var b0 = matrix[1];
          var c0 = matrix[2];
          var d0 = matrix[3];
          var tx0 = matrix[4];
          var ty0 = matrix[5];
          var pse = offsetX * a0 + offsetY * c0 + tx0;
          var psf = offsetX * b0 + offsetY * d0 + ty0;
          var a1 = otherMatrix[0];
          var b1 = otherMatrix[1];
          var c1 = otherMatrix[2];
          var d1 = otherMatrix[3];
          var tx1 = otherMatrix[4];
          var ty1 = otherMatrix[5];
          matrix[0] = a1 * a0 + b1 * c0;
          matrix[1] = a1 * b0 + b1 * d0;
          matrix[2] = c1 * a0 + d1 * c0;
          matrix[3] = c1 * b0 + d1 * d0;
          matrix[4] = tx1 * a0 + ty1 * c0 + pse;
          matrix[5] = tx1 * b0 + ty1 * d0 + psf;
          return this;
        },
        transform: function(a, b, c, d, tx, ty) {
          var matrix = this.matrix;
          var a0 = matrix[0];
          var b0 = matrix[1];
          var c0 = matrix[2];
          var d0 = matrix[3];
          var tx0 = matrix[4];
          var ty0 = matrix[5];
          matrix[0] = a * a0 + b * c0;
          matrix[1] = a * b0 + b * d0;
          matrix[2] = c * a0 + d * c0;
          matrix[3] = c * b0 + d * d0;
          matrix[4] = tx * a0 + ty * c0 + tx0;
          matrix[5] = tx * b0 + ty * d0 + ty0;
          return this;
        },
        transformPoint: function(x, y, point) {
          if (point === void 0) {
            point = { x: 0, y: 0 };
          }
          var matrix = this.matrix;
          var a = matrix[0];
          var b = matrix[1];
          var c = matrix[2];
          var d = matrix[3];
          var tx = matrix[4];
          var ty = matrix[5];
          point.x = x * a + y * c + tx;
          point.y = x * b + y * d + ty;
          return point;
        },
        invert: function() {
          var matrix = this.matrix;
          var a = matrix[0];
          var b = matrix[1];
          var c = matrix[2];
          var d = matrix[3];
          var tx = matrix[4];
          var ty = matrix[5];
          var n = a * d - b * c;
          matrix[0] = d / n;
          matrix[1] = -b / n;
          matrix[2] = -c / n;
          matrix[3] = a / n;
          matrix[4] = (c * ty - d * tx) / n;
          matrix[5] = -(a * ty - b * tx) / n;
          return this;
        },
        copyFrom: function(src) {
          var matrix = this.matrix;
          matrix[0] = src.a;
          matrix[1] = src.b;
          matrix[2] = src.c;
          matrix[3] = src.d;
          matrix[4] = src.e;
          matrix[5] = src.f;
          return this;
        },
        copyFromArray: function(src) {
          var matrix = this.matrix;
          matrix[0] = src[0];
          matrix[1] = src[1];
          matrix[2] = src[2];
          matrix[3] = src[3];
          matrix[4] = src[4];
          matrix[5] = src[5];
          return this;
        },
        copyToContext: function(ctx) {
          var matrix = this.matrix;
          ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
          return ctx;
        },
        setToContext: function(ctx) {
          var matrix = this.matrix;
          ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
          return ctx;
        },
        copyToArray: function(out) {
          var matrix = this.matrix;
          if (out === void 0) {
            out = [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]];
          } else {
            out[0] = matrix[0];
            out[1] = matrix[1];
            out[2] = matrix[2];
            out[3] = matrix[3];
            out[4] = matrix[4];
            out[5] = matrix[5];
          }
          return out;
        },
        setTransform: function(a, b, c, d, tx, ty) {
          var matrix = this.matrix;
          matrix[0] = a;
          matrix[1] = b;
          matrix[2] = c;
          matrix[3] = d;
          matrix[4] = tx;
          matrix[5] = ty;
          return this;
        },
        decomposeMatrix: function() {
          var decomposedMatrix = this.decomposedMatrix;
          var matrix = this.matrix;
          var a = matrix[0];
          var b = matrix[1];
          var c = matrix[2];
          var d = matrix[3];
          var determ = a * d - b * c;
          decomposedMatrix.translateX = matrix[4];
          decomposedMatrix.translateY = matrix[5];
          if (a || b) {
            var r = Math.sqrt(a * a + b * b);
            decomposedMatrix.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);
            decomposedMatrix.scaleX = r;
            decomposedMatrix.scaleY = determ / r;
          } else if (c || d) {
            var s = Math.sqrt(c * c + d * d);
            decomposedMatrix.rotation = Math.PI * 0.5 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));
            decomposedMatrix.scaleX = determ / s;
            decomposedMatrix.scaleY = s;
          } else {
            decomposedMatrix.rotation = 0;
            decomposedMatrix.scaleX = 0;
            decomposedMatrix.scaleY = 0;
          }
          return decomposedMatrix;
        },
        applyITRS: function(x, y, rotation, scaleX, scaleY) {
          var matrix = this.matrix;
          var radianSin = Math.sin(rotation);
          var radianCos = Math.cos(rotation);
          matrix[4] = x;
          matrix[5] = y;
          matrix[0] = radianCos * scaleX;
          matrix[1] = radianSin * scaleX;
          matrix[2] = -radianSin * scaleY;
          matrix[3] = radianCos * scaleY;
          return this;
        },
        applyInverse: function(x, y, output) {
          if (output === void 0) {
            output = new Vector2();
          }
          var matrix = this.matrix;
          var a = matrix[0];
          var b = matrix[1];
          var c = matrix[2];
          var d = matrix[3];
          var tx = matrix[4];
          var ty = matrix[5];
          var id = 1 / (a * d + c * -b);
          output.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;
          output.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;
          return output;
        },
        setQuad: function(x, y, xw, yh, roundPixels, quad) {
          if (quad === void 0) {
            quad = this.quad;
          }
          var matrix = this.matrix;
          var a = matrix[0];
          var b = matrix[1];
          var c = matrix[2];
          var d = matrix[3];
          var e = matrix[4];
          var f = matrix[5];
          quad[0] = x * a + y * c + e;
          quad[1] = x * b + y * d + f;
          quad[2] = x * a + yh * c + e;
          quad[3] = x * b + yh * d + f;
          quad[4] = xw * a + yh * c + e;
          quad[5] = xw * b + yh * d + f;
          quad[6] = xw * a + y * c + e;
          quad[7] = xw * b + y * d + f;
          if (roundPixels) {
            quad.forEach(function(value, index) {
              quad[index] = Math.round(value);
            });
          }
          return quad;
        },
        getX: function(x, y) {
          return x * this.a + y * this.c + this.e;
        },
        getY: function(x, y) {
          return x * this.b + y * this.d + this.f;
        },
        getXRound: function(x, y, round) {
          var v = this.getX(x, y);
          if (round) {
            v = Math.round(v);
          }
          return v;
        },
        getYRound: function(x, y, round) {
          var v = this.getY(x, y);
          if (round) {
            v = Math.round(v);
          }
          return v;
        },
        getCSSMatrix: function() {
          var m = this.matrix;
          return "matrix(" + m[0] + "," + m[1] + "," + m[2] + "," + m[3] + "," + m[4] + "," + m[5] + ")";
        },
        destroy: function() {
          this.matrix = null;
          this.quad = null;
          this.decomposedMatrix = null;
        }
      });
      module.exports = TransformMatrix;
    }
  });

  // ../../node_modules/phaser/src/math/TransformXY.js
  var require_TransformXY = __commonJS({
    "../../node_modules/phaser/src/math/TransformXY.js": function(exports, module) {
      var Vector2 = require_Vector2();
      var TransformXY = function(x, y, positionX, positionY, rotation, scaleX, scaleY, output) {
        if (output === void 0) {
          output = new Vector2();
        }
        var radianSin = Math.sin(rotation);
        var radianCos = Math.cos(rotation);
        var a = radianCos * scaleX;
        var b = radianSin * scaleX;
        var c = -radianSin * scaleY;
        var d = radianCos * scaleY;
        var id = 1 / (a * d + c * -b);
        output.x = d * id * x + -c * id * y + (positionY * c - positionX * d) * id;
        output.y = a * id * y + -b * id * x + (-positionY * a + positionX * b) * id;
        return output;
      };
      module.exports = TransformXY;
    }
  });

  // ../../node_modules/phaser/src/math/Wrap.js
  var require_Wrap = __commonJS({
    "../../node_modules/phaser/src/math/Wrap.js": function(exports, module) {
      var Wrap = function(value, min, max) {
        if (value >= min && value <= max) {
          return value;
        }
        var range = max - min;
        return min + ((value - min) % range + range) % range;
      };
      module.exports = Wrap;
    }
  });

  // ../../node_modules/phaser/src/math/angle/Wrap.js
  var require_Wrap2 = __commonJS({
    "../../node_modules/phaser/src/math/angle/Wrap.js": function(exports, module) {
      var MathWrap = require_Wrap();
      var Wrap = function(angle) {
        return MathWrap(angle, -Math.PI, Math.PI);
      };
      module.exports = Wrap;
    }
  });

  // ../../node_modules/phaser/src/math/angle/WrapDegrees.js
  var require_WrapDegrees = __commonJS({
    "../../node_modules/phaser/src/math/angle/WrapDegrees.js": function(exports, module) {
      var Wrap = require_Wrap();
      var WrapDegrees = function(angle) {
        return Wrap(angle, -180, 180);
      };
      module.exports = WrapDegrees;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/Transform.js
  var require_Transform = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/Transform.js": function(exports, module) {
      var MATH_CONST = require_const4();
      var TransformMatrix = require_TransformMatrix();
      var TransformXY = require_TransformXY();
      var WrapAngle = require_Wrap2();
      var WrapAngleDegrees = require_WrapDegrees();
      var Vector2 = require_Vector2();
      var _FLAG = 4;
      var Transform = {
        hasTransformComponent: true,
        _scaleX: 1,
        _scaleY: 1,
        _rotation: 0,
        x: 0,
        y: 0,
        z: 0,
        w: 0,
        scale: {
          get: function() {
            return (this._scaleX + this._scaleY) / 2;
          },
          set: function(value) {
            this._scaleX = value;
            this._scaleY = value;
            if (value === 0) {
              this.renderFlags &= ~_FLAG;
            } else {
              this.renderFlags |= _FLAG;
            }
          }
        },
        scaleX: {
          get: function() {
            return this._scaleX;
          },
          set: function(value) {
            this._scaleX = value;
            if (value === 0) {
              this.renderFlags &= ~_FLAG;
            } else {
              this.renderFlags |= _FLAG;
            }
          }
        },
        scaleY: {
          get: function() {
            return this._scaleY;
          },
          set: function(value) {
            this._scaleY = value;
            if (value === 0) {
              this.renderFlags &= ~_FLAG;
            } else {
              this.renderFlags |= _FLAG;
            }
          }
        },
        angle: {
          get: function() {
            return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);
          },
          set: function(value) {
            this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;
          }
        },
        rotation: {
          get: function() {
            return this._rotation;
          },
          set: function(value) {
            this._rotation = WrapAngle(value);
          }
        },
        setPosition: function(x, y, z, w) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = x;
          }
          if (z === void 0) {
            z = 0;
          }
          if (w === void 0) {
            w = 0;
          }
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
          return this;
        },
        copyPosition: function(source) {
          if (source.x !== void 0) {
            this.x = source.x;
          }
          if (source.y !== void 0) {
            this.y = source.y;
          }
          if (source.z !== void 0) {
            this.z = source.z;
          }
          if (source.w !== void 0) {
            this.w = source.w;
          }
          return this;
        },
        setRandomPosition: function(x, y, width, height) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (width === void 0) {
            width = this.scene.sys.scale.width;
          }
          if (height === void 0) {
            height = this.scene.sys.scale.height;
          }
          this.x = x + Math.random() * width;
          this.y = y + Math.random() * height;
          return this;
        },
        setRotation: function(radians) {
          if (radians === void 0) {
            radians = 0;
          }
          this.rotation = radians;
          return this;
        },
        setAngle: function(degrees) {
          if (degrees === void 0) {
            degrees = 0;
          }
          this.angle = degrees;
          return this;
        },
        setScale: function(x, y) {
          if (x === void 0) {
            x = 1;
          }
          if (y === void 0) {
            y = x;
          }
          this.scaleX = x;
          this.scaleY = y;
          return this;
        },
        setX: function(value) {
          if (value === void 0) {
            value = 0;
          }
          this.x = value;
          return this;
        },
        setY: function(value) {
          if (value === void 0) {
            value = 0;
          }
          this.y = value;
          return this;
        },
        setZ: function(value) {
          if (value === void 0) {
            value = 0;
          }
          this.z = value;
          return this;
        },
        setW: function(value) {
          if (value === void 0) {
            value = 0;
          }
          this.w = value;
          return this;
        },
        getLocalTransformMatrix: function(tempMatrix) {
          if (tempMatrix === void 0) {
            tempMatrix = new TransformMatrix();
          }
          return tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);
        },
        getWorldTransformMatrix: function(tempMatrix, parentMatrix) {
          if (tempMatrix === void 0) {
            tempMatrix = new TransformMatrix();
          }
          var parent = this.parentContainer;
          if (!parent) {
            return this.getLocalTransformMatrix(tempMatrix);
          }
          if (!parentMatrix) {
            parentMatrix = new TransformMatrix();
          }
          tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);
          while (parent) {
            parentMatrix.applyITRS(parent.x, parent.y, parent._rotation, parent._scaleX, parent._scaleY);
            parentMatrix.multiply(tempMatrix, tempMatrix);
            parent = parent.parentContainer;
          }
          return tempMatrix;
        },
        getLocalPoint: function(x, y, point, camera) {
          if (!point) {
            point = new Vector2();
          }
          if (!camera) {
            camera = this.scene.sys.cameras.main;
          }
          var csx = camera.scrollX;
          var csy = camera.scrollY;
          var px = x + csx * this.scrollFactorX - csx;
          var py = y + csy * this.scrollFactorY - csy;
          if (this.parentContainer) {
            this.getWorldTransformMatrix().applyInverse(px, py, point);
          } else {
            TransformXY(px, py, this.x, this.y, this.rotation, this.scaleX, this.scaleY, point);
          }
          if (this._originComponent) {
            point.x += this._displayOriginX;
            point.y += this._displayOriginY;
          }
          return point;
        },
        getParentRotation: function() {
          var rotation = 0;
          var parent = this.parentContainer;
          while (parent) {
            rotation += parent.rotation;
            parent = parent.parentContainer;
          }
          return rotation;
        }
      };
      module.exports = Transform;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/Visible.js
  var require_Visible = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/Visible.js": function(exports, module) {
      var _FLAG = 1;
      var Visible = {
        _visible: true,
        visible: {
          get: function() {
            return this._visible;
          },
          set: function(value) {
            if (value) {
              this._visible = true;
              this.renderFlags |= _FLAG;
            } else {
              this._visible = false;
              this.renderFlags &= ~_FLAG;
            }
          }
        },
        setVisible: function(value) {
          this.visible = value;
          return this;
        }
      };
      module.exports = Visible;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/components/index.js
  var require_components = __commonJS({
    "../../node_modules/phaser/src/gameobjects/components/index.js": function(exports, module) {
      module.exports = {
        Alpha: require_Alpha(),
        AlphaSingle: require_AlphaSingle(),
        BlendMode: require_BlendMode(),
        ComputedSize: require_ComputedSize(),
        Crop: require_Crop(),
        Depth: require_Depth(),
        Flip: require_Flip(),
        FX: require_FX(),
        GetBounds: require_GetBounds(),
        Mask: require_Mask(),
        Origin: require_Origin(),
        PathFollower: require_PathFollower(),
        Pipeline: require_Pipeline(),
        PostPipeline: require_PostPipeline(),
        ScrollFactor: require_ScrollFactor(),
        Size: require_Size(),
        Texture: require_Texture(),
        TextureCrop: require_TextureCrop(),
        Tint: require_Tint(),
        ToJSON: require_ToJSON(),
        Transform: require_Transform(),
        TransformMatrix: require_TransformMatrix(),
        Visible: require_Visible()
      };
    }
  });

  // ../../node_modules/phaser/src/data/events/CHANGE_DATA_EVENT.js
  var require_CHANGE_DATA_EVENT = __commonJS({
    "../../node_modules/phaser/src/data/events/CHANGE_DATA_EVENT.js": function(exports, module) {
      module.exports = "changedata";
    }
  });

  // ../../node_modules/phaser/src/data/events/CHANGE_DATA_KEY_EVENT.js
  var require_CHANGE_DATA_KEY_EVENT = __commonJS({
    "../../node_modules/phaser/src/data/events/CHANGE_DATA_KEY_EVENT.js": function(exports, module) {
      module.exports = "changedata-";
    }
  });

  // ../../node_modules/phaser/src/data/events/DESTROY_EVENT.js
  var require_DESTROY_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/data/events/DESTROY_EVENT.js": function(exports, module) {
      module.exports = "destroy";
    }
  });

  // ../../node_modules/phaser/src/data/events/REMOVE_DATA_EVENT.js
  var require_REMOVE_DATA_EVENT = __commonJS({
    "../../node_modules/phaser/src/data/events/REMOVE_DATA_EVENT.js": function(exports, module) {
      module.exports = "removedata";
    }
  });

  // ../../node_modules/phaser/src/data/events/SET_DATA_EVENT.js
  var require_SET_DATA_EVENT = __commonJS({
    "../../node_modules/phaser/src/data/events/SET_DATA_EVENT.js": function(exports, module) {
      module.exports = "setdata";
    }
  });

  // ../../node_modules/phaser/src/data/events/index.js
  var require_events2 = __commonJS({
    "../../node_modules/phaser/src/data/events/index.js": function(exports, module) {
      module.exports = {
        CHANGE_DATA: require_CHANGE_DATA_EVENT(),
        CHANGE_DATA_KEY: require_CHANGE_DATA_KEY_EVENT(),
        DESTROY: require_DESTROY_EVENT2(),
        REMOVE_DATA: require_REMOVE_DATA_EVENT(),
        SET_DATA: require_SET_DATA_EVENT()
      };
    }
  });

  // ../../node_modules/phaser/src/data/DataManager.js
  var require_DataManager = __commonJS({
    "../../node_modules/phaser/src/data/DataManager.js": function(exports, module) {
      var Class = require_Class();
      var Events = require_events2();
      var DataManager = new Class({
        initialize: function DataManager2(parent, eventEmitter) {
          this.parent = parent;
          this.events = eventEmitter;
          if (!eventEmitter) {
            this.events = parent.events ? parent.events : parent;
          }
          this.list = {};
          this.values = {};
          this._frozen = false;
          if (!parent.hasOwnProperty("sys") && this.events) {
            this.events.once(Events.DESTROY, this.destroy, this);
          }
        },
        get: function(key) {
          var list = this.list;
          if (Array.isArray(key)) {
            var output = [];
            for (var i = 0; i < key.length; i++) {
              output.push(list[key[i]]);
            }
            return output;
          } else {
            return list[key];
          }
        },
        getAll: function() {
          var results = {};
          for (var key in this.list) {
            if (this.list.hasOwnProperty(key)) {
              results[key] = this.list[key];
            }
          }
          return results;
        },
        query: function(search) {
          var results = {};
          for (var key in this.list) {
            if (this.list.hasOwnProperty(key) && key.match(search)) {
              results[key] = this.list[key];
            }
          }
          return results;
        },
        set: function(key, data) {
          if (this._frozen) {
            return this;
          }
          if (typeof key === "string") {
            return this.setValue(key, data);
          } else {
            for (var entry in key) {
              this.setValue(entry, key[entry]);
            }
          }
          return this;
        },
        inc: function(key, data) {
          if (this._frozen) {
            return this;
          }
          if (data === void 0) {
            data = 1;
          }
          var value = this.get(key);
          if (value === void 0) {
            value = 0;
          }
          this.set(key, value + data);
          return this;
        },
        toggle: function(key) {
          if (this._frozen) {
            return this;
          }
          this.set(key, !this.get(key));
          return this;
        },
        setValue: function(key, data) {
          if (this._frozen) {
            return this;
          }
          if (this.has(key)) {
            this.values[key] = data;
          } else {
            var _this = this;
            var list = this.list;
            var events = this.events;
            var parent = this.parent;
            Object.defineProperty(this.values, key, {
              enumerable: true,
              configurable: true,
              get: function() {
                return list[key];
              },
              set: function(value) {
                if (!_this._frozen) {
                  var previousValue = list[key];
                  list[key] = value;
                  events.emit(Events.CHANGE_DATA, parent, key, value, previousValue);
                  events.emit(Events.CHANGE_DATA_KEY + key, parent, value, previousValue);
                }
              }
            });
            list[key] = data;
            events.emit(Events.SET_DATA, parent, key, data);
          }
          return this;
        },
        each: function(callback, context) {
          var args = [this.parent, null, void 0];
          for (var i = 1; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          for (var key in this.list) {
            args[1] = key;
            args[2] = this.list[key];
            callback.apply(context, args);
          }
          return this;
        },
        merge: function(data, overwrite) {
          if (overwrite === void 0) {
            overwrite = true;
          }
          for (var key in data) {
            if (data.hasOwnProperty(key) && (overwrite || !overwrite && !this.has(key))) {
              this.setValue(key, data[key]);
            }
          }
          return this;
        },
        remove: function(key) {
          if (this._frozen) {
            return this;
          }
          if (Array.isArray(key)) {
            for (var i = 0; i < key.length; i++) {
              this.removeValue(key[i]);
            }
          } else {
            return this.removeValue(key);
          }
          return this;
        },
        removeValue: function(key) {
          if (this.has(key)) {
            var data = this.list[key];
            delete this.list[key];
            delete this.values[key];
            this.events.emit(Events.REMOVE_DATA, this.parent, key, data);
          }
          return this;
        },
        pop: function(key) {
          var data = void 0;
          if (!this._frozen && this.has(key)) {
            data = this.list[key];
            delete this.list[key];
            delete this.values[key];
            this.events.emit(Events.REMOVE_DATA, this.parent, key, data);
          }
          return data;
        },
        has: function(key) {
          return this.list.hasOwnProperty(key);
        },
        setFreeze: function(value) {
          this._frozen = value;
          return this;
        },
        reset: function() {
          for (var key in this.list) {
            delete this.list[key];
            delete this.values[key];
          }
          this._frozen = false;
          return this;
        },
        destroy: function() {
          this.reset();
          this.events.off(Events.CHANGE_DATA);
          this.events.off(Events.SET_DATA);
          this.events.off(Events.REMOVE_DATA);
          this.parent = null;
        },
        freeze: {
          get: function() {
            return this._frozen;
          },
          set: function(value) {
            this._frozen = value ? true : false;
          }
        },
        count: {
          get: function() {
            var i = 0;
            for (var key in this.list) {
              if (this.list[key] !== void 0) {
                i++;
              }
            }
            return i;
          }
        }
      });
      module.exports = DataManager;
    }
  });

  // ../../node_modules/phaser/node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "../../node_modules/phaser/node_modules/eventemitter3/index.js": function(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events = this._events) {
          if (has.call(events, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once)
              this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j = 1, args = new Array(len - 1); j < len; j++) {
                    args[j - 1] = arguments[j];
                  }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.addListener = EventEmitter.prototype.on;
      EventEmitter.prefixed = prefix;
      EventEmitter.EventEmitter = EventEmitter;
      if (typeof module !== "undefined") {
        module.exports = EventEmitter;
      }
    }
  });

  // ../../node_modules/phaser/src/gameobjects/events/ADDED_TO_SCENE_EVENT.js
  var require_ADDED_TO_SCENE_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/gameobjects/events/ADDED_TO_SCENE_EVENT.js": function(exports, module) {
      module.exports = "addedtoscene";
    }
  });

  // ../../node_modules/phaser/src/gameobjects/events/DESTROY_EVENT.js
  var require_DESTROY_EVENT3 = __commonJS({
    "../../node_modules/phaser/src/gameobjects/events/DESTROY_EVENT.js": function(exports, module) {
      module.exports = "destroy";
    }
  });

  // ../../node_modules/phaser/src/gameobjects/events/REMOVED_FROM_SCENE_EVENT.js
  var require_REMOVED_FROM_SCENE_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/gameobjects/events/REMOVED_FROM_SCENE_EVENT.js": function(exports, module) {
      module.exports = "removedfromscene";
    }
  });

  // ../../node_modules/phaser/src/gameobjects/events/VIDEO_COMPLETE_EVENT.js
  var require_VIDEO_COMPLETE_EVENT = __commonJS({
    "../../node_modules/phaser/src/gameobjects/events/VIDEO_COMPLETE_EVENT.js": function(exports, module) {
      module.exports = "complete";
    }
  });

  // ../../node_modules/phaser/src/gameobjects/events/VIDEO_CREATED_EVENT.js
  var require_VIDEO_CREATED_EVENT = __commonJS({
    "../../node_modules/phaser/src/gameobjects/events/VIDEO_CREATED_EVENT.js": function(exports, module) {
      module.exports = "created";
    }
  });

  // ../../node_modules/phaser/src/gameobjects/events/VIDEO_ERROR_EVENT.js
  var require_VIDEO_ERROR_EVENT = __commonJS({
    "../../node_modules/phaser/src/gameobjects/events/VIDEO_ERROR_EVENT.js": function(exports, module) {
      module.exports = "error";
    }
  });

  // ../../node_modules/phaser/src/gameobjects/events/VIDEO_LOOP_EVENT.js
  var require_VIDEO_LOOP_EVENT = __commonJS({
    "../../node_modules/phaser/src/gameobjects/events/VIDEO_LOOP_EVENT.js": function(exports, module) {
      module.exports = "loop";
    }
  });

  // ../../node_modules/phaser/src/gameobjects/events/VIDEO_PLAY_EVENT.js
  var require_VIDEO_PLAY_EVENT = __commonJS({
    "../../node_modules/phaser/src/gameobjects/events/VIDEO_PLAY_EVENT.js": function(exports, module) {
      module.exports = "play";
    }
  });

  // ../../node_modules/phaser/src/gameobjects/events/VIDEO_SEEKED_EVENT.js
  var require_VIDEO_SEEKED_EVENT = __commonJS({
    "../../node_modules/phaser/src/gameobjects/events/VIDEO_SEEKED_EVENT.js": function(exports, module) {
      module.exports = "seeked";
    }
  });

  // ../../node_modules/phaser/src/gameobjects/events/VIDEO_SEEKING_EVENT.js
  var require_VIDEO_SEEKING_EVENT = __commonJS({
    "../../node_modules/phaser/src/gameobjects/events/VIDEO_SEEKING_EVENT.js": function(exports, module) {
      module.exports = "seeking";
    }
  });

  // ../../node_modules/phaser/src/gameobjects/events/VIDEO_STOP_EVENT.js
  var require_VIDEO_STOP_EVENT = __commonJS({
    "../../node_modules/phaser/src/gameobjects/events/VIDEO_STOP_EVENT.js": function(exports, module) {
      module.exports = "stop";
    }
  });

  // ../../node_modules/phaser/src/gameobjects/events/VIDEO_TIMEOUT_EVENT.js
  var require_VIDEO_TIMEOUT_EVENT = __commonJS({
    "../../node_modules/phaser/src/gameobjects/events/VIDEO_TIMEOUT_EVENT.js": function(exports, module) {
      module.exports = "timeout";
    }
  });

  // ../../node_modules/phaser/src/gameobjects/events/VIDEO_UNLOCKED_EVENT.js
  var require_VIDEO_UNLOCKED_EVENT = __commonJS({
    "../../node_modules/phaser/src/gameobjects/events/VIDEO_UNLOCKED_EVENT.js": function(exports, module) {
      module.exports = "unlocked";
    }
  });

  // ../../node_modules/phaser/src/gameobjects/events/index.js
  var require_events3 = __commonJS({
    "../../node_modules/phaser/src/gameobjects/events/index.js": function(exports, module) {
      module.exports = {
        ADDED_TO_SCENE: require_ADDED_TO_SCENE_EVENT2(),
        DESTROY: require_DESTROY_EVENT3(),
        REMOVED_FROM_SCENE: require_REMOVED_FROM_SCENE_EVENT2(),
        VIDEO_COMPLETE: require_VIDEO_COMPLETE_EVENT(),
        VIDEO_CREATED: require_VIDEO_CREATED_EVENT(),
        VIDEO_ERROR: require_VIDEO_ERROR_EVENT(),
        VIDEO_LOOP: require_VIDEO_LOOP_EVENT(),
        VIDEO_PLAY: require_VIDEO_PLAY_EVENT(),
        VIDEO_SEEKED: require_VIDEO_SEEKED_EVENT(),
        VIDEO_SEEKING: require_VIDEO_SEEKING_EVENT(),
        VIDEO_STOP: require_VIDEO_STOP_EVENT(),
        VIDEO_TIMEOUT: require_VIDEO_TIMEOUT_EVENT(),
        VIDEO_UNLOCKED: require_VIDEO_UNLOCKED_EVENT()
      };
    }
  });

  // ../../node_modules/phaser/src/gameobjects/GameObject.js
  var require_GameObject = __commonJS({
    "../../node_modules/phaser/src/gameobjects/GameObject.js": function(exports, module) {
      var Class = require_Class();
      var ComponentsToJSON = require_ToJSON();
      var DataManager = require_DataManager();
      var EventEmitter = require_eventemitter3();
      var Events = require_events3();
      var SceneEvents = require_events();
      var GameObject = new Class({
        Extends: EventEmitter,
        initialize: function GameObject2(scene, type) {
          EventEmitter.call(this);
          this.scene = scene;
          this.displayList = null;
          this.type = type;
          this.state = 0;
          this.parentContainer = null;
          this.name = "";
          this.active = true;
          this.tabIndex = -1;
          this.data = null;
          this.renderFlags = 15;
          this.cameraFilter = 0;
          this.input = null;
          this.body = null;
          this.ignoreDestroy = false;
          this.on(Events.ADDED_TO_SCENE, this.addedToScene, this);
          this.on(Events.REMOVED_FROM_SCENE, this.removedFromScene, this);
          scene.sys.queueDepthSort();
        },
        setActive: function(value) {
          this.active = value;
          return this;
        },
        setName: function(value) {
          this.name = value;
          return this;
        },
        setState: function(value) {
          this.state = value;
          return this;
        },
        setDataEnabled: function() {
          if (!this.data) {
            this.data = new DataManager(this);
          }
          return this;
        },
        setData: function(key, value) {
          if (!this.data) {
            this.data = new DataManager(this);
          }
          this.data.set(key, value);
          return this;
        },
        incData: function(key, value) {
          if (!this.data) {
            this.data = new DataManager(this);
          }
          this.data.inc(key, value);
          return this;
        },
        toggleData: function(key) {
          if (!this.data) {
            this.data = new DataManager(this);
          }
          this.data.toggle(key);
          return this;
        },
        getData: function(key) {
          if (!this.data) {
            this.data = new DataManager(this);
          }
          return this.data.get(key);
        },
        setInteractive: function(hitArea, hitAreaCallback, dropZone) {
          this.scene.sys.input.enable(this, hitArea, hitAreaCallback, dropZone);
          return this;
        },
        disableInteractive: function() {
          this.scene.sys.input.disable(this);
          return this;
        },
        removeInteractive: function() {
          this.scene.sys.input.clear(this);
          this.input = void 0;
          return this;
        },
        addedToScene: function() {
        },
        removedFromScene: function() {
        },
        update: function() {
        },
        toJSON: function() {
          return ComponentsToJSON(this);
        },
        willRender: function(camera) {
          var listWillRender = this.displayList && this.displayList.active ? this.displayList.willRender(camera) : true;
          return !(!listWillRender || GameObject.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
        },
        getIndexList: function() {
          var child = this;
          var parent = this.parentContainer;
          var indexes = [];
          while (parent) {
            indexes.unshift(parent.getIndex(child));
            child = parent;
            if (!parent.parentContainer) {
              break;
            } else {
              parent = parent.parentContainer;
            }
          }
          if (this.displayList) {
            indexes.unshift(this.displayList.getIndex(child));
          } else {
            indexes.unshift(this.scene.sys.displayList.getIndex(child));
          }
          return indexes;
        },
        addToDisplayList: function(displayList) {
          if (displayList === void 0) {
            displayList = this.scene.sys.displayList;
          }
          if (this.displayList && this.displayList !== displayList) {
            this.removeFromDisplayList();
          }
          if (!displayList.exists(this)) {
            this.displayList = displayList;
            displayList.add(this, true);
            displayList.queueDepthSort();
            this.emit(Events.ADDED_TO_SCENE, this, this.scene);
            displayList.events.emit(SceneEvents.ADDED_TO_SCENE, this, this.scene);
          }
          return this;
        },
        addToUpdateList: function() {
          if (this.scene && this.preUpdate) {
            this.scene.sys.updateList.add(this);
          }
          return this;
        },
        removeFromDisplayList: function() {
          var displayList = this.displayList || this.scene.sys.displayList;
          if (displayList && displayList.exists(this)) {
            displayList.remove(this, true);
            displayList.queueDepthSort();
            this.displayList = null;
            this.emit(Events.REMOVED_FROM_SCENE, this, this.scene);
            displayList.events.emit(SceneEvents.REMOVED_FROM_SCENE, this, this.scene);
          }
          return this;
        },
        removeFromUpdateList: function() {
          if (this.scene && this.preUpdate) {
            this.scene.sys.updateList.remove(this);
          }
          return this;
        },
        destroy: function(fromScene) {
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          if (fromScene === void 0) {
            fromScene = false;
          }
          if (this.preDestroy) {
            this.preDestroy.call(this);
          }
          this.emit(Events.DESTROY, this, fromScene);
          this.removeAllListeners();
          if (this.postPipelines) {
            this.resetPostPipeline(true);
          }
          this.removeFromDisplayList();
          this.removeFromUpdateList();
          if (this.input) {
            this.scene.sys.input.clear(this);
            this.input = void 0;
          }
          if (this.data) {
            this.data.destroy();
            this.data = void 0;
          }
          if (this.body) {
            this.body.destroy();
            this.body = void 0;
          }
          this.active = false;
          this.visible = false;
          this.scene = void 0;
          this.parentContainer = void 0;
        }
      });
      GameObject.RENDER_MASK = 15;
      module.exports = GameObject;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/zone/Zone.js
  var require_Zone = __commonJS({
    "../../node_modules/phaser/src/gameobjects/zone/Zone.js": function(exports, module) {
      var BlendModes = require_BlendModes();
      var Circle = require_Circle();
      var CircleContains = require_Contains();
      var Class = require_Class();
      var Components = require_components();
      var GameObject = require_GameObject();
      var Rectangle = require_Rectangle();
      var RectangleContains = require_Contains2();
      var Zone = new Class({
        Extends: GameObject,
        Mixins: [
          Components.Depth,
          Components.GetBounds,
          Components.Origin,
          Components.Transform,
          Components.ScrollFactor,
          Components.Visible
        ],
        initialize: function Zone2(scene, x, y, width, height) {
          if (width === void 0) {
            width = 1;
          }
          if (height === void 0) {
            height = width;
          }
          GameObject.call(this, scene, "Zone");
          this.setPosition(x, y);
          this.width = width;
          this.height = height;
          this.blendMode = BlendModes.NORMAL;
          this.updateDisplayOrigin();
        },
        displayWidth: {
          get: function() {
            return this.scaleX * this.width;
          },
          set: function(value) {
            this.scaleX = value / this.width;
          }
        },
        displayHeight: {
          get: function() {
            return this.scaleY * this.height;
          },
          set: function(value) {
            this.scaleY = value / this.height;
          }
        },
        setSize: function(width, height, resizeInput) {
          if (resizeInput === void 0) {
            resizeInput = true;
          }
          this.width = width;
          this.height = height;
          this.updateDisplayOrigin();
          var input = this.input;
          if (resizeInput && input && !input.customHitArea) {
            input.hitArea.width = width;
            input.hitArea.height = height;
          }
          return this;
        },
        setDisplaySize: function(width, height) {
          this.displayWidth = width;
          this.displayHeight = height;
          return this;
        },
        setCircleDropZone: function(radius) {
          return this.setDropZone(new Circle(0, 0, radius), CircleContains);
        },
        setRectangleDropZone: function(width, height) {
          return this.setDropZone(new Rectangle(0, 0, width, height), RectangleContains);
        },
        setDropZone: function(hitArea, hitAreaCallback) {
          if (!this.input) {
            this.setInteractive(hitArea, hitAreaCallback, true);
          }
          return this;
        },
        setAlpha: function() {
        },
        setBlendMode: function() {
        },
        renderCanvas: function(renderer, src, camera) {
          camera.addToRenderList(src);
        },
        renderWebGL: function(renderer, src, camera) {
          camera.addToRenderList(src);
        }
      });
      module.exports = Zone;
    }
  });

  // ../../node_modules/phaser/src/actions/GridAlign.js
  var require_GridAlign = __commonJS({
    "../../node_modules/phaser/src/actions/GridAlign.js": function(exports, module) {
      var AlignIn = require_QuickSet();
      var CONST = require_const2();
      var GetFastValue = require_GetFastValue();
      var NOOP = require_NOOP();
      var Zone = require_Zone();
      var tempZone = new Zone({ sys: { queueDepthSort: NOOP, events: { once: NOOP } } }, 0, 0, 1, 1).setOrigin(0, 0);
      var GridAlign = function(items, options) {
        if (options === void 0) {
          options = {};
        }
        var widthSet = options.hasOwnProperty("width");
        var heightSet = options.hasOwnProperty("height");
        var width = GetFastValue(options, "width", -1);
        var height = GetFastValue(options, "height", -1);
        var cellWidth = GetFastValue(options, "cellWidth", 1);
        var cellHeight = GetFastValue(options, "cellHeight", cellWidth);
        var position = GetFastValue(options, "position", CONST.TOP_LEFT);
        var x = GetFastValue(options, "x", 0);
        var y = GetFastValue(options, "y", 0);
        var cx = 0;
        var cy = 0;
        var w = width * cellWidth;
        var h = height * cellHeight;
        tempZone.setPosition(x, y);
        tempZone.setSize(cellWidth, cellHeight);
        for (var i = 0; i < items.length; i++) {
          AlignIn(items[i], tempZone, position);
          if (widthSet && width === -1) {
            tempZone.x += cellWidth;
          } else if (heightSet && height === -1) {
            tempZone.y += cellHeight;
          } else if (heightSet && !widthSet) {
            cy += cellHeight;
            tempZone.y += cellHeight;
            if (cy === h) {
              cy = 0;
              cx += cellWidth;
              tempZone.y = y;
              tempZone.x += cellWidth;
              if (cx === w) {
                break;
              }
            }
          } else {
            cx += cellWidth;
            tempZone.x += cellWidth;
            if (cx === w) {
              cx = 0;
              cy += cellHeight;
              tempZone.x = x;
              tempZone.y += cellHeight;
              if (cy === h) {
                break;
              }
            }
          }
        }
        return items;
      };
      module.exports = GridAlign;
    }
  });

  // ../../node_modules/phaser/src/structs/Map.js
  var require_Map = __commonJS({
    "../../node_modules/phaser/src/structs/Map.js": function(exports, module) {
      var Class = require_Class();
      var Map = new Class({
        initialize: function Map2(elements) {
          this.entries = {};
          this.size = 0;
          if (Array.isArray(elements)) {
            for (var i = 0; i < elements.length; i++) {
              this.set(elements[i][0], elements[i][1]);
            }
          }
        },
        set: function(key, value) {
          if (!this.has(key)) {
            this.size++;
          }
          this.entries[key] = value;
          return this;
        },
        get: function(key) {
          if (this.has(key)) {
            return this.entries[key];
          }
        },
        getArray: function() {
          var output = [];
          var entries = this.entries;
          for (var key in entries) {
            output.push(entries[key]);
          }
          return output;
        },
        has: function(key) {
          return this.entries.hasOwnProperty(key);
        },
        delete: function(key) {
          if (this.has(key)) {
            delete this.entries[key];
            this.size--;
          }
          return this;
        },
        clear: function() {
          Object.keys(this.entries).forEach(function(prop) {
            delete this.entries[prop];
          }, this);
          this.size = 0;
          return this;
        },
        keys: function() {
          return Object.keys(this.entries);
        },
        values: function() {
          var output = [];
          var entries = this.entries;
          for (var key in entries) {
            output.push(entries[key]);
          }
          return output;
        },
        dump: function() {
          var entries = this.entries;
          console.group("Map");
          for (var key in entries) {
            console.log(key, entries[key]);
          }
          console.groupEnd();
        },
        each: function(callback) {
          var entries = this.entries;
          for (var key in entries) {
            if (callback(key, entries[key]) === false) {
              break;
            }
          }
          return this;
        },
        contains: function(value) {
          var entries = this.entries;
          for (var key in entries) {
            if (entries[key] === value) {
              return true;
            }
          }
          return false;
        },
        merge: function(map, override) {
          if (override === void 0) {
            override = false;
          }
          var local = this.entries;
          var source = map.entries;
          for (var key in source) {
            if (local.hasOwnProperty(key) && override) {
              local[key] = source[key];
            } else {
              this.set(key, source[key]);
            }
          }
          return this;
        }
      });
      module.exports = Map;
    }
  });

  // ../../node_modules/phaser/src/cache/events/ADD_EVENT.js
  var require_ADD_EVENT = __commonJS({
    "../../node_modules/phaser/src/cache/events/ADD_EVENT.js": function(exports, module) {
      module.exports = "add";
    }
  });

  // ../../node_modules/phaser/src/cache/events/REMOVE_EVENT.js
  var require_REMOVE_EVENT = __commonJS({
    "../../node_modules/phaser/src/cache/events/REMOVE_EVENT.js": function(exports, module) {
      module.exports = "remove";
    }
  });

  // ../../node_modules/phaser/src/cache/events/index.js
  var require_events4 = __commonJS({
    "../../node_modules/phaser/src/cache/events/index.js": function(exports, module) {
      module.exports = {
        ADD: require_ADD_EVENT(),
        REMOVE: require_REMOVE_EVENT()
      };
    }
  });

  // ../../node_modules/phaser/src/cache/BaseCache.js
  var require_BaseCache = __commonJS({
    "../../node_modules/phaser/src/cache/BaseCache.js": function(exports, module) {
      var Class = require_Class();
      var CustomMap = require_Map();
      var EventEmitter = require_eventemitter3();
      var Events = require_events4();
      var BaseCache = new Class({
        initialize: function BaseCache2() {
          this.entries = new CustomMap();
          this.events = new EventEmitter();
        },
        add: function(key, data) {
          this.entries.set(key, data);
          this.events.emit(Events.ADD, this, key, data);
          return this;
        },
        has: function(key) {
          return this.entries.has(key);
        },
        exists: function(key) {
          return this.entries.has(key);
        },
        get: function(key) {
          return this.entries.get(key);
        },
        remove: function(key) {
          var entry = this.get(key);
          if (entry) {
            this.entries.delete(key);
            this.events.emit(Events.REMOVE, this, key, entry.data);
          }
          return this;
        },
        getKeys: function() {
          return this.entries.keys();
        },
        destroy: function() {
          this.entries.clear();
          this.events.removeAllListeners();
          this.entries = null;
          this.events = null;
        }
      });
      module.exports = BaseCache;
    }
  });

  // ../../node_modules/phaser/src/core/events/BLUR_EVENT.js
  var require_BLUR_EVENT = __commonJS({
    "../../node_modules/phaser/src/core/events/BLUR_EVENT.js": function(exports, module) {
      module.exports = "blur";
    }
  });

  // ../../node_modules/phaser/src/core/events/BOOT_EVENT.js
  var require_BOOT_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/core/events/BOOT_EVENT.js": function(exports, module) {
      module.exports = "boot";
    }
  });

  // ../../node_modules/phaser/src/core/events/CONTEXT_LOST_EVENT.js
  var require_CONTEXT_LOST_EVENT = __commonJS({
    "../../node_modules/phaser/src/core/events/CONTEXT_LOST_EVENT.js": function(exports, module) {
      module.exports = "contextlost";
    }
  });

  // ../../node_modules/phaser/src/core/events/DESTROY_EVENT.js
  var require_DESTROY_EVENT4 = __commonJS({
    "../../node_modules/phaser/src/core/events/DESTROY_EVENT.js": function(exports, module) {
      module.exports = "destroy";
    }
  });

  // ../../node_modules/phaser/src/core/events/FOCUS_EVENT.js
  var require_FOCUS_EVENT = __commonJS({
    "../../node_modules/phaser/src/core/events/FOCUS_EVENT.js": function(exports, module) {
      module.exports = "focus";
    }
  });

  // ../../node_modules/phaser/src/core/events/HIDDEN_EVENT.js
  var require_HIDDEN_EVENT = __commonJS({
    "../../node_modules/phaser/src/core/events/HIDDEN_EVENT.js": function(exports, module) {
      module.exports = "hidden";
    }
  });

  // ../../node_modules/phaser/src/core/events/PAUSE_EVENT.js
  var require_PAUSE_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/core/events/PAUSE_EVENT.js": function(exports, module) {
      module.exports = "pause";
    }
  });

  // ../../node_modules/phaser/src/core/events/POST_RENDER_EVENT.js
  var require_POST_RENDER_EVENT = __commonJS({
    "../../node_modules/phaser/src/core/events/POST_RENDER_EVENT.js": function(exports, module) {
      module.exports = "postrender";
    }
  });

  // ../../node_modules/phaser/src/core/events/POST_STEP_EVENT.js
  var require_POST_STEP_EVENT = __commonJS({
    "../../node_modules/phaser/src/core/events/POST_STEP_EVENT.js": function(exports, module) {
      module.exports = "poststep";
    }
  });

  // ../../node_modules/phaser/src/core/events/PRE_RENDER_EVENT.js
  var require_PRE_RENDER_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/core/events/PRE_RENDER_EVENT.js": function(exports, module) {
      module.exports = "prerender";
    }
  });

  // ../../node_modules/phaser/src/core/events/PRE_STEP_EVENT.js
  var require_PRE_STEP_EVENT = __commonJS({
    "../../node_modules/phaser/src/core/events/PRE_STEP_EVENT.js": function(exports, module) {
      module.exports = "prestep";
    }
  });

  // ../../node_modules/phaser/src/core/events/READY_EVENT.js
  var require_READY_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/core/events/READY_EVENT.js": function(exports, module) {
      module.exports = "ready";
    }
  });

  // ../../node_modules/phaser/src/core/events/RESUME_EVENT.js
  var require_RESUME_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/core/events/RESUME_EVENT.js": function(exports, module) {
      module.exports = "resume";
    }
  });

  // ../../node_modules/phaser/src/core/events/STEP_EVENT.js
  var require_STEP_EVENT = __commonJS({
    "../../node_modules/phaser/src/core/events/STEP_EVENT.js": function(exports, module) {
      module.exports = "step";
    }
  });

  // ../../node_modules/phaser/src/core/events/VISIBLE_EVENT.js
  var require_VISIBLE_EVENT = __commonJS({
    "../../node_modules/phaser/src/core/events/VISIBLE_EVENT.js": function(exports, module) {
      module.exports = "visible";
    }
  });

  // ../../node_modules/phaser/src/core/events/index.js
  var require_events5 = __commonJS({
    "../../node_modules/phaser/src/core/events/index.js": function(exports, module) {
      module.exports = {
        BLUR: require_BLUR_EVENT(),
        BOOT: require_BOOT_EVENT2(),
        CONTEXT_LOST: require_CONTEXT_LOST_EVENT(),
        DESTROY: require_DESTROY_EVENT4(),
        FOCUS: require_FOCUS_EVENT(),
        HIDDEN: require_HIDDEN_EVENT(),
        PAUSE: require_PAUSE_EVENT2(),
        POST_RENDER: require_POST_RENDER_EVENT(),
        POST_STEP: require_POST_STEP_EVENT(),
        PRE_RENDER: require_PRE_RENDER_EVENT2(),
        PRE_STEP: require_PRE_STEP_EVENT(),
        READY: require_READY_EVENT2(),
        RESUME: require_RESUME_EVENT2(),
        STEP: require_STEP_EVENT(),
        VISIBLE: require_VISIBLE_EVENT()
      };
    }
  });

  // ../../node_modules/phaser/src/cache/CacheManager.js
  var require_CacheManager = __commonJS({
    "../../node_modules/phaser/src/cache/CacheManager.js": function(exports, module) {
      var BaseCache = require_BaseCache();
      var Class = require_Class();
      var GameEvents = require_events5();
      var CacheManager = new Class({
        initialize: function CacheManager2(game) {
          this.game = game;
          this.binary = new BaseCache();
          this.bitmapFont = new BaseCache();
          this.json = new BaseCache();
          this.physics = new BaseCache();
          this.shader = new BaseCache();
          this.audio = new BaseCache();
          this.video = new BaseCache();
          this.text = new BaseCache();
          this.html = new BaseCache();
          this.obj = new BaseCache();
          this.tilemap = new BaseCache();
          this.xml = new BaseCache();
          this.custom = {};
          this.game.events.once(GameEvents.DESTROY, this.destroy, this);
        },
        addCustom: function(key) {
          if (!this.custom.hasOwnProperty(key)) {
            this.custom[key] = new BaseCache();
          }
          return this.custom[key];
        },
        destroy: function() {
          var keys = [
            "binary",
            "bitmapFont",
            "json",
            "physics",
            "shader",
            "audio",
            "video",
            "text",
            "html",
            "obj",
            "tilemap",
            "xml"
          ];
          for (var i = 0; i < keys.length; i++) {
            this[keys[i]].destroy();
            this[keys[i]] = null;
          }
          for (var key in this.custom) {
            this.custom[key].destroy();
          }
          this.custom = null;
          this.game = null;
        }
      });
      module.exports = CacheManager;
    }
  });

  // ../../node_modules/phaser/src/cache/index.js
  var require_cache = __commonJS({
    "../../node_modules/phaser/src/cache/index.js": function(exports, module) {
      module.exports = {
        BaseCache: require_BaseCache(),
        CacheManager: require_CacheManager(),
        Events: require_events4()
      };
    }
  });

  // ../../node_modules/phaser/src/cameras/controls/FixedKeyControl.js
  var require_FixedKeyControl = __commonJS({
    "../../node_modules/phaser/src/cameras/controls/FixedKeyControl.js": function(exports, module) {
      var Class = require_Class();
      var GetValue = require_GetValue();
      var FixedKeyControl = new Class({
        initialize: function FixedKeyControl2(config) {
          this.camera = GetValue(config, "camera", null);
          this.left = GetValue(config, "left", null);
          this.right = GetValue(config, "right", null);
          this.up = GetValue(config, "up", null);
          this.down = GetValue(config, "down", null);
          this.zoomIn = GetValue(config, "zoomIn", null);
          this.zoomOut = GetValue(config, "zoomOut", null);
          this.zoomSpeed = GetValue(config, "zoomSpeed", 0.01);
          this.minZoom = GetValue(config, "minZoom", 1e-3);
          this.maxZoom = GetValue(config, "maxZoom", 1e3);
          this.speedX = 0;
          this.speedY = 0;
          var speed = GetValue(config, "speed", null);
          if (typeof speed === "number") {
            this.speedX = speed;
            this.speedY = speed;
          } else {
            this.speedX = GetValue(config, "speed.x", 0);
            this.speedY = GetValue(config, "speed.y", 0);
          }
          this._zoom = 0;
          this.active = this.camera !== null;
        },
        start: function() {
          this.active = this.camera !== null;
          return this;
        },
        stop: function() {
          this.active = false;
          return this;
        },
        setCamera: function(camera) {
          this.camera = camera;
          return this;
        },
        update: function(delta) {
          if (!this.active) {
            return;
          }
          if (delta === void 0) {
            delta = 1;
          }
          var cam = this.camera;
          if (this.up && this.up.isDown) {
            cam.scrollY -= this.speedY * delta | 0;
          } else if (this.down && this.down.isDown) {
            cam.scrollY += this.speedY * delta | 0;
          }
          if (this.left && this.left.isDown) {
            cam.scrollX -= this.speedX * delta | 0;
          } else if (this.right && this.right.isDown) {
            cam.scrollX += this.speedX * delta | 0;
          }
          if (this.zoomIn && this.zoomIn.isDown) {
            cam.zoom -= this.zoomSpeed;
            if (cam.zoom < this.minZoom) {
              cam.zoom = this.minZoom;
            }
          } else if (this.zoomOut && this.zoomOut.isDown) {
            cam.zoom += this.zoomSpeed;
            if (cam.zoom > this.maxZoom) {
              cam.zoom = this.maxZoom;
            }
          }
        },
        destroy: function() {
          this.camera = null;
          this.left = null;
          this.right = null;
          this.up = null;
          this.down = null;
          this.zoomIn = null;
          this.zoomOut = null;
        }
      });
      module.exports = FixedKeyControl;
    }
  });

  // ../../node_modules/phaser/src/cameras/controls/SmoothedKeyControl.js
  var require_SmoothedKeyControl = __commonJS({
    "../../node_modules/phaser/src/cameras/controls/SmoothedKeyControl.js": function(exports, module) {
      var Class = require_Class();
      var GetValue = require_GetValue();
      var SmoothedKeyControl = new Class({
        initialize: function SmoothedKeyControl2(config) {
          this.camera = GetValue(config, "camera", null);
          this.left = GetValue(config, "left", null);
          this.right = GetValue(config, "right", null);
          this.up = GetValue(config, "up", null);
          this.down = GetValue(config, "down", null);
          this.zoomIn = GetValue(config, "zoomIn", null);
          this.zoomOut = GetValue(config, "zoomOut", null);
          this.zoomSpeed = GetValue(config, "zoomSpeed", 0.01);
          this.minZoom = GetValue(config, "minZoom", 1e-3);
          this.maxZoom = GetValue(config, "maxZoom", 1e3);
          this.accelX = 0;
          this.accelY = 0;
          var accel = GetValue(config, "acceleration", null);
          if (typeof accel === "number") {
            this.accelX = accel;
            this.accelY = accel;
          } else {
            this.accelX = GetValue(config, "acceleration.x", 0);
            this.accelY = GetValue(config, "acceleration.y", 0);
          }
          this.dragX = 0;
          this.dragY = 0;
          var drag = GetValue(config, "drag", null);
          if (typeof drag === "number") {
            this.dragX = drag;
            this.dragY = drag;
          } else {
            this.dragX = GetValue(config, "drag.x", 0);
            this.dragY = GetValue(config, "drag.y", 0);
          }
          this.maxSpeedX = 0;
          this.maxSpeedY = 0;
          var maxSpeed = GetValue(config, "maxSpeed", null);
          if (typeof maxSpeed === "number") {
            this.maxSpeedX = maxSpeed;
            this.maxSpeedY = maxSpeed;
          } else {
            this.maxSpeedX = GetValue(config, "maxSpeed.x", 0);
            this.maxSpeedY = GetValue(config, "maxSpeed.y", 0);
          }
          this._speedX = 0;
          this._speedY = 0;
          this._zoom = 0;
          this.active = this.camera !== null;
        },
        start: function() {
          this.active = this.camera !== null;
          return this;
        },
        stop: function() {
          this.active = false;
          return this;
        },
        setCamera: function(camera) {
          this.camera = camera;
          return this;
        },
        update: function(delta) {
          if (!this.active) {
            return;
          }
          if (delta === void 0) {
            delta = 1;
          }
          var cam = this.camera;
          if (this._speedX > 0) {
            this._speedX -= this.dragX * delta;
            if (this._speedX < 0) {
              this._speedX = 0;
            }
          } else if (this._speedX < 0) {
            this._speedX += this.dragX * delta;
            if (this._speedX > 0) {
              this._speedX = 0;
            }
          }
          if (this._speedY > 0) {
            this._speedY -= this.dragY * delta;
            if (this._speedY < 0) {
              this._speedY = 0;
            }
          } else if (this._speedY < 0) {
            this._speedY += this.dragY * delta;
            if (this._speedY > 0) {
              this._speedY = 0;
            }
          }
          if (this.up && this.up.isDown) {
            this._speedY += this.accelY;
            if (this._speedY > this.maxSpeedY) {
              this._speedY = this.maxSpeedY;
            }
          } else if (this.down && this.down.isDown) {
            this._speedY -= this.accelY;
            if (this._speedY < -this.maxSpeedY) {
              this._speedY = -this.maxSpeedY;
            }
          }
          if (this.left && this.left.isDown) {
            this._speedX += this.accelX;
            if (this._speedX > this.maxSpeedX) {
              this._speedX = this.maxSpeedX;
            }
          } else if (this.right && this.right.isDown) {
            this._speedX -= this.accelX;
            if (this._speedX < -this.maxSpeedX) {
              this._speedX = -this.maxSpeedX;
            }
          }
          if (this.zoomIn && this.zoomIn.isDown) {
            this._zoom = -this.zoomSpeed;
          } else if (this.zoomOut && this.zoomOut.isDown) {
            this._zoom = this.zoomSpeed;
          } else {
            this._zoom = 0;
          }
          if (this._speedX !== 0) {
            cam.scrollX -= this._speedX * delta | 0;
          }
          if (this._speedY !== 0) {
            cam.scrollY -= this._speedY * delta | 0;
          }
          if (this._zoom !== 0) {
            cam.zoom += this._zoom;
            if (cam.zoom < this.minZoom) {
              cam.zoom = this.minZoom;
            } else if (cam.zoom > this.maxZoom) {
              cam.zoom = this.maxZoom;
            }
          }
        },
        destroy: function() {
          this.camera = null;
          this.left = null;
          this.right = null;
          this.up = null;
          this.down = null;
          this.zoomIn = null;
          this.zoomOut = null;
        }
      });
      module.exports = SmoothedKeyControl;
    }
  });

  // ../../node_modules/phaser/src/cameras/controls/index.js
  var require_controls = __commonJS({
    "../../node_modules/phaser/src/cameras/controls/index.js": function(exports, module) {
      module.exports = {
        FixedKeyControl: require_FixedKeyControl(),
        SmoothedKeyControl: require_SmoothedKeyControl()
      };
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/DESTROY_EVENT.js
  var require_DESTROY_EVENT5 = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/DESTROY_EVENT.js": function(exports, module) {
      module.exports = "cameradestroy";
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/FADE_IN_COMPLETE_EVENT.js
  var require_FADE_IN_COMPLETE_EVENT = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/FADE_IN_COMPLETE_EVENT.js": function(exports, module) {
      module.exports = "camerafadeincomplete";
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/FADE_IN_START_EVENT.js
  var require_FADE_IN_START_EVENT = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/FADE_IN_START_EVENT.js": function(exports, module) {
      module.exports = "camerafadeinstart";
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/FADE_OUT_COMPLETE_EVENT.js
  var require_FADE_OUT_COMPLETE_EVENT = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/FADE_OUT_COMPLETE_EVENT.js": function(exports, module) {
      module.exports = "camerafadeoutcomplete";
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/FADE_OUT_START_EVENT.js
  var require_FADE_OUT_START_EVENT = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/FADE_OUT_START_EVENT.js": function(exports, module) {
      module.exports = "camerafadeoutstart";
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/FLASH_COMPLETE_EVENT.js
  var require_FLASH_COMPLETE_EVENT = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/FLASH_COMPLETE_EVENT.js": function(exports, module) {
      module.exports = "cameraflashcomplete";
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/FLASH_START_EVENT.js
  var require_FLASH_START_EVENT = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/FLASH_START_EVENT.js": function(exports, module) {
      module.exports = "cameraflashstart";
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/FOLLOW_UPDATE_EVENT.js
  var require_FOLLOW_UPDATE_EVENT = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/FOLLOW_UPDATE_EVENT.js": function(exports, module) {
      module.exports = "followupdate";
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/PAN_COMPLETE_EVENT.js
  var require_PAN_COMPLETE_EVENT = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/PAN_COMPLETE_EVENT.js": function(exports, module) {
      module.exports = "camerapancomplete";
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/PAN_START_EVENT.js
  var require_PAN_START_EVENT = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/PAN_START_EVENT.js": function(exports, module) {
      module.exports = "camerapanstart";
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/POST_RENDER_EVENT.js
  var require_POST_RENDER_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/POST_RENDER_EVENT.js": function(exports, module) {
      module.exports = "postrender";
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/PRE_RENDER_EVENT.js
  var require_PRE_RENDER_EVENT3 = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/PRE_RENDER_EVENT.js": function(exports, module) {
      module.exports = "prerender";
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/ROTATE_COMPLETE_EVENT.js
  var require_ROTATE_COMPLETE_EVENT = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/ROTATE_COMPLETE_EVENT.js": function(exports, module) {
      module.exports = "camerarotatecomplete";
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/ROTATE_START_EVENT.js
  var require_ROTATE_START_EVENT = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/ROTATE_START_EVENT.js": function(exports, module) {
      module.exports = "camerarotatestart";
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/SHAKE_COMPLETE_EVENT.js
  var require_SHAKE_COMPLETE_EVENT = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/SHAKE_COMPLETE_EVENT.js": function(exports, module) {
      module.exports = "camerashakecomplete";
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/SHAKE_START_EVENT.js
  var require_SHAKE_START_EVENT = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/SHAKE_START_EVENT.js": function(exports, module) {
      module.exports = "camerashakestart";
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/ZOOM_COMPLETE_EVENT.js
  var require_ZOOM_COMPLETE_EVENT = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/ZOOM_COMPLETE_EVENT.js": function(exports, module) {
      module.exports = "camerazoomcomplete";
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/ZOOM_START_EVENT.js
  var require_ZOOM_START_EVENT = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/ZOOM_START_EVENT.js": function(exports, module) {
      module.exports = "camerazoomstart";
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/events/index.js
  var require_events6 = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/events/index.js": function(exports, module) {
      module.exports = {
        DESTROY: require_DESTROY_EVENT5(),
        FADE_IN_COMPLETE: require_FADE_IN_COMPLETE_EVENT(),
        FADE_IN_START: require_FADE_IN_START_EVENT(),
        FADE_OUT_COMPLETE: require_FADE_OUT_COMPLETE_EVENT(),
        FADE_OUT_START: require_FADE_OUT_START_EVENT(),
        FLASH_COMPLETE: require_FLASH_COMPLETE_EVENT(),
        FLASH_START: require_FLASH_START_EVENT(),
        FOLLOW_UPDATE: require_FOLLOW_UPDATE_EVENT(),
        PAN_COMPLETE: require_PAN_COMPLETE_EVENT(),
        PAN_START: require_PAN_START_EVENT(),
        POST_RENDER: require_POST_RENDER_EVENT2(),
        PRE_RENDER: require_PRE_RENDER_EVENT3(),
        ROTATE_COMPLETE: require_ROTATE_COMPLETE_EVENT(),
        ROTATE_START: require_ROTATE_START_EVENT(),
        SHAKE_COMPLETE: require_SHAKE_COMPLETE_EVENT(),
        SHAKE_START: require_SHAKE_START_EVENT(),
        ZOOM_COMPLETE: require_ZOOM_COMPLETE_EVENT(),
        ZOOM_START: require_ZOOM_START_EVENT()
      };
    }
  });

  // ../../node_modules/phaser/src/display/color/GetColor.js
  var require_GetColor = __commonJS({
    "../../node_modules/phaser/src/display/color/GetColor.js": function(exports, module) {
      var GetColor = function(red, green, blue) {
        return red << 16 | green << 8 | blue;
      };
      module.exports = GetColor;
    }
  });

  // ../../node_modules/phaser/src/display/color/GetColor32.js
  var require_GetColor32 = __commonJS({
    "../../node_modules/phaser/src/display/color/GetColor32.js": function(exports, module) {
      var GetColor32 = function(red, green, blue, alpha) {
        return alpha << 24 | red << 16 | green << 8 | blue;
      };
      module.exports = GetColor32;
    }
  });

  // ../../node_modules/phaser/src/display/color/HSVToRGB.js
  var require_HSVToRGB = __commonJS({
    "../../node_modules/phaser/src/display/color/HSVToRGB.js": function(exports, module) {
      var GetColor = require_GetColor();
      function ConvertValue(n, h, s, v) {
        var k = (n + h * 6) % 6;
        var min = Math.min(k, 4 - k, 1);
        return Math.round(255 * (v - v * s * Math.max(0, min)));
      }
      var HSVToRGB = function(h, s, v, out) {
        if (s === void 0) {
          s = 1;
        }
        if (v === void 0) {
          v = 1;
        }
        var r = ConvertValue(5, h, s, v);
        var g = ConvertValue(3, h, s, v);
        var b = ConvertValue(1, h, s, v);
        if (!out) {
          return { r: r, g: g, b: b, color: GetColor(r, g, b) };
        } else if (out.setTo) {
          return out.setTo(r, g, b, out.alpha, true);
        } else {
          out.r = r;
          out.g = g;
          out.b = b;
          out.color = GetColor(r, g, b);
          return out;
        }
      };
      module.exports = HSVToRGB;
    }
  });

  // ../../node_modules/phaser/src/display/color/RGBToHSV.js
  var require_RGBToHSV = __commonJS({
    "../../node_modules/phaser/src/display/color/RGBToHSV.js": function(exports, module) {
      var RGBToHSV = function(r, g, b, out) {
        if (out === void 0) {
          out = { h: 0, s: 0, v: 0 };
        }
        r /= 255;
        g /= 255;
        b /= 255;
        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);
        var d = max - min;
        var h = 0;
        var s = max === 0 ? 0 : d / max;
        var v = max;
        if (max !== min) {
          if (max === r) {
            h = (g - b) / d + (g < b ? 6 : 0);
          } else if (max === g) {
            h = (b - r) / d + 2;
          } else if (max === b) {
            h = (r - g) / d + 4;
          }
          h /= 6;
        }
        if (out.hasOwnProperty("_h")) {
          out._h = h;
          out._s = s;
          out._v = v;
        } else {
          out.h = h;
          out.s = s;
          out.v = v;
        }
        return out;
      };
      module.exports = RGBToHSV;
    }
  });

  // ../../node_modules/phaser/src/display/color/Color.js
  var require_Color = __commonJS({
    "../../node_modules/phaser/src/display/color/Color.js": function(exports, module) {
      var Class = require_Class();
      var GetColor = require_GetColor();
      var GetColor32 = require_GetColor32();
      var HSVToRGB = require_HSVToRGB();
      var RGBToHSV = require_RGBToHSV();
      var Color = new Class({
        initialize: function Color2(red, green, blue, alpha) {
          if (red === void 0) {
            red = 0;
          }
          if (green === void 0) {
            green = 0;
          }
          if (blue === void 0) {
            blue = 0;
          }
          if (alpha === void 0) {
            alpha = 255;
          }
          this.r = 0;
          this.g = 0;
          this.b = 0;
          this.a = 255;
          this._h = 0;
          this._s = 0;
          this._v = 0;
          this._locked = false;
          this.gl = [0, 0, 0, 1];
          this._color = 0;
          this._color32 = 0;
          this._rgba = "";
          this.setTo(red, green, blue, alpha);
        },
        transparent: function() {
          this._locked = true;
          this.red = 0;
          this.green = 0;
          this.blue = 0;
          this.alpha = 0;
          this._locked = false;
          return this.update(true);
        },
        setTo: function(red, green, blue, alpha, updateHSV) {
          if (alpha === void 0) {
            alpha = 255;
          }
          if (updateHSV === void 0) {
            updateHSV = true;
          }
          this._locked = true;
          this.red = red;
          this.green = green;
          this.blue = blue;
          this.alpha = alpha;
          this._locked = false;
          return this.update(updateHSV);
        },
        setGLTo: function(red, green, blue, alpha) {
          if (alpha === void 0) {
            alpha = 1;
          }
          this._locked = true;
          this.redGL = red;
          this.greenGL = green;
          this.blueGL = blue;
          this.alphaGL = alpha;
          this._locked = false;
          return this.update(true);
        },
        setFromRGB: function(color) {
          this._locked = true;
          this.red = color.r;
          this.green = color.g;
          this.blue = color.b;
          if (color.hasOwnProperty("a")) {
            this.alpha = color.a;
          }
          this._locked = false;
          return this.update(true);
        },
        setFromHSV: function(h, s, v) {
          return HSVToRGB(h, s, v, this);
        },
        update: function(updateHSV) {
          if (updateHSV === void 0) {
            updateHSV = false;
          }
          if (this._locked) {
            return this;
          }
          var r = this.r;
          var g = this.g;
          var b = this.b;
          var a = this.a;
          this._color = GetColor(r, g, b);
          this._color32 = GetColor32(r, g, b, a);
          this._rgba = "rgba(" + r + "," + g + "," + b + "," + a / 255 + ")";
          if (updateHSV) {
            RGBToHSV(r, g, b, this);
          }
          return this;
        },
        updateHSV: function() {
          var r = this.r;
          var g = this.g;
          var b = this.b;
          RGBToHSV(r, g, b, this);
          return this;
        },
        clone: function() {
          return new Color(this.r, this.g, this.b, this.a);
        },
        gray: function(shade) {
          return this.setTo(shade, shade, shade);
        },
        random: function(min, max) {
          if (min === void 0) {
            min = 0;
          }
          if (max === void 0) {
            max = 255;
          }
          var r = Math.floor(min + Math.random() * (max - min));
          var g = Math.floor(min + Math.random() * (max - min));
          var b = Math.floor(min + Math.random() * (max - min));
          return this.setTo(r, g, b);
        },
        randomGray: function(min, max) {
          if (min === void 0) {
            min = 0;
          }
          if (max === void 0) {
            max = 255;
          }
          var s = Math.floor(min + Math.random() * (max - min));
          return this.setTo(s, s, s);
        },
        saturate: function(amount) {
          this.s += amount / 100;
          return this;
        },
        desaturate: function(amount) {
          this.s -= amount / 100;
          return this;
        },
        lighten: function(amount) {
          this.v += amount / 100;
          return this;
        },
        darken: function(amount) {
          this.v -= amount / 100;
          return this;
        },
        brighten: function(amount) {
          var r = this.r;
          var g = this.g;
          var b = this.b;
          r = Math.max(0, Math.min(255, r - Math.round(255 * -(amount / 100))));
          g = Math.max(0, Math.min(255, g - Math.round(255 * -(amount / 100))));
          b = Math.max(0, Math.min(255, b - Math.round(255 * -(amount / 100))));
          return this.setTo(r, g, b);
        },
        color: {
          get: function() {
            return this._color;
          }
        },
        color32: {
          get: function() {
            return this._color32;
          }
        },
        rgba: {
          get: function() {
            return this._rgba;
          }
        },
        redGL: {
          get: function() {
            return this.gl[0];
          },
          set: function(value) {
            this.gl[0] = Math.min(Math.abs(value), 1);
            this.r = Math.floor(this.gl[0] * 255);
            this.update(true);
          }
        },
        greenGL: {
          get: function() {
            return this.gl[1];
          },
          set: function(value) {
            this.gl[1] = Math.min(Math.abs(value), 1);
            this.g = Math.floor(this.gl[1] * 255);
            this.update(true);
          }
        },
        blueGL: {
          get: function() {
            return this.gl[2];
          },
          set: function(value) {
            this.gl[2] = Math.min(Math.abs(value), 1);
            this.b = Math.floor(this.gl[2] * 255);
            this.update(true);
          }
        },
        alphaGL: {
          get: function() {
            return this.gl[3];
          },
          set: function(value) {
            this.gl[3] = Math.min(Math.abs(value), 1);
            this.a = Math.floor(this.gl[3] * 255);
            this.update();
          }
        },
        red: {
          get: function() {
            return this.r;
          },
          set: function(value) {
            value = Math.floor(Math.abs(value));
            this.r = Math.min(value, 255);
            this.gl[0] = value / 255;
            this.update(true);
          }
        },
        green: {
          get: function() {
            return this.g;
          },
          set: function(value) {
            value = Math.floor(Math.abs(value));
            this.g = Math.min(value, 255);
            this.gl[1] = value / 255;
            this.update(true);
          }
        },
        blue: {
          get: function() {
            return this.b;
          },
          set: function(value) {
            value = Math.floor(Math.abs(value));
            this.b = Math.min(value, 255);
            this.gl[2] = value / 255;
            this.update(true);
          }
        },
        alpha: {
          get: function() {
            return this.a;
          },
          set: function(value) {
            value = Math.floor(Math.abs(value));
            this.a = Math.min(value, 255);
            this.gl[3] = value / 255;
            this.update();
          }
        },
        h: {
          get: function() {
            return this._h;
          },
          set: function(value) {
            this._h = value;
            HSVToRGB(value, this._s, this._v, this);
          }
        },
        s: {
          get: function() {
            return this._s;
          },
          set: function(value) {
            this._s = value;
            HSVToRGB(this._h, value, this._v, this);
          }
        },
        v: {
          get: function() {
            return this._v;
          },
          set: function(value) {
            this._v = value;
            HSVToRGB(this._h, this._s, value, this);
          }
        }
      });
      module.exports = Color;
    }
  });

  // ../../node_modules/phaser/src/display/color/HexStringToColor.js
  var require_HexStringToColor = __commonJS({
    "../../node_modules/phaser/src/display/color/HexStringToColor.js": function(exports, module) {
      var Color = require_Color();
      var HexStringToColor = function(hex) {
        var color = new Color();
        hex = hex.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(m, r2, g2, b2) {
          return r2 + r2 + g2 + g2 + b2 + b2;
        });
        var result = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (result) {
          var r = parseInt(result[1], 16);
          var g = parseInt(result[2], 16);
          var b = parseInt(result[3], 16);
          color.setTo(r, g, b);
        }
        return color;
      };
      module.exports = HexStringToColor;
    }
  });

  // ../../node_modules/phaser/src/display/color/IntegerToRGB.js
  var require_IntegerToRGB = __commonJS({
    "../../node_modules/phaser/src/display/color/IntegerToRGB.js": function(exports, module) {
      var IntegerToRGB = function(color) {
        if (color > 16777215) {
          return {
            a: color >>> 24,
            r: color >> 16 & 255,
            g: color >> 8 & 255,
            b: color & 255
          };
        } else {
          return {
            a: 255,
            r: color >> 16 & 255,
            g: color >> 8 & 255,
            b: color & 255
          };
        }
      };
      module.exports = IntegerToRGB;
    }
  });

  // ../../node_modules/phaser/src/display/color/IntegerToColor.js
  var require_IntegerToColor = __commonJS({
    "../../node_modules/phaser/src/display/color/IntegerToColor.js": function(exports, module) {
      var Color = require_Color();
      var IntegerToRGB = require_IntegerToRGB();
      var IntegerToColor = function(input) {
        var rgb = IntegerToRGB(input);
        return new Color(rgb.r, rgb.g, rgb.b, rgb.a);
      };
      module.exports = IntegerToColor;
    }
  });

  // ../../node_modules/phaser/src/display/color/ObjectToColor.js
  var require_ObjectToColor = __commonJS({
    "../../node_modules/phaser/src/display/color/ObjectToColor.js": function(exports, module) {
      var Color = require_Color();
      var ObjectToColor = function(input) {
        return new Color(input.r, input.g, input.b, input.a);
      };
      module.exports = ObjectToColor;
    }
  });

  // ../../node_modules/phaser/src/display/color/RGBStringToColor.js
  var require_RGBStringToColor = __commonJS({
    "../../node_modules/phaser/src/display/color/RGBStringToColor.js": function(exports, module) {
      var Color = require_Color();
      var RGBStringToColor = function(rgb) {
        var color = new Color();
        var result = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(rgb.toLowerCase());
        if (result) {
          var r = parseInt(result[1], 10);
          var g = parseInt(result[2], 10);
          var b = parseInt(result[3], 10);
          var a = result[4] !== void 0 ? parseFloat(result[4]) : 1;
          color.setTo(r, g, b, a * 255);
        }
        return color;
      };
      module.exports = RGBStringToColor;
    }
  });

  // ../../node_modules/phaser/src/display/color/ValueToColor.js
  var require_ValueToColor = __commonJS({
    "../../node_modules/phaser/src/display/color/ValueToColor.js": function(exports, module) {
      var HexStringToColor = require_HexStringToColor();
      var IntegerToColor = require_IntegerToColor();
      var ObjectToColor = require_ObjectToColor();
      var RGBStringToColor = require_RGBStringToColor();
      var ValueToColor = function(input) {
        var t = typeof input;
        switch (t) {
          case "string":
            if (input.substr(0, 3).toLowerCase() === "rgb") {
              return RGBStringToColor(input);
            } else {
              return HexStringToColor(input);
            }
          case "number":
            return IntegerToColor(input);
          case "object":
            return ObjectToColor(input);
        }
      };
      module.exports = ValueToColor;
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/BaseCamera.js
  var require_BaseCamera = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/BaseCamera.js": function(exports, module) {
      var Class = require_Class();
      var Components = require_components();
      var DegToRad = require_DegToRad();
      var EventEmitter = require_eventemitter3();
      var Events = require_events6();
      var Rectangle = require_Rectangle();
      var TransformMatrix = require_TransformMatrix();
      var ValueToColor = require_ValueToColor();
      var Vector2 = require_Vector2();
      var BaseCamera = new Class({
        Extends: EventEmitter,
        Mixins: [
          Components.AlphaSingle,
          Components.Visible
        ],
        initialize: function BaseCamera2(x, y, width, height) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (width === void 0) {
            width = 0;
          }
          if (height === void 0) {
            height = 0;
          }
          EventEmitter.call(this);
          this.scene;
          this.sceneManager;
          this.scaleManager;
          this.cameraManager;
          this.id = 0;
          this.name = "";
          this.roundPixels = false;
          this.useBounds = false;
          this.worldView = new Rectangle();
          this.dirty = true;
          this._x = x;
          this._y = y;
          this._width = width;
          this._height = height;
          this._bounds = new Rectangle();
          this._scrollX = 0;
          this._scrollY = 0;
          this._zoomX = 1;
          this._zoomY = 1;
          this._rotation = 0;
          this.matrix = new TransformMatrix();
          this.transparent = true;
          this.backgroundColor = ValueToColor("rgba(0,0,0,0)");
          this.disableCull = false;
          this.culledObjects = [];
          this.midPoint = new Vector2(width / 2, height / 2);
          this.originX = 0.5;
          this.originY = 0.5;
          this._customViewport = false;
          this.mask = null;
          this._maskCamera = null;
          this.renderList = [];
          this.isSceneCamera = true;
        },
        addToRenderList: function(child) {
          this.renderList.push(child);
        },
        setOrigin: function(x, y) {
          if (x === void 0) {
            x = 0.5;
          }
          if (y === void 0) {
            y = x;
          }
          this.originX = x;
          this.originY = y;
          return this;
        },
        getScroll: function(x, y, out) {
          if (out === void 0) {
            out = new Vector2();
          }
          var originX = this.width * 0.5;
          var originY = this.height * 0.5;
          out.x = x - originX;
          out.y = y - originY;
          if (this.useBounds) {
            out.x = this.clampX(out.x);
            out.y = this.clampY(out.y);
          }
          return out;
        },
        centerOnX: function(x) {
          var originX = this.width * 0.5;
          this.midPoint.x = x;
          this.scrollX = x - originX;
          if (this.useBounds) {
            this.scrollX = this.clampX(this.scrollX);
          }
          return this;
        },
        centerOnY: function(y) {
          var originY = this.height * 0.5;
          this.midPoint.y = y;
          this.scrollY = y - originY;
          if (this.useBounds) {
            this.scrollY = this.clampY(this.scrollY);
          }
          return this;
        },
        centerOn: function(x, y) {
          this.centerOnX(x);
          this.centerOnY(y);
          return this;
        },
        centerToBounds: function() {
          if (this.useBounds) {
            var bounds = this._bounds;
            var originX = this.width * 0.5;
            var originY = this.height * 0.5;
            this.midPoint.set(bounds.centerX, bounds.centerY);
            this.scrollX = bounds.centerX - originX;
            this.scrollY = bounds.centerY - originY;
          }
          return this;
        },
        centerToSize: function() {
          this.scrollX = this.width * 0.5;
          this.scrollY = this.height * 0.5;
          return this;
        },
        cull: function(renderableObjects) {
          if (this.disableCull) {
            return renderableObjects;
          }
          var cameraMatrix = this.matrix.matrix;
          var mva = cameraMatrix[0];
          var mvb = cameraMatrix[1];
          var mvc = cameraMatrix[2];
          var mvd = cameraMatrix[3];
          var determinant = mva * mvd - mvb * mvc;
          if (!determinant) {
            return renderableObjects;
          }
          var mve = cameraMatrix[4];
          var mvf = cameraMatrix[5];
          var scrollX = this.scrollX;
          var scrollY = this.scrollY;
          var cameraW = this.width;
          var cameraH = this.height;
          var cullTop = this.y;
          var cullBottom = cullTop + cameraH;
          var cullLeft = this.x;
          var cullRight = cullLeft + cameraW;
          var culledObjects = this.culledObjects;
          var length = renderableObjects.length;
          determinant = 1 / determinant;
          culledObjects.length = 0;
          for (var index = 0; index < length; ++index) {
            var object = renderableObjects[index];
            if (!object.hasOwnProperty("width") || object.parentContainer) {
              culledObjects.push(object);
              continue;
            }
            var objectW = object.width;
            var objectH = object.height;
            var objectX = object.x - scrollX * object.scrollFactorX - objectW * object.originX;
            var objectY = object.y - scrollY * object.scrollFactorY - objectH * object.originY;
            var tx = objectX * mva + objectY * mvc + mve;
            var ty = objectX * mvb + objectY * mvd + mvf;
            var tw = (objectX + objectW) * mva + (objectY + objectH) * mvc + mve;
            var th = (objectX + objectW) * mvb + (objectY + objectH) * mvd + mvf;
            if (tw > cullLeft && tx < cullRight && (th > cullTop && ty < cullBottom)) {
              culledObjects.push(object);
            }
          }
          return culledObjects;
        },
        getWorldPoint: function(x, y, output) {
          if (output === void 0) {
            output = new Vector2();
          }
          var cameraMatrix = this.matrix.matrix;
          var mva = cameraMatrix[0];
          var mvb = cameraMatrix[1];
          var mvc = cameraMatrix[2];
          var mvd = cameraMatrix[3];
          var mve = cameraMatrix[4];
          var mvf = cameraMatrix[5];
          var determinant = mva * mvd - mvb * mvc;
          if (!determinant) {
            output.x = x;
            output.y = y;
            return output;
          }
          determinant = 1 / determinant;
          var ima = mvd * determinant;
          var imb = -mvb * determinant;
          var imc = -mvc * determinant;
          var imd = mva * determinant;
          var ime = (mvc * mvf - mvd * mve) * determinant;
          var imf = (mvb * mve - mva * mvf) * determinant;
          var c = Math.cos(this.rotation);
          var s = Math.sin(this.rotation);
          var zoomX = this.zoomX;
          var zoomY = this.zoomY;
          var scrollX = this.scrollX;
          var scrollY = this.scrollY;
          var sx = x + (scrollX * c - scrollY * s) * zoomX;
          var sy = y + (scrollX * s + scrollY * c) * zoomY;
          output.x = sx * ima + sy * imc + ime;
          output.y = sx * imb + sy * imd + imf;
          return output;
        },
        ignore: function(entries) {
          var id = this.id;
          if (!Array.isArray(entries)) {
            entries = [entries];
          }
          for (var i = 0; i < entries.length; i++) {
            var entry = entries[i];
            if (Array.isArray(entry)) {
              this.ignore(entry);
            } else if (entry.isParent) {
              this.ignore(entry.getChildren());
            } else {
              entry.cameraFilter |= id;
            }
          }
          return this;
        },
        preRender: function() {
          this.renderList.length = 0;
          var width = this.width;
          var height = this.height;
          var halfWidth = width * 0.5;
          var halfHeight = height * 0.5;
          var zoomX = this.zoomX;
          var zoomY = this.zoomY;
          var matrix = this.matrix;
          var originX = width * this.originX;
          var originY = height * this.originY;
          var sx = this.scrollX;
          var sy = this.scrollY;
          if (this.useBounds) {
            sx = this.clampX(sx);
            sy = this.clampY(sy);
          }
          if (this.roundPixels) {
            originX = Math.round(originX);
            originY = Math.round(originY);
          }
          this.scrollX = sx;
          this.scrollY = sy;
          var midX = sx + halfWidth;
          var midY = sy + halfHeight;
          this.midPoint.set(midX, midY);
          var displayWidth = width / zoomX;
          var displayHeight = height / zoomY;
          this.worldView.setTo(midX - displayWidth / 2, midY - displayHeight / 2, displayWidth, displayHeight);
          matrix.applyITRS(this.x + originX, this.y + originY, this.rotation, zoomX, zoomY);
          matrix.translate(-originX, -originY);
        },
        clampX: function(x) {
          var bounds = this._bounds;
          var dw = this.displayWidth;
          var bx = bounds.x + (dw - this.width) / 2;
          var bw = Math.max(bx, bx + bounds.width - dw);
          if (x < bx) {
            x = bx;
          } else if (x > bw) {
            x = bw;
          }
          return x;
        },
        clampY: function(y) {
          var bounds = this._bounds;
          var dh = this.displayHeight;
          var by = bounds.y + (dh - this.height) / 2;
          var bh = Math.max(by, by + bounds.height - dh);
          if (y < by) {
            y = by;
          } else if (y > bh) {
            y = bh;
          }
          return y;
        },
        removeBounds: function() {
          this.useBounds = false;
          this.dirty = true;
          this._bounds.setEmpty();
          return this;
        },
        setAngle: function(value) {
          if (value === void 0) {
            value = 0;
          }
          this.rotation = DegToRad(value);
          return this;
        },
        setBackgroundColor: function(color) {
          if (color === void 0) {
            color = "rgba(0,0,0,0)";
          }
          this.backgroundColor = ValueToColor(color);
          this.transparent = this.backgroundColor.alpha === 0;
          return this;
        },
        setBounds: function(x, y, width, height, centerOn) {
          if (centerOn === void 0) {
            centerOn = false;
          }
          this._bounds.setTo(x, y, width, height);
          this.dirty = true;
          this.useBounds = true;
          if (centerOn) {
            this.centerToBounds();
          } else {
            this.scrollX = this.clampX(this.scrollX);
            this.scrollY = this.clampY(this.scrollY);
          }
          return this;
        },
        getBounds: function(out) {
          if (out === void 0) {
            out = new Rectangle();
          }
          var source = this._bounds;
          out.setTo(source.x, source.y, source.width, source.height);
          return out;
        },
        setName: function(value) {
          if (value === void 0) {
            value = "";
          }
          this.name = value;
          return this;
        },
        setPosition: function(x, y) {
          if (y === void 0) {
            y = x;
          }
          this.x = x;
          this.y = y;
          return this;
        },
        setRotation: function(value) {
          if (value === void 0) {
            value = 0;
          }
          this.rotation = value;
          return this;
        },
        setRoundPixels: function(value) {
          this.roundPixels = value;
          return this;
        },
        setScene: function(scene, isSceneCamera) {
          if (isSceneCamera === void 0) {
            isSceneCamera = true;
          }
          if (this.scene && this._customViewport) {
            this.sceneManager.customViewports--;
          }
          this.scene = scene;
          this.isSceneCamera = isSceneCamera;
          var sys = scene.sys;
          this.sceneManager = sys.game.scene;
          this.scaleManager = sys.scale;
          this.cameraManager = sys.cameras;
          this.updateSystem();
          return this;
        },
        setScroll: function(x, y) {
          if (y === void 0) {
            y = x;
          }
          this.scrollX = x;
          this.scrollY = y;
          return this;
        },
        setSize: function(width, height) {
          if (height === void 0) {
            height = width;
          }
          this.width = width;
          this.height = height;
          return this;
        },
        setViewport: function(x, y, width, height) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
          return this;
        },
        setZoom: function(x, y) {
          if (x === void 0) {
            x = 1;
          }
          if (y === void 0) {
            y = x;
          }
          if (x === 0) {
            x = 1e-3;
          }
          if (y === 0) {
            y = 1e-3;
          }
          this.zoomX = x;
          this.zoomY = y;
          return this;
        },
        setMask: function(mask, fixedPosition) {
          if (fixedPosition === void 0) {
            fixedPosition = true;
          }
          this.mask = mask;
          this._maskCamera = fixedPosition ? this.cameraManager.default : this;
          return this;
        },
        clearMask: function(destroyMask) {
          if (destroyMask === void 0) {
            destroyMask = false;
          }
          if (destroyMask && this.mask) {
            this.mask.destroy();
          }
          this.mask = null;
          return this;
        },
        toJSON: function() {
          var output = {
            name: this.name,
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height,
            zoom: this.zoom,
            rotation: this.rotation,
            roundPixels: this.roundPixels,
            scrollX: this.scrollX,
            scrollY: this.scrollY,
            backgroundColor: this.backgroundColor.rgba
          };
          if (this.useBounds) {
            output["bounds"] = {
              x: this._bounds.x,
              y: this._bounds.y,
              width: this._bounds.width,
              height: this._bounds.height
            };
          }
          return output;
        },
        update: function() {
        },
        setIsSceneCamera: function(value) {
          this.isSceneCamera = value;
          return this;
        },
        updateSystem: function() {
          if (!this.scaleManager || !this.isSceneCamera) {
            return;
          }
          var custom = this._x !== 0 || this._y !== 0 || this.scaleManager.width !== this._width || this.scaleManager.height !== this._height;
          var sceneManager = this.sceneManager;
          if (custom && !this._customViewport) {
            sceneManager.customViewports++;
          } else if (!custom && this._customViewport) {
            sceneManager.customViewports--;
          }
          this.dirty = true;
          this._customViewport = custom;
        },
        destroy: function() {
          this.emit(Events.DESTROY, this);
          this.removeAllListeners();
          this.matrix.destroy();
          this.culledObjects = [];
          if (this._customViewport) {
            this.sceneManager.customViewports--;
          }
          this.renderList = [];
          this._bounds = null;
          this.scene = null;
          this.scaleManager = null;
          this.sceneManager = null;
          this.cameraManager = null;
        },
        x: {
          get: function() {
            return this._x;
          },
          set: function(value) {
            this._x = value;
            this.updateSystem();
          }
        },
        y: {
          get: function() {
            return this._y;
          },
          set: function(value) {
            this._y = value;
            this.updateSystem();
          }
        },
        width: {
          get: function() {
            return this._width;
          },
          set: function(value) {
            this._width = value;
            this.updateSystem();
          }
        },
        height: {
          get: function() {
            return this._height;
          },
          set: function(value) {
            this._height = value;
            this.updateSystem();
          }
        },
        scrollX: {
          get: function() {
            return this._scrollX;
          },
          set: function(value) {
            if (value !== this._scrollX) {
              this._scrollX = value;
              this.dirty = true;
            }
          }
        },
        scrollY: {
          get: function() {
            return this._scrollY;
          },
          set: function(value) {
            if (value !== this._scrollY) {
              this._scrollY = value;
              this.dirty = true;
            }
          }
        },
        zoom: {
          get: function() {
            return (this._zoomX + this._zoomY) / 2;
          },
          set: function(value) {
            this._zoomX = value;
            this._zoomY = value;
            this.dirty = true;
          }
        },
        zoomX: {
          get: function() {
            return this._zoomX;
          },
          set: function(value) {
            this._zoomX = value;
            this.dirty = true;
          }
        },
        zoomY: {
          get: function() {
            return this._zoomY;
          },
          set: function(value) {
            this._zoomY = value;
            this.dirty = true;
          }
        },
        rotation: {
          get: function() {
            return this._rotation;
          },
          set: function(value) {
            this._rotation = value;
            this.dirty = true;
          }
        },
        centerX: {
          get: function() {
            return this.x + 0.5 * this.width;
          }
        },
        centerY: {
          get: function() {
            return this.y + 0.5 * this.height;
          }
        },
        displayWidth: {
          get: function() {
            return this.width / this.zoomX;
          }
        },
        displayHeight: {
          get: function() {
            return this.height / this.zoomY;
          }
        }
      });
      module.exports = BaseCamera;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/CenterOn.js
  var require_CenterOn2 = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/CenterOn.js": function(exports, module) {
      var CenterOn = function(rect, x, y) {
        rect.x = x - rect.width / 2;
        rect.y = y - rect.height / 2;
        return rect;
      };
      module.exports = CenterOn;
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/effects/Fade.js
  var require_Fade = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/effects/Fade.js": function(exports, module) {
      var Clamp = require_Clamp();
      var Class = require_Class();
      var Events = require_events6();
      var Fade = new Class({
        initialize: function Fade2(camera) {
          this.camera = camera;
          this.isRunning = false;
          this.isComplete = false;
          this.direction = true;
          this.duration = 0;
          this.red = 0;
          this.green = 0;
          this.blue = 0;
          this.alpha = 0;
          this.progress = 0;
          this._elapsed = 0;
          this._onUpdate;
          this._onUpdateScope;
        },
        start: function(direction, duration, red, green, blue, force, callback, context) {
          if (direction === void 0) {
            direction = true;
          }
          if (duration === void 0) {
            duration = 1e3;
          }
          if (red === void 0) {
            red = 0;
          }
          if (green === void 0) {
            green = 0;
          }
          if (blue === void 0) {
            blue = 0;
          }
          if (force === void 0) {
            force = false;
          }
          if (callback === void 0) {
            callback = null;
          }
          if (context === void 0) {
            context = this.camera.scene;
          }
          if (!force && this.isRunning) {
            return this.camera;
          }
          this.isRunning = true;
          this.isComplete = false;
          this.duration = duration;
          this.direction = direction;
          this.progress = 0;
          this.red = red;
          this.green = green;
          this.blue = blue;
          this.alpha = direction ? Number.MIN_VALUE : 1;
          this._elapsed = 0;
          this._onUpdate = callback;
          this._onUpdateScope = context;
          var eventName = direction ? Events.FADE_OUT_START : Events.FADE_IN_START;
          this.camera.emit(eventName, this.camera, this, duration, red, green, blue);
          return this.camera;
        },
        update: function(time, delta) {
          if (!this.isRunning) {
            return;
          }
          this._elapsed += delta;
          this.progress = Clamp(this._elapsed / this.duration, 0, 1);
          if (this._onUpdate) {
            this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
          }
          if (this._elapsed < this.duration) {
            this.alpha = this.direction ? this.progress : 1 - this.progress;
          } else {
            this.alpha = this.direction ? 1 : 0;
            this.effectComplete();
          }
        },
        postRenderCanvas: function(ctx) {
          if (!this.isRunning && !this.isComplete) {
            return false;
          }
          var camera = this.camera;
          ctx.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")";
          ctx.fillRect(camera.x, camera.y, camera.width, camera.height);
          return true;
        },
        postRenderWebGL: function(pipeline, getTintFunction) {
          if (!this.isRunning && !this.isComplete) {
            return false;
          }
          var camera = this.camera;
          var red = this.red / 255;
          var green = this.green / 255;
          var blue = this.blue / 255;
          pipeline.drawFillRect(camera.x, camera.y, camera.width, camera.height, getTintFunction(blue, green, red, 1), this.alpha);
          return true;
        },
        effectComplete: function() {
          this._onUpdate = null;
          this._onUpdateScope = null;
          this.isRunning = false;
          this.isComplete = true;
          var eventName = this.direction ? Events.FADE_OUT_COMPLETE : Events.FADE_IN_COMPLETE;
          this.camera.emit(eventName, this.camera, this);
        },
        reset: function() {
          this.isRunning = false;
          this.isComplete = false;
          this._onUpdate = null;
          this._onUpdateScope = null;
        },
        destroy: function() {
          this.reset();
          this.camera = null;
        }
      });
      module.exports = Fade;
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/effects/Flash.js
  var require_Flash = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/effects/Flash.js": function(exports, module) {
      var Clamp = require_Clamp();
      var Class = require_Class();
      var Events = require_events6();
      var Flash = new Class({
        initialize: function Flash2(camera) {
          this.camera = camera;
          this.isRunning = false;
          this.duration = 0;
          this.red = 0;
          this.green = 0;
          this.blue = 0;
          this.alpha = 1;
          this.progress = 0;
          this._elapsed = 0;
          this._alpha;
          this._onUpdate;
          this._onUpdateScope;
        },
        start: function(duration, red, green, blue, force, callback, context) {
          if (duration === void 0) {
            duration = 250;
          }
          if (red === void 0) {
            red = 255;
          }
          if (green === void 0) {
            green = 255;
          }
          if (blue === void 0) {
            blue = 255;
          }
          if (force === void 0) {
            force = false;
          }
          if (callback === void 0) {
            callback = null;
          }
          if (context === void 0) {
            context = this.camera.scene;
          }
          if (!force && this.isRunning) {
            return this.camera;
          }
          this.isRunning = true;
          this.duration = duration;
          this.progress = 0;
          this.red = red;
          this.green = green;
          this.blue = blue;
          this._alpha = this.alpha;
          this._elapsed = 0;
          this._onUpdate = callback;
          this._onUpdateScope = context;
          this.camera.emit(Events.FLASH_START, this.camera, this, duration, red, green, blue);
          return this.camera;
        },
        update: function(time, delta) {
          if (!this.isRunning) {
            return;
          }
          this._elapsed += delta;
          this.progress = Clamp(this._elapsed / this.duration, 0, 1);
          if (this._onUpdate) {
            this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
          }
          if (this._elapsed < this.duration) {
            this.alpha = this._alpha * (1 - this.progress);
          } else {
            this.effectComplete();
          }
        },
        postRenderCanvas: function(ctx) {
          if (!this.isRunning) {
            return false;
          }
          var camera = this.camera;
          ctx.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")";
          ctx.fillRect(camera.x, camera.y, camera.width, camera.height);
          return true;
        },
        postRenderWebGL: function(pipeline, getTintFunction) {
          if (!this.isRunning) {
            return false;
          }
          var camera = this.camera;
          var red = this.red / 255;
          var green = this.green / 255;
          var blue = this.blue / 255;
          pipeline.drawFillRect(camera.x, camera.y, camera.width, camera.height, getTintFunction(blue, green, red, 1), this.alpha);
          return true;
        },
        effectComplete: function() {
          this.alpha = this._alpha;
          this._onUpdate = null;
          this._onUpdateScope = null;
          this.isRunning = false;
          this.camera.emit(Events.FLASH_COMPLETE, this.camera, this);
        },
        reset: function() {
          this.isRunning = false;
          this._onUpdate = null;
          this._onUpdateScope = null;
        },
        destroy: function() {
          this.reset();
          this.camera = null;
        }
      });
      module.exports = Flash;
    }
  });

  // ../../node_modules/phaser/src/math/easing/back/In.js
  var require_In = __commonJS({
    "../../node_modules/phaser/src/math/easing/back/In.js": function(exports, module) {
      var In = function(v, overshoot) {
        if (overshoot === void 0) {
          overshoot = 1.70158;
        }
        return v * v * ((overshoot + 1) * v - overshoot);
      };
      module.exports = In;
    }
  });

  // ../../node_modules/phaser/src/math/easing/back/Out.js
  var require_Out = __commonJS({
    "../../node_modules/phaser/src/math/easing/back/Out.js": function(exports, module) {
      var Out = function(v, overshoot) {
        if (overshoot === void 0) {
          overshoot = 1.70158;
        }
        return --v * v * ((overshoot + 1) * v + overshoot) + 1;
      };
      module.exports = Out;
    }
  });

  // ../../node_modules/phaser/src/math/easing/back/InOut.js
  var require_InOut = __commonJS({
    "../../node_modules/phaser/src/math/easing/back/InOut.js": function(exports, module) {
      var InOut = function(v, overshoot) {
        if (overshoot === void 0) {
          overshoot = 1.70158;
        }
        var s = overshoot * 1.525;
        if ((v *= 2) < 1) {
          return 0.5 * (v * v * ((s + 1) * v - s));
        } else {
          return 0.5 * ((v -= 2) * v * ((s + 1) * v + s) + 2);
        }
      };
      module.exports = InOut;
    }
  });

  // ../../node_modules/phaser/src/math/easing/back/index.js
  var require_back = __commonJS({
    "../../node_modules/phaser/src/math/easing/back/index.js": function(exports, module) {
      module.exports = {
        In: require_In(),
        Out: require_Out(),
        InOut: require_InOut()
      };
    }
  });

  // ../../node_modules/phaser/src/math/easing/bounce/In.js
  var require_In2 = __commonJS({
    "../../node_modules/phaser/src/math/easing/bounce/In.js": function(exports, module) {
      var In = function(v) {
        v = 1 - v;
        if (v < 1 / 2.75) {
          return 1 - 7.5625 * v * v;
        } else if (v < 2 / 2.75) {
          return 1 - (7.5625 * (v -= 1.5 / 2.75) * v + 0.75);
        } else if (v < 2.5 / 2.75) {
          return 1 - (7.5625 * (v -= 2.25 / 2.75) * v + 0.9375);
        } else {
          return 1 - (7.5625 * (v -= 2.625 / 2.75) * v + 0.984375);
        }
      };
      module.exports = In;
    }
  });

  // ../../node_modules/phaser/src/math/easing/bounce/Out.js
  var require_Out2 = __commonJS({
    "../../node_modules/phaser/src/math/easing/bounce/Out.js": function(exports, module) {
      var Out = function(v) {
        if (v < 1 / 2.75) {
          return 7.5625 * v * v;
        } else if (v < 2 / 2.75) {
          return 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
        } else if (v < 2.5 / 2.75) {
          return 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
        } else {
          return 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
        }
      };
      module.exports = Out;
    }
  });

  // ../../node_modules/phaser/src/math/easing/bounce/InOut.js
  var require_InOut2 = __commonJS({
    "../../node_modules/phaser/src/math/easing/bounce/InOut.js": function(exports, module) {
      var InOut = function(v) {
        var reverse = false;
        if (v < 0.5) {
          v = 1 - v * 2;
          reverse = true;
        } else {
          v = v * 2 - 1;
        }
        if (v < 1 / 2.75) {
          v = 7.5625 * v * v;
        } else if (v < 2 / 2.75) {
          v = 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
        } else if (v < 2.5 / 2.75) {
          v = 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
        } else {
          v = 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
        }
        if (reverse) {
          return (1 - v) * 0.5;
        } else {
          return v * 0.5 + 0.5;
        }
      };
      module.exports = InOut;
    }
  });

  // ../../node_modules/phaser/src/math/easing/bounce/index.js
  var require_bounce = __commonJS({
    "../../node_modules/phaser/src/math/easing/bounce/index.js": function(exports, module) {
      module.exports = {
        In: require_In2(),
        Out: require_Out2(),
        InOut: require_InOut2()
      };
    }
  });

  // ../../node_modules/phaser/src/math/easing/circular/In.js
  var require_In3 = __commonJS({
    "../../node_modules/phaser/src/math/easing/circular/In.js": function(exports, module) {
      var In = function(v) {
        return 1 - Math.sqrt(1 - v * v);
      };
      module.exports = In;
    }
  });

  // ../../node_modules/phaser/src/math/easing/circular/Out.js
  var require_Out3 = __commonJS({
    "../../node_modules/phaser/src/math/easing/circular/Out.js": function(exports, module) {
      var Out = function(v) {
        return Math.sqrt(1 - --v * v);
      };
      module.exports = Out;
    }
  });

  // ../../node_modules/phaser/src/math/easing/circular/InOut.js
  var require_InOut3 = __commonJS({
    "../../node_modules/phaser/src/math/easing/circular/InOut.js": function(exports, module) {
      var InOut = function(v) {
        if ((v *= 2) < 1) {
          return -0.5 * (Math.sqrt(1 - v * v) - 1);
        } else {
          return 0.5 * (Math.sqrt(1 - (v -= 2) * v) + 1);
        }
      };
      module.exports = InOut;
    }
  });

  // ../../node_modules/phaser/src/math/easing/circular/index.js
  var require_circular = __commonJS({
    "../../node_modules/phaser/src/math/easing/circular/index.js": function(exports, module) {
      module.exports = {
        In: require_In3(),
        Out: require_Out3(),
        InOut: require_InOut3()
      };
    }
  });

  // ../../node_modules/phaser/src/math/easing/cubic/In.js
  var require_In4 = __commonJS({
    "../../node_modules/phaser/src/math/easing/cubic/In.js": function(exports, module) {
      var In = function(v) {
        return v * v * v;
      };
      module.exports = In;
    }
  });

  // ../../node_modules/phaser/src/math/easing/cubic/Out.js
  var require_Out4 = __commonJS({
    "../../node_modules/phaser/src/math/easing/cubic/Out.js": function(exports, module) {
      var Out = function(v) {
        return --v * v * v + 1;
      };
      module.exports = Out;
    }
  });

  // ../../node_modules/phaser/src/math/easing/cubic/InOut.js
  var require_InOut4 = __commonJS({
    "../../node_modules/phaser/src/math/easing/cubic/InOut.js": function(exports, module) {
      var InOut = function(v) {
        if ((v *= 2) < 1) {
          return 0.5 * v * v * v;
        } else {
          return 0.5 * ((v -= 2) * v * v + 2);
        }
      };
      module.exports = InOut;
    }
  });

  // ../../node_modules/phaser/src/math/easing/cubic/index.js
  var require_cubic = __commonJS({
    "../../node_modules/phaser/src/math/easing/cubic/index.js": function(exports, module) {
      module.exports = {
        In: require_In4(),
        Out: require_Out4(),
        InOut: require_InOut4()
      };
    }
  });

  // ../../node_modules/phaser/src/math/easing/elastic/In.js
  var require_In5 = __commonJS({
    "../../node_modules/phaser/src/math/easing/elastic/In.js": function(exports, module) {
      var In = function(v, amplitude, period) {
        if (amplitude === void 0) {
          amplitude = 0.1;
        }
        if (period === void 0) {
          period = 0.1;
        }
        if (v === 0) {
          return 0;
        } else if (v === 1) {
          return 1;
        } else {
          var s = period / 4;
          if (amplitude < 1) {
            amplitude = 1;
          } else {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
          }
          return -(amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
        }
      };
      module.exports = In;
    }
  });

  // ../../node_modules/phaser/src/math/easing/elastic/Out.js
  var require_Out5 = __commonJS({
    "../../node_modules/phaser/src/math/easing/elastic/Out.js": function(exports, module) {
      var Out = function(v, amplitude, period) {
        if (amplitude === void 0) {
          amplitude = 0.1;
        }
        if (period === void 0) {
          period = 0.1;
        }
        if (v === 0) {
          return 0;
        } else if (v === 1) {
          return 1;
        } else {
          var s = period / 4;
          if (amplitude < 1) {
            amplitude = 1;
          } else {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
          }
          return amplitude * Math.pow(2, -10 * v) * Math.sin((v - s) * (2 * Math.PI) / period) + 1;
        }
      };
      module.exports = Out;
    }
  });

  // ../../node_modules/phaser/src/math/easing/elastic/InOut.js
  var require_InOut5 = __commonJS({
    "../../node_modules/phaser/src/math/easing/elastic/InOut.js": function(exports, module) {
      var InOut = function(v, amplitude, period) {
        if (amplitude === void 0) {
          amplitude = 0.1;
        }
        if (period === void 0) {
          period = 0.1;
        }
        if (v === 0) {
          return 0;
        } else if (v === 1) {
          return 1;
        } else {
          var s = period / 4;
          if (amplitude < 1) {
            amplitude = 1;
          } else {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
          }
          if ((v *= 2) < 1) {
            return -0.5 * (amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
          } else {
            return amplitude * Math.pow(2, -10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period) * 0.5 + 1;
          }
        }
      };
      module.exports = InOut;
    }
  });

  // ../../node_modules/phaser/src/math/easing/elastic/index.js
  var require_elastic = __commonJS({
    "../../node_modules/phaser/src/math/easing/elastic/index.js": function(exports, module) {
      module.exports = {
        In: require_In5(),
        Out: require_Out5(),
        InOut: require_InOut5()
      };
    }
  });

  // ../../node_modules/phaser/src/math/easing/expo/In.js
  var require_In6 = __commonJS({
    "../../node_modules/phaser/src/math/easing/expo/In.js": function(exports, module) {
      var In = function(v) {
        return Math.pow(2, 10 * (v - 1)) - 1e-3;
      };
      module.exports = In;
    }
  });

  // ../../node_modules/phaser/src/math/easing/expo/Out.js
  var require_Out6 = __commonJS({
    "../../node_modules/phaser/src/math/easing/expo/Out.js": function(exports, module) {
      var Out = function(v) {
        return 1 - Math.pow(2, -10 * v);
      };
      module.exports = Out;
    }
  });

  // ../../node_modules/phaser/src/math/easing/expo/InOut.js
  var require_InOut6 = __commonJS({
    "../../node_modules/phaser/src/math/easing/expo/InOut.js": function(exports, module) {
      var InOut = function(v) {
        if ((v *= 2) < 1) {
          return 0.5 * Math.pow(2, 10 * (v - 1));
        } else {
          return 0.5 * (2 - Math.pow(2, -10 * (v - 1)));
        }
      };
      module.exports = InOut;
    }
  });

  // ../../node_modules/phaser/src/math/easing/expo/index.js
  var require_expo = __commonJS({
    "../../node_modules/phaser/src/math/easing/expo/index.js": function(exports, module) {
      module.exports = {
        In: require_In6(),
        Out: require_Out6(),
        InOut: require_InOut6()
      };
    }
  });

  // ../../node_modules/phaser/src/math/easing/linear/Linear.js
  var require_Linear = __commonJS({
    "../../node_modules/phaser/src/math/easing/linear/Linear.js": function(exports, module) {
      var Linear = function(v) {
        return v;
      };
      module.exports = Linear;
    }
  });

  // ../../node_modules/phaser/src/math/easing/linear/index.js
  var require_linear = __commonJS({
    "../../node_modules/phaser/src/math/easing/linear/index.js": function(exports, module) {
      module.exports = require_Linear();
    }
  });

  // ../../node_modules/phaser/src/math/easing/quadratic/In.js
  var require_In7 = __commonJS({
    "../../node_modules/phaser/src/math/easing/quadratic/In.js": function(exports, module) {
      var In = function(v) {
        return v * v;
      };
      module.exports = In;
    }
  });

  // ../../node_modules/phaser/src/math/easing/quadratic/Out.js
  var require_Out7 = __commonJS({
    "../../node_modules/phaser/src/math/easing/quadratic/Out.js": function(exports, module) {
      var Out = function(v) {
        return v * (2 - v);
      };
      module.exports = Out;
    }
  });

  // ../../node_modules/phaser/src/math/easing/quadratic/InOut.js
  var require_InOut7 = __commonJS({
    "../../node_modules/phaser/src/math/easing/quadratic/InOut.js": function(exports, module) {
      var InOut = function(v) {
        if ((v *= 2) < 1) {
          return 0.5 * v * v;
        } else {
          return -0.5 * (--v * (v - 2) - 1);
        }
      };
      module.exports = InOut;
    }
  });

  // ../../node_modules/phaser/src/math/easing/quadratic/index.js
  var require_quadratic = __commonJS({
    "../../node_modules/phaser/src/math/easing/quadratic/index.js": function(exports, module) {
      module.exports = {
        In: require_In7(),
        Out: require_Out7(),
        InOut: require_InOut7()
      };
    }
  });

  // ../../node_modules/phaser/src/math/easing/quartic/In.js
  var require_In8 = __commonJS({
    "../../node_modules/phaser/src/math/easing/quartic/In.js": function(exports, module) {
      var In = function(v) {
        return v * v * v * v;
      };
      module.exports = In;
    }
  });

  // ../../node_modules/phaser/src/math/easing/quartic/Out.js
  var require_Out8 = __commonJS({
    "../../node_modules/phaser/src/math/easing/quartic/Out.js": function(exports, module) {
      var Out = function(v) {
        return 1 - --v * v * v * v;
      };
      module.exports = Out;
    }
  });

  // ../../node_modules/phaser/src/math/easing/quartic/InOut.js
  var require_InOut8 = __commonJS({
    "../../node_modules/phaser/src/math/easing/quartic/InOut.js": function(exports, module) {
      var InOut = function(v) {
        if ((v *= 2) < 1) {
          return 0.5 * v * v * v * v;
        } else {
          return -0.5 * ((v -= 2) * v * v * v - 2);
        }
      };
      module.exports = InOut;
    }
  });

  // ../../node_modules/phaser/src/math/easing/quartic/index.js
  var require_quartic = __commonJS({
    "../../node_modules/phaser/src/math/easing/quartic/index.js": function(exports, module) {
      module.exports = {
        In: require_In8(),
        Out: require_Out8(),
        InOut: require_InOut8()
      };
    }
  });

  // ../../node_modules/phaser/src/math/easing/quintic/In.js
  var require_In9 = __commonJS({
    "../../node_modules/phaser/src/math/easing/quintic/In.js": function(exports, module) {
      var In = function(v) {
        return v * v * v * v * v;
      };
      module.exports = In;
    }
  });

  // ../../node_modules/phaser/src/math/easing/quintic/Out.js
  var require_Out9 = __commonJS({
    "../../node_modules/phaser/src/math/easing/quintic/Out.js": function(exports, module) {
      var Out = function(v) {
        return --v * v * v * v * v + 1;
      };
      module.exports = Out;
    }
  });

  // ../../node_modules/phaser/src/math/easing/quintic/InOut.js
  var require_InOut9 = __commonJS({
    "../../node_modules/phaser/src/math/easing/quintic/InOut.js": function(exports, module) {
      var InOut = function(v) {
        if ((v *= 2) < 1) {
          return 0.5 * v * v * v * v * v;
        } else {
          return 0.5 * ((v -= 2) * v * v * v * v + 2);
        }
      };
      module.exports = InOut;
    }
  });

  // ../../node_modules/phaser/src/math/easing/quintic/index.js
  var require_quintic = __commonJS({
    "../../node_modules/phaser/src/math/easing/quintic/index.js": function(exports, module) {
      module.exports = {
        In: require_In9(),
        Out: require_Out9(),
        InOut: require_InOut9()
      };
    }
  });

  // ../../node_modules/phaser/src/math/easing/sine/In.js
  var require_In10 = __commonJS({
    "../../node_modules/phaser/src/math/easing/sine/In.js": function(exports, module) {
      var In = function(v) {
        if (v === 0) {
          return 0;
        } else if (v === 1) {
          return 1;
        } else {
          return 1 - Math.cos(v * Math.PI / 2);
        }
      };
      module.exports = In;
    }
  });

  // ../../node_modules/phaser/src/math/easing/sine/Out.js
  var require_Out10 = __commonJS({
    "../../node_modules/phaser/src/math/easing/sine/Out.js": function(exports, module) {
      var Out = function(v) {
        if (v === 0) {
          return 0;
        } else if (v === 1) {
          return 1;
        } else {
          return Math.sin(v * Math.PI / 2);
        }
      };
      module.exports = Out;
    }
  });

  // ../../node_modules/phaser/src/math/easing/sine/InOut.js
  var require_InOut10 = __commonJS({
    "../../node_modules/phaser/src/math/easing/sine/InOut.js": function(exports, module) {
      var InOut = function(v) {
        if (v === 0) {
          return 0;
        } else if (v === 1) {
          return 1;
        } else {
          return 0.5 * (1 - Math.cos(Math.PI * v));
        }
      };
      module.exports = InOut;
    }
  });

  // ../../node_modules/phaser/src/math/easing/sine/index.js
  var require_sine = __commonJS({
    "../../node_modules/phaser/src/math/easing/sine/index.js": function(exports, module) {
      module.exports = {
        In: require_In10(),
        Out: require_Out10(),
        InOut: require_InOut10()
      };
    }
  });

  // ../../node_modules/phaser/src/math/easing/stepped/Stepped.js
  var require_Stepped = __commonJS({
    "../../node_modules/phaser/src/math/easing/stepped/Stepped.js": function(exports, module) {
      var Stepped = function(v, steps) {
        if (steps === void 0) {
          steps = 1;
        }
        if (v <= 0) {
          return 0;
        } else if (v >= 1) {
          return 1;
        } else {
          return ((steps * v | 0) + 1) * (1 / steps);
        }
      };
      module.exports = Stepped;
    }
  });

  // ../../node_modules/phaser/src/math/easing/stepped/index.js
  var require_stepped = __commonJS({
    "../../node_modules/phaser/src/math/easing/stepped/index.js": function(exports, module) {
      module.exports = require_Stepped();
    }
  });

  // ../../node_modules/phaser/src/math/easing/EaseMap.js
  var require_EaseMap = __commonJS({
    "../../node_modules/phaser/src/math/easing/EaseMap.js": function(exports, module) {
      var Back = require_back();
      var Bounce = require_bounce();
      var Circular = require_circular();
      var Cubic = require_cubic();
      var Elastic = require_elastic();
      var Expo = require_expo();
      var Linear = require_linear();
      var Quadratic = require_quadratic();
      var Quartic = require_quartic();
      var Quintic = require_quintic();
      var Sine = require_sine();
      var Stepped = require_stepped();
      module.exports = {
        Power0: Linear,
        Power1: Quadratic.Out,
        Power2: Cubic.Out,
        Power3: Quartic.Out,
        Power4: Quintic.Out,
        Linear: Linear,
        Quad: Quadratic.Out,
        Cubic: Cubic.Out,
        Quart: Quartic.Out,
        Quint: Quintic.Out,
        Sine: Sine.Out,
        Expo: Expo.Out,
        Circ: Circular.Out,
        Elastic: Elastic.Out,
        Back: Back.Out,
        Bounce: Bounce.Out,
        Stepped: Stepped,
        "Quad.easeIn": Quadratic.In,
        "Cubic.easeIn": Cubic.In,
        "Quart.easeIn": Quartic.In,
        "Quint.easeIn": Quintic.In,
        "Sine.easeIn": Sine.In,
        "Expo.easeIn": Expo.In,
        "Circ.easeIn": Circular.In,
        "Elastic.easeIn": Elastic.In,
        "Back.easeIn": Back.In,
        "Bounce.easeIn": Bounce.In,
        "Quad.easeOut": Quadratic.Out,
        "Cubic.easeOut": Cubic.Out,
        "Quart.easeOut": Quartic.Out,
        "Quint.easeOut": Quintic.Out,
        "Sine.easeOut": Sine.Out,
        "Expo.easeOut": Expo.Out,
        "Circ.easeOut": Circular.Out,
        "Elastic.easeOut": Elastic.Out,
        "Back.easeOut": Back.Out,
        "Bounce.easeOut": Bounce.Out,
        "Quad.easeInOut": Quadratic.InOut,
        "Cubic.easeInOut": Cubic.InOut,
        "Quart.easeInOut": Quartic.InOut,
        "Quint.easeInOut": Quintic.InOut,
        "Sine.easeInOut": Sine.InOut,
        "Expo.easeInOut": Expo.InOut,
        "Circ.easeInOut": Circular.InOut,
        "Elastic.easeInOut": Elastic.InOut,
        "Back.easeInOut": Back.InOut,
        "Bounce.easeInOut": Bounce.InOut
      };
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/effects/Pan.js
  var require_Pan = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/effects/Pan.js": function(exports, module) {
      var Clamp = require_Clamp();
      var Class = require_Class();
      var EaseMap = require_EaseMap();
      var Events = require_events6();
      var Vector2 = require_Vector2();
      var Pan = new Class({
        initialize: function Pan2(camera) {
          this.camera = camera;
          this.isRunning = false;
          this.duration = 0;
          this.source = new Vector2();
          this.current = new Vector2();
          this.destination = new Vector2();
          this.ease;
          this.progress = 0;
          this._elapsed = 0;
          this._onUpdate;
          this._onUpdateScope;
        },
        start: function(x, y, duration, ease, force, callback, context) {
          if (duration === void 0) {
            duration = 1e3;
          }
          if (ease === void 0) {
            ease = EaseMap.Linear;
          }
          if (force === void 0) {
            force = false;
          }
          if (callback === void 0) {
            callback = null;
          }
          if (context === void 0) {
            context = this.camera.scene;
          }
          var cam = this.camera;
          if (!force && this.isRunning) {
            return cam;
          }
          this.isRunning = true;
          this.duration = duration;
          this.progress = 0;
          this.source.set(cam.scrollX, cam.scrollY);
          this.destination.set(x, y);
          cam.getScroll(x, y, this.current);
          if (typeof ease === "string" && EaseMap.hasOwnProperty(ease)) {
            this.ease = EaseMap[ease];
          } else if (typeof ease === "function") {
            this.ease = ease;
          }
          this._elapsed = 0;
          this._onUpdate = callback;
          this._onUpdateScope = context;
          this.camera.emit(Events.PAN_START, this.camera, this, duration, x, y);
          return cam;
        },
        update: function(time, delta) {
          if (!this.isRunning) {
            return;
          }
          this._elapsed += delta;
          var progress = Clamp(this._elapsed / this.duration, 0, 1);
          this.progress = progress;
          var cam = this.camera;
          if (this._elapsed < this.duration) {
            var v = this.ease(progress);
            cam.getScroll(this.destination.x, this.destination.y, this.current);
            var x = this.source.x + (this.current.x - this.source.x) * v;
            var y = this.source.y + (this.current.y - this.source.y) * v;
            cam.setScroll(x, y);
            if (this._onUpdate) {
              this._onUpdate.call(this._onUpdateScope, cam, progress, x, y);
            }
          } else {
            cam.centerOn(this.destination.x, this.destination.y);
            if (this._onUpdate) {
              this._onUpdate.call(this._onUpdateScope, cam, progress, cam.scrollX, cam.scrollY);
            }
            this.effectComplete();
          }
        },
        effectComplete: function() {
          this._onUpdate = null;
          this._onUpdateScope = null;
          this.isRunning = false;
          this.camera.emit(Events.PAN_COMPLETE, this.camera, this);
        },
        reset: function() {
          this.isRunning = false;
          this._onUpdate = null;
          this._onUpdateScope = null;
        },
        destroy: function() {
          this.reset();
          this.camera = null;
          this.source = null;
          this.destination = null;
        }
      });
      module.exports = Pan;
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/effects/Shake.js
  var require_Shake = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/effects/Shake.js": function(exports, module) {
      var Clamp = require_Clamp();
      var Class = require_Class();
      var Events = require_events6();
      var Vector2 = require_Vector2();
      var Shake = new Class({
        initialize: function Shake2(camera) {
          this.camera = camera;
          this.isRunning = false;
          this.duration = 0;
          this.intensity = new Vector2();
          this.progress = 0;
          this._elapsed = 0;
          this._offsetX = 0;
          this._offsetY = 0;
          this._onUpdate;
          this._onUpdateScope;
        },
        start: function(duration, intensity, force, callback, context) {
          if (duration === void 0) {
            duration = 100;
          }
          if (intensity === void 0) {
            intensity = 0.05;
          }
          if (force === void 0) {
            force = false;
          }
          if (callback === void 0) {
            callback = null;
          }
          if (context === void 0) {
            context = this.camera.scene;
          }
          if (!force && this.isRunning) {
            return this.camera;
          }
          this.isRunning = true;
          this.duration = duration;
          this.progress = 0;
          if (typeof intensity === "number") {
            this.intensity.set(intensity);
          } else {
            this.intensity.set(intensity.x, intensity.y);
          }
          this._elapsed = 0;
          this._offsetX = 0;
          this._offsetY = 0;
          this._onUpdate = callback;
          this._onUpdateScope = context;
          this.camera.emit(Events.SHAKE_START, this.camera, this, duration, intensity);
          return this.camera;
        },
        preRender: function() {
          if (this.isRunning) {
            this.camera.matrix.translate(this._offsetX, this._offsetY);
          }
        },
        update: function(time, delta) {
          if (!this.isRunning) {
            return;
          }
          this._elapsed += delta;
          this.progress = Clamp(this._elapsed / this.duration, 0, 1);
          if (this._onUpdate) {
            this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
          }
          if (this._elapsed < this.duration) {
            var intensity = this.intensity;
            var width = this.camera.width;
            var height = this.camera.height;
            var zoom = this.camera.zoom;
            this._offsetX = (Math.random() * intensity.x * width * 2 - intensity.x * width) * zoom;
            this._offsetY = (Math.random() * intensity.y * height * 2 - intensity.y * height) * zoom;
            if (this.camera.roundPixels) {
              this._offsetX = Math.round(this._offsetX);
              this._offsetY = Math.round(this._offsetY);
            }
          } else {
            this.effectComplete();
          }
        },
        effectComplete: function() {
          this._offsetX = 0;
          this._offsetY = 0;
          this._onUpdate = null;
          this._onUpdateScope = null;
          this.isRunning = false;
          this.camera.emit(Events.SHAKE_COMPLETE, this.camera, this);
        },
        reset: function() {
          this.isRunning = false;
          this._offsetX = 0;
          this._offsetY = 0;
          this._onUpdate = null;
          this._onUpdateScope = null;
        },
        destroy: function() {
          this.reset();
          this.camera = null;
          this.intensity = null;
        }
      });
      module.exports = Shake;
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/effects/RotateTo.js
  var require_RotateTo = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/effects/RotateTo.js": function(exports, module) {
      var Clamp = require_Clamp();
      var Class = require_Class();
      var Events = require_events6();
      var EaseMap = require_EaseMap();
      var RotateTo = new Class({
        initialize: function RotateTo2(camera) {
          this.camera = camera;
          this.isRunning = false;
          this.duration = 0;
          this.source = 0;
          this.current = 0;
          this.destination = 0;
          this.ease;
          this.progress = 0;
          this._elapsed = 0;
          this._onUpdate;
          this._onUpdateScope;
          this.clockwise = true;
          this.shortestPath = false;
        },
        start: function(radians, shortestPath, duration, ease, force, callback, context) {
          if (duration === void 0) {
            duration = 1e3;
          }
          if (ease === void 0) {
            ease = EaseMap.Linear;
          }
          if (force === void 0) {
            force = false;
          }
          if (callback === void 0) {
            callback = null;
          }
          if (context === void 0) {
            context = this.camera.scene;
          }
          if (shortestPath === void 0) {
            shortestPath = false;
          }
          this.shortestPath = shortestPath;
          var tmpDestination = radians;
          if (radians < 0) {
            tmpDestination = -1 * radians;
            this.clockwise = false;
          } else {
            this.clockwise = true;
          }
          var maxRad = 360 * Math.PI / 180;
          tmpDestination = tmpDestination - Math.floor(tmpDestination / maxRad) * maxRad;
          var cam = this.camera;
          if (!force && this.isRunning) {
            return cam;
          }
          this.isRunning = true;
          this.duration = duration;
          this.progress = 0;
          this.source = cam.rotation;
          this.destination = tmpDestination;
          if (typeof ease === "string" && EaseMap.hasOwnProperty(ease)) {
            this.ease = EaseMap[ease];
          } else if (typeof ease === "function") {
            this.ease = ease;
          }
          this._elapsed = 0;
          this._onUpdate = callback;
          this._onUpdateScope = context;
          if (this.shortestPath) {
            var cwDist = 0;
            var acwDist = 0;
            if (this.destination > this.source) {
              cwDist = Math.abs(this.destination - this.source);
            } else {
              cwDist = Math.abs(this.destination + maxRad) - this.source;
            }
            if (this.source > this.destination) {
              acwDist = Math.abs(this.source - this.destination);
            } else {
              acwDist = Math.abs(this.source + maxRad) - this.destination;
            }
            if (cwDist < acwDist) {
              this.clockwise = true;
            } else if (cwDist > acwDist) {
              this.clockwise = false;
            }
          }
          this.camera.emit(Events.ROTATE_START, this.camera, this, duration, tmpDestination);
          return cam;
        },
        update: function(time, delta) {
          if (!this.isRunning) {
            return;
          }
          this._elapsed += delta;
          var progress = Clamp(this._elapsed / this.duration, 0, 1);
          this.progress = progress;
          var cam = this.camera;
          if (this._elapsed < this.duration) {
            var v = this.ease(progress);
            this.current = cam.rotation;
            var distance = 0;
            var maxRad = 360 * Math.PI / 180;
            var target = this.destination;
            var current = this.current;
            if (this.clockwise === false) {
              target = this.current;
              current = this.destination;
            }
            if (target >= current) {
              distance = Math.abs(target - current);
            } else {
              distance = Math.abs(target + maxRad) - current;
            }
            var r = 0;
            if (this.clockwise) {
              r = cam.rotation + distance * v;
            } else {
              r = cam.rotation - distance * v;
            }
            cam.rotation = r;
            if (this._onUpdate) {
              this._onUpdate.call(this._onUpdateScope, cam, progress, r);
            }
          } else {
            cam.rotation = this.destination;
            if (this._onUpdate) {
              this._onUpdate.call(this._onUpdateScope, cam, progress, this.destination);
            }
            this.effectComplete();
          }
        },
        effectComplete: function() {
          this._onUpdate = null;
          this._onUpdateScope = null;
          this.isRunning = false;
          this.camera.emit(Events.ROTATE_COMPLETE, this.camera, this);
        },
        reset: function() {
          this.isRunning = false;
          this._onUpdate = null;
          this._onUpdateScope = null;
        },
        destroy: function() {
          this.reset();
          this.camera = null;
          this.source = null;
          this.destination = null;
        }
      });
      module.exports = RotateTo;
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/effects/Zoom.js
  var require_Zoom = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/effects/Zoom.js": function(exports, module) {
      var Clamp = require_Clamp();
      var Class = require_Class();
      var EaseMap = require_EaseMap();
      var Events = require_events6();
      var Zoom = new Class({
        initialize: function Zoom2(camera) {
          this.camera = camera;
          this.isRunning = false;
          this.duration = 0;
          this.source = 1;
          this.destination = 1;
          this.ease;
          this.progress = 0;
          this._elapsed = 0;
          this._onUpdate;
          this._onUpdateScope;
        },
        start: function(zoom, duration, ease, force, callback, context) {
          if (duration === void 0) {
            duration = 1e3;
          }
          if (ease === void 0) {
            ease = EaseMap.Linear;
          }
          if (force === void 0) {
            force = false;
          }
          if (callback === void 0) {
            callback = null;
          }
          if (context === void 0) {
            context = this.camera.scene;
          }
          var cam = this.camera;
          if (!force && this.isRunning) {
            return cam;
          }
          this.isRunning = true;
          this.duration = duration;
          this.progress = 0;
          this.source = cam.zoom;
          this.destination = zoom;
          if (typeof ease === "string" && EaseMap.hasOwnProperty(ease)) {
            this.ease = EaseMap[ease];
          } else if (typeof ease === "function") {
            this.ease = ease;
          }
          this._elapsed = 0;
          this._onUpdate = callback;
          this._onUpdateScope = context;
          this.camera.emit(Events.ZOOM_START, this.camera, this, duration, zoom);
          return cam;
        },
        update: function(time, delta) {
          if (!this.isRunning) {
            return;
          }
          this._elapsed += delta;
          this.progress = Clamp(this._elapsed / this.duration, 0, 1);
          if (this._elapsed < this.duration) {
            this.camera.zoom = this.source + (this.destination - this.source) * this.ease(this.progress);
            if (this._onUpdate) {
              this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.camera.zoom);
            }
          } else {
            this.camera.zoom = this.destination;
            if (this._onUpdate) {
              this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.destination);
            }
            this.effectComplete();
          }
        },
        effectComplete: function() {
          this._onUpdate = null;
          this._onUpdateScope = null;
          this.isRunning = false;
          this.camera.emit(Events.ZOOM_COMPLETE, this.camera, this);
        },
        reset: function() {
          this.isRunning = false;
          this._onUpdate = null;
          this._onUpdateScope = null;
        },
        destroy: function() {
          this.reset();
          this.camera = null;
        }
      });
      module.exports = Zoom;
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/effects/index.js
  var require_effects = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/effects/index.js": function(exports, module) {
      module.exports = {
        Fade: require_Fade(),
        Flash: require_Flash(),
        Pan: require_Pan(),
        Shake: require_Shake(),
        RotateTo: require_RotateTo(),
        Zoom: require_Zoom()
      };
    }
  });

  // ../../node_modules/phaser/src/math/Linear.js
  var require_Linear2 = __commonJS({
    "../../node_modules/phaser/src/math/Linear.js": function(exports, module) {
      var Linear = function(p0, p1, t) {
        return (p1 - p0) * t + p0;
      };
      module.exports = Linear;
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/Camera.js
  var require_Camera = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/Camera.js": function(exports, module) {
      var BaseCamera = require_BaseCamera();
      var CenterOn = require_CenterOn2();
      var Clamp = require_Clamp();
      var Class = require_Class();
      var Components = require_components();
      var Effects = require_effects();
      var Events = require_events6();
      var Linear = require_Linear2();
      var Rectangle = require_Rectangle();
      var Vector2 = require_Vector2();
      var Camera = new Class({
        Extends: BaseCamera,
        Mixins: [
          Components.PostPipeline
        ],
        initialize: function Camera2(x, y, width, height) {
          BaseCamera.call(this, x, y, width, height);
          this.initPostPipeline();
          this.inputEnabled = true;
          this.fadeEffect = new Effects.Fade(this);
          this.flashEffect = new Effects.Flash(this);
          this.shakeEffect = new Effects.Shake(this);
          this.panEffect = new Effects.Pan(this);
          this.rotateToEffect = new Effects.RotateTo(this);
          this.zoomEffect = new Effects.Zoom(this);
          this.lerp = new Vector2(1, 1);
          this.followOffset = new Vector2();
          this.deadzone = null;
          this._follow = null;
        },
        setDeadzone: function(width, height) {
          if (width === void 0) {
            this.deadzone = null;
          } else {
            if (this.deadzone) {
              this.deadzone.width = width;
              this.deadzone.height = height;
            } else {
              this.deadzone = new Rectangle(0, 0, width, height);
            }
            if (this._follow) {
              var originX = this.width / 2;
              var originY = this.height / 2;
              var fx = this._follow.x - this.followOffset.x;
              var fy = this._follow.y - this.followOffset.y;
              this.midPoint.set(fx, fy);
              this.scrollX = fx - originX;
              this.scrollY = fy - originY;
            }
            CenterOn(this.deadzone, this.midPoint.x, this.midPoint.y);
          }
          return this;
        },
        fadeIn: function(duration, red, green, blue, callback, context) {
          return this.fadeEffect.start(false, duration, red, green, blue, true, callback, context);
        },
        fadeOut: function(duration, red, green, blue, callback, context) {
          return this.fadeEffect.start(true, duration, red, green, blue, true, callback, context);
        },
        fadeFrom: function(duration, red, green, blue, force, callback, context) {
          return this.fadeEffect.start(false, duration, red, green, blue, force, callback, context);
        },
        fade: function(duration, red, green, blue, force, callback, context) {
          return this.fadeEffect.start(true, duration, red, green, blue, force, callback, context);
        },
        flash: function(duration, red, green, blue, force, callback, context) {
          return this.flashEffect.start(duration, red, green, blue, force, callback, context);
        },
        shake: function(duration, intensity, force, callback, context) {
          return this.shakeEffect.start(duration, intensity, force, callback, context);
        },
        pan: function(x, y, duration, ease, force, callback, context) {
          return this.panEffect.start(x, y, duration, ease, force, callback, context);
        },
        rotateTo: function(radians, shortestPath, duration, ease, force, callback, context) {
          return this.rotateToEffect.start(radians, shortestPath, duration, ease, force, callback, context);
        },
        zoomTo: function(zoom, duration, ease, force, callback, context) {
          return this.zoomEffect.start(zoom, duration, ease, force, callback, context);
        },
        preRender: function() {
          this.renderList.length = 0;
          var width = this.width;
          var height = this.height;
          var halfWidth = width * 0.5;
          var halfHeight = height * 0.5;
          var zoom = this.zoom;
          var matrix = this.matrix;
          var originX = width * this.originX;
          var originY = height * this.originY;
          var follow = this._follow;
          var deadzone = this.deadzone;
          var sx = this.scrollX;
          var sy = this.scrollY;
          if (deadzone) {
            CenterOn(deadzone, this.midPoint.x, this.midPoint.y);
          }
          var emitFollowEvent = false;
          if (this.roundPixels) {
            originX = Math.floor(originX);
            originY = Math.floor(originY);
          }
          if (follow && !this.panEffect.isRunning) {
            var lerp = this.lerp;
            var fx = follow.x - this.followOffset.x;
            var fy = follow.y - this.followOffset.y;
            if (this.roundPixels) {
              fx = Math.floor(fx);
              fy = Math.floor(fy);
            }
            if (deadzone) {
              if (fx < deadzone.x) {
                sx = Linear(sx, sx - (deadzone.x - fx), lerp.x);
              } else if (fx > deadzone.right) {
                sx = Linear(sx, sx + (fx - deadzone.right), lerp.x);
              }
              if (fy < deadzone.y) {
                sy = Linear(sy, sy - (deadzone.y - fy), lerp.y);
              } else if (fy > deadzone.bottom) {
                sy = Linear(sy, sy + (fy - deadzone.bottom), lerp.y);
              }
            } else {
              sx = Linear(sx, fx - originX, lerp.x);
              sy = Linear(sy, fy - originY, lerp.y);
            }
            emitFollowEvent = true;
          }
          if (this.useBounds) {
            sx = this.clampX(sx);
            sy = this.clampY(sy);
          }
          if (this.roundPixels) {
            sx = Math.floor(sx);
            sy = Math.floor(sy);
          }
          this.scrollX = sx;
          this.scrollY = sy;
          var midX = sx + halfWidth;
          var midY = sy + halfHeight;
          this.midPoint.set(midX, midY);
          var displayWidth = width / zoom;
          var displayHeight = height / zoom;
          var vwx = midX - displayWidth / 2;
          var vwy = midY - displayHeight / 2;
          if (this.roundPixels) {
            vwx = Math.floor(vwx);
            vwy = Math.floor(vwy);
          }
          this.worldView.setTo(vwx, vwy, displayWidth, displayHeight);
          matrix.applyITRS(Math.floor(this.x + originX), Math.floor(this.y + originY), this.rotation, zoom, zoom);
          matrix.translate(-originX, -originY);
          this.shakeEffect.preRender();
          if (emitFollowEvent) {
            this.emit(Events.FOLLOW_UPDATE, this, follow);
          }
        },
        setLerp: function(x, y) {
          if (x === void 0) {
            x = 1;
          }
          if (y === void 0) {
            y = x;
          }
          this.lerp.set(x, y);
          return this;
        },
        setFollowOffset: function(x, y) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          this.followOffset.set(x, y);
          return this;
        },
        startFollow: function(target, roundPixels, lerpX, lerpY, offsetX, offsetY) {
          if (roundPixels === void 0) {
            roundPixels = false;
          }
          if (lerpX === void 0) {
            lerpX = 1;
          }
          if (lerpY === void 0) {
            lerpY = lerpX;
          }
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = offsetX;
          }
          this._follow = target;
          this.roundPixels = roundPixels;
          lerpX = Clamp(lerpX, 0, 1);
          lerpY = Clamp(lerpY, 0, 1);
          this.lerp.set(lerpX, lerpY);
          this.followOffset.set(offsetX, offsetY);
          var originX = this.width / 2;
          var originY = this.height / 2;
          var fx = target.x - offsetX;
          var fy = target.y - offsetY;
          this.midPoint.set(fx, fy);
          this.scrollX = fx - originX;
          this.scrollY = fy - originY;
          if (this.useBounds) {
            this.scrollX = this.clampX(this.scrollX);
            this.scrollY = this.clampY(this.scrollY);
          }
          return this;
        },
        stopFollow: function() {
          this._follow = null;
          return this;
        },
        resetFX: function() {
          this.rotateToEffect.reset();
          this.panEffect.reset();
          this.shakeEffect.reset();
          this.flashEffect.reset();
          this.fadeEffect.reset();
          return this;
        },
        update: function(time, delta) {
          if (this.visible) {
            this.rotateToEffect.update(time, delta);
            this.panEffect.update(time, delta);
            this.zoomEffect.update(time, delta);
            this.shakeEffect.update(time, delta);
            this.flashEffect.update(time, delta);
            this.fadeEffect.update(time, delta);
          }
        },
        destroy: function() {
          this.resetFX();
          BaseCamera.prototype.destroy.call(this);
          this._follow = null;
          this.deadzone = null;
        }
      });
      module.exports = Camera;
    }
  });

  // ../../node_modules/phaser/src/scale/events/ENTER_FULLSCREEN_EVENT.js
  var require_ENTER_FULLSCREEN_EVENT = __commonJS({
    "../../node_modules/phaser/src/scale/events/ENTER_FULLSCREEN_EVENT.js": function(exports, module) {
      module.exports = "enterfullscreen";
    }
  });

  // ../../node_modules/phaser/src/scale/events/FULLSCREEN_FAILED_EVENT.js
  var require_FULLSCREEN_FAILED_EVENT = __commonJS({
    "../../node_modules/phaser/src/scale/events/FULLSCREEN_FAILED_EVENT.js": function(exports, module) {
      module.exports = "fullscreenfailed";
    }
  });

  // ../../node_modules/phaser/src/scale/events/FULLSCREEN_UNSUPPORTED_EVENT.js
  var require_FULLSCREEN_UNSUPPORTED_EVENT = __commonJS({
    "../../node_modules/phaser/src/scale/events/FULLSCREEN_UNSUPPORTED_EVENT.js": function(exports, module) {
      module.exports = "fullscreenunsupported";
    }
  });

  // ../../node_modules/phaser/src/scale/events/LEAVE_FULLSCREEN_EVENT.js
  var require_LEAVE_FULLSCREEN_EVENT = __commonJS({
    "../../node_modules/phaser/src/scale/events/LEAVE_FULLSCREEN_EVENT.js": function(exports, module) {
      module.exports = "leavefullscreen";
    }
  });

  // ../../node_modules/phaser/src/scale/events/ORIENTATION_CHANGE_EVENT.js
  var require_ORIENTATION_CHANGE_EVENT = __commonJS({
    "../../node_modules/phaser/src/scale/events/ORIENTATION_CHANGE_EVENT.js": function(exports, module) {
      module.exports = "orientationchange";
    }
  });

  // ../../node_modules/phaser/src/scale/events/RESIZE_EVENT.js
  var require_RESIZE_EVENT = __commonJS({
    "../../node_modules/phaser/src/scale/events/RESIZE_EVENT.js": function(exports, module) {
      module.exports = "resize";
    }
  });

  // ../../node_modules/phaser/src/scale/events/index.js
  var require_events7 = __commonJS({
    "../../node_modules/phaser/src/scale/events/index.js": function(exports, module) {
      module.exports = {
        ENTER_FULLSCREEN: require_ENTER_FULLSCREEN_EVENT(),
        FULLSCREEN_FAILED: require_FULLSCREEN_FAILED_EVENT(),
        FULLSCREEN_UNSUPPORTED: require_FULLSCREEN_UNSUPPORTED_EVENT(),
        LEAVE_FULLSCREEN: require_LEAVE_FULLSCREEN_EVENT(),
        ORIENTATION_CHANGE: require_ORIENTATION_CHANGE_EVENT(),
        RESIZE: require_RESIZE_EVENT()
      };
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/CameraManager.js
  var require_CameraManager = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/CameraManager.js": function(exports, module) {
      var Camera = require_Camera();
      var Class = require_Class();
      var GetFastValue = require_GetFastValue();
      var PluginCache = require_PluginCache();
      var RectangleContains = require_Contains2();
      var ScaleEvents = require_events7();
      var SceneEvents = require_events();
      var CameraManager = new Class({
        initialize: function CameraManager2(scene) {
          this.scene = scene;
          this.systems = scene.sys;
          this.roundPixels = scene.sys.game.config.roundPixels;
          this.cameras = [];
          this.main;
          this.default;
          scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
          scene.sys.events.on(SceneEvents.START, this.start, this);
        },
        boot: function() {
          var sys = this.systems;
          if (sys.settings.cameras) {
            this.fromJSON(sys.settings.cameras);
          } else {
            this.add();
          }
          this.main = this.cameras[0];
          this.default = new Camera(0, 0, sys.scale.width, sys.scale.height).setScene(this.scene);
          sys.game.scale.on(ScaleEvents.RESIZE, this.onResize, this);
          this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
        },
        start: function() {
          if (!this.main) {
            var sys = this.systems;
            if (sys.settings.cameras) {
              this.fromJSON(sys.settings.cameras);
            } else {
              this.add();
            }
            this.main = this.cameras[0];
          }
          var eventEmitter = this.systems.events;
          eventEmitter.on(SceneEvents.UPDATE, this.update, this);
          eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        add: function(x, y, width, height, makeMain, name) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (width === void 0) {
            width = this.scene.sys.scale.width;
          }
          if (height === void 0) {
            height = this.scene.sys.scale.height;
          }
          if (makeMain === void 0) {
            makeMain = false;
          }
          if (name === void 0) {
            name = "";
          }
          var camera = new Camera(x, y, width, height);
          camera.setName(name);
          camera.setScene(this.scene);
          camera.setRoundPixels(this.roundPixels);
          camera.id = this.getNextID();
          this.cameras.push(camera);
          if (makeMain) {
            this.main = camera;
          }
          return camera;
        },
        addExisting: function(camera, makeMain) {
          if (makeMain === void 0) {
            makeMain = false;
          }
          var index = this.cameras.indexOf(camera);
          if (index === -1) {
            camera.id = this.getNextID();
            camera.setRoundPixels(this.roundPixels);
            this.cameras.push(camera);
            if (makeMain) {
              this.main = camera;
            }
            return camera;
          }
          return null;
        },
        getNextID: function() {
          var cameras = this.cameras;
          var testID = 1;
          for (var t = 0; t < 32; t++) {
            var found = false;
            for (var i = 0; i < cameras.length; i++) {
              var camera = cameras[i];
              if (camera && camera.id === testID) {
                found = true;
                continue;
              }
            }
            if (found) {
              testID = testID << 1;
            } else {
              return testID;
            }
          }
          return 0;
        },
        getTotal: function(isVisible) {
          if (isVisible === void 0) {
            isVisible = false;
          }
          var total = 0;
          var cameras = this.cameras;
          for (var i = 0; i < cameras.length; i++) {
            var camera = cameras[i];
            if (!isVisible || isVisible && camera.visible) {
              total++;
            }
          }
          return total;
        },
        fromJSON: function(config) {
          if (!Array.isArray(config)) {
            config = [config];
          }
          var gameWidth = this.scene.sys.scale.width;
          var gameHeight = this.scene.sys.scale.height;
          for (var i = 0; i < config.length; i++) {
            var cameraConfig = config[i];
            var x = GetFastValue(cameraConfig, "x", 0);
            var y = GetFastValue(cameraConfig, "y", 0);
            var width = GetFastValue(cameraConfig, "width", gameWidth);
            var height = GetFastValue(cameraConfig, "height", gameHeight);
            var camera = this.add(x, y, width, height);
            camera.name = GetFastValue(cameraConfig, "name", "");
            camera.zoom = GetFastValue(cameraConfig, "zoom", 1);
            camera.rotation = GetFastValue(cameraConfig, "rotation", 0);
            camera.scrollX = GetFastValue(cameraConfig, "scrollX", 0);
            camera.scrollY = GetFastValue(cameraConfig, "scrollY", 0);
            camera.roundPixels = GetFastValue(cameraConfig, "roundPixels", false);
            camera.visible = GetFastValue(cameraConfig, "visible", true);
            var backgroundColor = GetFastValue(cameraConfig, "backgroundColor", false);
            if (backgroundColor) {
              camera.setBackgroundColor(backgroundColor);
            }
            var boundsConfig = GetFastValue(cameraConfig, "bounds", null);
            if (boundsConfig) {
              var bx = GetFastValue(boundsConfig, "x", 0);
              var by = GetFastValue(boundsConfig, "y", 0);
              var bwidth = GetFastValue(boundsConfig, "width", gameWidth);
              var bheight = GetFastValue(boundsConfig, "height", gameHeight);
              camera.setBounds(bx, by, bwidth, bheight);
            }
          }
          return this;
        },
        getCamera: function(name) {
          var cameras = this.cameras;
          for (var i = 0; i < cameras.length; i++) {
            if (cameras[i].name === name) {
              return cameras[i];
            }
          }
          return null;
        },
        getCamerasBelowPointer: function(pointer) {
          var cameras = this.cameras;
          var x = pointer.x;
          var y = pointer.y;
          var output = [];
          for (var i = 0; i < cameras.length; i++) {
            var camera = cameras[i];
            if (camera.visible && camera.inputEnabled && RectangleContains(camera, x, y)) {
              output.unshift(camera);
            }
          }
          return output;
        },
        remove: function(camera, runDestroy) {
          if (runDestroy === void 0) {
            runDestroy = true;
          }
          if (!Array.isArray(camera)) {
            camera = [camera];
          }
          var total = 0;
          var cameras = this.cameras;
          for (var i = 0; i < camera.length; i++) {
            var index = cameras.indexOf(camera[i]);
            if (index !== -1) {
              if (runDestroy) {
                cameras[index].destroy();
              } else {
                cameras[index].renderList = [];
              }
              cameras.splice(index, 1);
              total++;
            }
          }
          if (!this.main && cameras[0]) {
            this.main = cameras[0];
          }
          return total;
        },
        render: function(renderer, displayList) {
          var scene = this.scene;
          var cameras = this.cameras;
          for (var i = 0; i < cameras.length; i++) {
            var camera = cameras[i];
            if (camera.visible && camera.alpha > 0) {
              camera.preRender();
              var visibleChildren = this.getVisibleChildren(displayList.getChildren(), camera);
              renderer.render(scene, visibleChildren, camera);
            }
          }
        },
        getVisibleChildren: function(children, camera) {
          return children.filter(function(child) {
            return child.willRender(camera);
          });
        },
        resetAll: function() {
          for (var i = 0; i < this.cameras.length; i++) {
            this.cameras[i].destroy();
          }
          this.cameras = [];
          this.main = this.add();
          return this.main;
        },
        update: function(time, delta) {
          for (var i = 0; i < this.cameras.length; i++) {
            this.cameras[i].update(time, delta);
          }
        },
        onResize: function(gameSize, baseSize, displaySize, previousWidth, previousHeight) {
          for (var i = 0; i < this.cameras.length; i++) {
            var cam = this.cameras[i];
            if (cam._x === 0 && cam._y === 0 && cam._width === previousWidth && cam._height === previousHeight) {
              cam.setSize(baseSize.width, baseSize.height);
            }
          }
        },
        resize: function(width, height) {
          for (var i = 0; i < this.cameras.length; i++) {
            this.cameras[i].setSize(width, height);
          }
        },
        shutdown: function() {
          this.main = void 0;
          for (var i = 0; i < this.cameras.length; i++) {
            this.cameras[i].destroy();
          }
          this.cameras = [];
          var eventEmitter = this.systems.events;
          eventEmitter.off(SceneEvents.UPDATE, this.update, this);
          eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        destroy: function() {
          this.shutdown();
          this.default.destroy();
          this.systems.events.off(SceneEvents.START, this.start, this);
          this.systems.events.off(SceneEvents.DESTROY, this.destroy, this);
          this.systems.game.scale.off(ScaleEvents.RESIZE, this.onResize, this);
          this.scene = null;
          this.systems = null;
        }
      });
      PluginCache.register("CameraManager", CameraManager, "cameras");
      module.exports = CameraManager;
    }
  });

  // ../../node_modules/phaser/src/cameras/2d/index.js
  var require_d = __commonJS({
    "../../node_modules/phaser/src/cameras/2d/index.js": function(exports, module) {
      module.exports = {
        Camera: require_Camera(),
        BaseCamera: require_BaseCamera(),
        CameraManager: require_CameraManager(),
        Effects: require_effects(),
        Events: require_events6()
      };
    }
  });

  // ../../node_modules/phaser/src/cameras/index.js
  var require_cameras = __commonJS({
    "../../node_modules/phaser/src/cameras/index.js": function(exports, module) {
      module.exports = {
        Controls: require_controls(),
        Scene2D: require_d()
      };
    }
  });

  // ../../node_modules/phaser/src/plugins/DefaultPlugins.js
  var require_DefaultPlugins = __commonJS({
    "../../node_modules/phaser/src/plugins/DefaultPlugins.js": function(exports, module) {
      var DefaultPlugins = {
        Global: [
          "game",
          "anims",
          "cache",
          "plugins",
          "registry",
          "scale",
          "sound",
          "textures",
          "renderer"
        ],
        CoreScene: [
          "EventEmitter",
          "CameraManager",
          "GameObjectCreator",
          "GameObjectFactory",
          "ScenePlugin",
          "DisplayList",
          "UpdateList"
        ],
        DefaultScene: [
          "Clock",
          "DataManagerPlugin",
          "InputPlugin",
          "Loader",
          "TweenManager",
          "LightsPlugin"
        ]
      };
      if (false) {
        DefaultPlugins.DefaultScene.push("CameraManager3D");
      }
      if (false) {
        DefaultPlugins.Global.push("facebook");
      }
      module.exports = DefaultPlugins;
    }
  });

  // ../../node_modules/phaser/src/device/OS.js
  var require_OS = __commonJS({
    "../../node_modules/phaser/src/device/OS.js": function(exports, module) {
      var OS = {
        android: false,
        chromeOS: false,
        cordova: false,
        crosswalk: false,
        desktop: false,
        ejecta: false,
        electron: false,
        iOS: false,
        iOSVersion: 0,
        iPad: false,
        iPhone: false,
        kindle: false,
        linux: false,
        macOS: false,
        node: false,
        nodeWebkit: false,
        pixelRatio: 1,
        webApp: false,
        windows: false,
        windowsPhone: false
      };
      function init() {
        if (typeof importScripts === "function") {
          return OS;
        }
        var ua = navigator.userAgent;
        if (/Windows/.test(ua)) {
          OS.windows = true;
        } else if (/Mac OS/.test(ua) && !/like Mac OS/.test(ua)) {
          if (navigator.maxTouchPoints && navigator.maxTouchPoints > 2) {
            OS.iOS = true;
            OS.iPad = true;
            navigator.appVersion.match(/Version\/(\d+)/);
            OS.iOSVersion = parseInt(RegExp.$1, 10);
          } else {
            OS.macOS = true;
          }
        } else if (/Android/.test(ua)) {
          OS.android = true;
        } else if (/Linux/.test(ua)) {
          OS.linux = true;
        } else if (/iP[ao]d|iPhone/i.test(ua)) {
          OS.iOS = true;
          navigator.appVersion.match(/OS (\d+)/);
          OS.iOSVersion = parseInt(RegExp.$1, 10);
          OS.iPhone = ua.toLowerCase().indexOf("iphone") !== -1;
          OS.iPad = ua.toLowerCase().indexOf("ipad") !== -1;
        } else if (/Kindle/.test(ua) || /\bKF[A-Z][A-Z]+/.test(ua) || /Silk.*Mobile Safari/.test(ua)) {
          OS.kindle = true;
        } else if (/CrOS/.test(ua)) {
          OS.chromeOS = true;
        }
        if (/Windows Phone/i.test(ua) || /IEMobile/i.test(ua)) {
          OS.android = false;
          OS.iOS = false;
          OS.macOS = false;
          OS.windows = true;
          OS.windowsPhone = true;
        }
        var silk = /Silk/.test(ua);
        if (OS.windows || OS.macOS || OS.linux && !silk || OS.chromeOS) {
          OS.desktop = true;
        }
        if (OS.windowsPhone || /Windows NT/i.test(ua) && /Touch/i.test(ua)) {
          OS.desktop = false;
        }
        if (navigator.standalone) {
          OS.webApp = true;
        }
        if (typeof importScripts !== "function") {
          if (window.cordova !== void 0) {
            OS.cordova = true;
          }
          if (window.ejecta !== void 0) {
            OS.ejecta = true;
          }
        }
        if (typeof process !== "undefined" && process.versions && process.versions.node) {
          OS.node = true;
        }
        if (OS.node && typeof process.versions === "object") {
          OS.nodeWebkit = !!process.versions["node-webkit"];
          OS.electron = !!process.versions.electron;
        }
        if (/Crosswalk/.test(ua)) {
          OS.crosswalk = true;
        }
        OS.pixelRatio = window["devicePixelRatio"] || 1;
        return OS;
      }
      module.exports = init();
    }
  });

  // ../../node_modules/phaser/src/device/Browser.js
  var require_Browser = __commonJS({
    "../../node_modules/phaser/src/device/Browser.js": function(exports, module) {
      var OS = require_OS();
      var Browser = {
        chrome: false,
        chromeVersion: 0,
        edge: false,
        firefox: false,
        firefoxVersion: 0,
        ie: false,
        ieVersion: 0,
        mobileSafari: false,
        opera: false,
        safari: false,
        safariVersion: 0,
        silk: false,
        trident: false,
        tridentVersion: 0,
        es2019: false
      };
      function init() {
        var ua = navigator.userAgent;
        if (/Edg\/\d+/.test(ua)) {
          Browser.edge = true;
          Browser.es2019 = true;
        } else if (/OPR/.test(ua)) {
          Browser.opera = true;
          Browser.es2019 = true;
        } else if (/Chrome\/(\d+)/.test(ua) && !OS.windowsPhone) {
          Browser.chrome = true;
          Browser.chromeVersion = parseInt(RegExp.$1, 10);
          Browser.es2019 = Browser.chromeVersion > 69;
        } else if (/Firefox\D+(\d+)/.test(ua)) {
          Browser.firefox = true;
          Browser.firefoxVersion = parseInt(RegExp.$1, 10);
          Browser.es2019 = Browser.firefoxVersion > 10;
        } else if (/AppleWebKit/.test(ua) && OS.iOS) {
          Browser.mobileSafari = true;
        } else if (/MSIE (\d+\.\d+);/.test(ua)) {
          Browser.ie = true;
          Browser.ieVersion = parseInt(RegExp.$1, 10);
        } else if (/Version\/(\d+\.\d+) Safari/.test(ua) && !OS.windowsPhone) {
          Browser.safari = true;
          Browser.safariVersion = parseInt(RegExp.$1, 10);
          Browser.es2019 = Browser.safariVersion > 10;
        } else if (/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(ua)) {
          Browser.ie = true;
          Browser.trident = true;
          Browser.tridentVersion = parseInt(RegExp.$1, 10);
          Browser.ieVersion = parseInt(RegExp.$3, 10);
        }
        if (/Silk/.test(ua)) {
          Browser.silk = true;
        }
        return Browser;
      }
      module.exports = init();
    }
  });

  // ../../node_modules/phaser/src/display/canvas/Smoothing.js
  var require_Smoothing = __commonJS({
    "../../node_modules/phaser/src/display/canvas/Smoothing.js": function(exports, module) {
      var prefix = "";
      var Smoothing = function() {
        var getPrefix = function(context) {
          var vendors = ["i", "webkitI", "msI", "mozI", "oI"];
          for (var i = 0; i < vendors.length; i++) {
            var s = vendors[i] + "mageSmoothingEnabled";
            if (s in context) {
              return s;
            }
          }
          return null;
        };
        var enable = function(context) {
          if (prefix === "") {
            prefix = getPrefix(context);
          }
          if (prefix) {
            context[prefix] = true;
          }
          return context;
        };
        var disable = function(context) {
          if (prefix === "") {
            prefix = getPrefix(context);
          }
          if (prefix) {
            context[prefix] = false;
          }
          return context;
        };
        var isEnabled = function(context) {
          return prefix !== null ? context[prefix] : null;
        };
        return {
          disable: disable,
          enable: enable,
          getPrefix: getPrefix,
          isEnabled: isEnabled
        };
      };
      module.exports = Smoothing();
    }
  });

  // ../../node_modules/phaser/src/display/canvas/CanvasPool.js
  var require_CanvasPool = __commonJS({
    "../../node_modules/phaser/src/display/canvas/CanvasPool.js": function(exports, module) {
      var CONST = require_const();
      var Smoothing = require_Smoothing();
      var pool = [];
      var _disableContextSmoothing = false;
      var CanvasPool = function() {
        var create = function(parent, width, height, canvasType, selfParent) {
          if (width === void 0) {
            width = 1;
          }
          if (height === void 0) {
            height = 1;
          }
          if (canvasType === void 0) {
            canvasType = CONST.CANVAS;
          }
          if (selfParent === void 0) {
            selfParent = false;
          }
          var canvas;
          var container = first(canvasType);
          if (container === null) {
            container = {
              parent: parent,
              canvas: document.createElement("canvas"),
              type: canvasType
            };
            if (canvasType === CONST.CANVAS) {
              pool.push(container);
            }
            canvas = container.canvas;
          } else {
            container.parent = parent;
            canvas = container.canvas;
          }
          if (selfParent) {
            container.parent = canvas;
          }
          canvas.width = width;
          canvas.height = height;
          if (_disableContextSmoothing && canvasType === CONST.CANVAS) {
            Smoothing.disable(canvas.getContext("2d"));
          }
          return canvas;
        };
        var create2D = function(parent, width, height) {
          return create(parent, width, height, CONST.CANVAS);
        };
        var createWebGL = function(parent, width, height) {
          return create(parent, width, height, CONST.WEBGL);
        };
        var first = function(canvasType) {
          if (canvasType === void 0) {
            canvasType = CONST.CANVAS;
          }
          if (canvasType === CONST.WEBGL) {
            return null;
          }
          for (var i = 0; i < pool.length; i++) {
            var container = pool[i];
            if (!container.parent && container.type === canvasType) {
              return container;
            }
          }
          return null;
        };
        var remove = function(parent) {
          var isCanvas = parent instanceof HTMLCanvasElement;
          pool.forEach(function(container) {
            if (isCanvas && container.canvas === parent || !isCanvas && container.parent === parent) {
              container.parent = null;
              container.canvas.width = 1;
              container.canvas.height = 1;
            }
          });
        };
        var total = function() {
          var c = 0;
          pool.forEach(function(container) {
            if (container.parent) {
              c++;
            }
          });
          return c;
        };
        var free = function() {
          return pool.length - total();
        };
        var disableSmoothing = function() {
          _disableContextSmoothing = true;
        };
        var enableSmoothing = function() {
          _disableContextSmoothing = false;
        };
        return {
          create2D: create2D,
          create: create,
          createWebGL: createWebGL,
          disableSmoothing: disableSmoothing,
          enableSmoothing: enableSmoothing,
          first: first,
          free: free,
          pool: pool,
          remove: remove,
          total: total
        };
      };
      module.exports = CanvasPool();
    }
  });

  // ../../node_modules/phaser/src/device/Features.js
  var require_Features = __commonJS({
    "../../node_modules/phaser/src/device/Features.js": function(exports, module) {
      var OS = require_OS();
      var Browser = require_Browser();
      var CanvasPool = require_CanvasPool();
      var Features = {
        canvas: false,
        canvasBitBltShift: null,
        file: false,
        fileSystem: false,
        getUserMedia: true,
        littleEndian: false,
        localStorage: false,
        pointerLock: false,
        stableSort: false,
        support32bit: false,
        vibration: false,
        webGL: false,
        worker: false
      };
      function checkIsLittleEndian() {
        var a = new ArrayBuffer(4);
        var b = new Uint8Array(a);
        var c = new Uint32Array(a);
        b[0] = 161;
        b[1] = 178;
        b[2] = 195;
        b[3] = 212;
        if (c[0] === 3569595041) {
          return true;
        }
        if (c[0] === 2712847316) {
          return false;
        } else {
          return null;
        }
      }
      function init() {
        if (typeof importScripts === "function") {
          return Features;
        }
        Features.canvas = !!window["CanvasRenderingContext2D"];
        try {
          Features.localStorage = !!localStorage.getItem;
        } catch (error) {
          Features.localStorage = false;
        }
        Features.file = !!window["File"] && !!window["FileReader"] && !!window["FileList"] && !!window["Blob"];
        Features.fileSystem = !!window["requestFileSystem"];
        var isUint8 = false;
        var testWebGL = function() {
          if (window["WebGLRenderingContext"]) {
            try {
              var canvas = CanvasPool.createWebGL(this);
              var ctx = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
              var canvas2D = CanvasPool.create2D(this);
              var ctx2D = canvas2D.getContext("2d", { willReadFrequently: true });
              var image = ctx2D.createImageData(1, 1);
              isUint8 = image.data instanceof Uint8ClampedArray;
              CanvasPool.remove(canvas);
              CanvasPool.remove(canvas2D);
              return !!ctx;
            } catch (e) {
              return false;
            }
          }
          return false;
        };
        Features.webGL = testWebGL();
        Features.worker = !!window["Worker"];
        Features.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;
        window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
        Features.getUserMedia = Features.getUserMedia && !!navigator.getUserMedia && !!window.URL;
        if (Browser.firefox && Browser.firefoxVersion < 21) {
          Features.getUserMedia = false;
        }
        if (!OS.iOS && (Browser.ie || Browser.firefox || Browser.chrome)) {
          Features.canvasBitBltShift = true;
        }
        if (Browser.safari || Browser.mobileSafari) {
          Features.canvasBitBltShift = false;
        }
        navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;
        if (navigator.vibrate) {
          Features.vibration = true;
        }
        if (typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint32Array !== "undefined") {
          Features.littleEndian = checkIsLittleEndian();
        }
        Features.support32bit = typeof ArrayBuffer !== "undefined" && typeof Uint8ClampedArray !== "undefined" && typeof Int32Array !== "undefined" && Features.littleEndian !== null && isUint8;
        return Features;
      }
      module.exports = init();
    }
  });

  // ../../node_modules/phaser/src/device/Input.js
  var require_Input = __commonJS({
    "../../node_modules/phaser/src/device/Input.js": function(exports, module) {
      var Browser = require_Browser();
      var Input = {
        gamepads: false,
        mspointer: false,
        touch: false,
        wheelEvent: null
      };
      function init() {
        if (typeof importScripts === "function") {
          return Input;
        }
        if ("ontouchstart" in document.documentElement || navigator.maxTouchPoints && navigator.maxTouchPoints >= 1) {
          Input.touch = true;
        }
        if (navigator.msPointerEnabled || navigator.pointerEnabled) {
          Input.mspointer = true;
        }
        if (navigator.getGamepads) {
          Input.gamepads = true;
        }
        if ("onwheel" in window || Browser.ie && "WheelEvent" in window) {
          Input.wheelEvent = "wheel";
        } else if ("onmousewheel" in window) {
          Input.wheelEvent = "mousewheel";
        } else if (Browser.firefox && "MouseScrollEvent" in window) {
          Input.wheelEvent = "DOMMouseScroll";
        }
        return Input;
      }
      module.exports = init();
    }
  });

  // ../../node_modules/phaser/src/device/Audio.js
  var require_Audio = __commonJS({
    "../../node_modules/phaser/src/device/Audio.js": function(exports, module) {
      var Browser = require_Browser();
      var Audio = {
        flac: false,
        aac: false,
        audioData: false,
        dolby: false,
        m4a: false,
        mp3: false,
        ogg: false,
        opus: false,
        wav: false,
        webAudio: false,
        webm: false
      };
      function init() {
        if (typeof importScripts === "function") {
          return Audio;
        }
        Audio.audioData = !!window["Audio"];
        Audio.webAudio = !!(window["AudioContext"] || window["webkitAudioContext"]);
        var audioElement = document.createElement("audio");
        var result = !!audioElement.canPlayType;
        try {
          if (result) {
            var CanPlay = function(type1, type2) {
              var canPlayType1 = audioElement.canPlayType("audio/" + type1).replace(/^no$/, "");
              if (type2) {
                return Boolean(canPlayType1 || audioElement.canPlayType("audio/" + type2).replace(/^no$/, ""));
              } else {
                return Boolean(canPlayType1);
              }
            };
            Audio.ogg = CanPlay('ogg; codecs="vorbis"');
            Audio.opus = CanPlay('ogg; codecs="opus"', "opus");
            Audio.mp3 = CanPlay("mpeg");
            Audio.wav = CanPlay("wav");
            Audio.m4a = CanPlay("x-m4a");
            Audio.aac = CanPlay("aac");
            Audio.flac = CanPlay("flac", "x-flac");
            Audio.webm = CanPlay('webm; codecs="vorbis"');
            if (audioElement.canPlayType('audio/mp4; codecs="ec-3"') !== "") {
              if (Browser.edge) {
                Audio.dolby = true;
              } else if (Browser.safari && Browser.safariVersion >= 9) {
                if (/Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                  var major = parseInt(RegExp.$1, 10);
                  var minor = parseInt(RegExp.$2, 10);
                  if (major === 10 && minor >= 11 || major > 10) {
                    Audio.dolby = true;
                  }
                }
              }
            }
          }
        } catch (e) {
        }
        return Audio;
      }
      module.exports = init();
    }
  });

  // ../../node_modules/phaser/src/device/Video.js
  var require_Video = __commonJS({
    "../../node_modules/phaser/src/device/Video.js": function(exports, module) {
      var Video = {
        h264: false,
        hls: false,
        mp4: false,
        m4v: false,
        ogg: false,
        vp9: false,
        webm: false
      };
      function init() {
        if (typeof importScripts === "function") {
          return Video;
        }
        var videoElement = document.createElement("video");
        var result = !!videoElement.canPlayType;
        var no = /^no$/;
        try {
          if (result) {
            if (videoElement.canPlayType('video/ogg; codecs="theora"').replace(no, "")) {
              Video.ogg = true;
            }
            if (videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(no, "")) {
              Video.h264 = true;
              Video.mp4 = true;
            }
            if (videoElement.canPlayType("video/x-m4v").replace(no, "")) {
              Video.m4v = true;
            }
            if (videoElement.canPlayType('video/webm; codecs="vp8, vorbis"').replace(no, "")) {
              Video.webm = true;
            }
            if (videoElement.canPlayType('video/webm; codecs="vp9"').replace(no, "")) {
              Video.vp9 = true;
            }
            if (videoElement.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(no, "")) {
              Video.hls = true;
            }
          }
        } catch (e) {
        }
        return Video;
      }
      module.exports = init();
    }
  });

  // ../../node_modules/phaser/src/device/Fullscreen.js
  var require_Fullscreen = __commonJS({
    "../../node_modules/phaser/src/device/Fullscreen.js": function(exports, module) {
      var Fullscreen = {
        available: false,
        cancel: "",
        keyboard: false,
        request: ""
      };
      function init() {
        if (typeof importScripts === "function") {
          return Fullscreen;
        }
        var i;
        var suffix1 = "Fullscreen";
        var suffix2 = "FullScreen";
        var fs = [
          "request" + suffix1,
          "request" + suffix2,
          "webkitRequest" + suffix1,
          "webkitRequest" + suffix2,
          "msRequest" + suffix1,
          "msRequest" + suffix2,
          "mozRequest" + suffix2,
          "mozRequest" + suffix1
        ];
        for (i = 0; i < fs.length; i++) {
          if (document.documentElement[fs[i]]) {
            Fullscreen.available = true;
            Fullscreen.request = fs[i];
            break;
          }
        }
        var cfs = [
          "cancel" + suffix2,
          "exit" + suffix1,
          "webkitCancel" + suffix2,
          "webkitExit" + suffix1,
          "msCancel" + suffix2,
          "msExit" + suffix1,
          "mozCancel" + suffix2,
          "mozExit" + suffix1
        ];
        if (Fullscreen.available) {
          for (i = 0; i < cfs.length; i++) {
            if (document[cfs[i]]) {
              Fullscreen.cancel = cfs[i];
              break;
            }
          }
        }
        if (window["Element"] && Element["ALLOW_KEYBOARD_INPUT"] && !/ Version\/5\.1(?:\.\d+)? Safari\//.test(navigator.userAgent)) {
          Fullscreen.keyboard = true;
        }
        Object.defineProperty(Fullscreen, "active", { get: function() {
          return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
        } });
        return Fullscreen;
      }
      module.exports = init();
    }
  });

  // ../../node_modules/phaser/src/device/CanvasFeatures.js
  var require_CanvasFeatures = __commonJS({
    "../../node_modules/phaser/src/device/CanvasFeatures.js": function(exports, module) {
      var CanvasPool = require_CanvasPool();
      var CanvasFeatures = {
        supportInverseAlpha: false,
        supportNewBlendModes: false
      };
      function checkBlendMode() {
        var pngHead = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/";
        var pngEnd = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==";
        var magenta = new Image();
        magenta.onload = function() {
          var yellow = new Image();
          yellow.onload = function() {
            var canvas = CanvasPool.create2D(yellow, 6);
            var context = canvas.getContext("2d", { willReadFrequently: true });
            context.globalCompositeOperation = "multiply";
            context.drawImage(magenta, 0, 0);
            context.drawImage(yellow, 2, 0);
            if (!context.getImageData(2, 0, 1, 1)) {
              return false;
            }
            var data = context.getImageData(2, 0, 1, 1).data;
            CanvasPool.remove(yellow);
            CanvasFeatures.supportNewBlendModes = data[0] === 255 && data[1] === 0 && data[2] === 0;
          };
          yellow.src = pngHead + "/wCKxvRF" + pngEnd;
        };
        magenta.src = pngHead + "AP804Oa6" + pngEnd;
        return false;
      }
      function checkInverseAlpha() {
        var canvas = CanvasPool.create2D(this, 2);
        var context = canvas.getContext("2d", { willReadFrequently: true });
        context.fillStyle = "rgba(10, 20, 30, 0.5)";
        context.fillRect(0, 0, 1, 1);
        var s1 = context.getImageData(0, 0, 1, 1);
        if (s1 === null) {
          return false;
        }
        context.putImageData(s1, 1, 0);
        var s2 = context.getImageData(1, 0, 1, 1);
        var result = s2.data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3];
        CanvasPool.remove(this);
        return result;
      }
      function init() {
        if (typeof importScripts !== "function" && document !== void 0) {
          CanvasFeatures.supportNewBlendModes = checkBlendMode();
          CanvasFeatures.supportInverseAlpha = checkInverseAlpha();
        }
        return CanvasFeatures;
      }
      module.exports = init();
    }
  });

  // ../../node_modules/phaser/src/device/index.js
  var require_device = __commonJS({
    "../../node_modules/phaser/src/device/index.js": function(exports, module) {
      module.exports = {
        os: require_OS(),
        browser: require_Browser(),
        features: require_Features(),
        input: require_Input(),
        audio: require_Audio(),
        video: require_Video(),
        fullscreen: require_Fullscreen(),
        canvasFeatures: require_CanvasFeatures()
      };
    }
  });

  // ../../node_modules/phaser/src/math/angle/Between.js
  var require_Between = __commonJS({
    "../../node_modules/phaser/src/math/angle/Between.js": function(exports, module) {
      var Between = function(x1, y1, x2, y2) {
        return Math.atan2(y2 - y1, x2 - x1);
      };
      module.exports = Between;
    }
  });

  // ../../node_modules/phaser/src/math/angle/BetweenPoints.js
  var require_BetweenPoints = __commonJS({
    "../../node_modules/phaser/src/math/angle/BetweenPoints.js": function(exports, module) {
      var BetweenPoints = function(point1, point2) {
        return Math.atan2(point2.y - point1.y, point2.x - point1.x);
      };
      module.exports = BetweenPoints;
    }
  });

  // ../../node_modules/phaser/src/math/angle/BetweenPointsY.js
  var require_BetweenPointsY = __commonJS({
    "../../node_modules/phaser/src/math/angle/BetweenPointsY.js": function(exports, module) {
      var BetweenPointsY = function(point1, point2) {
        return Math.atan2(point2.x - point1.x, point2.y - point1.y);
      };
      module.exports = BetweenPointsY;
    }
  });

  // ../../node_modules/phaser/src/math/angle/BetweenY.js
  var require_BetweenY = __commonJS({
    "../../node_modules/phaser/src/math/angle/BetweenY.js": function(exports, module) {
      var BetweenY = function(x1, y1, x2, y2) {
        return Math.atan2(x2 - x1, y2 - y1);
      };
      module.exports = BetweenY;
    }
  });

  // ../../node_modules/phaser/src/math/angle/CounterClockwise.js
  var require_CounterClockwise = __commonJS({
    "../../node_modules/phaser/src/math/angle/CounterClockwise.js": function(exports, module) {
      var CONST = require_const4();
      var CounterClockwise = function(angle) {
        if (angle > Math.PI) {
          angle -= CONST.PI2;
        }
        return Math.abs(((angle + CONST.TAU) % CONST.PI2 - CONST.PI2) % CONST.PI2);
      };
      module.exports = CounterClockwise;
    }
  });

  // ../../node_modules/phaser/src/math/angle/Normalize.js
  var require_Normalize = __commonJS({
    "../../node_modules/phaser/src/math/angle/Normalize.js": function(exports, module) {
      var Normalize = function(angle) {
        angle = angle % (2 * Math.PI);
        if (angle >= 0) {
          return angle;
        } else {
          return angle + 2 * Math.PI;
        }
      };
      module.exports = Normalize;
    }
  });

  // ../../node_modules/phaser/src/math/FloatBetween.js
  var require_FloatBetween = __commonJS({
    "../../node_modules/phaser/src/math/FloatBetween.js": function(exports, module) {
      var FloatBetween = function(min, max) {
        return Math.random() * (max - min) + min;
      };
      module.exports = FloatBetween;
    }
  });

  // ../../node_modules/phaser/src/math/angle/Random.js
  var require_Random4 = __commonJS({
    "../../node_modules/phaser/src/math/angle/Random.js": function(exports, module) {
      var FloatBetween = require_FloatBetween();
      var Random = function() {
        return FloatBetween(-Math.PI, Math.PI);
      };
      module.exports = Random;
    }
  });

  // ../../node_modules/phaser/src/math/angle/RandomDegrees.js
  var require_RandomDegrees = __commonJS({
    "../../node_modules/phaser/src/math/angle/RandomDegrees.js": function(exports, module) {
      var FloatBetween = require_FloatBetween();
      var RandomDegrees = function() {
        return FloatBetween(-180, 180);
      };
      module.exports = RandomDegrees;
    }
  });

  // ../../node_modules/phaser/src/math/angle/Reverse.js
  var require_Reverse = __commonJS({
    "../../node_modules/phaser/src/math/angle/Reverse.js": function(exports, module) {
      var Normalize = require_Normalize();
      var Reverse = function(angle) {
        return Normalize(angle + Math.PI);
      };
      module.exports = Reverse;
    }
  });

  // ../../node_modules/phaser/src/math/angle/RotateTo.js
  var require_RotateTo2 = __commonJS({
    "../../node_modules/phaser/src/math/angle/RotateTo.js": function(exports, module) {
      var MATH_CONST = require_const4();
      var RotateTo = function(currentAngle, targetAngle, lerp) {
        if (lerp === void 0) {
          lerp = 0.05;
        }
        if (currentAngle === targetAngle) {
          return currentAngle;
        }
        if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= MATH_CONST.PI2 - lerp) {
          currentAngle = targetAngle;
        } else {
          if (Math.abs(targetAngle - currentAngle) > Math.PI) {
            if (targetAngle < currentAngle) {
              targetAngle += MATH_CONST.PI2;
            } else {
              targetAngle -= MATH_CONST.PI2;
            }
          }
          if (targetAngle > currentAngle) {
            currentAngle += lerp;
          } else if (targetAngle < currentAngle) {
            currentAngle -= lerp;
          }
        }
        return currentAngle;
      };
      module.exports = RotateTo;
    }
  });

  // ../../node_modules/phaser/src/math/angle/ShortestBetween.js
  var require_ShortestBetween = __commonJS({
    "../../node_modules/phaser/src/math/angle/ShortestBetween.js": function(exports, module) {
      var ShortestBetween = function(angle1, angle2) {
        var difference = angle2 - angle1;
        if (difference === 0) {
          return 0;
        }
        var times = Math.floor((difference - -180) / 360);
        return difference - times * 360;
      };
      module.exports = ShortestBetween;
    }
  });

  // ../../node_modules/phaser/src/math/angle/index.js
  var require_angle = __commonJS({
    "../../node_modules/phaser/src/math/angle/index.js": function(exports, module) {
      module.exports = {
        Between: require_Between(),
        BetweenPoints: require_BetweenPoints(),
        BetweenPointsY: require_BetweenPointsY(),
        BetweenY: require_BetweenY(),
        CounterClockwise: require_CounterClockwise(),
        Normalize: require_Normalize(),
        Random: require_Random4(),
        RandomDegrees: require_RandomDegrees(),
        Reverse: require_Reverse(),
        RotateTo: require_RotateTo2(),
        ShortestBetween: require_ShortestBetween(),
        Wrap: require_Wrap2(),
        WrapDegrees: require_WrapDegrees()
      };
    }
  });

  // ../../node_modules/phaser/src/math/distance/DistanceBetween.js
  var require_DistanceBetween = __commonJS({
    "../../node_modules/phaser/src/math/distance/DistanceBetween.js": function(exports, module) {
      var DistanceBetween = function(x1, y1, x2, y2) {
        var dx = x1 - x2;
        var dy = y1 - y2;
        return Math.sqrt(dx * dx + dy * dy);
      };
      module.exports = DistanceBetween;
    }
  });

  // ../../node_modules/phaser/src/math/distance/DistanceBetweenPoints.js
  var require_DistanceBetweenPoints = __commonJS({
    "../../node_modules/phaser/src/math/distance/DistanceBetweenPoints.js": function(exports, module) {
      var DistanceBetweenPoints = function(a, b) {
        var dx = a.x - b.x;
        var dy = a.y - b.y;
        return Math.sqrt(dx * dx + dy * dy);
      };
      module.exports = DistanceBetweenPoints;
    }
  });

  // ../../node_modules/phaser/src/math/distance/DistanceBetweenPointsSquared.js
  var require_DistanceBetweenPointsSquared = __commonJS({
    "../../node_modules/phaser/src/math/distance/DistanceBetweenPointsSquared.js": function(exports, module) {
      var DistanceBetweenPointsSquared = function(a, b) {
        var dx = a.x - b.x;
        var dy = a.y - b.y;
        return dx * dx + dy * dy;
      };
      module.exports = DistanceBetweenPointsSquared;
    }
  });

  // ../../node_modules/phaser/src/math/distance/DistanceChebyshev.js
  var require_DistanceChebyshev = __commonJS({
    "../../node_modules/phaser/src/math/distance/DistanceChebyshev.js": function(exports, module) {
      var ChebyshevDistance = function(x1, y1, x2, y2) {
        return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));
      };
      module.exports = ChebyshevDistance;
    }
  });

  // ../../node_modules/phaser/src/math/distance/DistancePower.js
  var require_DistancePower = __commonJS({
    "../../node_modules/phaser/src/math/distance/DistancePower.js": function(exports, module) {
      var DistancePower = function(x1, y1, x2, y2, pow) {
        if (pow === void 0) {
          pow = 2;
        }
        return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
      };
      module.exports = DistancePower;
    }
  });

  // ../../node_modules/phaser/src/math/distance/DistanceSnake.js
  var require_DistanceSnake = __commonJS({
    "../../node_modules/phaser/src/math/distance/DistanceSnake.js": function(exports, module) {
      var SnakeDistance = function(x1, y1, x2, y2) {
        return Math.abs(x1 - x2) + Math.abs(y1 - y2);
      };
      module.exports = SnakeDistance;
    }
  });

  // ../../node_modules/phaser/src/math/distance/DistanceSquared.js
  var require_DistanceSquared = __commonJS({
    "../../node_modules/phaser/src/math/distance/DistanceSquared.js": function(exports, module) {
      var DistanceSquared = function(x1, y1, x2, y2) {
        var dx = x1 - x2;
        var dy = y1 - y2;
        return dx * dx + dy * dy;
      };
      module.exports = DistanceSquared;
    }
  });

  // ../../node_modules/phaser/src/math/distance/index.js
  var require_distance = __commonJS({
    "../../node_modules/phaser/src/math/distance/index.js": function(exports, module) {
      module.exports = {
        Between: require_DistanceBetween(),
        BetweenPoints: require_DistanceBetweenPoints(),
        BetweenPointsSquared: require_DistanceBetweenPointsSquared(),
        Chebyshev: require_DistanceChebyshev(),
        Power: require_DistancePower(),
        Snake: require_DistanceSnake(),
        Squared: require_DistanceSquared()
      };
    }
  });

  // ../../node_modules/phaser/src/math/easing/index.js
  var require_easing = __commonJS({
    "../../node_modules/phaser/src/math/easing/index.js": function(exports, module) {
      module.exports = {
        Back: require_back(),
        Bounce: require_bounce(),
        Circular: require_circular(),
        Cubic: require_cubic(),
        Elastic: require_elastic(),
        Expo: require_expo(),
        Linear: require_linear(),
        Quadratic: require_quadratic(),
        Quartic: require_quartic(),
        Quintic: require_quintic(),
        Sine: require_sine(),
        Stepped: require_stepped()
      };
    }
  });

  // ../../node_modules/phaser/src/math/fuzzy/Ceil.js
  var require_Ceil = __commonJS({
    "../../node_modules/phaser/src/math/fuzzy/Ceil.js": function(exports, module) {
      var Ceil = function(value, epsilon) {
        if (epsilon === void 0) {
          epsilon = 1e-4;
        }
        return Math.ceil(value - epsilon);
      };
      module.exports = Ceil;
    }
  });

  // ../../node_modules/phaser/src/math/fuzzy/Floor.js
  var require_Floor = __commonJS({
    "../../node_modules/phaser/src/math/fuzzy/Floor.js": function(exports, module) {
      var Floor = function(value, epsilon) {
        if (epsilon === void 0) {
          epsilon = 1e-4;
        }
        return Math.floor(value + epsilon);
      };
      module.exports = Floor;
    }
  });

  // ../../node_modules/phaser/src/math/fuzzy/GreaterThan.js
  var require_GreaterThan = __commonJS({
    "../../node_modules/phaser/src/math/fuzzy/GreaterThan.js": function(exports, module) {
      var GreaterThan = function(a, b, epsilon) {
        if (epsilon === void 0) {
          epsilon = 1e-4;
        }
        return a > b - epsilon;
      };
      module.exports = GreaterThan;
    }
  });

  // ../../node_modules/phaser/src/math/fuzzy/LessThan.js
  var require_LessThan = __commonJS({
    "../../node_modules/phaser/src/math/fuzzy/LessThan.js": function(exports, module) {
      var LessThan = function(a, b, epsilon) {
        if (epsilon === void 0) {
          epsilon = 1e-4;
        }
        return a < b + epsilon;
      };
      module.exports = LessThan;
    }
  });

  // ../../node_modules/phaser/src/math/fuzzy/index.js
  var require_fuzzy = __commonJS({
    "../../node_modules/phaser/src/math/fuzzy/index.js": function(exports, module) {
      module.exports = {
        Ceil: require_Ceil(),
        Equal: require_Equal(),
        Floor: require_Floor(),
        GreaterThan: require_GreaterThan(),
        LessThan: require_LessThan()
      };
    }
  });

  // ../../node_modules/phaser/src/math/Factorial.js
  var require_Factorial = __commonJS({
    "../../node_modules/phaser/src/math/Factorial.js": function(exports, module) {
      var Factorial = function(value) {
        if (value === 0) {
          return 1;
        }
        var res = value;
        while (--value) {
          res *= value;
        }
        return res;
      };
      module.exports = Factorial;
    }
  });

  // ../../node_modules/phaser/src/math/Bernstein.js
  var require_Bernstein = __commonJS({
    "../../node_modules/phaser/src/math/Bernstein.js": function(exports, module) {
      var Factorial = require_Factorial();
      var Bernstein = function(n, i) {
        return Factorial(n) / Factorial(i) / Factorial(n - i);
      };
      module.exports = Bernstein;
    }
  });

  // ../../node_modules/phaser/src/math/interpolation/BezierInterpolation.js
  var require_BezierInterpolation = __commonJS({
    "../../node_modules/phaser/src/math/interpolation/BezierInterpolation.js": function(exports, module) {
      var Bernstein = require_Bernstein();
      var BezierInterpolation = function(v, k) {
        var b = 0;
        var n = v.length - 1;
        for (var i = 0; i <= n; i++) {
          b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);
        }
        return b;
      };
      module.exports = BezierInterpolation;
    }
  });

  // ../../node_modules/phaser/src/math/CatmullRom.js
  var require_CatmullRom = __commonJS({
    "../../node_modules/phaser/src/math/CatmullRom.js": function(exports, module) {
      var CatmullRom = function(t, p0, p1, p2, p3) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
      };
      module.exports = CatmullRom;
    }
  });

  // ../../node_modules/phaser/src/math/interpolation/CatmullRomInterpolation.js
  var require_CatmullRomInterpolation = __commonJS({
    "../../node_modules/phaser/src/math/interpolation/CatmullRomInterpolation.js": function(exports, module) {
      var CatmullRom = require_CatmullRom();
      var CatmullRomInterpolation = function(v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        if (v[0] === v[m]) {
          if (k < 0) {
            i = Math.floor(f = m * (1 + k));
          }
          return CatmullRom(f - i, v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m]);
        } else {
          if (k < 0) {
            return v[0] - (CatmullRom(-f, v[0], v[0], v[1], v[1]) - v[0]);
          }
          if (k > 1) {
            return v[m] - (CatmullRom(f - m, v[m], v[m], v[m - 1], v[m - 1]) - v[m]);
          }
          return CatmullRom(f - i, v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2]);
        }
      };
      module.exports = CatmullRomInterpolation;
    }
  });

  // ../../node_modules/phaser/src/math/interpolation/CubicBezierInterpolation.js
  var require_CubicBezierInterpolation = __commonJS({
    "../../node_modules/phaser/src/math/interpolation/CubicBezierInterpolation.js": function(exports, module) {
      function P0(t, p) {
        var k = 1 - t;
        return k * k * k * p;
      }
      function P1(t, p) {
        var k = 1 - t;
        return 3 * k * k * t * p;
      }
      function P2(t, p) {
        return 3 * (1 - t) * t * t * p;
      }
      function P3(t, p) {
        return t * t * t * p;
      }
      var CubicBezierInterpolation = function(t, p0, p1, p2, p3) {
        return P0(t, p0) + P1(t, p1) + P2(t, p2) + P3(t, p3);
      };
      module.exports = CubicBezierInterpolation;
    }
  });

  // ../../node_modules/phaser/src/math/interpolation/LinearInterpolation.js
  var require_LinearInterpolation = __commonJS({
    "../../node_modules/phaser/src/math/interpolation/LinearInterpolation.js": function(exports, module) {
      var Linear = require_Linear2();
      var LinearInterpolation = function(v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        if (k < 0) {
          return Linear(v[0], v[1], f);
        } else if (k > 1) {
          return Linear(v[m], v[m - 1], m - f);
        } else {
          return Linear(v[i], v[i + 1 > m ? m : i + 1], f - i);
        }
      };
      module.exports = LinearInterpolation;
    }
  });

  // ../../node_modules/phaser/src/math/interpolation/QuadraticBezierInterpolation.js
  var require_QuadraticBezierInterpolation = __commonJS({
    "../../node_modules/phaser/src/math/interpolation/QuadraticBezierInterpolation.js": function(exports, module) {
      function P0(t, p) {
        var k = 1 - t;
        return k * k * p;
      }
      function P1(t, p) {
        return 2 * (1 - t) * t * p;
      }
      function P2(t, p) {
        return t * t * p;
      }
      var QuadraticBezierInterpolation = function(t, p0, p1, p2) {
        return P0(t, p0) + P1(t, p1) + P2(t, p2);
      };
      module.exports = QuadraticBezierInterpolation;
    }
  });

  // ../../node_modules/phaser/src/math/SmoothStep.js
  var require_SmoothStep = __commonJS({
    "../../node_modules/phaser/src/math/SmoothStep.js": function(exports, module) {
      var SmoothStep = function(x, min, max) {
        if (x <= min) {
          return 0;
        }
        if (x >= max) {
          return 1;
        }
        x = (x - min) / (max - min);
        return x * x * (3 - 2 * x);
      };
      module.exports = SmoothStep;
    }
  });

  // ../../node_modules/phaser/src/math/interpolation/SmoothStepInterpolation.js
  var require_SmoothStepInterpolation = __commonJS({
    "../../node_modules/phaser/src/math/interpolation/SmoothStepInterpolation.js": function(exports, module) {
      var SmoothStep = require_SmoothStep();
      var SmoothStepInterpolation = function(t, min, max) {
        return min + (max - min) * SmoothStep(t, 0, 1);
      };
      module.exports = SmoothStepInterpolation;
    }
  });

  // ../../node_modules/phaser/src/math/SmootherStep.js
  var require_SmootherStep = __commonJS({
    "../../node_modules/phaser/src/math/SmootherStep.js": function(exports, module) {
      var SmootherStep = function(x, min, max) {
        x = Math.max(0, Math.min(1, (x - min) / (max - min)));
        return x * x * x * (x * (x * 6 - 15) + 10);
      };
      module.exports = SmootherStep;
    }
  });

  // ../../node_modules/phaser/src/math/interpolation/SmootherStepInterpolation.js
  var require_SmootherStepInterpolation = __commonJS({
    "../../node_modules/phaser/src/math/interpolation/SmootherStepInterpolation.js": function(exports, module) {
      var SmootherStep = require_SmootherStep();
      var SmootherStepInterpolation = function(t, min, max) {
        return min + (max - min) * SmootherStep(t, 0, 1);
      };
      module.exports = SmootherStepInterpolation;
    }
  });

  // ../../node_modules/phaser/src/math/interpolation/index.js
  var require_interpolation = __commonJS({
    "../../node_modules/phaser/src/math/interpolation/index.js": function(exports, module) {
      module.exports = {
        Bezier: require_BezierInterpolation(),
        CatmullRom: require_CatmullRomInterpolation(),
        CubicBezier: require_CubicBezierInterpolation(),
        Linear: require_LinearInterpolation(),
        QuadraticBezier: require_QuadraticBezierInterpolation(),
        SmoothStep: require_SmoothStepInterpolation(),
        SmootherStep: require_SmootherStepInterpolation()
      };
    }
  });

  // ../../node_modules/phaser/src/math/pow2/GetPowerOfTwo.js
  var require_GetPowerOfTwo = __commonJS({
    "../../node_modules/phaser/src/math/pow2/GetPowerOfTwo.js": function(exports, module) {
      var GetPowerOfTwo = function(value) {
        var index = Math.log(value) / 0.6931471805599453;
        return 1 << Math.ceil(index);
      };
      module.exports = GetPowerOfTwo;
    }
  });

  // ../../node_modules/phaser/src/math/pow2/IsSizePowerOfTwo.js
  var require_IsSizePowerOfTwo = __commonJS({
    "../../node_modules/phaser/src/math/pow2/IsSizePowerOfTwo.js": function(exports, module) {
      var IsSizePowerOfTwo = function(width, height) {
        return width > 0 && (width & width - 1) === 0 && height > 0 && (height & height - 1) === 0;
      };
      module.exports = IsSizePowerOfTwo;
    }
  });

  // ../../node_modules/phaser/src/math/pow2/IsValuePowerOfTwo.js
  var require_IsValuePowerOfTwo = __commonJS({
    "../../node_modules/phaser/src/math/pow2/IsValuePowerOfTwo.js": function(exports, module) {
      var IsValuePowerOfTwo = function(value) {
        return value > 0 && (value & value - 1) === 0;
      };
      module.exports = IsValuePowerOfTwo;
    }
  });

  // ../../node_modules/phaser/src/math/pow2/index.js
  var require_pow2 = __commonJS({
    "../../node_modules/phaser/src/math/pow2/index.js": function(exports, module) {
      module.exports = {
        GetNext: require_GetPowerOfTwo(),
        IsSize: require_IsSizePowerOfTwo(),
        IsValue: require_IsValuePowerOfTwo()
      };
    }
  });

  // ../../node_modules/phaser/src/math/snap/SnapCeil.js
  var require_SnapCeil = __commonJS({
    "../../node_modules/phaser/src/math/snap/SnapCeil.js": function(exports, module) {
      var SnapCeil = function(value, gap, start, divide) {
        if (start === void 0) {
          start = 0;
        }
        if (gap === 0) {
          return value;
        }
        value -= start;
        value = gap * Math.ceil(value / gap);
        return divide ? (start + value) / gap : start + value;
      };
      module.exports = SnapCeil;
    }
  });

  // ../../node_modules/phaser/src/math/snap/SnapFloor.js
  var require_SnapFloor = __commonJS({
    "../../node_modules/phaser/src/math/snap/SnapFloor.js": function(exports, module) {
      var SnapFloor = function(value, gap, start, divide) {
        if (start === void 0) {
          start = 0;
        }
        if (gap === 0) {
          return value;
        }
        value -= start;
        value = gap * Math.floor(value / gap);
        return divide ? (start + value) / gap : start + value;
      };
      module.exports = SnapFloor;
    }
  });

  // ../../node_modules/phaser/src/math/snap/SnapTo.js
  var require_SnapTo = __commonJS({
    "../../node_modules/phaser/src/math/snap/SnapTo.js": function(exports, module) {
      var SnapTo = function(value, gap, start, divide) {
        if (start === void 0) {
          start = 0;
        }
        if (gap === 0) {
          return value;
        }
        value -= start;
        value = gap * Math.round(value / gap);
        return divide ? (start + value) / gap : start + value;
      };
      module.exports = SnapTo;
    }
  });

  // ../../node_modules/phaser/src/math/snap/index.js
  var require_snap = __commonJS({
    "../../node_modules/phaser/src/math/snap/index.js": function(exports, module) {
      module.exports = {
        Ceil: require_SnapCeil(),
        Floor: require_SnapFloor(),
        To: require_SnapTo()
      };
    }
  });

  // ../../node_modules/phaser/src/math/random-data-generator/RandomDataGenerator.js
  var require_RandomDataGenerator = __commonJS({
    "../../node_modules/phaser/src/math/random-data-generator/RandomDataGenerator.js": function(exports, module) {
      var Class = require_Class();
      var RandomDataGenerator = new Class({
        initialize: function RandomDataGenerator2(seeds) {
          if (seeds === void 0) {
            seeds = [(Date.now() * Math.random()).toString()];
          }
          this.c = 1;
          this.s0 = 0;
          this.s1 = 0;
          this.s2 = 0;
          this.n = 0;
          this.signs = [-1, 1];
          if (seeds) {
            this.init(seeds);
          }
        },
        rnd: function() {
          var t = 2091639 * this.s0 + this.c * 23283064365386963e-26;
          this.c = t | 0;
          this.s0 = this.s1;
          this.s1 = this.s2;
          this.s2 = t - this.c;
          return this.s2;
        },
        hash: function(data) {
          var h;
          var n = this.n;
          data = data.toString();
          for (var i = 0; i < data.length; i++) {
            n += data.charCodeAt(i);
            h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 4294967296;
          }
          this.n = n;
          return (n >>> 0) * 23283064365386963e-26;
        },
        init: function(seeds) {
          if (typeof seeds === "string") {
            this.state(seeds);
          } else {
            this.sow(seeds);
          }
        },
        sow: function(seeds) {
          this.n = 4022871197;
          this.s0 = this.hash(" ");
          this.s1 = this.hash(" ");
          this.s2 = this.hash(" ");
          this.c = 1;
          if (!seeds) {
            return;
          }
          for (var i = 0; i < seeds.length && seeds[i] != null; i++) {
            var seed = seeds[i];
            this.s0 -= this.hash(seed);
            this.s0 += ~~(this.s0 < 0);
            this.s1 -= this.hash(seed);
            this.s1 += ~~(this.s1 < 0);
            this.s2 -= this.hash(seed);
            this.s2 += ~~(this.s2 < 0);
          }
        },
        integer: function() {
          return this.rnd() * 4294967296;
        },
        frac: function() {
          return this.rnd() + (this.rnd() * 2097152 | 0) * 11102230246251565e-32;
        },
        real: function() {
          return this.integer() + this.frac();
        },
        integerInRange: function(min, max) {
          return Math.floor(this.realInRange(0, max - min + 1) + min);
        },
        between: function(min, max) {
          return Math.floor(this.realInRange(0, max - min + 1) + min);
        },
        realInRange: function(min, max) {
          return this.frac() * (max - min) + min;
        },
        normal: function() {
          return 1 - 2 * this.frac();
        },
        uuid: function() {
          var a = "";
          var b = "";
          for (b = a = ""; a++ < 36; b += ~a % 5 | a * 3 & 4 ? (a ^ 15 ? 8 ^ this.frac() * (a ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
          }
          return b;
        },
        pick: function(array) {
          return array[this.integerInRange(0, array.length - 1)];
        },
        sign: function() {
          return this.pick(this.signs);
        },
        weightedPick: function(array) {
          return array[~~(Math.pow(this.frac(), 2) * (array.length - 1) + 0.5)];
        },
        timestamp: function(min, max) {
          return this.realInRange(min || 9466848e5, max || 1577862e6);
        },
        angle: function() {
          return this.integerInRange(-180, 180);
        },
        rotation: function() {
          return this.realInRange(-3.1415926, 3.1415926);
        },
        state: function(state) {
          if (typeof state === "string" && state.match(/^!rnd/)) {
            state = state.split(",");
            this.c = parseFloat(state[1]);
            this.s0 = parseFloat(state[2]);
            this.s1 = parseFloat(state[3]);
            this.s2 = parseFloat(state[4]);
          }
          return ["!rnd", this.c, this.s0, this.s1, this.s2].join(",");
        },
        shuffle: function(array) {
          var len = array.length - 1;
          for (var i = len; i > 0; i--) {
            var randomIndex = Math.floor(this.frac() * (i + 1));
            var itemAtIndex = array[randomIndex];
            array[randomIndex] = array[i];
            array[i] = itemAtIndex;
          }
          return array;
        }
      });
      module.exports = RandomDataGenerator;
    }
  });

  // ../../node_modules/phaser/src/math/Average.js
  var require_Average = __commonJS({
    "../../node_modules/phaser/src/math/Average.js": function(exports, module) {
      var Average = function(values) {
        var sum = 0;
        for (var i = 0; i < values.length; i++) {
          sum += +values[i];
        }
        return sum / values.length;
      };
      module.exports = Average;
    }
  });

  // ../../node_modules/phaser/src/math/Between.js
  var require_Between2 = __commonJS({
    "../../node_modules/phaser/src/math/Between.js": function(exports, module) {
      var Between = function(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
      };
      module.exports = Between;
    }
  });

  // ../../node_modules/phaser/src/math/CeilTo.js
  var require_CeilTo = __commonJS({
    "../../node_modules/phaser/src/math/CeilTo.js": function(exports, module) {
      var CeilTo = function(value, place, base) {
        if (place === void 0) {
          place = 0;
        }
        if (base === void 0) {
          base = 10;
        }
        var p = Math.pow(base, -place);
        return Math.ceil(value * p) / p;
      };
      module.exports = CeilTo;
    }
  });

  // ../../node_modules/phaser/src/math/Difference.js
  var require_Difference = __commonJS({
    "../../node_modules/phaser/src/math/Difference.js": function(exports, module) {
      var Difference = function(a, b) {
        return Math.abs(a - b);
      };
      module.exports = Difference;
    }
  });

  // ../../node_modules/phaser/src/math/Vector3.js
  var require_Vector3 = __commonJS({
    "../../node_modules/phaser/src/math/Vector3.js": function(exports, module) {
      var Class = require_Class();
      var Vector3 = new Class({
        initialize: function Vector32(x, y, z) {
          this.x = 0;
          this.y = 0;
          this.z = 0;
          if (typeof x === "object") {
            this.x = x.x || 0;
            this.y = x.y || 0;
            this.z = x.z || 0;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
          }
        },
        up: function() {
          this.x = 0;
          this.y = 1;
          this.z = 0;
          return this;
        },
        min: function(v) {
          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);
          this.z = Math.min(this.z, v.z);
          return this;
        },
        max: function(v) {
          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);
          this.z = Math.max(this.z, v.z);
          return this;
        },
        clone: function() {
          return new Vector3(this.x, this.y, this.z);
        },
        addVectors: function(a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          this.z = a.z + b.z;
          return this;
        },
        crossVectors: function(a, b) {
          var ax = a.x;
          var ay = a.y;
          var az = a.z;
          var bx = b.x;
          var by = b.y;
          var bz = b.z;
          this.x = ay * bz - az * by;
          this.y = az * bx - ax * bz;
          this.z = ax * by - ay * bx;
          return this;
        },
        equals: function(v) {
          return this.x === v.x && this.y === v.y && this.z === v.z;
        },
        copy: function(src) {
          this.x = src.x;
          this.y = src.y;
          this.z = src.z || 0;
          return this;
        },
        set: function(x, y, z) {
          if (typeof x === "object") {
            this.x = x.x || 0;
            this.y = x.y || 0;
            this.z = x.z || 0;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
          }
          return this;
        },
        setFromMatrixPosition: function(m) {
          return this.fromArray(m.val, 12);
        },
        setFromMatrixColumn: function(mat4, index) {
          return this.fromArray(mat4.val, index * 4);
        },
        fromArray: function(array, offset) {
          if (offset === void 0) {
            offset = 0;
          }
          this.x = array[offset];
          this.y = array[offset + 1];
          this.z = array[offset + 2];
          return this;
        },
        add: function(v) {
          this.x += v.x;
          this.y += v.y;
          this.z += v.z || 0;
          return this;
        },
        addScalar: function(s) {
          this.x += s;
          this.y += s;
          this.z += s;
          return this;
        },
        addScale: function(v, scale) {
          this.x += v.x * scale;
          this.y += v.y * scale;
          this.z += v.z * scale || 0;
          return this;
        },
        subtract: function(v) {
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z || 0;
          return this;
        },
        multiply: function(v) {
          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z || 1;
          return this;
        },
        scale: function(scale) {
          if (isFinite(scale)) {
            this.x *= scale;
            this.y *= scale;
            this.z *= scale;
          } else {
            this.x = 0;
            this.y = 0;
            this.z = 0;
          }
          return this;
        },
        divide: function(v) {
          this.x /= v.x;
          this.y /= v.y;
          this.z /= v.z || 1;
          return this;
        },
        negate: function() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          return this;
        },
        distance: function(v) {
          var dx = v.x - this.x;
          var dy = v.y - this.y;
          var dz = v.z - this.z || 0;
          return Math.sqrt(dx * dx + dy * dy + dz * dz);
        },
        distanceSq: function(v) {
          var dx = v.x - this.x;
          var dy = v.y - this.y;
          var dz = v.z - this.z || 0;
          return dx * dx + dy * dy + dz * dz;
        },
        length: function() {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          return Math.sqrt(x * x + y * y + z * z);
        },
        lengthSq: function() {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          return x * x + y * y + z * z;
        },
        normalize: function() {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var len = x * x + y * y + z * z;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            this.x = x * len;
            this.y = y * len;
            this.z = z * len;
          }
          return this;
        },
        dot: function(v) {
          return this.x * v.x + this.y * v.y + this.z * v.z;
        },
        cross: function(v) {
          var ax = this.x;
          var ay = this.y;
          var az = this.z;
          var bx = v.x;
          var by = v.y;
          var bz = v.z;
          this.x = ay * bz - az * by;
          this.y = az * bx - ax * bz;
          this.z = ax * by - ay * bx;
          return this;
        },
        lerp: function(v, t) {
          if (t === void 0) {
            t = 0;
          }
          var ax = this.x;
          var ay = this.y;
          var az = this.z;
          this.x = ax + t * (v.x - ax);
          this.y = ay + t * (v.y - ay);
          this.z = az + t * (v.z - az);
          return this;
        },
        applyMatrix3: function(mat3) {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var m = mat3.val;
          this.x = m[0] * x + m[3] * y + m[6] * z;
          this.y = m[1] * x + m[4] * y + m[7] * z;
          this.z = m[2] * x + m[5] * y + m[8] * z;
          return this;
        },
        applyMatrix4: function(mat4) {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var m = mat4.val;
          var w = 1 / (m[3] * x + m[7] * y + m[11] * z + m[15]);
          this.x = (m[0] * x + m[4] * y + m[8] * z + m[12]) * w;
          this.y = (m[1] * x + m[5] * y + m[9] * z + m[13]) * w;
          this.z = (m[2] * x + m[6] * y + m[10] * z + m[14]) * w;
          return this;
        },
        transformMat3: function(mat) {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var m = mat.val;
          this.x = x * m[0] + y * m[3] + z * m[6];
          this.y = x * m[1] + y * m[4] + z * m[7];
          this.z = x * m[2] + y * m[5] + z * m[8];
          return this;
        },
        transformMat4: function(mat) {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var m = mat.val;
          this.x = m[0] * x + m[4] * y + m[8] * z + m[12];
          this.y = m[1] * x + m[5] * y + m[9] * z + m[13];
          this.z = m[2] * x + m[6] * y + m[10] * z + m[14];
          return this;
        },
        transformCoordinates: function(mat) {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var m = mat.val;
          var tx = x * m[0] + y * m[4] + z * m[8] + m[12];
          var ty = x * m[1] + y * m[5] + z * m[9] + m[13];
          var tz = x * m[2] + y * m[6] + z * m[10] + m[14];
          var tw = x * m[3] + y * m[7] + z * m[11] + m[15];
          this.x = tx / tw;
          this.y = ty / tw;
          this.z = tz / tw;
          return this;
        },
        transformQuat: function(q) {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var qx = q.x;
          var qy = q.y;
          var qz = q.z;
          var qw = q.w;
          var ix = qw * x + qy * z - qz * y;
          var iy = qw * y + qz * x - qx * z;
          var iz = qw * z + qx * y - qy * x;
          var iw = -qx * x - qy * y - qz * z;
          this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
          this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
          this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
          return this;
        },
        project: function(mat) {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var m = mat.val;
          var a00 = m[0];
          var a01 = m[1];
          var a02 = m[2];
          var a03 = m[3];
          var a10 = m[4];
          var a11 = m[5];
          var a12 = m[6];
          var a13 = m[7];
          var a20 = m[8];
          var a21 = m[9];
          var a22 = m[10];
          var a23 = m[11];
          var a30 = m[12];
          var a31 = m[13];
          var a32 = m[14];
          var a33 = m[15];
          var lw = 1 / (x * a03 + y * a13 + z * a23 + a33);
          this.x = (x * a00 + y * a10 + z * a20 + a30) * lw;
          this.y = (x * a01 + y * a11 + z * a21 + a31) * lw;
          this.z = (x * a02 + y * a12 + z * a22 + a32) * lw;
          return this;
        },
        projectViewMatrix: function(viewMatrix, projectionMatrix) {
          return this.applyMatrix4(viewMatrix).applyMatrix4(projectionMatrix);
        },
        unprojectViewMatrix: function(projectionMatrix, worldMatrix) {
          return this.applyMatrix4(projectionMatrix).applyMatrix4(worldMatrix);
        },
        unproject: function(viewport, invProjectionView) {
          var viewX = viewport.x;
          var viewY = viewport.y;
          var viewWidth = viewport.z;
          var viewHeight = viewport.w;
          var x = this.x - viewX;
          var y = viewHeight - this.y - 1 - viewY;
          var z = this.z;
          this.x = 2 * x / viewWidth - 1;
          this.y = 2 * y / viewHeight - 1;
          this.z = 2 * z - 1;
          return this.project(invProjectionView);
        },
        reset: function() {
          this.x = 0;
          this.y = 0;
          this.z = 0;
          return this;
        }
      });
      Vector3.ZERO = new Vector3();
      Vector3.RIGHT = new Vector3(1, 0, 0);
      Vector3.LEFT = new Vector3(-1, 0, 0);
      Vector3.UP = new Vector3(0, -1, 0);
      Vector3.DOWN = new Vector3(0, 1, 0);
      Vector3.FORWARD = new Vector3(0, 0, 1);
      Vector3.BACK = new Vector3(0, 0, -1);
      Vector3.ONE = new Vector3(1, 1, 1);
      module.exports = Vector3;
    }
  });

  // ../../node_modules/phaser/src/math/Matrix4.js
  var require_Matrix4 = __commonJS({
    "../../node_modules/phaser/src/math/Matrix4.js": function(exports, module) {
      var Class = require_Class();
      var Vector3 = require_Vector3();
      var EPSILON = 1e-6;
      var Matrix4 = new Class({
        initialize: function Matrix42(m) {
          this.val = new Float32Array(16);
          if (m) {
            this.copy(m);
          } else {
            this.identity();
          }
        },
        clone: function() {
          return new Matrix4(this);
        },
        set: function(src) {
          return this.copy(src);
        },
        setValues: function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
          var out = this.val;
          out[0] = m00;
          out[1] = m01;
          out[2] = m02;
          out[3] = m03;
          out[4] = m10;
          out[5] = m11;
          out[6] = m12;
          out[7] = m13;
          out[8] = m20;
          out[9] = m21;
          out[10] = m22;
          out[11] = m23;
          out[12] = m30;
          out[13] = m31;
          out[14] = m32;
          out[15] = m33;
          return this;
        },
        copy: function(src) {
          var a = src.val;
          return this.setValues(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
        },
        fromArray: function(a) {
          return this.setValues(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
        },
        zero: function() {
          return this.setValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        },
        transform: function(position, scale, rotation) {
          var rotMatrix = _tempMat1.fromQuat(rotation);
          var rm = rotMatrix.val;
          var sx = scale.x;
          var sy = scale.y;
          var sz = scale.z;
          return this.setValues(rm[0] * sx, rm[1] * sx, rm[2] * sx, 0, rm[4] * sy, rm[5] * sy, rm[6] * sy, 0, rm[8] * sz, rm[9] * sz, rm[10] * sz, 0, position.x, position.y, position.z, 1);
        },
        xyz: function(x, y, z) {
          this.identity();
          var out = this.val;
          out[12] = x;
          out[13] = y;
          out[14] = z;
          return this;
        },
        scaling: function(x, y, z) {
          this.zero();
          var out = this.val;
          out[0] = x;
          out[5] = y;
          out[10] = z;
          out[15] = 1;
          return this;
        },
        identity: function() {
          return this.setValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        },
        transpose: function() {
          var a = this.val;
          var a01 = a[1];
          var a02 = a[2];
          var a03 = a[3];
          var a12 = a[6];
          var a13 = a[7];
          var a23 = a[11];
          a[1] = a[4];
          a[2] = a[8];
          a[3] = a[12];
          a[4] = a01;
          a[6] = a[9];
          a[7] = a[13];
          a[8] = a02;
          a[9] = a12;
          a[11] = a[14];
          a[12] = a03;
          a[13] = a13;
          a[14] = a23;
          return this;
        },
        getInverse: function(m) {
          this.copy(m);
          return this.invert();
        },
        invert: function() {
          var a = this.val;
          var a00 = a[0];
          var a01 = a[1];
          var a02 = a[2];
          var a03 = a[3];
          var a10 = a[4];
          var a11 = a[5];
          var a12 = a[6];
          var a13 = a[7];
          var a20 = a[8];
          var a21 = a[9];
          var a22 = a[10];
          var a23 = a[11];
          var a30 = a[12];
          var a31 = a[13];
          var a32 = a[14];
          var a33 = a[15];
          var b00 = a00 * a11 - a01 * a10;
          var b01 = a00 * a12 - a02 * a10;
          var b02 = a00 * a13 - a03 * a10;
          var b03 = a01 * a12 - a02 * a11;
          var b04 = a01 * a13 - a03 * a11;
          var b05 = a02 * a13 - a03 * a12;
          var b06 = a20 * a31 - a21 * a30;
          var b07 = a20 * a32 - a22 * a30;
          var b08 = a20 * a33 - a23 * a30;
          var b09 = a21 * a32 - a22 * a31;
          var b10 = a21 * a33 - a23 * a31;
          var b11 = a22 * a33 - a23 * a32;
          var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (!det) {
            return this;
          }
          det = 1 / det;
          return this.setValues((a11 * b11 - a12 * b10 + a13 * b09) * det, (a02 * b10 - a01 * b11 - a03 * b09) * det, (a31 * b05 - a32 * b04 + a33 * b03) * det, (a22 * b04 - a21 * b05 - a23 * b03) * det, (a12 * b08 - a10 * b11 - a13 * b07) * det, (a00 * b11 - a02 * b08 + a03 * b07) * det, (a32 * b02 - a30 * b05 - a33 * b01) * det, (a20 * b05 - a22 * b02 + a23 * b01) * det, (a10 * b10 - a11 * b08 + a13 * b06) * det, (a01 * b08 - a00 * b10 - a03 * b06) * det, (a30 * b04 - a31 * b02 + a33 * b00) * det, (a21 * b02 - a20 * b04 - a23 * b00) * det, (a11 * b07 - a10 * b09 - a12 * b06) * det, (a00 * b09 - a01 * b07 + a02 * b06) * det, (a31 * b01 - a30 * b03 - a32 * b00) * det, (a20 * b03 - a21 * b01 + a22 * b00) * det);
        },
        adjoint: function() {
          var a = this.val;
          var a00 = a[0];
          var a01 = a[1];
          var a02 = a[2];
          var a03 = a[3];
          var a10 = a[4];
          var a11 = a[5];
          var a12 = a[6];
          var a13 = a[7];
          var a20 = a[8];
          var a21 = a[9];
          var a22 = a[10];
          var a23 = a[11];
          var a30 = a[12];
          var a31 = a[13];
          var a32 = a[14];
          var a33 = a[15];
          return this.setValues(a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22), -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22)), a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12), -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12)), -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22)), a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22), -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12)), a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12), a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21), -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21)), a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11), -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11)), -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21)), a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21), -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11)), a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
        },
        determinant: function() {
          var a = this.val;
          var a00 = a[0];
          var a01 = a[1];
          var a02 = a[2];
          var a03 = a[3];
          var a10 = a[4];
          var a11 = a[5];
          var a12 = a[6];
          var a13 = a[7];
          var a20 = a[8];
          var a21 = a[9];
          var a22 = a[10];
          var a23 = a[11];
          var a30 = a[12];
          var a31 = a[13];
          var a32 = a[14];
          var a33 = a[15];
          var b00 = a00 * a11 - a01 * a10;
          var b01 = a00 * a12 - a02 * a10;
          var b02 = a00 * a13 - a03 * a10;
          var b03 = a01 * a12 - a02 * a11;
          var b04 = a01 * a13 - a03 * a11;
          var b05 = a02 * a13 - a03 * a12;
          var b06 = a20 * a31 - a21 * a30;
          var b07 = a20 * a32 - a22 * a30;
          var b08 = a20 * a33 - a23 * a30;
          var b09 = a21 * a32 - a22 * a31;
          var b10 = a21 * a33 - a23 * a31;
          var b11 = a22 * a33 - a23 * a32;
          return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        },
        multiply: function(src) {
          var a = this.val;
          var a00 = a[0];
          var a01 = a[1];
          var a02 = a[2];
          var a03 = a[3];
          var a10 = a[4];
          var a11 = a[5];
          var a12 = a[6];
          var a13 = a[7];
          var a20 = a[8];
          var a21 = a[9];
          var a22 = a[10];
          var a23 = a[11];
          var a30 = a[12];
          var a31 = a[13];
          var a32 = a[14];
          var a33 = a[15];
          var b = src.val;
          var b0 = b[0];
          var b1 = b[1];
          var b2 = b[2];
          var b3 = b[3];
          a[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          a[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          a[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          a[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[4];
          b1 = b[5];
          b2 = b[6];
          b3 = b[7];
          a[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          a[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          a[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          a[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[8];
          b1 = b[9];
          b2 = b[10];
          b3 = b[11];
          a[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          a[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          a[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          a[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[12];
          b1 = b[13];
          b2 = b[14];
          b3 = b[15];
          a[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          a[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          a[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          a[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          return this;
        },
        multiplyLocal: function(src) {
          var a = this.val;
          var b = src.val;
          return this.setValues(a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12], a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13], a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14], a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15], a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12], a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13], a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14], a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15], a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12], a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13], a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14], a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15], a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12], a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13], a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14], a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15]);
        },
        premultiply: function(m) {
          return this.multiplyMatrices(m, this);
        },
        multiplyMatrices: function(a, b) {
          var am = a.val;
          var bm = b.val;
          var a11 = am[0];
          var a12 = am[4];
          var a13 = am[8];
          var a14 = am[12];
          var a21 = am[1];
          var a22 = am[5];
          var a23 = am[9];
          var a24 = am[13];
          var a31 = am[2];
          var a32 = am[6];
          var a33 = am[10];
          var a34 = am[14];
          var a41 = am[3];
          var a42 = am[7];
          var a43 = am[11];
          var a44 = am[15];
          var b11 = bm[0];
          var b12 = bm[4];
          var b13 = bm[8];
          var b14 = bm[12];
          var b21 = bm[1];
          var b22 = bm[5];
          var b23 = bm[9];
          var b24 = bm[13];
          var b31 = bm[2];
          var b32 = bm[6];
          var b33 = bm[10];
          var b34 = bm[14];
          var b41 = bm[3];
          var b42 = bm[7];
          var b43 = bm[11];
          var b44 = bm[15];
          return this.setValues(a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41, a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41, a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41, a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41, a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42, a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42, a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42, a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42, a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43, a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43, a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43, a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43, a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44, a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44, a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44, a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44);
        },
        translate: function(v) {
          return this.translateXYZ(v.x, v.y, v.z);
        },
        translateXYZ: function(x, y, z) {
          var a = this.val;
          a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
          a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
          a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
          a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
          return this;
        },
        scale: function(v) {
          return this.scaleXYZ(v.x, v.y, v.z);
        },
        scaleXYZ: function(x, y, z) {
          var a = this.val;
          a[0] = a[0] * x;
          a[1] = a[1] * x;
          a[2] = a[2] * x;
          a[3] = a[3] * x;
          a[4] = a[4] * y;
          a[5] = a[5] * y;
          a[6] = a[6] * y;
          a[7] = a[7] * y;
          a[8] = a[8] * z;
          a[9] = a[9] * z;
          a[10] = a[10] * z;
          a[11] = a[11] * z;
          return this;
        },
        makeRotationAxis: function(axis, angle) {
          var c = Math.cos(angle);
          var s = Math.sin(angle);
          var t = 1 - c;
          var x = axis.x;
          var y = axis.y;
          var z = axis.z;
          var tx = t * x;
          var ty = t * y;
          return this.setValues(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
        },
        rotate: function(rad, axis) {
          var a = this.val;
          var x = axis.x;
          var y = axis.y;
          var z = axis.z;
          var len = Math.sqrt(x * x + y * y + z * z);
          if (Math.abs(len) < EPSILON) {
            return this;
          }
          len = 1 / len;
          x *= len;
          y *= len;
          z *= len;
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          var t = 1 - c;
          var a00 = a[0];
          var a01 = a[1];
          var a02 = a[2];
          var a03 = a[3];
          var a10 = a[4];
          var a11 = a[5];
          var a12 = a[6];
          var a13 = a[7];
          var a20 = a[8];
          var a21 = a[9];
          var a22 = a[10];
          var a23 = a[11];
          var a30 = a[12];
          var a31 = a[13];
          var a32 = a[14];
          var a33 = a[15];
          var b00 = x * x * t + c;
          var b01 = y * x * t + z * s;
          var b02 = z * x * t - y * s;
          var b10 = x * y * t - z * s;
          var b11 = y * y * t + c;
          var b12 = z * y * t + x * s;
          var b20 = x * z * t + y * s;
          var b21 = y * z * t - x * s;
          var b22 = z * z * t + c;
          return this.setValues(a00 * b00 + a10 * b01 + a20 * b02, a01 * b00 + a11 * b01 + a21 * b02, a02 * b00 + a12 * b01 + a22 * b02, a03 * b00 + a13 * b01 + a23 * b02, a00 * b10 + a10 * b11 + a20 * b12, a01 * b10 + a11 * b11 + a21 * b12, a02 * b10 + a12 * b11 + a22 * b12, a03 * b10 + a13 * b11 + a23 * b12, a00 * b20 + a10 * b21 + a20 * b22, a01 * b20 + a11 * b21 + a21 * b22, a02 * b20 + a12 * b21 + a22 * b22, a03 * b20 + a13 * b21 + a23 * b22, a30, a31, a32, a33);
        },
        rotateX: function(rad) {
          var a = this.val;
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          var a10 = a[4];
          var a11 = a[5];
          var a12 = a[6];
          var a13 = a[7];
          var a20 = a[8];
          var a21 = a[9];
          var a22 = a[10];
          var a23 = a[11];
          a[4] = a10 * c + a20 * s;
          a[5] = a11 * c + a21 * s;
          a[6] = a12 * c + a22 * s;
          a[7] = a13 * c + a23 * s;
          a[8] = a20 * c - a10 * s;
          a[9] = a21 * c - a11 * s;
          a[10] = a22 * c - a12 * s;
          a[11] = a23 * c - a13 * s;
          return this;
        },
        rotateY: function(rad) {
          var a = this.val;
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          var a00 = a[0];
          var a01 = a[1];
          var a02 = a[2];
          var a03 = a[3];
          var a20 = a[8];
          var a21 = a[9];
          var a22 = a[10];
          var a23 = a[11];
          a[0] = a00 * c - a20 * s;
          a[1] = a01 * c - a21 * s;
          a[2] = a02 * c - a22 * s;
          a[3] = a03 * c - a23 * s;
          a[8] = a00 * s + a20 * c;
          a[9] = a01 * s + a21 * c;
          a[10] = a02 * s + a22 * c;
          a[11] = a03 * s + a23 * c;
          return this;
        },
        rotateZ: function(rad) {
          var a = this.val;
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          var a00 = a[0];
          var a01 = a[1];
          var a02 = a[2];
          var a03 = a[3];
          var a10 = a[4];
          var a11 = a[5];
          var a12 = a[6];
          var a13 = a[7];
          a[0] = a00 * c + a10 * s;
          a[1] = a01 * c + a11 * s;
          a[2] = a02 * c + a12 * s;
          a[3] = a03 * c + a13 * s;
          a[4] = a10 * c - a00 * s;
          a[5] = a11 * c - a01 * s;
          a[6] = a12 * c - a02 * s;
          a[7] = a13 * c - a03 * s;
          return this;
        },
        fromRotationTranslation: function(q, v) {
          var x = q.x;
          var y = q.y;
          var z = q.z;
          var w = q.w;
          var x2 = x + x;
          var y2 = y + y;
          var z2 = z + z;
          var xx = x * x2;
          var xy = x * y2;
          var xz = x * z2;
          var yy = y * y2;
          var yz = y * z2;
          var zz = z * z2;
          var wx = w * x2;
          var wy = w * y2;
          var wz = w * z2;
          return this.setValues(1 - (yy + zz), xy + wz, xz - wy, 0, xy - wz, 1 - (xx + zz), yz + wx, 0, xz + wy, yz - wx, 1 - (xx + yy), 0, v.x, v.y, v.z, 1);
        },
        fromQuat: function(q) {
          var x = q.x;
          var y = q.y;
          var z = q.z;
          var w = q.w;
          var x2 = x + x;
          var y2 = y + y;
          var z2 = z + z;
          var xx = x * x2;
          var xy = x * y2;
          var xz = x * z2;
          var yy = y * y2;
          var yz = y * z2;
          var zz = z * z2;
          var wx = w * x2;
          var wy = w * y2;
          var wz = w * z2;
          return this.setValues(1 - (yy + zz), xy + wz, xz - wy, 0, xy - wz, 1 - (xx + zz), yz + wx, 0, xz + wy, yz - wx, 1 - (xx + yy), 0, 0, 0, 0, 1);
        },
        frustum: function(left, right, bottom, top, near, far) {
          var rl = 1 / (right - left);
          var tb = 1 / (top - bottom);
          var nf = 1 / (near - far);
          return this.setValues(near * 2 * rl, 0, 0, 0, 0, near * 2 * tb, 0, 0, (right + left) * rl, (top + bottom) * tb, (far + near) * nf, -1, 0, 0, far * near * 2 * nf, 0);
        },
        perspective: function(fovy, aspect, near, far) {
          var f = 1 / Math.tan(fovy / 2);
          var nf = 1 / (near - far);
          return this.setValues(f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (far + near) * nf, -1, 0, 0, 2 * far * near * nf, 0);
        },
        perspectiveLH: function(width, height, near, far) {
          return this.setValues(2 * near / width, 0, 0, 0, 0, 2 * near / height, 0, 0, 0, 0, -far / (near - far), 1, 0, 0, near * far / (near - far), 0);
        },
        ortho: function(left, right, bottom, top, near, far) {
          var lr = left - right;
          var bt = bottom - top;
          var nf = near - far;
          lr = lr === 0 ? lr : 1 / lr;
          bt = bt === 0 ? bt : 1 / bt;
          nf = nf === 0 ? nf : 1 / nf;
          return this.setValues(-2 * lr, 0, 0, 0, 0, -2 * bt, 0, 0, 0, 0, 2 * nf, 0, (left + right) * lr, (top + bottom) * bt, (far + near) * nf, 1);
        },
        lookAtRH: function(eye, target, up) {
          var m = this.val;
          _z.subVectors(eye, target);
          if (_z.getLengthSquared() === 0) {
            _z.z = 1;
          }
          _z.normalize();
          _x.crossVectors(up, _z);
          if (_x.getLengthSquared() === 0) {
            if (Math.abs(up.z) === 1) {
              _z.x += 1e-4;
            } else {
              _z.z += 1e-4;
            }
            _z.normalize();
            _x.crossVectors(up, _z);
          }
          _x.normalize();
          _y.crossVectors(_z, _x);
          m[0] = _x.x;
          m[1] = _x.y;
          m[2] = _x.z;
          m[4] = _y.x;
          m[5] = _y.y;
          m[6] = _y.z;
          m[8] = _z.x;
          m[9] = _z.y;
          m[10] = _z.z;
          return this;
        },
        lookAt: function(eye, center, up) {
          var eyex = eye.x;
          var eyey = eye.y;
          var eyez = eye.z;
          var upx = up.x;
          var upy = up.y;
          var upz = up.z;
          var centerx = center.x;
          var centery = center.y;
          var centerz = center.z;
          if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
            return this.identity();
          }
          var z0 = eyex - centerx;
          var z1 = eyey - centery;
          var z2 = eyez - centerz;
          var len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
          z0 *= len;
          z1 *= len;
          z2 *= len;
          var x0 = upy * z2 - upz * z1;
          var x1 = upz * z0 - upx * z2;
          var x2 = upx * z1 - upy * z0;
          len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
          if (!len) {
            x0 = 0;
            x1 = 0;
            x2 = 0;
          } else {
            len = 1 / len;
            x0 *= len;
            x1 *= len;
            x2 *= len;
          }
          var y0 = z1 * x2 - z2 * x1;
          var y1 = z2 * x0 - z0 * x2;
          var y2 = z0 * x1 - z1 * x0;
          len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
          if (!len) {
            y0 = 0;
            y1 = 0;
            y2 = 0;
          } else {
            len = 1 / len;
            y0 *= len;
            y1 *= len;
            y2 *= len;
          }
          return this.setValues(x0, y0, z0, 0, x1, y1, z1, 0, x2, y2, z2, 0, -(x0 * eyex + x1 * eyey + x2 * eyez), -(y0 * eyex + y1 * eyey + y2 * eyez), -(z0 * eyex + z1 * eyey + z2 * eyez), 1);
        },
        yawPitchRoll: function(yaw, pitch, roll) {
          this.zero();
          _tempMat1.zero();
          _tempMat2.zero();
          var m0 = this.val;
          var m1 = _tempMat1.val;
          var m2 = _tempMat2.val;
          var s = Math.sin(roll);
          var c = Math.cos(roll);
          m0[10] = 1;
          m0[15] = 1;
          m0[0] = c;
          m0[1] = s;
          m0[4] = -s;
          m0[5] = c;
          s = Math.sin(pitch);
          c = Math.cos(pitch);
          m1[0] = 1;
          m1[15] = 1;
          m1[5] = c;
          m1[10] = c;
          m1[9] = -s;
          m1[6] = s;
          s = Math.sin(yaw);
          c = Math.cos(yaw);
          m2[5] = 1;
          m2[15] = 1;
          m2[0] = c;
          m2[2] = -s;
          m2[8] = s;
          m2[10] = c;
          this.multiplyLocal(_tempMat1);
          this.multiplyLocal(_tempMat2);
          return this;
        },
        setWorldMatrix: function(rotation, position, scale, viewMatrix, projectionMatrix) {
          this.yawPitchRoll(rotation.y, rotation.x, rotation.z);
          _tempMat1.scaling(scale.x, scale.y, scale.z);
          _tempMat2.xyz(position.x, position.y, position.z);
          this.multiplyLocal(_tempMat1);
          this.multiplyLocal(_tempMat2);
          if (viewMatrix) {
            this.multiplyLocal(viewMatrix);
          }
          if (projectionMatrix) {
            this.multiplyLocal(projectionMatrix);
          }
          return this;
        },
        multiplyToMat4: function(src, out) {
          var a = this.val;
          var b = src.val;
          var a00 = a[0];
          var a01 = a[1];
          var a02 = a[2];
          var a03 = a[3];
          var a10 = a[4];
          var a11 = a[5];
          var a12 = a[6];
          var a13 = a[7];
          var a20 = a[8];
          var a21 = a[9];
          var a22 = a[10];
          var a23 = a[11];
          var a30 = a[12];
          var a31 = a[13];
          var a32 = a[14];
          var a33 = a[15];
          var b00 = b[0];
          var b01 = b[1];
          var b02 = b[2];
          var b03 = b[3];
          var b10 = b[4];
          var b11 = b[5];
          var b12 = b[6];
          var b13 = b[7];
          var b20 = b[8];
          var b21 = b[9];
          var b22 = b[10];
          var b23 = b[11];
          var b30 = b[12];
          var b31 = b[13];
          var b32 = b[14];
          var b33 = b[15];
          return out.setValues(b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30, b01 * a01 + b01 * a11 + b02 * a21 + b03 * a31, b02 * a02 + b01 * a12 + b02 * a22 + b03 * a32, b03 * a03 + b01 * a13 + b02 * a23 + b03 * a33, b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30, b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31, b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32, b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33, b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30, b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31, b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32, b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33, b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30, b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31, b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32, b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33);
        },
        fromRotationXYTranslation: function(rotation, position, translateFirst) {
          var x = position.x;
          var y = position.y;
          var z = position.z;
          var sx = Math.sin(rotation.x);
          var cx = Math.cos(rotation.x);
          var sy = Math.sin(rotation.y);
          var cy = Math.cos(rotation.y);
          var a30 = x;
          var a31 = y;
          var a32 = z;
          var b21 = -sx;
          var c01 = 0 - b21 * sy;
          var c02 = 0 - cx * sy;
          var c21 = b21 * cy;
          var c22 = cx * cy;
          if (!translateFirst) {
            a30 = cy * x + sy * z;
            a31 = c01 * x + cx * y + c21 * z;
            a32 = c02 * x + sx * y + c22 * z;
          }
          return this.setValues(cy, c01, c02, 0, 0, cx, sx, 0, sy, c21, c22, 0, a30, a31, a32, 1);
        },
        getMaxScaleOnAxis: function() {
          var m = this.val;
          var scaleXSq = m[0] * m[0] + m[1] * m[1] + m[2] * m[2];
          var scaleYSq = m[4] * m[4] + m[5] * m[5] + m[6] * m[6];
          var scaleZSq = m[8] * m[8] + m[9] * m[9] + m[10] * m[10];
          return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        }
      });
      var _tempMat1 = new Matrix4();
      var _tempMat2 = new Matrix4();
      var _x = new Vector3();
      var _y = new Vector3();
      var _z = new Vector3();
      module.exports = Matrix4;
    }
  });

  // ../../node_modules/phaser/src/math/Euler.js
  var require_Euler = __commonJS({
    "../../node_modules/phaser/src/math/Euler.js": function(exports, module) {
      var Clamp = require_Clamp();
      var Class = require_Class();
      var Matrix4 = require_Matrix4();
      var NOOP = require_NOOP();
      var tempMatrix = new Matrix4();
      var Euler = new Class({
        initialize: function Euler2(x, y, z, order) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (z === void 0) {
            z = 0;
          }
          if (order === void 0) {
            order = Euler2.DefaultOrder;
          }
          this._x = x;
          this._y = y;
          this._z = z;
          this._order = order;
          this.onChangeCallback = NOOP;
        },
        x: {
          get: function() {
            return this._x;
          },
          set: function(value) {
            this._x = value;
            this.onChangeCallback(this);
          }
        },
        y: {
          get: function() {
            return this._y;
          },
          set: function(value) {
            this._y = value;
            this.onChangeCallback(this);
          }
        },
        z: {
          get: function() {
            return this._z;
          },
          set: function(value) {
            this._z = value;
            this.onChangeCallback(this);
          }
        },
        order: {
          get: function() {
            return this._order;
          },
          set: function(value) {
            this._order = value;
            this.onChangeCallback(this);
          }
        },
        set: function(x, y, z, order) {
          if (order === void 0) {
            order = this._order;
          }
          this._x = x;
          this._y = y;
          this._z = z;
          this._order = order;
          this.onChangeCallback(this);
          return this;
        },
        copy: function(euler) {
          return this.set(euler.x, euler.y, euler.z, euler.order);
        },
        setFromQuaternion: function(quaternion, order, update) {
          if (order === void 0) {
            order = this._order;
          }
          if (update === void 0) {
            update = false;
          }
          tempMatrix.fromQuat(quaternion);
          return this.setFromRotationMatrix(tempMatrix, order, update);
        },
        setFromRotationMatrix: function(matrix, order, update) {
          if (order === void 0) {
            order = this._order;
          }
          if (update === void 0) {
            update = false;
          }
          var elements = matrix.val;
          var m11 = elements[0];
          var m12 = elements[4];
          var m13 = elements[8];
          var m21 = elements[1];
          var m22 = elements[5];
          var m23 = elements[9];
          var m31 = elements[2];
          var m32 = elements[6];
          var m33 = elements[10];
          var x = 0;
          var y = 0;
          var z = 0;
          var epsilon = 0.99999;
          switch (order) {
            case "XYZ": {
              y = Math.asin(Clamp(m13, -1, 1));
              if (Math.abs(m13) < epsilon) {
                x = Math.atan2(-m23, m33);
                z = Math.atan2(-m12, m11);
              } else {
                x = Math.atan2(m32, m22);
              }
              break;
            }
            case "YXZ": {
              x = Math.asin(-Clamp(m23, -1, 1));
              if (Math.abs(m23) < epsilon) {
                y = Math.atan2(m13, m33);
                z = Math.atan2(m21, m22);
              } else {
                y = Math.atan2(-m31, m11);
              }
              break;
            }
            case "ZXY": {
              x = Math.asin(Clamp(m32, -1, 1));
              if (Math.abs(m32) < epsilon) {
                y = Math.atan2(-m31, m33);
                z = Math.atan2(-m12, m22);
              } else {
                z = Math.atan2(m21, m11);
              }
              break;
            }
            case "ZYX": {
              y = Math.asin(-Clamp(m31, -1, 1));
              if (Math.abs(m31) < epsilon) {
                x = Math.atan2(m32, m33);
                z = Math.atan2(m21, m11);
              } else {
                z = Math.atan2(-m12, m22);
              }
              break;
            }
            case "YZX": {
              z = Math.asin(Clamp(m21, -1, 1));
              if (Math.abs(m21) < epsilon) {
                x = Math.atan2(-m23, m22);
                y = Math.atan2(-m31, m11);
              } else {
                y = Math.atan2(m13, m33);
              }
              break;
            }
            case "XZY": {
              z = Math.asin(-Clamp(m12, -1, 1));
              if (Math.abs(m12) < epsilon) {
                x = Math.atan2(m32, m22);
                y = Math.atan2(m13, m11);
              } else {
                x = Math.atan2(-m23, m33);
              }
              break;
            }
          }
          this._x = x;
          this._y = y;
          this._z = z;
          this._order = order;
          if (update) {
            this.onChangeCallback(this);
          }
          return this;
        }
      });
      Euler.RotationOrders = ["XYZ", "YXZ", "ZXY", "ZYX", "YZX", "XZY"];
      Euler.DefaultOrder = "XYZ";
      module.exports = Euler;
    }
  });

  // ../../node_modules/phaser/src/math/FloorTo.js
  var require_FloorTo = __commonJS({
    "../../node_modules/phaser/src/math/FloorTo.js": function(exports, module) {
      var FloorTo = function(value, place, base) {
        if (place === void 0) {
          place = 0;
        }
        if (base === void 0) {
          base = 10;
        }
        var p = Math.pow(base, -place);
        return Math.floor(value * p) / p;
      };
      module.exports = FloorTo;
    }
  });

  // ../../node_modules/phaser/src/math/GetSpeed.js
  var require_GetSpeed = __commonJS({
    "../../node_modules/phaser/src/math/GetSpeed.js": function(exports, module) {
      var GetSpeed = function(distance, time) {
        return distance / time / 1e3;
      };
      module.exports = GetSpeed;
    }
  });

  // ../../node_modules/phaser/src/math/IsEven.js
  var require_IsEven = __commonJS({
    "../../node_modules/phaser/src/math/IsEven.js": function(exports, module) {
      var IsEven = function(value) {
        return value == parseFloat(value) ? !(value % 2) : void 0;
      };
      module.exports = IsEven;
    }
  });

  // ../../node_modules/phaser/src/math/IsEvenStrict.js
  var require_IsEvenStrict = __commonJS({
    "../../node_modules/phaser/src/math/IsEvenStrict.js": function(exports, module) {
      var IsEvenStrict = function(value) {
        return value === parseFloat(value) ? !(value % 2) : void 0;
      };
      module.exports = IsEvenStrict;
    }
  });

  // ../../node_modules/phaser/src/math/LinearXY.js
  var require_LinearXY = __commonJS({
    "../../node_modules/phaser/src/math/LinearXY.js": function(exports, module) {
      var LinearXY = function(vector1, vector2, t) {
        if (t === void 0) {
          t = 0;
        }
        return vector1.clone().lerp(vector2, t);
      };
      module.exports = LinearXY;
    }
  });

  // ../../node_modules/phaser/src/math/MaxAdd.js
  var require_MaxAdd = __commonJS({
    "../../node_modules/phaser/src/math/MaxAdd.js": function(exports, module) {
      var MaxAdd = function(value, amount, max) {
        return Math.min(value + amount, max);
      };
      module.exports = MaxAdd;
    }
  });

  // ../../node_modules/phaser/src/math/Median.js
  var require_Median = __commonJS({
    "../../node_modules/phaser/src/math/Median.js": function(exports, module) {
      var Median = function(values) {
        var valuesNum = values.length;
        if (valuesNum === 0) {
          return 0;
        }
        values.sort(function(a, b) {
          return a - b;
        });
        var halfIndex = Math.floor(valuesNum / 2);
        return valuesNum % 2 === 0 ? (values[halfIndex] + values[halfIndex - 1]) / 2 : values[halfIndex];
      };
      module.exports = Median;
    }
  });

  // ../../node_modules/phaser/src/math/MinSub.js
  var require_MinSub = __commonJS({
    "../../node_modules/phaser/src/math/MinSub.js": function(exports, module) {
      var MinSub = function(value, amount, min) {
        return Math.max(value - amount, min);
      };
      module.exports = MinSub;
    }
  });

  // ../../node_modules/phaser/src/math/Percent.js
  var require_Percent = __commonJS({
    "../../node_modules/phaser/src/math/Percent.js": function(exports, module) {
      var Percent = function(value, min, max, upperMax) {
        if (max === void 0) {
          max = min + 1;
        }
        var percentage = (value - min) / (max - min);
        if (percentage > 1) {
          if (upperMax !== void 0) {
            percentage = (upperMax - value) / (upperMax - max);
            if (percentage < 0) {
              percentage = 0;
            }
          } else {
            percentage = 1;
          }
        } else if (percentage < 0) {
          percentage = 0;
        }
        return percentage;
      };
      module.exports = Percent;
    }
  });

  // ../../node_modules/phaser/src/math/RadToDeg.js
  var require_RadToDeg = __commonJS({
    "../../node_modules/phaser/src/math/RadToDeg.js": function(exports, module) {
      var CONST = require_const4();
      var RadToDeg = function(radians) {
        return radians * CONST.RAD_TO_DEG;
      };
      module.exports = RadToDeg;
    }
  });

  // ../../node_modules/phaser/src/math/RandomXY.js
  var require_RandomXY = __commonJS({
    "../../node_modules/phaser/src/math/RandomXY.js": function(exports, module) {
      var RandomXY = function(vector, scale) {
        if (scale === void 0) {
          scale = 1;
        }
        var r = Math.random() * 2 * Math.PI;
        vector.x = Math.cos(r) * scale;
        vector.y = Math.sin(r) * scale;
        return vector;
      };
      module.exports = RandomXY;
    }
  });

  // ../../node_modules/phaser/src/math/RandomXYZ.js
  var require_RandomXYZ = __commonJS({
    "../../node_modules/phaser/src/math/RandomXYZ.js": function(exports, module) {
      var RandomXYZ = function(vec3, radius) {
        if (radius === void 0) {
          radius = 1;
        }
        var r = Math.random() * 2 * Math.PI;
        var z = Math.random() * 2 - 1;
        var zScale = Math.sqrt(1 - z * z) * radius;
        vec3.x = Math.cos(r) * zScale;
        vec3.y = Math.sin(r) * zScale;
        vec3.z = z * radius;
        return vec3;
      };
      module.exports = RandomXYZ;
    }
  });

  // ../../node_modules/phaser/src/math/RandomXYZW.js
  var require_RandomXYZW = __commonJS({
    "../../node_modules/phaser/src/math/RandomXYZW.js": function(exports, module) {
      var RandomXYZW = function(vec4, scale) {
        if (scale === void 0) {
          scale = 1;
        }
        vec4.x = (Math.random() * 2 - 1) * scale;
        vec4.y = (Math.random() * 2 - 1) * scale;
        vec4.z = (Math.random() * 2 - 1) * scale;
        vec4.w = (Math.random() * 2 - 1) * scale;
        return vec4;
      };
      module.exports = RandomXYZW;
    }
  });

  // ../../node_modules/phaser/src/math/Rotate.js
  var require_Rotate = __commonJS({
    "../../node_modules/phaser/src/math/Rotate.js": function(exports, module) {
      var Rotate = function(point, angle) {
        var x = point.x;
        var y = point.y;
        point.x = x * Math.cos(angle) - y * Math.sin(angle);
        point.y = x * Math.sin(angle) + y * Math.cos(angle);
        return point;
      };
      module.exports = Rotate;
    }
  });

  // ../../node_modules/phaser/src/math/RotateAroundDistance.js
  var require_RotateAroundDistance = __commonJS({
    "../../node_modules/phaser/src/math/RotateAroundDistance.js": function(exports, module) {
      var RotateAroundDistance = function(point, x, y, angle, distance) {
        var t = angle + Math.atan2(point.y - y, point.x - x);
        point.x = x + distance * Math.cos(t);
        point.y = y + distance * Math.sin(t);
        return point;
      };
      module.exports = RotateAroundDistance;
    }
  });

  // ../../node_modules/phaser/src/math/RotateTo.js
  var require_RotateTo3 = __commonJS({
    "../../node_modules/phaser/src/math/RotateTo.js": function(exports, module) {
      var RotateTo = function(point, x, y, angle, distance) {
        point.x = x + distance * Math.cos(angle);
        point.y = y + distance * Math.sin(angle);
        return point;
      };
      module.exports = RotateTo;
    }
  });

  // ../../node_modules/phaser/src/math/RoundAwayFromZero.js
  var require_RoundAwayFromZero = __commonJS({
    "../../node_modules/phaser/src/math/RoundAwayFromZero.js": function(exports, module) {
      var RoundAwayFromZero = function(value) {
        return value > 0 ? Math.ceil(value) : Math.floor(value);
      };
      module.exports = RoundAwayFromZero;
    }
  });

  // ../../node_modules/phaser/src/math/RoundTo.js
  var require_RoundTo = __commonJS({
    "../../node_modules/phaser/src/math/RoundTo.js": function(exports, module) {
      var RoundTo = function(value, place, base) {
        if (place === void 0) {
          place = 0;
        }
        if (base === void 0) {
          base = 10;
        }
        var p = Math.pow(base, -place);
        return Math.round(value * p) / p;
      };
      module.exports = RoundTo;
    }
  });

  // ../../node_modules/phaser/src/math/SinCosTableGenerator.js
  var require_SinCosTableGenerator = __commonJS({
    "../../node_modules/phaser/src/math/SinCosTableGenerator.js": function(exports, module) {
      var SinCosTableGenerator = function(length, sinAmp, cosAmp, frequency) {
        if (sinAmp === void 0) {
          sinAmp = 1;
        }
        if (cosAmp === void 0) {
          cosAmp = 1;
        }
        if (frequency === void 0) {
          frequency = 1;
        }
        frequency *= Math.PI / length;
        var cos = [];
        var sin = [];
        for (var c = 0; c < length; c++) {
          cosAmp -= sinAmp * frequency;
          sinAmp += cosAmp * frequency;
          cos[c] = cosAmp;
          sin[c] = sinAmp;
        }
        return {
          sin: sin,
          cos: cos,
          length: length
        };
      };
      module.exports = SinCosTableGenerator;
    }
  });

  // ../../node_modules/phaser/src/math/ToXY.js
  var require_ToXY = __commonJS({
    "../../node_modules/phaser/src/math/ToXY.js": function(exports, module) {
      var Vector2 = require_Vector2();
      var ToXY = function(index, width, height, out) {
        if (out === void 0) {
          out = new Vector2();
        }
        var x = 0;
        var y = 0;
        var total = width * height;
        if (index > 0 && index <= total) {
          if (index > width - 1) {
            y = Math.floor(index / width);
            x = index - y * width;
          } else {
            x = index;
          }
        }
        return out.set(x, y);
      };
      module.exports = ToXY;
    }
  });

  // ../../node_modules/phaser/src/math/Within.js
  var require_Within = __commonJS({
    "../../node_modules/phaser/src/math/Within.js": function(exports, module) {
      var Within = function(a, b, tolerance) {
        return Math.abs(a - b) <= tolerance;
      };
      module.exports = Within;
    }
  });

  // ../../node_modules/phaser/src/math/Vector4.js
  var require_Vector4 = __commonJS({
    "../../node_modules/phaser/src/math/Vector4.js": function(exports, module) {
      var Class = require_Class();
      var Vector4 = new Class({
        initialize: function Vector42(x, y, z, w) {
          this.x = 0;
          this.y = 0;
          this.z = 0;
          this.w = 0;
          if (typeof x === "object") {
            this.x = x.x || 0;
            this.y = x.y || 0;
            this.z = x.z || 0;
            this.w = x.w || 0;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w || 0;
          }
        },
        clone: function() {
          return new Vector4(this.x, this.y, this.z, this.w);
        },
        copy: function(src) {
          this.x = src.x;
          this.y = src.y;
          this.z = src.z || 0;
          this.w = src.w || 0;
          return this;
        },
        equals: function(v) {
          return this.x === v.x && this.y === v.y && this.z === v.z && this.w === v.w;
        },
        set: function(x, y, z, w) {
          if (typeof x === "object") {
            this.x = x.x || 0;
            this.y = x.y || 0;
            this.z = x.z || 0;
            this.w = x.w || 0;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w || 0;
          }
          return this;
        },
        add: function(v) {
          this.x += v.x;
          this.y += v.y;
          this.z += v.z || 0;
          this.w += v.w || 0;
          return this;
        },
        subtract: function(v) {
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z || 0;
          this.w -= v.w || 0;
          return this;
        },
        scale: function(scale) {
          this.x *= scale;
          this.y *= scale;
          this.z *= scale;
          this.w *= scale;
          return this;
        },
        length: function() {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var w = this.w;
          return Math.sqrt(x * x + y * y + z * z + w * w);
        },
        lengthSq: function() {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var w = this.w;
          return x * x + y * y + z * z + w * w;
        },
        normalize: function() {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var w = this.w;
          var len = x * x + y * y + z * z + w * w;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            this.x = x * len;
            this.y = y * len;
            this.z = z * len;
            this.w = w * len;
          }
          return this;
        },
        dot: function(v) {
          return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        },
        lerp: function(v, t) {
          if (t === void 0) {
            t = 0;
          }
          var ax = this.x;
          var ay = this.y;
          var az = this.z;
          var aw = this.w;
          this.x = ax + t * (v.x - ax);
          this.y = ay + t * (v.y - ay);
          this.z = az + t * (v.z - az);
          this.w = aw + t * (v.w - aw);
          return this;
        },
        multiply: function(v) {
          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z || 1;
          this.w *= v.w || 1;
          return this;
        },
        divide: function(v) {
          this.x /= v.x;
          this.y /= v.y;
          this.z /= v.z || 1;
          this.w /= v.w || 1;
          return this;
        },
        distance: function(v) {
          var dx = v.x - this.x;
          var dy = v.y - this.y;
          var dz = v.z - this.z || 0;
          var dw = v.w - this.w || 0;
          return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
        },
        distanceSq: function(v) {
          var dx = v.x - this.x;
          var dy = v.y - this.y;
          var dz = v.z - this.z || 0;
          var dw = v.w - this.w || 0;
          return dx * dx + dy * dy + dz * dz + dw * dw;
        },
        negate: function() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          this.w = -this.w;
          return this;
        },
        transformMat4: function(mat) {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var w = this.w;
          var m = mat.val;
          this.x = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
          this.y = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
          this.z = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
          this.w = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
          return this;
        },
        transformQuat: function(q) {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var qx = q.x;
          var qy = q.y;
          var qz = q.z;
          var qw = q.w;
          var ix = qw * x + qy * z - qz * y;
          var iy = qw * y + qz * x - qx * z;
          var iz = qw * z + qx * y - qy * x;
          var iw = -qx * x - qy * y - qz * z;
          this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
          this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
          this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
          return this;
        },
        reset: function() {
          this.x = 0;
          this.y = 0;
          this.z = 0;
          this.w = 0;
          return this;
        }
      });
      Vector4.prototype.sub = Vector4.prototype.subtract;
      Vector4.prototype.mul = Vector4.prototype.multiply;
      Vector4.prototype.div = Vector4.prototype.divide;
      Vector4.prototype.dist = Vector4.prototype.distance;
      Vector4.prototype.distSq = Vector4.prototype.distanceSq;
      Vector4.prototype.len = Vector4.prototype.length;
      Vector4.prototype.lenSq = Vector4.prototype.lengthSq;
      module.exports = Vector4;
    }
  });

  // ../../node_modules/phaser/src/math/Matrix3.js
  var require_Matrix3 = __commonJS({
    "../../node_modules/phaser/src/math/Matrix3.js": function(exports, module) {
      var Class = require_Class();
      var Matrix3 = new Class({
        initialize: function Matrix32(m) {
          this.val = new Float32Array(9);
          if (m) {
            this.copy(m);
          } else {
            this.identity();
          }
        },
        clone: function() {
          return new Matrix3(this);
        },
        set: function(src) {
          return this.copy(src);
        },
        copy: function(src) {
          var out = this.val;
          var a = src.val;
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          out[4] = a[4];
          out[5] = a[5];
          out[6] = a[6];
          out[7] = a[7];
          out[8] = a[8];
          return this;
        },
        fromMat4: function(m) {
          var a = m.val;
          var out = this.val;
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[4];
          out[4] = a[5];
          out[5] = a[6];
          out[6] = a[8];
          out[7] = a[9];
          out[8] = a[10];
          return this;
        },
        fromArray: function(a) {
          var out = this.val;
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          out[4] = a[4];
          out[5] = a[5];
          out[6] = a[6];
          out[7] = a[7];
          out[8] = a[8];
          return this;
        },
        identity: function() {
          var out = this.val;
          out[0] = 1;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 1;
          out[5] = 0;
          out[6] = 0;
          out[7] = 0;
          out[8] = 1;
          return this;
        },
        transpose: function() {
          var a = this.val;
          var a01 = a[1];
          var a02 = a[2];
          var a12 = a[5];
          a[1] = a[3];
          a[2] = a[6];
          a[3] = a01;
          a[5] = a[7];
          a[6] = a02;
          a[7] = a12;
          return this;
        },
        invert: function() {
          var a = this.val;
          var a00 = a[0];
          var a01 = a[1];
          var a02 = a[2];
          var a10 = a[3];
          var a11 = a[4];
          var a12 = a[5];
          var a20 = a[6];
          var a21 = a[7];
          var a22 = a[8];
          var b01 = a22 * a11 - a12 * a21;
          var b11 = -a22 * a10 + a12 * a20;
          var b21 = a21 * a10 - a11 * a20;
          var det = a00 * b01 + a01 * b11 + a02 * b21;
          if (!det) {
            return null;
          }
          det = 1 / det;
          a[0] = b01 * det;
          a[1] = (-a22 * a01 + a02 * a21) * det;
          a[2] = (a12 * a01 - a02 * a11) * det;
          a[3] = b11 * det;
          a[4] = (a22 * a00 - a02 * a20) * det;
          a[5] = (-a12 * a00 + a02 * a10) * det;
          a[6] = b21 * det;
          a[7] = (-a21 * a00 + a01 * a20) * det;
          a[8] = (a11 * a00 - a01 * a10) * det;
          return this;
        },
        adjoint: function() {
          var a = this.val;
          var a00 = a[0];
          var a01 = a[1];
          var a02 = a[2];
          var a10 = a[3];
          var a11 = a[4];
          var a12 = a[5];
          var a20 = a[6];
          var a21 = a[7];
          var a22 = a[8];
          a[0] = a11 * a22 - a12 * a21;
          a[1] = a02 * a21 - a01 * a22;
          a[2] = a01 * a12 - a02 * a11;
          a[3] = a12 * a20 - a10 * a22;
          a[4] = a00 * a22 - a02 * a20;
          a[5] = a02 * a10 - a00 * a12;
          a[6] = a10 * a21 - a11 * a20;
          a[7] = a01 * a20 - a00 * a21;
          a[8] = a00 * a11 - a01 * a10;
          return this;
        },
        determinant: function() {
          var a = this.val;
          var a00 = a[0];
          var a01 = a[1];
          var a02 = a[2];
          var a10 = a[3];
          var a11 = a[4];
          var a12 = a[5];
          var a20 = a[6];
          var a21 = a[7];
          var a22 = a[8];
          return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
        },
        multiply: function(src) {
          var a = this.val;
          var a00 = a[0];
          var a01 = a[1];
          var a02 = a[2];
          var a10 = a[3];
          var a11 = a[4];
          var a12 = a[5];
          var a20 = a[6];
          var a21 = a[7];
          var a22 = a[8];
          var b = src.val;
          var b00 = b[0];
          var b01 = b[1];
          var b02 = b[2];
          var b10 = b[3];
          var b11 = b[4];
          var b12 = b[5];
          var b20 = b[6];
          var b21 = b[7];
          var b22 = b[8];
          a[0] = b00 * a00 + b01 * a10 + b02 * a20;
          a[1] = b00 * a01 + b01 * a11 + b02 * a21;
          a[2] = b00 * a02 + b01 * a12 + b02 * a22;
          a[3] = b10 * a00 + b11 * a10 + b12 * a20;
          a[4] = b10 * a01 + b11 * a11 + b12 * a21;
          a[5] = b10 * a02 + b11 * a12 + b12 * a22;
          a[6] = b20 * a00 + b21 * a10 + b22 * a20;
          a[7] = b20 * a01 + b21 * a11 + b22 * a21;
          a[8] = b20 * a02 + b21 * a12 + b22 * a22;
          return this;
        },
        translate: function(v) {
          var a = this.val;
          var x = v.x;
          var y = v.y;
          a[6] = x * a[0] + y * a[3] + a[6];
          a[7] = x * a[1] + y * a[4] + a[7];
          a[8] = x * a[2] + y * a[5] + a[8];
          return this;
        },
        rotate: function(rad) {
          var a = this.val;
          var a00 = a[0];
          var a01 = a[1];
          var a02 = a[2];
          var a10 = a[3];
          var a11 = a[4];
          var a12 = a[5];
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          a[0] = c * a00 + s * a10;
          a[1] = c * a01 + s * a11;
          a[2] = c * a02 + s * a12;
          a[3] = c * a10 - s * a00;
          a[4] = c * a11 - s * a01;
          a[5] = c * a12 - s * a02;
          return this;
        },
        scale: function(v) {
          var a = this.val;
          var x = v.x;
          var y = v.y;
          a[0] = x * a[0];
          a[1] = x * a[1];
          a[2] = x * a[2];
          a[3] = y * a[3];
          a[4] = y * a[4];
          a[5] = y * a[5];
          return this;
        },
        fromQuat: function(q) {
          var x = q.x;
          var y = q.y;
          var z = q.z;
          var w = q.w;
          var x2 = x + x;
          var y2 = y + y;
          var z2 = z + z;
          var xx = x * x2;
          var xy = x * y2;
          var xz = x * z2;
          var yy = y * y2;
          var yz = y * z2;
          var zz = z * z2;
          var wx = w * x2;
          var wy = w * y2;
          var wz = w * z2;
          var out = this.val;
          out[0] = 1 - (yy + zz);
          out[3] = xy + wz;
          out[6] = xz - wy;
          out[1] = xy - wz;
          out[4] = 1 - (xx + zz);
          out[7] = yz + wx;
          out[2] = xz + wy;
          out[5] = yz - wx;
          out[8] = 1 - (xx + yy);
          return this;
        },
        normalFromMat4: function(m) {
          var a = m.val;
          var out = this.val;
          var a00 = a[0];
          var a01 = a[1];
          var a02 = a[2];
          var a03 = a[3];
          var a10 = a[4];
          var a11 = a[5];
          var a12 = a[6];
          var a13 = a[7];
          var a20 = a[8];
          var a21 = a[9];
          var a22 = a[10];
          var a23 = a[11];
          var a30 = a[12];
          var a31 = a[13];
          var a32 = a[14];
          var a33 = a[15];
          var b00 = a00 * a11 - a01 * a10;
          var b01 = a00 * a12 - a02 * a10;
          var b02 = a00 * a13 - a03 * a10;
          var b03 = a01 * a12 - a02 * a11;
          var b04 = a01 * a13 - a03 * a11;
          var b05 = a02 * a13 - a03 * a12;
          var b06 = a20 * a31 - a21 * a30;
          var b07 = a20 * a32 - a22 * a30;
          var b08 = a20 * a33 - a23 * a30;
          var b09 = a21 * a32 - a22 * a31;
          var b10 = a21 * a33 - a23 * a31;
          var b11 = a22 * a33 - a23 * a32;
          var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (!det) {
            return null;
          }
          det = 1 / det;
          out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          return this;
        }
      });
      module.exports = Matrix3;
    }
  });

  // ../../node_modules/phaser/src/math/Quaternion.js
  var require_Quaternion = __commonJS({
    "../../node_modules/phaser/src/math/Quaternion.js": function(exports, module) {
      var Class = require_Class();
      var Matrix3 = require_Matrix3();
      var NOOP = require_NOOP();
      var Vector3 = require_Vector3();
      var EPSILON = 1e-6;
      var siNext = new Int8Array([1, 2, 0]);
      var tmp = new Float32Array([0, 0, 0]);
      var xUnitVec3 = new Vector3(1, 0, 0);
      var yUnitVec3 = new Vector3(0, 1, 0);
      var tmpvec = new Vector3();
      var tmpMat3 = new Matrix3();
      var Quaternion = new Class({
        initialize: function Quaternion2(x, y, z, w) {
          this.onChangeCallback = NOOP;
          this.set(x, y, z, w);
        },
        x: {
          get: function() {
            return this._x;
          },
          set: function(value) {
            this._x = value;
            this.onChangeCallback(this);
          }
        },
        y: {
          get: function() {
            return this._y;
          },
          set: function(value) {
            this._y = value;
            this.onChangeCallback(this);
          }
        },
        z: {
          get: function() {
            return this._z;
          },
          set: function(value) {
            this._z = value;
            this.onChangeCallback(this);
          }
        },
        w: {
          get: function() {
            return this._w;
          },
          set: function(value) {
            this._w = value;
            this.onChangeCallback(this);
          }
        },
        copy: function(src) {
          return this.set(src);
        },
        set: function(x, y, z, w, update) {
          if (update === void 0) {
            update = true;
          }
          if (typeof x === "object") {
            this._x = x.x || 0;
            this._y = x.y || 0;
            this._z = x.z || 0;
            this._w = x.w || 0;
          } else {
            this._x = x || 0;
            this._y = y || 0;
            this._z = z || 0;
            this._w = w || 0;
          }
          if (update) {
            this.onChangeCallback(this);
          }
          return this;
        },
        add: function(v) {
          this._x += v.x;
          this._y += v.y;
          this._z += v.z;
          this._w += v.w;
          this.onChangeCallback(this);
          return this;
        },
        subtract: function(v) {
          this._x -= v.x;
          this._y -= v.y;
          this._z -= v.z;
          this._w -= v.w;
          this.onChangeCallback(this);
          return this;
        },
        scale: function(scale) {
          this._x *= scale;
          this._y *= scale;
          this._z *= scale;
          this._w *= scale;
          this.onChangeCallback(this);
          return this;
        },
        length: function() {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var w = this.w;
          return Math.sqrt(x * x + y * y + z * z + w * w);
        },
        lengthSq: function() {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var w = this.w;
          return x * x + y * y + z * z + w * w;
        },
        normalize: function() {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var w = this.w;
          var len = x * x + y * y + z * z + w * w;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            this._x = x * len;
            this._y = y * len;
            this._z = z * len;
            this._w = w * len;
          }
          this.onChangeCallback(this);
          return this;
        },
        dot: function(v) {
          return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        },
        lerp: function(v, t) {
          if (t === void 0) {
            t = 0;
          }
          var ax = this.x;
          var ay = this.y;
          var az = this.z;
          var aw = this.w;
          return this.set(ax + t * (v.x - ax), ay + t * (v.y - ay), az + t * (v.z - az), aw + t * (v.w - aw));
        },
        rotationTo: function(a, b) {
          var dot = a.x * b.x + a.y * b.y + a.z * b.z;
          if (dot < -0.999999) {
            if (tmpvec.copy(xUnitVec3).cross(a).length() < EPSILON) {
              tmpvec.copy(yUnitVec3).cross(a);
            }
            tmpvec.normalize();
            return this.setAxisAngle(tmpvec, Math.PI);
          } else if (dot > 0.999999) {
            return this.set(0, 0, 0, 1);
          } else {
            tmpvec.copy(a).cross(b);
            this._x = tmpvec.x;
            this._y = tmpvec.y;
            this._z = tmpvec.z;
            this._w = 1 + dot;
            return this.normalize();
          }
        },
        setAxes: function(view, right, up) {
          var m = tmpMat3.val;
          m[0] = right.x;
          m[3] = right.y;
          m[6] = right.z;
          m[1] = up.x;
          m[4] = up.y;
          m[7] = up.z;
          m[2] = -view.x;
          m[5] = -view.y;
          m[8] = -view.z;
          return this.fromMat3(tmpMat3).normalize();
        },
        identity: function() {
          return this.set(0, 0, 0, 1);
        },
        setAxisAngle: function(axis, rad) {
          rad = rad * 0.5;
          var s = Math.sin(rad);
          return this.set(s * axis.x, s * axis.y, s * axis.z, Math.cos(rad));
        },
        multiply: function(b) {
          var ax = this.x;
          var ay = this.y;
          var az = this.z;
          var aw = this.w;
          var bx = b.x;
          var by = b.y;
          var bz = b.z;
          var bw = b.w;
          return this.set(ax * bw + aw * bx + ay * bz - az * by, ay * bw + aw * by + az * bx - ax * bz, az * bw + aw * bz + ax * by - ay * bx, aw * bw - ax * bx - ay * by - az * bz);
        },
        slerp: function(b, t) {
          var ax = this.x;
          var ay = this.y;
          var az = this.z;
          var aw = this.w;
          var bx = b.x;
          var by = b.y;
          var bz = b.z;
          var bw = b.w;
          var cosom = ax * bx + ay * by + az * bz + aw * bw;
          if (cosom < 0) {
            cosom = -cosom;
            bx = -bx;
            by = -by;
            bz = -bz;
            bw = -bw;
          }
          var scale0 = 1 - t;
          var scale1 = t;
          if (1 - cosom > EPSILON) {
            var omega = Math.acos(cosom);
            var sinom = Math.sin(omega);
            scale0 = Math.sin((1 - t) * omega) / sinom;
            scale1 = Math.sin(t * omega) / sinom;
          }
          return this.set(scale0 * ax + scale1 * bx, scale0 * ay + scale1 * by, scale0 * az + scale1 * bz, scale0 * aw + scale1 * bw);
        },
        invert: function() {
          var a0 = this.x;
          var a1 = this.y;
          var a2 = this.z;
          var a3 = this.w;
          var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
          var invDot = dot ? 1 / dot : 0;
          return this.set(-a0 * invDot, -a1 * invDot, -a2 * invDot, a3 * invDot);
        },
        conjugate: function() {
          this._x = -this.x;
          this._y = -this.y;
          this._z = -this.z;
          this.onChangeCallback(this);
          return this;
        },
        rotateX: function(rad) {
          rad *= 0.5;
          var ax = this.x;
          var ay = this.y;
          var az = this.z;
          var aw = this.w;
          var bx = Math.sin(rad);
          var bw = Math.cos(rad);
          return this.set(ax * bw + aw * bx, ay * bw + az * bx, az * bw - ay * bx, aw * bw - ax * bx);
        },
        rotateY: function(rad) {
          rad *= 0.5;
          var ax = this.x;
          var ay = this.y;
          var az = this.z;
          var aw = this.w;
          var by = Math.sin(rad);
          var bw = Math.cos(rad);
          return this.set(ax * bw - az * by, ay * bw + aw * by, az * bw + ax * by, aw * bw - ay * by);
        },
        rotateZ: function(rad) {
          rad *= 0.5;
          var ax = this.x;
          var ay = this.y;
          var az = this.z;
          var aw = this.w;
          var bz = Math.sin(rad);
          var bw = Math.cos(rad);
          return this.set(ax * bw + ay * bz, ay * bw - ax * bz, az * bw + aw * bz, aw * bw - az * bz);
        },
        calculateW: function() {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          this.w = -Math.sqrt(1 - x * x - y * y - z * z);
          return this;
        },
        setFromEuler: function(euler, update) {
          var x = euler.x / 2;
          var y = euler.y / 2;
          var z = euler.z / 2;
          var c1 = Math.cos(x);
          var c2 = Math.cos(y);
          var c3 = Math.cos(z);
          var s1 = Math.sin(x);
          var s2 = Math.sin(y);
          var s3 = Math.sin(z);
          switch (euler.order) {
            case "XYZ": {
              this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
              break;
            }
            case "YXZ": {
              this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
              break;
            }
            case "ZXY": {
              this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
              break;
            }
            case "ZYX": {
              this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
              break;
            }
            case "YZX": {
              this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
              break;
            }
            case "XZY": {
              this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
              break;
            }
          }
          return this;
        },
        setFromRotationMatrix: function(mat4) {
          var m = mat4.val;
          var m11 = m[0];
          var m12 = m[4];
          var m13 = m[8];
          var m21 = m[1];
          var m22 = m[5];
          var m23 = m[9];
          var m31 = m[2];
          var m32 = m[6];
          var m33 = m[10];
          var trace = m11 + m22 + m33;
          var s;
          if (trace > 0) {
            s = 0.5 / Math.sqrt(trace + 1);
            this.set((m32 - m23) * s, (m13 - m31) * s, (m21 - m12) * s, 0.25 / s);
          } else if (m11 > m22 && m11 > m33) {
            s = 2 * Math.sqrt(1 + m11 - m22 - m33);
            this.set(0.25 * s, (m12 + m21) / s, (m13 + m31) / s, (m32 - m23) / s);
          } else if (m22 > m33) {
            s = 2 * Math.sqrt(1 + m22 - m11 - m33);
            this.set((m12 + m21) / s, 0.25 * s, (m23 + m32) / s, (m13 - m31) / s);
          } else {
            s = 2 * Math.sqrt(1 + m33 - m11 - m22);
            this.set((m13 + m31) / s, (m23 + m32) / s, 0.25 * s, (m21 - m12) / s);
          }
          return this;
        },
        fromMat3: function(mat) {
          var m = mat.val;
          var fTrace = m[0] + m[4] + m[8];
          var fRoot;
          if (fTrace > 0) {
            fRoot = Math.sqrt(fTrace + 1);
            this.w = 0.5 * fRoot;
            fRoot = 0.5 / fRoot;
            this._x = (m[7] - m[5]) * fRoot;
            this._y = (m[2] - m[6]) * fRoot;
            this._z = (m[3] - m[1]) * fRoot;
          } else {
            var i = 0;
            if (m[4] > m[0]) {
              i = 1;
            }
            if (m[8] > m[i * 3 + i]) {
              i = 2;
            }
            var j = siNext[i];
            var k = siNext[j];
            fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
            tmp[i] = 0.5 * fRoot;
            fRoot = 0.5 / fRoot;
            tmp[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
            tmp[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
            this._x = tmp[0];
            this._y = tmp[1];
            this._z = tmp[2];
            this._w = (m[k * 3 + j] - m[j * 3 + k]) * fRoot;
          }
          this.onChangeCallback(this);
          return this;
        }
      });
      module.exports = Quaternion;
    }
  });

  // ../../node_modules/phaser/src/math/RotateVec3.js
  var require_RotateVec3 = __commonJS({
    "../../node_modules/phaser/src/math/RotateVec3.js": function(exports, module) {
      var Vector3 = require_Vector3();
      var Matrix4 = require_Matrix4();
      var Quaternion = require_Quaternion();
      var tmpMat4 = new Matrix4();
      var tmpQuat = new Quaternion();
      var tmpVec3 = new Vector3();
      var RotateVec3 = function(vec, axis, radians) {
        tmpQuat.setAxisAngle(axis, radians);
        tmpMat4.fromRotationTranslation(tmpQuat, tmpVec3.set(0, 0, 0));
        return vec.transformMat4(tmpMat4);
      };
      module.exports = RotateVec3;
    }
  });

  // ../../node_modules/phaser/src/math/index.js
  var require_math = __commonJS({
    "../../node_modules/phaser/src/math/index.js": function(exports, module) {
      var CONST = require_const4();
      var Extend = require_Extend();
      var PhaserMath = {
        Angle: require_angle(),
        Distance: require_distance(),
        Easing: require_easing(),
        Fuzzy: require_fuzzy(),
        Interpolation: require_interpolation(),
        Pow2: require_pow2(),
        Snap: require_snap(),
        RandomDataGenerator: require_RandomDataGenerator(),
        Average: require_Average(),
        Bernstein: require_Bernstein(),
        Between: require_Between2(),
        CatmullRom: require_CatmullRom(),
        CeilTo: require_CeilTo(),
        Clamp: require_Clamp(),
        DegToRad: require_DegToRad(),
        Difference: require_Difference(),
        Euler: require_Euler(),
        Factorial: require_Factorial(),
        FloatBetween: require_FloatBetween(),
        FloorTo: require_FloorTo(),
        FromPercent: require_FromPercent(),
        GetSpeed: require_GetSpeed(),
        IsEven: require_IsEven(),
        IsEvenStrict: require_IsEvenStrict(),
        Linear: require_Linear2(),
        LinearXY: require_LinearXY(),
        MaxAdd: require_MaxAdd(),
        Median: require_Median(),
        MinSub: require_MinSub(),
        Percent: require_Percent(),
        RadToDeg: require_RadToDeg(),
        RandomXY: require_RandomXY(),
        RandomXYZ: require_RandomXYZ(),
        RandomXYZW: require_RandomXYZW(),
        Rotate: require_Rotate(),
        RotateAround: require_RotateAround(),
        RotateAroundDistance: require_RotateAroundDistance(),
        RotateTo: require_RotateTo3(),
        RoundAwayFromZero: require_RoundAwayFromZero(),
        RoundTo: require_RoundTo(),
        SinCosTableGenerator: require_SinCosTableGenerator(),
        SmootherStep: require_SmootherStep(),
        SmoothStep: require_SmoothStep(),
        ToXY: require_ToXY(),
        TransformXY: require_TransformXY(),
        Within: require_Within(),
        Wrap: require_Wrap(),
        Vector2: require_Vector2(),
        Vector3: require_Vector3(),
        Vector4: require_Vector4(),
        Matrix3: require_Matrix3(),
        Matrix4: require_Matrix4(),
        Quaternion: require_Quaternion(),
        RotateVec3: require_RotateVec3()
      };
      PhaserMath = Extend(false, PhaserMath, CONST);
      module.exports = PhaserMath;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/const.js
  var require_const6 = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/const.js": function(exports, module) {
      var PIPELINE_CONST = {
        BITMAPMASK_PIPELINE: "BitmapMaskPipeline",
        LIGHT_PIPELINE: "Light2D",
        POINTLIGHT_PIPELINE: "PointLightPipeline",
        SINGLE_PIPELINE: "SinglePipeline",
        MULTI_PIPELINE: "MultiPipeline",
        ROPE_PIPELINE: "RopePipeline",
        GRAPHICS_PIPELINE: "GraphicsPipeline",
        POSTFX_PIPELINE: "PostFXPipeline",
        UTILITY_PIPELINE: "UtilityPipeline",
        MOBILE_PIPELINE: "MobilePipeline"
      };
      module.exports = PIPELINE_CONST;
    }
  });

  // ../../node_modules/phaser/src/core/Config.js
  var require_Config = __commonJS({
    "../../node_modules/phaser/src/core/Config.js": function(exports, module) {
      var Class = require_Class();
      var CONST = require_const();
      var DefaultPlugins = require_DefaultPlugins();
      var Device = require_device();
      var GetFastValue = require_GetFastValue();
      var GetValue = require_GetValue();
      var IsPlainObject = require_IsPlainObject();
      var NOOP = require_NOOP();
      var PhaserMath = require_math();
      var PIPELINE_CONST = require_const6();
      var ValueToColor = require_ValueToColor();
      var Config = new Class({
        initialize: function Config2(config) {
          if (config === void 0) {
            config = {};
          }
          var defaultBannerColor = [
            "#ff0000",
            "#ffff00",
            "#00ff00",
            "#00ffff",
            "#000000"
          ];
          var defaultBannerTextColor = "#ffffff";
          var scaleConfig = GetValue(config, "scale", null);
          this.width = GetValue(scaleConfig, "width", 1024, config);
          this.height = GetValue(scaleConfig, "height", 768, config);
          this.zoom = GetValue(scaleConfig, "zoom", 1, config);
          this.parent = GetValue(scaleConfig, "parent", void 0, config);
          this.scaleMode = GetValue(scaleConfig, scaleConfig ? "mode" : "scaleMode", 0, config);
          this.expandParent = GetValue(scaleConfig, "expandParent", true, config);
          this.autoRound = GetValue(scaleConfig, "autoRound", false, config);
          this.autoCenter = GetValue(scaleConfig, "autoCenter", 0, config);
          this.resizeInterval = GetValue(scaleConfig, "resizeInterval", 500, config);
          this.fullscreenTarget = GetValue(scaleConfig, "fullscreenTarget", null, config);
          this.minWidth = GetValue(scaleConfig, "minWidth", 0, config);
          this.maxWidth = GetValue(scaleConfig, "maxWidth", 0, config);
          this.minHeight = GetValue(scaleConfig, "minHeight", 0, config);
          this.maxHeight = GetValue(scaleConfig, "maxHeight", 0, config);
          this.renderType = GetValue(config, "type", CONST.AUTO);
          this.canvas = GetValue(config, "canvas", null);
          this.context = GetValue(config, "context", null);
          this.canvasStyle = GetValue(config, "canvasStyle", null);
          this.customEnvironment = GetValue(config, "customEnvironment", false);
          this.sceneConfig = GetValue(config, "scene", null);
          this.seed = GetValue(config, "seed", [(Date.now() * Math.random()).toString()]);
          PhaserMath.RND = new PhaserMath.RandomDataGenerator(this.seed);
          this.gameTitle = GetValue(config, "title", "");
          this.gameURL = GetValue(config, "url", "https://phaser.io");
          this.gameVersion = GetValue(config, "version", "");
          this.autoFocus = GetValue(config, "autoFocus", true);
          this.stableSort = GetValue(config, "stableSort", -1);
          if (this.stableSort === -1) {
            this.stableSort = Device.browser.es2019 ? 1 : 0;
          }
          Device.features.stableSort = this.stableSort;
          this.domCreateContainer = GetValue(config, "dom.createContainer", false);
          this.domPointerEvents = GetValue(config, "dom.pointerEvents", "none");
          this.inputKeyboard = GetValue(config, "input.keyboard", true);
          this.inputKeyboardEventTarget = GetValue(config, "input.keyboard.target", window);
          this.inputKeyboardCapture = GetValue(config, "input.keyboard.capture", []);
          this.inputMouse = GetValue(config, "input.mouse", true);
          this.inputMouseEventTarget = GetValue(config, "input.mouse.target", null);
          this.inputMousePreventDefaultDown = GetValue(config, "input.mouse.preventDefaultDown", true);
          this.inputMousePreventDefaultUp = GetValue(config, "input.mouse.preventDefaultUp", true);
          this.inputMousePreventDefaultMove = GetValue(config, "input.mouse.preventDefaultMove", true);
          this.inputMousePreventDefaultWheel = GetValue(config, "input.mouse.preventDefaultWheel", true);
          this.inputTouch = GetValue(config, "input.touch", Device.input.touch);
          this.inputTouchEventTarget = GetValue(config, "input.touch.target", null);
          this.inputTouchCapture = GetValue(config, "input.touch.capture", true);
          this.inputActivePointers = GetValue(config, "input.activePointers", 1);
          this.inputSmoothFactor = GetValue(config, "input.smoothFactor", 0);
          this.inputWindowEvents = GetValue(config, "input.windowEvents", true);
          this.inputGamepad = GetValue(config, "input.gamepad", false);
          this.inputGamepadEventTarget = GetValue(config, "input.gamepad.target", window);
          this.disableContextMenu = GetValue(config, "disableContextMenu", false);
          this.audio = GetValue(config, "audio", {});
          this.hideBanner = GetValue(config, "banner", null) === false;
          this.hidePhaser = GetValue(config, "banner.hidePhaser", false);
          this.bannerTextColor = GetValue(config, "banner.text", defaultBannerTextColor);
          this.bannerBackgroundColor = GetValue(config, "banner.background", defaultBannerColor);
          if (this.gameTitle === "" && this.hidePhaser) {
            this.hideBanner = true;
          }
          this.fps = GetValue(config, "fps", null);
          var renderConfig = GetValue(config, "render", null);
          this.pipeline = GetValue(renderConfig, "pipeline", null, config);
          this.autoMobilePipeline = GetValue(renderConfig, "autoMobilePipeline", true, config);
          this.defaultPipeline = GetValue(renderConfig, "defaultPipeline", PIPELINE_CONST.MULTI_PIPELINE, config);
          this.antialias = GetValue(renderConfig, "antialias", true, config);
          this.antialiasGL = GetValue(renderConfig, "antialiasGL", true, config);
          this.mipmapFilter = GetValue(renderConfig, "mipmapFilter", "", config);
          this.desynchronized = GetValue(renderConfig, "desynchronized", false, config);
          this.roundPixels = GetValue(renderConfig, "roundPixels", false, config);
          this.pixelArt = GetValue(renderConfig, "pixelArt", this.zoom !== 1, config);
          if (this.pixelArt) {
            this.antialias = false;
            this.antialiasGL = false;
            this.roundPixels = true;
          }
          this.transparent = GetValue(renderConfig, "transparent", false, config);
          this.clearBeforeRender = GetValue(renderConfig, "clearBeforeRender", true, config);
          this.preserveDrawingBuffer = GetValue(renderConfig, "preserveDrawingBuffer", false, config);
          this.premultipliedAlpha = GetValue(renderConfig, "premultipliedAlpha", true, config);
          this.failIfMajorPerformanceCaveat = GetValue(renderConfig, "failIfMajorPerformanceCaveat", false, config);
          this.powerPreference = GetValue(renderConfig, "powerPreference", "default", config);
          this.batchSize = GetValue(renderConfig, "batchSize", 4096, config);
          this.maxTextures = GetValue(renderConfig, "maxTextures", -1, config);
          this.maxLights = GetValue(renderConfig, "maxLights", 10, config);
          var bgc = GetValue(config, "backgroundColor", 0);
          this.backgroundColor = ValueToColor(bgc);
          if (this.transparent) {
            this.backgroundColor = ValueToColor(0);
            this.backgroundColor.alpha = 0;
          }
          this.preBoot = GetValue(config, "callbacks.preBoot", NOOP);
          this.postBoot = GetValue(config, "callbacks.postBoot", NOOP);
          this.physics = GetValue(config, "physics", {});
          this.defaultPhysicsSystem = GetValue(this.physics, "default", false);
          this.loaderBaseURL = GetValue(config, "loader.baseURL", "");
          this.loaderPath = GetValue(config, "loader.path", "");
          this.loaderMaxParallelDownloads = GetValue(config, "loader.maxParallelDownloads", Device.os.android ? 6 : 32);
          this.loaderCrossOrigin = GetValue(config, "loader.crossOrigin", void 0);
          this.loaderResponseType = GetValue(config, "loader.responseType", "");
          this.loaderAsync = GetValue(config, "loader.async", true);
          this.loaderUser = GetValue(config, "loader.user", "");
          this.loaderPassword = GetValue(config, "loader.password", "");
          this.loaderTimeout = GetValue(config, "loader.timeout", 0);
          this.loaderWithCredentials = GetValue(config, "loader.withCredentials", false);
          this.loaderImageLoadType = GetValue(config, "loader.imageLoadType", "XHR");
          this.loaderLocalScheme = GetValue(config, "loader.localScheme", ["file://", "capacitor://"]);
          this.installGlobalPlugins = [];
          this.installScenePlugins = [];
          var plugins = GetValue(config, "plugins", null);
          var defaultPlugins = DefaultPlugins.DefaultScene;
          if (plugins) {
            if (Array.isArray(plugins)) {
              this.defaultPlugins = plugins;
            } else if (IsPlainObject(plugins)) {
              this.installGlobalPlugins = GetFastValue(plugins, "global", []);
              this.installScenePlugins = GetFastValue(plugins, "scene", []);
              if (Array.isArray(plugins.default)) {
                defaultPlugins = plugins.default;
              } else if (Array.isArray(plugins.defaultMerge)) {
                defaultPlugins = defaultPlugins.concat(plugins.defaultMerge);
              }
            }
          }
          this.defaultPlugins = defaultPlugins;
          var pngPrefix = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg";
          this.defaultImage = GetValue(config, "images.default", pngPrefix + "AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==");
          this.missingImage = GetValue(config, "images.missing", pngPrefix + "CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==");
          this.whiteImage = GetValue(config, "images.white", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABdJREFUeNpi/P//PwMMMDEgAdwcgAADAJZuAwXJYZOzAAAAAElFTkSuQmCC");
          if (window) {
            if (window.FORCE_WEBGL) {
              this.renderType = CONST.WEBGL;
            } else if (window.FORCE_CANVAS) {
              this.renderType = CONST.CANVAS;
            }
          }
        }
      });
      module.exports = Config;
    }
  });

  // ../../node_modules/phaser/src/display/canvas/CanvasInterpolation.js
  var require_CanvasInterpolation = __commonJS({
    "../../node_modules/phaser/src/display/canvas/CanvasInterpolation.js": function(exports, module) {
      var CanvasInterpolation = {
        setCrisp: function(canvas) {
          var types = ["optimizeSpeed", "-moz-crisp-edges", "-o-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "crisp-edges", "pixelated"];
          types.forEach(function(type) {
            canvas.style["image-rendering"] = type;
          });
          canvas.style.msInterpolationMode = "nearest-neighbor";
          return canvas;
        },
        setBicubic: function(canvas) {
          canvas.style["image-rendering"] = "auto";
          canvas.style.msInterpolationMode = "bicubic";
          return canvas;
        }
      };
      module.exports = CanvasInterpolation;
    }
  });

  // ../../node_modules/phaser/src/renderer/snapshot/CanvasSnapshot.js
  var require_CanvasSnapshot = __commonJS({
    "../../node_modules/phaser/src/renderer/snapshot/CanvasSnapshot.js": function(exports, module) {
      var CanvasPool = require_CanvasPool();
      var Color = require_Color();
      var GetFastValue = require_GetFastValue();
      var CanvasSnapshot = function(canvas, config) {
        var callback = GetFastValue(config, "callback");
        var type = GetFastValue(config, "type", "image/png");
        var encoderOptions = GetFastValue(config, "encoder", 0.92);
        var x = Math.abs(Math.round(GetFastValue(config, "x", 0)));
        var y = Math.abs(Math.round(GetFastValue(config, "y", 0)));
        var width = Math.floor(GetFastValue(config, "width", canvas.width));
        var height = Math.floor(GetFastValue(config, "height", canvas.height));
        var getPixel = GetFastValue(config, "getPixel", false);
        if (getPixel) {
          var context = canvas.getContext("2d");
          var imageData = context.getImageData(x, y, 1, 1);
          var data = imageData.data;
          callback.call(null, new Color(data[0], data[1], data[2], data[3]));
        } else if (x !== 0 || y !== 0 || width !== canvas.width || height !== canvas.height) {
          var copyCanvas = CanvasPool.createWebGL(this, width, height);
          var ctx = copyCanvas.getContext("2d");
          if (width > 0 && height > 0) {
            ctx.drawImage(canvas, x, y, width, height, 0, 0, width, height);
          }
          var image1 = new Image();
          image1.onerror = function() {
            callback.call(null);
            CanvasPool.remove(copyCanvas);
          };
          image1.onload = function() {
            callback.call(null, image1);
            CanvasPool.remove(copyCanvas);
          };
          image1.src = copyCanvas.toDataURL(type, encoderOptions);
        } else {
          var image2 = new Image();
          image2.onerror = function() {
            callback.call(null);
          };
          image2.onload = function() {
            callback.call(null, image2);
          };
          image2.src = canvas.toDataURL(type, encoderOptions);
        }
      };
      module.exports = CanvasSnapshot;
    }
  });

  // ../../node_modules/phaser/src/renderer/events/POST_RENDER_EVENT.js
  var require_POST_RENDER_EVENT3 = __commonJS({
    "../../node_modules/phaser/src/renderer/events/POST_RENDER_EVENT.js": function(exports, module) {
      module.exports = "postrender";
    }
  });

  // ../../node_modules/phaser/src/renderer/events/PRE_RENDER_EVENT.js
  var require_PRE_RENDER_EVENT4 = __commonJS({
    "../../node_modules/phaser/src/renderer/events/PRE_RENDER_EVENT.js": function(exports, module) {
      module.exports = "prerender";
    }
  });

  // ../../node_modules/phaser/src/renderer/events/RENDER_EVENT.js
  var require_RENDER_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/renderer/events/RENDER_EVENT.js": function(exports, module) {
      module.exports = "render";
    }
  });

  // ../../node_modules/phaser/src/renderer/events/RESIZE_EVENT.js
  var require_RESIZE_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/renderer/events/RESIZE_EVENT.js": function(exports, module) {
      module.exports = "resize";
    }
  });

  // ../../node_modules/phaser/src/renderer/events/index.js
  var require_events8 = __commonJS({
    "../../node_modules/phaser/src/renderer/events/index.js": function(exports, module) {
      module.exports = {
        POST_RENDER: require_POST_RENDER_EVENT3(),
        PRE_RENDER: require_PRE_RENDER_EVENT4(),
        RENDER: require_RENDER_EVENT2(),
        RESIZE: require_RESIZE_EVENT2()
      };
    }
  });

  // ../../node_modules/phaser/src/renderer/canvas/utils/GetBlendModes.js
  var require_GetBlendModes = __commonJS({
    "../../node_modules/phaser/src/renderer/canvas/utils/GetBlendModes.js": function(exports, module) {
      var modes = require_BlendModes();
      var CanvasFeatures = require_CanvasFeatures();
      var GetBlendModes = function() {
        var output = [];
        var useNew = CanvasFeatures.supportNewBlendModes;
        var so = "source-over";
        output[modes.NORMAL] = so;
        output[modes.ADD] = "lighter";
        output[modes.MULTIPLY] = useNew ? "multiply" : so;
        output[modes.SCREEN] = useNew ? "screen" : so;
        output[modes.OVERLAY] = useNew ? "overlay" : so;
        output[modes.DARKEN] = useNew ? "darken" : so;
        output[modes.LIGHTEN] = useNew ? "lighten" : so;
        output[modes.COLOR_DODGE] = useNew ? "color-dodge" : so;
        output[modes.COLOR_BURN] = useNew ? "color-burn" : so;
        output[modes.HARD_LIGHT] = useNew ? "hard-light" : so;
        output[modes.SOFT_LIGHT] = useNew ? "soft-light" : so;
        output[modes.DIFFERENCE] = useNew ? "difference" : so;
        output[modes.EXCLUSION] = useNew ? "exclusion" : so;
        output[modes.HUE] = useNew ? "hue" : so;
        output[modes.SATURATION] = useNew ? "saturation" : so;
        output[modes.COLOR] = useNew ? "color" : so;
        output[modes.LUMINOSITY] = useNew ? "luminosity" : so;
        output[modes.ERASE] = "destination-out";
        output[modes.SOURCE_IN] = "source-in";
        output[modes.SOURCE_OUT] = "source-out";
        output[modes.SOURCE_ATOP] = "source-atop";
        output[modes.DESTINATION_OVER] = "destination-over";
        output[modes.DESTINATION_IN] = "destination-in";
        output[modes.DESTINATION_OUT] = "destination-out";
        output[modes.DESTINATION_ATOP] = "destination-atop";
        output[modes.LIGHTER] = "lighter";
        output[modes.COPY] = "copy";
        output[modes.XOR] = "xor";
        return output;
      };
      module.exports = GetBlendModes;
    }
  });

  // ../../node_modules/phaser/src/textures/events/ADD_EVENT.js
  var require_ADD_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/textures/events/ADD_EVENT.js": function(exports, module) {
      module.exports = "addtexture";
    }
  });

  // ../../node_modules/phaser/src/textures/events/ADD_KEY_EVENT.js
  var require_ADD_KEY_EVENT = __commonJS({
    "../../node_modules/phaser/src/textures/events/ADD_KEY_EVENT.js": function(exports, module) {
      module.exports = "addtexture-";
    }
  });

  // ../../node_modules/phaser/src/textures/events/ERROR_EVENT.js
  var require_ERROR_EVENT = __commonJS({
    "../../node_modules/phaser/src/textures/events/ERROR_EVENT.js": function(exports, module) {
      module.exports = "onerror";
    }
  });

  // ../../node_modules/phaser/src/textures/events/LOAD_EVENT.js
  var require_LOAD_EVENT = __commonJS({
    "../../node_modules/phaser/src/textures/events/LOAD_EVENT.js": function(exports, module) {
      module.exports = "onload";
    }
  });

  // ../../node_modules/phaser/src/textures/events/READY_EVENT.js
  var require_READY_EVENT3 = __commonJS({
    "../../node_modules/phaser/src/textures/events/READY_EVENT.js": function(exports, module) {
      module.exports = "ready";
    }
  });

  // ../../node_modules/phaser/src/textures/events/REMOVE_EVENT.js
  var require_REMOVE_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/textures/events/REMOVE_EVENT.js": function(exports, module) {
      module.exports = "removetexture";
    }
  });

  // ../../node_modules/phaser/src/textures/events/REMOVE_KEY_EVENT.js
  var require_REMOVE_KEY_EVENT = __commonJS({
    "../../node_modules/phaser/src/textures/events/REMOVE_KEY_EVENT.js": function(exports, module) {
      module.exports = "removetexture-";
    }
  });

  // ../../node_modules/phaser/src/textures/events/index.js
  var require_events9 = __commonJS({
    "../../node_modules/phaser/src/textures/events/index.js": function(exports, module) {
      module.exports = {
        ADD: require_ADD_EVENT2(),
        ADD_KEY: require_ADD_KEY_EVENT(),
        ERROR: require_ERROR_EVENT(),
        LOAD: require_LOAD_EVENT(),
        READY: require_READY_EVENT3(),
        REMOVE: require_REMOVE_EVENT2(),
        REMOVE_KEY: require_REMOVE_KEY_EVENT()
      };
    }
  });

  // ../../node_modules/phaser/src/renderer/canvas/CanvasRenderer.js
  var require_CanvasRenderer = __commonJS({
    "../../node_modules/phaser/src/renderer/canvas/CanvasRenderer.js": function(exports, module) {
      var CameraEvents = require_events6();
      var CanvasSnapshot = require_CanvasSnapshot();
      var Class = require_Class();
      var CONST = require_const();
      var EventEmitter = require_eventemitter3();
      var Events = require_events8();
      var GetBlendModes = require_GetBlendModes();
      var ScaleEvents = require_events7();
      var TextureEvents = require_events9();
      var TransformMatrix = require_TransformMatrix();
      var CanvasRenderer = new Class({
        Extends: EventEmitter,
        initialize: function CanvasRenderer2(game) {
          EventEmitter.call(this);
          var gameConfig = game.config;
          this.config = {
            clearBeforeRender: gameConfig.clearBeforeRender,
            backgroundColor: gameConfig.backgroundColor,
            antialias: gameConfig.antialias,
            roundPixels: gameConfig.roundPixels
          };
          this.game = game;
          this.type = CONST.CANVAS;
          this.drawCount = 0;
          this.width = 0;
          this.height = 0;
          this.gameCanvas = game.canvas;
          var contextOptions = {
            alpha: game.config.transparent,
            desynchronized: game.config.desynchronized,
            willReadFrequently: false
          };
          this.gameContext = gameConfig.context ? gameConfig.context : this.gameCanvas.getContext("2d", contextOptions);
          this.currentContext = this.gameContext;
          this.antialias = game.config.antialias;
          this.blendModes = GetBlendModes();
          this.snapshotState = {
            x: 0,
            y: 0,
            width: 1,
            height: 1,
            getPixel: false,
            callback: null,
            type: "image/png",
            encoder: 0.92
          };
          this._tempMatrix1 = new TransformMatrix();
          this._tempMatrix2 = new TransformMatrix();
          this._tempMatrix3 = new TransformMatrix();
          this.isBooted = false;
          this.init();
        },
        init: function() {
          this.game.textures.once(TextureEvents.READY, this.boot, this);
        },
        boot: function() {
          var game = this.game;
          var baseSize = game.scale.baseSize;
          this.width = baseSize.width;
          this.height = baseSize.height;
          this.isBooted = true;
          game.scale.on(ScaleEvents.RESIZE, this.onResize, this);
          this.resize(baseSize.width, baseSize.height);
        },
        onResize: function(gameSize, baseSize) {
          if (baseSize.width !== this.width || baseSize.height !== this.height) {
            this.resize(baseSize.width, baseSize.height);
          }
        },
        resize: function(width, height) {
          this.width = width;
          this.height = height;
          this.emit(Events.RESIZE, width, height);
        },
        resetTransform: function() {
          this.currentContext.setTransform(1, 0, 0, 1, 0, 0);
        },
        setBlendMode: function(blendMode) {
          this.currentContext.globalCompositeOperation = blendMode;
          return this;
        },
        setContext: function(ctx) {
          this.currentContext = ctx ? ctx : this.gameContext;
          return this;
        },
        setAlpha: function(alpha) {
          this.currentContext.globalAlpha = alpha;
          return this;
        },
        preRender: function() {
          var ctx = this.gameContext;
          var config = this.config;
          var width = this.width;
          var height = this.height;
          ctx.globalAlpha = 1;
          ctx.globalCompositeOperation = "source-over";
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          if (config.clearBeforeRender) {
            ctx.clearRect(0, 0, width, height);
            if (!config.transparent) {
              ctx.fillStyle = config.backgroundColor.rgba;
              ctx.fillRect(0, 0, width, height);
            }
          }
          ctx.save();
          this.drawCount = 0;
          this.emit(Events.PRE_RENDER);
        },
        render: function(scene, children, camera) {
          var childCount = children.length;
          this.emit(Events.RENDER, scene, camera);
          var cx = camera.x;
          var cy = camera.y;
          var cw = camera.width;
          var ch = camera.height;
          var ctx = camera.renderToTexture ? camera.context : scene.sys.context;
          ctx.save();
          if (this.game.scene.customViewports) {
            ctx.beginPath();
            ctx.rect(cx, cy, cw, ch);
            ctx.clip();
          }
          camera.emit(CameraEvents.PRE_RENDER, camera);
          this.currentContext = ctx;
          var mask = camera.mask;
          if (mask) {
            mask.preRenderCanvas(this, null, camera._maskCamera);
          }
          if (!camera.transparent) {
            ctx.fillStyle = camera.backgroundColor.rgba;
            ctx.fillRect(cx, cy, cw, ch);
          }
          ctx.globalAlpha = camera.alpha;
          ctx.globalCompositeOperation = "source-over";
          this.drawCount += childCount;
          if (camera.renderToTexture) {
            camera.emit(CameraEvents.PRE_RENDER, camera);
          }
          camera.matrix.copyToContext(ctx);
          for (var i = 0; i < childCount; i++) {
            var child = children[i];
            if (child.mask) {
              child.mask.preRenderCanvas(this, child, camera);
            }
            child.renderCanvas(this, child, camera);
            if (child.mask) {
              child.mask.postRenderCanvas(this, child, camera);
            }
          }
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.globalCompositeOperation = "source-over";
          ctx.globalAlpha = 1;
          camera.flashEffect.postRenderCanvas(ctx);
          camera.fadeEffect.postRenderCanvas(ctx);
          camera.dirty = false;
          if (mask) {
            mask.postRenderCanvas(this);
          }
          ctx.restore();
          if (camera.renderToTexture) {
            camera.emit(CameraEvents.POST_RENDER, camera);
            if (camera.renderToGame) {
              scene.sys.context.drawImage(camera.canvas, cx, cy);
            }
          }
          camera.emit(CameraEvents.POST_RENDER, camera);
        },
        postRender: function() {
          var ctx = this.gameContext;
          ctx.restore();
          this.emit(Events.POST_RENDER);
          var state = this.snapshotState;
          if (state.callback) {
            CanvasSnapshot(this.gameCanvas, state);
            state.callback = null;
          }
        },
        snapshotCanvas: function(canvas, callback, getPixel, x, y, width, height, type, encoderOptions) {
          if (getPixel === void 0) {
            getPixel = false;
          }
          this.snapshotArea(x, y, width, height, callback, type, encoderOptions);
          var state = this.snapshotState;
          state.getPixel = getPixel;
          CanvasSnapshot(canvas, state);
          state.callback = null;
          return this;
        },
        snapshot: function(callback, type, encoderOptions) {
          return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, callback, type, encoderOptions);
        },
        snapshotArea: function(x, y, width, height, callback, type, encoderOptions) {
          var state = this.snapshotState;
          state.callback = callback;
          state.type = type;
          state.encoder = encoderOptions;
          state.getPixel = false;
          state.x = x;
          state.y = y;
          state.width = Math.min(width, this.gameCanvas.width);
          state.height = Math.min(height, this.gameCanvas.height);
          return this;
        },
        snapshotPixel: function(x, y, callback) {
          this.snapshotArea(x, y, 1, 1, callback);
          this.snapshotState.getPixel = true;
          return this;
        },
        batchSprite: function(sprite, frame, camera, parentTransformMatrix) {
          var alpha = camera.alpha * sprite.alpha;
          if (alpha === 0) {
            return;
          }
          var ctx = this.currentContext;
          var camMatrix = this._tempMatrix1;
          var spriteMatrix = this._tempMatrix2;
          var cd = frame.canvasData;
          var frameX = cd.x;
          var frameY = cd.y;
          var frameWidth = frame.cutWidth;
          var frameHeight = frame.cutHeight;
          var customPivot = frame.customPivot;
          var res = frame.source.resolution;
          var displayOriginX = sprite.displayOriginX;
          var displayOriginY = sprite.displayOriginY;
          var x = -displayOriginX + frame.x;
          var y = -displayOriginY + frame.y;
          if (sprite.isCropped) {
            var crop = sprite._crop;
            if (crop.flipX !== sprite.flipX || crop.flipY !== sprite.flipY) {
              frame.updateCropUVs(crop, sprite.flipX, sprite.flipY);
            }
            frameWidth = crop.cw;
            frameHeight = crop.ch;
            frameX = crop.cx;
            frameY = crop.cy;
            x = -displayOriginX + crop.x;
            y = -displayOriginY + crop.y;
            if (sprite.flipX) {
              if (x >= 0) {
                x = -(x + frameWidth);
              } else if (x < 0) {
                x = Math.abs(x) - frameWidth;
              }
            }
            if (sprite.flipY) {
              if (y >= 0) {
                y = -(y + frameHeight);
              } else if (y < 0) {
                y = Math.abs(y) - frameHeight;
              }
            }
          }
          var flipX = 1;
          var flipY = 1;
          if (sprite.flipX) {
            if (!customPivot) {
              x += -frame.realWidth + displayOriginX * 2;
            }
            flipX = -1;
          }
          if (sprite.flipY) {
            if (!customPivot) {
              y += -frame.realHeight + displayOriginY * 2;
            }
            flipY = -1;
          }
          var gx = sprite.x;
          var gy = sprite.y;
          if (camera.roundPixels) {
            gx = Math.floor(gx);
            gy = Math.floor(gy);
          }
          spriteMatrix.applyITRS(gx, gy, sprite.rotation, sprite.scaleX * flipX, sprite.scaleY * flipY);
          camMatrix.copyFrom(camera.matrix);
          if (parentTransformMatrix) {
            camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * sprite.scrollFactorX, -camera.scrollY * sprite.scrollFactorY);
            spriteMatrix.e = gx;
            spriteMatrix.f = gy;
          } else {
            spriteMatrix.e -= camera.scrollX * sprite.scrollFactorX;
            spriteMatrix.f -= camera.scrollY * sprite.scrollFactorY;
          }
          camMatrix.multiply(spriteMatrix);
          if (camera.roundPixels) {
            camMatrix.e = Math.round(camMatrix.e);
            camMatrix.f = Math.round(camMatrix.f);
          }
          ctx.save();
          camMatrix.setToContext(ctx);
          ctx.globalCompositeOperation = this.blendModes[sprite.blendMode];
          ctx.globalAlpha = alpha;
          ctx.imageSmoothingEnabled = !frame.source.scaleMode;
          if (sprite.mask) {
            sprite.mask.preRenderCanvas(this, sprite, camera);
          }
          if (frameWidth > 0 && frameHeight > 0) {
            ctx.drawImage(frame.source.image, frameX, frameY, frameWidth, frameHeight, x, y, frameWidth / res, frameHeight / res);
          }
          if (sprite.mask) {
            sprite.mask.postRenderCanvas(this, sprite, camera);
          }
          ctx.restore();
        },
        destroy: function() {
          this.removeAllListeners();
          this.game = null;
          this.gameCanvas = null;
          this.gameContext = null;
        }
      });
      module.exports = CanvasRenderer;
    }
  });

  // ../../node_modules/phaser/src/utils/array/Remove.js
  var require_Remove = __commonJS({
    "../../node_modules/phaser/src/utils/array/Remove.js": function(exports, module) {
      var SpliceOne = require_SpliceOne();
      var Remove = function(array, item, callback, context) {
        if (context === void 0) {
          context = array;
        }
        var index;
        if (!Array.isArray(item)) {
          index = array.indexOf(item);
          if (index !== -1) {
            SpliceOne(array, index);
            if (callback) {
              callback.call(context, item);
            }
            return item;
          } else {
            return null;
          }
        }
        var itemLength = item.length - 1;
        var removed = [];
        while (itemLength >= 0) {
          var entry = item[itemLength];
          index = array.indexOf(entry);
          if (index !== -1) {
            SpliceOne(array, index);
            removed.push(entry);
            if (callback) {
              callback.call(context, entry);
            }
          }
          itemLength--;
        }
        return removed;
      };
      module.exports = Remove;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/RenderTarget.js
  var require_RenderTarget = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/RenderTarget.js": function(exports, module) {
      var Class = require_Class();
      var Events = require_events8();
      var RenderTarget = new Class({
        initialize: function RenderTarget2(renderer, width, height, scale, minFilter, autoClear, autoResize) {
          if (scale === void 0) {
            scale = 1;
          }
          if (minFilter === void 0) {
            minFilter = 0;
          }
          if (autoClear === void 0) {
            autoClear = true;
          }
          if (autoResize === void 0) {
            autoResize = false;
          }
          this.renderer = renderer;
          this.framebuffer = null;
          this.texture = null;
          this.width = 0;
          this.height = 0;
          this.scale = scale;
          this.minFilter = minFilter;
          this.autoClear = autoClear;
          this.autoResize = false;
          this.resize(width, height);
          if (autoResize) {
            this.setAutoResize(true);
          }
        },
        setAutoResize: function(autoResize) {
          if (autoResize && !this.autoResize) {
            this.renderer.on(Events.RESIZE, this.resize, this);
            this.autoResize = true;
          } else if (!autoResize && this.autoResize) {
            this.renderer.off(Events.RESIZE, this.resize, this);
            this.autoResize = false;
          }
          return this;
        },
        resize: function(width, height) {
          var scaledWidth = width * this.scale;
          var scaledHeight = height * this.scale;
          if (scaledWidth !== this.width || scaledHeight !== this.height) {
            var renderer = this.renderer;
            renderer.deleteFramebuffer(this.framebuffer);
            renderer.deleteTexture(this.texture);
            width *= this.scale;
            height *= this.scale;
            width = Math.round(width);
            height = Math.round(height);
            if (width <= 0) {
              width = 1;
            }
            if (height <= 0) {
              height = 1;
            }
            this.texture = renderer.createTextureFromSource(null, width, height, this.minFilter, true);
            this.framebuffer = renderer.createFramebuffer(width, height, this.texture, true);
            this.width = width;
            this.height = height;
          }
          return this;
        },
        bind: function(adjustViewport, width, height) {
          if (adjustViewport === void 0) {
            adjustViewport = false;
          }
          if (adjustViewport) {
            this.renderer.flush();
          }
          if (width && height) {
            this.resize(width, height);
          }
          this.renderer.pushFramebuffer(this.framebuffer, false, false, false);
          if (adjustViewport) {
            this.adjustViewport();
          }
          if (this.autoClear) {
            var gl = this.renderer.gl;
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
          }
        },
        adjustViewport: function() {
          var gl = this.renderer.gl;
          gl.viewport(0, 0, this.width, this.height);
          gl.disable(gl.SCISSOR_TEST);
        },
        clear: function() {
          var renderer = this.renderer;
          var gl = renderer.gl;
          renderer.pushFramebuffer(this.framebuffer);
          gl.disable(gl.SCISSOR_TEST);
          gl.clearColor(0, 0, 0, 0);
          gl.clear(gl.COLOR_BUFFER_BIT);
          renderer.popFramebuffer();
          renderer.resetScissor();
        },
        unbind: function(flush) {
          if (flush === void 0) {
            flush = false;
          }
          var renderer = this.renderer;
          if (flush) {
            renderer.flush();
          }
          return renderer.popFramebuffer();
        },
        destroy: function() {
          var renderer = this.renderer;
          renderer.deleteFramebuffer(this.framebuffer);
          renderer.deleteTexture(this.texture);
          renderer.off(Events.RESIZE, this.resize, this);
          this.renderer = null;
          this.framebuffer = null;
          this.texture = null;
        }
      });
      module.exports = RenderTarget;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/shaders/BitmapMask-frag.js
  var require_BitmapMask_frag = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/shaders/BitmapMask-frag.js": function(exports, module) {
      module.exports = [
        "#define SHADER_NAME PHASER_BITMAP_MASK_FS",
        "",
        "precision mediump float;",
        "",
        "uniform vec2 uResolution;",
        "uniform sampler2D uMainSampler;",
        "uniform sampler2D uMaskSampler;",
        "uniform bool uInvertMaskAlpha;",
        "",
        "void main ()",
        "{",
        "    vec2 uv = gl_FragCoord.xy / uResolution;",
        "",
        "    vec4 mainColor = texture2D(uMainSampler, uv);",
        "    vec4 maskColor = texture2D(uMaskSampler, uv);",
        "",
        "    if (!uInvertMaskAlpha)",
        "    {",
        "        mainColor *= maskColor.a;",
        "    }",
        "    else",
        "    {",
        "        mainColor *= (1.0 - maskColor.a);",
        "    }",
        "",
        "    gl_FragColor = mainColor;",
        "}",
        ""
      ].join("\n");
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/shaders/BitmapMask-vert.js
  var require_BitmapMask_vert = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/shaders/BitmapMask-vert.js": function(exports, module) {
      module.exports = [
        "#define SHADER_NAME PHASER_BITMAP_MASK_VS",
        "",
        "precision mediump float;",
        "",
        "attribute vec2 inPosition;",
        "",
        "void main ()",
        "{",
        "    gl_Position = vec4(inPosition, 0.0, 1.0);",
        "}",
        ""
      ].join("\n");
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/const.js
  var require_const7 = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/const.js": function(exports, module) {
      var WEBGL_CONST = {
        BYTE: { enum: 5120, size: 1 },
        UNSIGNED_BYTE: { enum: 5121, size: 1 },
        SHORT: { enum: 5122, size: 2 },
        UNSIGNED_SHORT: { enum: 5123, size: 2 },
        INT: { enum: 5124, size: 4 },
        UNSIGNED_INT: { enum: 5125, size: 4 },
        FLOAT: { enum: 5126, size: 4 }
      };
      module.exports = WEBGL_CONST;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/events/AFTER_FLUSH_EVENT.js
  var require_AFTER_FLUSH_EVENT = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/events/AFTER_FLUSH_EVENT.js": function(exports, module) {
      module.exports = "pipelineafterflush";
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/events/BEFORE_FLUSH_EVENT.js
  var require_BEFORE_FLUSH_EVENT = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/events/BEFORE_FLUSH_EVENT.js": function(exports, module) {
      module.exports = "pipelinebeforeflush";
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/events/BIND_EVENT.js
  var require_BIND_EVENT = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/events/BIND_EVENT.js": function(exports, module) {
      module.exports = "pipelinebind";
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/events/BOOT_EVENT.js
  var require_BOOT_EVENT3 = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/events/BOOT_EVENT.js": function(exports, module) {
      module.exports = "pipelineboot";
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/events/DESTROY_EVENT.js
  var require_DESTROY_EVENT6 = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/events/DESTROY_EVENT.js": function(exports, module) {
      module.exports = "pipelinedestroy";
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/events/REBIND_EVENT.js
  var require_REBIND_EVENT = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/events/REBIND_EVENT.js": function(exports, module) {
      module.exports = "pipelinerebind";
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/events/RESIZE_EVENT.js
  var require_RESIZE_EVENT3 = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/events/RESIZE_EVENT.js": function(exports, module) {
      module.exports = "pipelineresize";
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/events/index.js
  var require_events10 = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/events/index.js": function(exports, module) {
      module.exports = {
        AFTER_FLUSH: require_AFTER_FLUSH_EVENT(),
        BEFORE_FLUSH: require_BEFORE_FLUSH_EVENT(),
        BIND: require_BIND_EVENT(),
        BOOT: require_BOOT_EVENT3(),
        DESTROY: require_DESTROY_EVENT6(),
        REBIND: require_REBIND_EVENT(),
        RESIZE: require_RESIZE_EVENT3()
      };
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/Utils.js
  var require_Utils = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/Utils.js": function(exports, module) {
      module.exports = {
        getTintFromFloats: function(r, g, b, a) {
          var ur = (r * 255 | 0) & 255;
          var ug = (g * 255 | 0) & 255;
          var ub = (b * 255 | 0) & 255;
          var ua = (a * 255 | 0) & 255;
          return (ua << 24 | ur << 16 | ug << 8 | ub) >>> 0;
        },
        getTintAppendFloatAlpha: function(rgb, a) {
          var ua = (a * 255 | 0) & 255;
          return (ua << 24 | rgb) >>> 0;
        },
        getTintAppendFloatAlphaAndSwap: function(rgb, a) {
          var ur = (rgb >> 16 | 0) & 255;
          var ug = (rgb >> 8 | 0) & 255;
          var ub = (rgb | 0) & 255;
          var ua = (a * 255 | 0) & 255;
          return (ua << 24 | ub << 16 | ug << 8 | ur) >>> 0;
        },
        getFloatsFromUintRGB: function(rgb) {
          var ur = (rgb >> 16 | 0) & 255;
          var ug = (rgb >> 8 | 0) & 255;
          var ub = (rgb | 0) & 255;
          return [ur / 255, ug / 255, ub / 255];
        },
        checkShaderMax: function(gl, maxTextures) {
          var gpuMax = Math.min(16, gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));
          if (!maxTextures || maxTextures === -1) {
            return gpuMax;
          } else {
            return Math.min(gpuMax, maxTextures);
          }
        },
        parseFragmentShaderMaxTextures: function(fragmentShaderSource, maxTextures) {
          if (!fragmentShaderSource) {
            return "";
          }
          var src = "";
          for (var i = 0; i < maxTextures; i++) {
            if (i > 0) {
              src += "\n	else ";
            }
            if (i < maxTextures - 1) {
              src += "if (outTexId < " + i + ".5)";
            }
            src += "\n	{";
            src += "\n		texture = texture2D(uMainSampler[" + i + "], outTexCoord);";
            src += "\n	}";
          }
          fragmentShaderSource = fragmentShaderSource.replace(/%count%/gi, maxTextures.toString());
          return fragmentShaderSource.replace(/%forloop%/gi, src);
        }
      };
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/WebGLShader.js
  var require_WebGLShader = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/WebGLShader.js": function(exports, module) {
      var Class = require_Class();
      var GetFastValue = require_GetFastValue();
      var WEBGL_CONST = require_const7();
      var WebGLShader = new Class({
        initialize: function WebGLShader2(pipeline, name, vertexShader, fragmentShader, attributes) {
          this.pipeline = pipeline;
          this.name = name;
          this.renderer = pipeline.renderer;
          this.gl = this.renderer.gl;
          this.fragSrc = fragmentShader;
          this.vertSrc = vertexShader;
          this.program = this.renderer.createProgram(vertexShader, fragmentShader);
          this.attributes;
          this.vertexComponentCount = 0;
          this.vertexSize = 0;
          this.uniforms = {};
          this.createAttributes(attributes);
          this.createUniforms();
        },
        createAttributes: function(attributes) {
          var count = 0;
          var offset = 0;
          var result = [];
          this.vertexComponentCount = 0;
          for (var i = 0; i < attributes.length; i++) {
            var element = attributes[i];
            var name = element.name;
            var size = GetFastValue(element, "size", 1);
            var glType = GetFastValue(element, "type", WEBGL_CONST.FLOAT);
            var type = glType.enum;
            var typeSize = glType.size;
            var normalized = element.normalized ? true : false;
            result.push({
              name: name,
              size: size,
              type: type,
              normalized: normalized,
              offset: offset,
              enabled: false,
              location: -1
            });
            if (typeSize === 4) {
              count += size;
            } else {
              count++;
            }
            offset += size * typeSize;
          }
          this.vertexSize = offset;
          this.vertexComponentCount = count;
          this.attributes = result;
        },
        bind: function(setAttributes, flush) {
          if (setAttributes === void 0) {
            setAttributes = false;
          }
          if (flush === void 0) {
            flush = false;
          }
          if (flush) {
            this.pipeline.flush();
          }
          this.renderer.setProgram(this.program);
          if (setAttributes) {
            this.setAttribPointers();
          }
          return this;
        },
        rebind: function() {
          this.renderer.setProgram(this.program);
          this.setAttribPointers(true);
          return this;
        },
        setAttribPointers: function(reset) {
          if (reset === void 0) {
            reset = false;
          }
          var gl = this.gl;
          var vertexSize = this.vertexSize;
          var attributes = this.attributes;
          var program = this.program;
          for (var i = 0; i < attributes.length; i++) {
            var element = attributes[i];
            var size = element.size;
            var type = element.type;
            var offset = element.offset;
            var enabled = element.enabled;
            var location = element.location;
            var normalized = element.normalized ? true : false;
            if (reset) {
              var attribLocation = gl.getAttribLocation(program, element.name);
              if (attribLocation >= 0) {
                gl.enableVertexAttribArray(attribLocation);
                gl.vertexAttribPointer(attribLocation, size, type, normalized, vertexSize, offset);
                element.enabled = true;
                element.location = attribLocation;
              } else if (attribLocation !== -1) {
                gl.disableVertexAttribArray(attribLocation);
              }
            } else if (enabled) {
              gl.vertexAttribPointer(location, size, type, normalized, vertexSize, offset);
            } else if (!enabled && location > -1) {
              gl.disableVertexAttribArray(location);
              element.location = -1;
            }
          }
          return this;
        },
        createUniforms: function() {
          var gl = this.gl;
          var program = this.program;
          var uniforms = this.uniforms;
          var i;
          var name;
          var location;
          var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
          for (i = 0; i < totalUniforms; i++) {
            var info = gl.getActiveUniform(program, i);
            if (info) {
              name = info.name;
              location = gl.getUniformLocation(program, name);
              if (location !== null) {
                uniforms[name] = {
                  name: name,
                  location: location,
                  value1: null,
                  value2: null,
                  value3: null,
                  value4: null
                };
              }
              var struct = name.indexOf("[");
              if (struct > 0) {
                name = name.substr(0, struct);
                if (!uniforms.hasOwnProperty(name)) {
                  location = gl.getUniformLocation(program, name);
                  if (location !== null) {
                    uniforms[name] = {
                      name: name,
                      location: location,
                      value1: null,
                      value2: null,
                      value3: null,
                      value4: null
                    };
                  }
                }
              }
            }
          }
          return this;
        },
        hasUniform: function(name) {
          return this.uniforms.hasOwnProperty(name);
        },
        resetUniform: function(name) {
          var uniform = this.uniforms[name];
          if (uniform) {
            uniform.value1 = null;
            uniform.value2 = null;
            uniform.value3 = null;
            uniform.value4 = null;
          }
          return this;
        },
        setUniform1: function(setter, name, value1, skipCheck) {
          var uniform = this.uniforms[name];
          if (!uniform) {
            return this;
          }
          if (skipCheck || uniform.value1 !== value1) {
            uniform.value1 = value1;
            this.renderer.setProgram(this.program);
            setter.call(this.gl, uniform.location, value1);
            this.pipeline.currentShader = this;
          }
          return this;
        },
        setUniform2: function(setter, name, value1, value2, skipCheck) {
          var uniform = this.uniforms[name];
          if (!uniform) {
            return this;
          }
          if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2) {
            uniform.value1 = value1;
            uniform.value2 = value2;
            this.renderer.setProgram(this.program);
            setter.call(this.gl, uniform.location, value1, value2);
            this.pipeline.currentShader = this;
          }
          return this;
        },
        setUniform3: function(setter, name, value1, value2, value3, skipCheck) {
          var uniform = this.uniforms[name];
          if (!uniform) {
            return this;
          }
          if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2 || uniform.value3 !== value3) {
            uniform.value1 = value1;
            uniform.value2 = value2;
            uniform.value3 = value3;
            this.renderer.setProgram(this.program);
            setter.call(this.gl, uniform.location, value1, value2, value3);
            this.pipeline.currentShader = this;
          }
          return this;
        },
        setUniform4: function(setter, name, value1, value2, value3, value4, skipCheck) {
          var uniform = this.uniforms[name];
          if (!uniform) {
            return this;
          }
          if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2 || uniform.value3 !== value3 || uniform.value4 !== value4) {
            uniform.value1 = value1;
            uniform.value2 = value2;
            uniform.value3 = value3;
            uniform.value4 = value4;
            this.renderer.setProgram(this.program);
            setter.call(this.gl, uniform.location, value1, value2, value3, value4);
            this.pipeline.currentShader = this;
          }
          return this;
        },
        setBoolean: function(name, value) {
          return this.setUniform1(this.gl.uniform1i, name, Number(value));
        },
        set1f: function(name, x) {
          return this.setUniform1(this.gl.uniform1f, name, x);
        },
        set2f: function(name, x, y) {
          return this.setUniform2(this.gl.uniform2f, name, x, y);
        },
        set3f: function(name, x, y, z) {
          return this.setUniform3(this.gl.uniform3f, name, x, y, z);
        },
        set4f: function(name, x, y, z, w) {
          return this.setUniform4(this.gl.uniform4f, name, x, y, z, w);
        },
        set1fv: function(name, arr) {
          return this.setUniform1(this.gl.uniform1fv, name, arr, true);
        },
        set2fv: function(name, arr) {
          return this.setUniform1(this.gl.uniform2fv, name, arr, true);
        },
        set3fv: function(name, arr) {
          return this.setUniform1(this.gl.uniform3fv, name, arr, true);
        },
        set4fv: function(name, arr) {
          return this.setUniform1(this.gl.uniform4fv, name, arr, true);
        },
        set1iv: function(name, arr) {
          return this.setUniform1(this.gl.uniform1iv, name, arr, true);
        },
        set2iv: function(name, arr) {
          return this.setUniform1(this.gl.uniform2iv, name, arr, true);
        },
        set3iv: function(name, arr) {
          return this.setUniform1(this.gl.uniform3iv, name, arr, true);
        },
        set4iv: function(name, arr) {
          return this.setUniform1(this.gl.uniform4iv, name, arr, true);
        },
        set1i: function(name, x) {
          return this.setUniform1(this.gl.uniform1i, name, x);
        },
        set2i: function(name, x, y) {
          return this.setUniform2(this.gl.uniform2i, name, x, y);
        },
        set3i: function(name, x, y, z) {
          return this.setUniform3(this.gl.uniform3i, name, x, y, z);
        },
        set4i: function(name, x, y, z, w) {
          return this.setUniform4(this.gl.uniform4i, name, x, y, z, w);
        },
        setMatrix2fv: function(name, transpose, matrix) {
          return this.setUniform2(this.gl.uniformMatrix2fv, name, transpose, matrix, true);
        },
        setMatrix3fv: function(name, transpose, matrix) {
          return this.setUniform2(this.gl.uniformMatrix3fv, name, transpose, matrix, true);
        },
        setMatrix4fv: function(name, transpose, matrix) {
          return this.setUniform2(this.gl.uniformMatrix4fv, name, transpose, matrix, true);
        },
        createProgram: function(vertSrc, fragSrc) {
          if (vertSrc === void 0) {
            vertSrc = this.vertSrc;
          }
          if (fragSrc === void 0) {
            fragSrc = this.fragSrc;
          }
          var gl = this.gl;
          if (this.program) {
            gl.deleteProgram(this.program);
          }
          this.vertSrc = vertSrc;
          this.fragSrc = fragSrc;
          this.program = this.renderer.createProgram(vertSrc, fragSrc);
          this.createUniforms();
          return this.rebind();
        },
        destroy: function() {
          this.gl.deleteProgram(this.program);
          this.pipeline = null;
          this.renderer = null;
          this.gl = null;
          this.program = null;
          this.attributes = null;
          this.uniforms = null;
        }
      });
      module.exports = WebGLShader;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/WebGLPipeline.js
  var require_WebGLPipeline = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/WebGLPipeline.js": function(exports, module) {
      var Class = require_Class();
      var DeepCopy = require_DeepCopy();
      var EventEmitter = require_eventemitter3();
      var Events = require_events10();
      var GetFastValue = require_GetFastValue();
      var Matrix4 = require_Matrix4();
      var RendererEvents = require_events8();
      var RenderTarget = require_RenderTarget();
      var Utils = require_Utils();
      var WebGLShader = require_WebGLShader();
      var WebGLPipeline = new Class({
        Extends: EventEmitter,
        initialize: function WebGLPipeline2(config) {
          EventEmitter.call(this);
          var game = config.game;
          var renderer = game.renderer;
          var gl = renderer.gl;
          this.name = GetFastValue(config, "name", "WebGLPipeline");
          this.game = game;
          this.renderer = renderer;
          this.manager;
          this.gl = gl;
          this.view = game.canvas;
          this.width = 0;
          this.height = 0;
          this.vertexCount = 0;
          this.vertexCapacity = 0;
          this.vertexData;
          this.vertexBuffer;
          this.activeBuffer;
          this.topology = GetFastValue(config, "topology", gl.TRIANGLES);
          this.bytes;
          this.vertexViewF32;
          this.vertexViewU32;
          this.active = true;
          this.forceZero = GetFastValue(config, "forceZero", false);
          this.hasBooted = false;
          this.isPostFX = false;
          this.isSpriteFX = false;
          this.renderTargets = [];
          this.currentRenderTarget;
          this.shaders = [];
          this.currentShader;
          this.projectionMatrix;
          this.projectionWidth = 0;
          this.projectionHeight = 0;
          this.config = config;
          this.glReset = false;
          this.batch = [];
          this.currentBatch = null;
          this.currentTexture = null;
          this.currentUnit = 0;
          this.activeTextures = [];
        },
        boot: function() {
          var i;
          var gl = this.gl;
          var config = this.config;
          var renderer = this.renderer;
          if (!this.isPostFX) {
            this.projectionMatrix = new Matrix4().identity();
          }
          var renderTargets = this.renderTargets;
          var targets = GetFastValue(config, "renderTarget", false);
          if (typeof targets === "boolean" && targets) {
            targets = 1;
          }
          var width = renderer.width;
          var height = renderer.height;
          if (typeof targets === "number") {
            for (i = 0; i < targets; i++) {
              renderTargets.push(new RenderTarget(renderer, width, height, 1, 0, true));
            }
          } else if (Array.isArray(targets)) {
            for (i = 0; i < targets.length; i++) {
              var scale = GetFastValue(targets[i], "scale", 1);
              var minFilter = GetFastValue(targets[i], "minFilter", 0);
              var autoClear = GetFastValue(targets[i], "autoClear", 1);
              var targetWidth = GetFastValue(targets[i], "width", null);
              var targetHeight = GetFastValue(targets[i], "height", targetWidth);
              if (targetWidth) {
                renderTargets.push(new RenderTarget(renderer, targetWidth, targetHeight, 1, minFilter, autoClear));
              } else {
                renderTargets.push(new RenderTarget(renderer, width, height, scale, minFilter, autoClear));
              }
            }
          }
          if (renderTargets.length) {
            this.currentRenderTarget = renderTargets[0];
          }
          this.setShadersFromConfig(config);
          var shaders = this.shaders;
          var vertexSize = 0;
          for (i = 0; i < shaders.length; i++) {
            if (shaders[i].vertexSize > vertexSize) {
              vertexSize = shaders[i].vertexSize;
            }
          }
          var batchSize = GetFastValue(config, "batchSize", renderer.config.batchSize);
          this.vertexCapacity = batchSize * 6;
          var data = new ArrayBuffer(this.vertexCapacity * vertexSize);
          this.vertexData = data;
          this.bytes = new Uint8Array(data);
          this.vertexViewF32 = new Float32Array(data);
          this.vertexViewU32 = new Uint32Array(data);
          var configVerts = GetFastValue(config, "vertices", null);
          if (configVerts) {
            this.vertexViewF32.set(configVerts);
            this.vertexBuffer = renderer.createVertexBuffer(data, gl.STATIC_DRAW);
          } else {
            this.vertexBuffer = renderer.createVertexBuffer(data.byteLength, gl.DYNAMIC_DRAW);
          }
          this.setVertexBuffer();
          for (i = shaders.length - 1; i >= 0; i--) {
            shaders[i].rebind();
          }
          this.hasBooted = true;
          renderer.on(RendererEvents.RESIZE, this.resize, this);
          renderer.on(RendererEvents.PRE_RENDER, this.onPreRender, this);
          renderer.on(RendererEvents.RENDER, this.onRender, this);
          renderer.on(RendererEvents.POST_RENDER, this.onPostRender, this);
          this.emit(Events.BOOT, this);
          this.onBoot();
        },
        onBoot: function() {
        },
        onResize: function() {
        },
        setShader: function(shader, setAttributes, vertexBuffer) {
          var renderer = this.renderer;
          if (shader !== this.currentShader || renderer.currentProgram !== this.currentShader.program) {
            this.flush();
            var wasBound = this.setVertexBuffer(vertexBuffer);
            if (wasBound && !setAttributes) {
              setAttributes = true;
            }
            shader.bind(setAttributes, false);
            this.currentShader = shader;
          }
          return this;
        },
        getShaderByName: function(name) {
          var shaders = this.shaders;
          for (var i = 0; i < shaders.length; i++) {
            if (shaders[i].name === name) {
              return shaders[i];
            }
          }
        },
        setShadersFromConfig: function(config) {
          var i;
          var shaders = this.shaders;
          var renderer = this.renderer;
          for (i = 0; i < shaders.length; i++) {
            shaders[i].destroy();
          }
          var vName = "vertShader";
          var fName = "fragShader";
          var aName = "attributes";
          var defaultVertShader = GetFastValue(config, vName, null);
          var defaultFragShader = Utils.parseFragmentShaderMaxTextures(GetFastValue(config, fName, null), renderer.maxTextures);
          var defaultAttribs = GetFastValue(config, aName, null);
          var configShaders = GetFastValue(config, "shaders", []);
          var len = configShaders.length;
          if (len === 0) {
            if (defaultVertShader && defaultFragShader) {
              this.shaders = [new WebGLShader(this, "default", defaultVertShader, defaultFragShader, DeepCopy(defaultAttribs))];
            }
          } else {
            var newShaders = [];
            for (i = 0; i < len; i++) {
              var shaderEntry = configShaders[i];
              var name = GetFastValue(shaderEntry, "name", "default");
              var vertShader = GetFastValue(shaderEntry, vName, defaultVertShader);
              var fragShader = Utils.parseFragmentShaderMaxTextures(GetFastValue(shaderEntry, fName, defaultFragShader), renderer.maxTextures);
              var attributes = GetFastValue(shaderEntry, aName, defaultAttribs);
              if (vertShader && fragShader) {
                newShaders.push(new WebGLShader(this, name, vertShader, fragShader, DeepCopy(attributes)));
              }
            }
            this.shaders = newShaders;
          }
          if (this.shaders.length === 0) {
            console.warn("Pipeline: " + this.name + " - Invalid shader config");
          } else {
            this.currentShader = this.shaders[0];
          }
          return this;
        },
        createBatch: function(texture) {
          this.currentBatch = {
            start: this.vertexCount,
            count: 0,
            texture: [texture],
            unit: 0,
            maxUnit: 0
          };
          this.currentUnit = 0;
          this.currentTexture = texture;
          this.batch.push(this.currentBatch);
          return 0;
        },
        addTextureToBatch: function(texture) {
          var batch = this.currentBatch;
          if (batch) {
            batch.texture.push(texture);
            batch.unit++;
            batch.maxUnit++;
          }
        },
        pushBatch: function(texture) {
          if (!this.currentBatch || this.forceZero && texture !== this.currentTexture) {
            return this.createBatch(texture);
          }
          if (texture === this.currentTexture) {
            return this.currentUnit;
          } else {
            var current = this.currentBatch;
            var idx = current.texture.indexOf(texture);
            if (idx === -1) {
              if (current.texture.length === this.renderer.maxTextures) {
                return this.createBatch(texture);
              } else {
                current.unit++;
                current.maxUnit++;
                current.texture.push(texture);
                this.currentUnit = current.unit;
                this.currentTexture = texture;
                return current.unit;
              }
            } else {
              this.currentUnit = idx;
              this.currentTexture = texture;
              return idx;
            }
          }
        },
        setGameObject: function(gameObject, frame) {
          if (frame === void 0) {
            frame = gameObject.frame;
          }
          return this.pushBatch(frame.source.glTexture);
        },
        shouldFlush: function(amount) {
          if (amount === void 0) {
            amount = 0;
          }
          return this.vertexCount + amount > this.vertexCapacity;
        },
        vertexAvailable: function() {
          return this.vertexCapacity - this.vertexCount;
        },
        resize: function(width, height) {
          if (width !== this.width || height !== this.height) {
            this.flush();
          }
          this.width = width;
          this.height = height;
          var targets = this.renderTargets;
          for (var i = 0; i < targets.length; i++) {
            targets[i].resize(width, height);
          }
          this.setProjectionMatrix(width, height);
          this.emit(Events.RESIZE, width, height, this);
          this.onResize(width, height);
          return this;
        },
        setProjectionMatrix: function(width, height) {
          var projectionMatrix = this.projectionMatrix;
          if (!projectionMatrix) {
            return this;
          }
          this.projectionWidth = width;
          this.projectionHeight = height;
          projectionMatrix.ortho(0, width, height, 0, -1e3, 1e3);
          var shaders = this.shaders;
          var name = "uProjectionMatrix";
          for (var i = 0; i < shaders.length; i++) {
            var shader = shaders[i];
            if (shader.hasUniform(name)) {
              shader.resetUniform(name);
              shader.setMatrix4fv(name, false, projectionMatrix.val, shader);
            }
          }
          return this;
        },
        flipProjectionMatrix: function(flipY) {
          if (flipY === void 0) {
            flipY = true;
          }
          var projectionMatrix = this.projectionMatrix;
          if (!projectionMatrix) {
            return this;
          }
          var width = this.projectionWidth;
          var height = this.projectionHeight;
          if (flipY) {
            projectionMatrix.ortho(0, width, 0, height, -1e3, 1e3);
          } else {
            projectionMatrix.ortho(0, width, height, 0, -1e3, 1e3);
          }
          this.setMatrix4fv("uProjectionMatrix", false, projectionMatrix.val);
        },
        updateProjectionMatrix: function() {
          if (this.projectionMatrix) {
            var globalWidth = this.renderer.projectionWidth;
            var globalHeight = this.renderer.projectionHeight;
            if (this.projectionWidth !== globalWidth || this.projectionHeight !== globalHeight) {
              this.setProjectionMatrix(globalWidth, globalHeight);
            }
          }
        },
        bind: function(currentShader) {
          if (currentShader === void 0) {
            currentShader = this.currentShader;
          }
          if (this.glReset) {
            return this.rebind(currentShader);
          }
          var wasBound = false;
          var gl = this.gl;
          if (gl.getParameter(gl.ARRAY_BUFFER_BINDING) !== this.vertexBuffer) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            this.activeBuffer = this.vertexBuffer;
            wasBound = true;
          }
          currentShader.bind(wasBound);
          this.currentShader = currentShader;
          this.activeTextures.length = 0;
          this.emit(Events.BIND, this, currentShader);
          this.onActive(currentShader);
          return this;
        },
        rebind: function(currentShader) {
          this.activeBuffer = null;
          this.setVertexBuffer();
          var shaders = this.shaders;
          for (var i = shaders.length - 1; i >= 0; i--) {
            var shader = shaders[i].rebind();
            if (!currentShader || shader === currentShader) {
              this.currentShader = shader;
            }
          }
          this.activeTextures.length = 0;
          this.emit(Events.REBIND, this.currentShader);
          this.onActive(this.currentShader);
          this.onRebind();
          this.glReset = false;
          return this;
        },
        setVertexBuffer: function(buffer) {
          if (buffer === void 0) {
            buffer = this.vertexBuffer;
          }
          if (buffer !== this.activeBuffer) {
            var gl = this.gl;
            this.gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            this.activeBuffer = buffer;
            return true;
          }
          return false;
        },
        preBatch: function(gameObject) {
          if (this.currentRenderTarget) {
            this.currentRenderTarget.bind();
          }
          this.onPreBatch(gameObject);
          return this;
        },
        postBatch: function(gameObject) {
          this.onDraw(this.currentRenderTarget);
          this.onPostBatch(gameObject);
          return this;
        },
        onDraw: function() {
        },
        unbind: function() {
          if (this.currentRenderTarget) {
            this.currentRenderTarget.unbind();
          }
        },
        flush: function(isPostFlush) {
          if (isPostFlush === void 0) {
            isPostFlush = false;
          }
          if (this.vertexCount > 0) {
            this.emit(Events.BEFORE_FLUSH, this, isPostFlush);
            this.onBeforeFlush(isPostFlush);
            var gl = this.gl;
            var vertexCount = this.vertexCount;
            var vertexSize = this.currentShader.vertexSize;
            var topology = this.topology;
            if (this.active) {
              this.setVertexBuffer();
              if (vertexCount === this.vertexCapacity) {
                gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.DYNAMIC_DRAW);
              } else {
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));
              }
              var i;
              var entry;
              var texture;
              var batch = this.batch;
              var activeTextures = this.activeTextures;
              if (this.forceZero) {
                if (!activeTextures[0]) {
                  gl.activeTexture(gl.TEXTURE0);
                }
                for (i = 0; i < batch.length; i++) {
                  entry = batch[i];
                  texture = entry.texture[0];
                  if (activeTextures[0] !== texture) {
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    activeTextures[0] = texture;
                  }
                  gl.drawArrays(topology, entry.start, entry.count);
                }
              } else {
                for (i = 0; i < batch.length; i++) {
                  entry = batch[i];
                  for (var t = 0; t <= entry.maxUnit; t++) {
                    texture = entry.texture[t];
                    if (activeTextures[t] !== texture) {
                      gl.activeTexture(gl.TEXTURE0 + t);
                      gl.bindTexture(gl.TEXTURE_2D, texture);
                      activeTextures[t] = texture;
                    }
                  }
                  gl.drawArrays(topology, entry.start, entry.count);
                }
              }
            }
            this.vertexCount = 0;
            this.batch.length = 0;
            this.currentBatch = null;
            this.currentTexture = null;
            this.currentUnit = 0;
            this.emit(Events.AFTER_FLUSH, this, isPostFlush);
            this.onAfterFlush(isPostFlush);
          }
          return this;
        },
        onActive: function() {
        },
        onBind: function() {
        },
        onRebind: function() {
        },
        onBatch: function() {
        },
        onPreBatch: function() {
        },
        onPostBatch: function() {
        },
        onPreRender: function() {
        },
        onRender: function() {
        },
        onPostRender: function() {
        },
        onBeforeFlush: function() {
        },
        onAfterFlush: function() {
        },
        batchVert: function(x, y, u, v, unit, tintEffect, tint) {
          var vertexViewF32 = this.vertexViewF32;
          var vertexViewU32 = this.vertexViewU32;
          var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
          vertexViewF32[++vertexOffset] = x;
          vertexViewF32[++vertexOffset] = y;
          vertexViewF32[++vertexOffset] = u;
          vertexViewF32[++vertexOffset] = v;
          vertexViewF32[++vertexOffset] = unit;
          vertexViewF32[++vertexOffset] = tintEffect;
          vertexViewU32[++vertexOffset] = tint;
          this.vertexCount++;
          this.currentBatch.count = this.vertexCount - this.currentBatch.start;
        },
        batchQuad: function(gameObject, x0, y0, x1, y1, x2, y2, x3, y3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, unit) {
          if (unit === void 0) {
            unit = this.currentUnit;
          }
          var hasFlushed = false;
          if (this.shouldFlush(6)) {
            this.flush();
            hasFlushed = true;
          }
          if (!this.currentBatch) {
            unit = this.setTexture2D(texture);
          }
          var vertexViewF32 = this.vertexViewF32;
          var vertexViewU32 = this.vertexViewU32;
          var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
          vertexViewF32[++vertexOffset] = x0;
          vertexViewF32[++vertexOffset] = y0;
          vertexViewF32[++vertexOffset] = u0;
          vertexViewF32[++vertexOffset] = v0;
          vertexViewF32[++vertexOffset] = unit;
          vertexViewF32[++vertexOffset] = tintEffect;
          vertexViewU32[++vertexOffset] = tintTL;
          vertexViewF32[++vertexOffset] = x1;
          vertexViewF32[++vertexOffset] = y1;
          vertexViewF32[++vertexOffset] = u0;
          vertexViewF32[++vertexOffset] = v1;
          vertexViewF32[++vertexOffset] = unit;
          vertexViewF32[++vertexOffset] = tintEffect;
          vertexViewU32[++vertexOffset] = tintBL;
          vertexViewF32[++vertexOffset] = x2;
          vertexViewF32[++vertexOffset] = y2;
          vertexViewF32[++vertexOffset] = u1;
          vertexViewF32[++vertexOffset] = v1;
          vertexViewF32[++vertexOffset] = unit;
          vertexViewF32[++vertexOffset] = tintEffect;
          vertexViewU32[++vertexOffset] = tintBR;
          vertexViewF32[++vertexOffset] = x0;
          vertexViewF32[++vertexOffset] = y0;
          vertexViewF32[++vertexOffset] = u0;
          vertexViewF32[++vertexOffset] = v0;
          vertexViewF32[++vertexOffset] = unit;
          vertexViewF32[++vertexOffset] = tintEffect;
          vertexViewU32[++vertexOffset] = tintTL;
          vertexViewF32[++vertexOffset] = x2;
          vertexViewF32[++vertexOffset] = y2;
          vertexViewF32[++vertexOffset] = u1;
          vertexViewF32[++vertexOffset] = v1;
          vertexViewF32[++vertexOffset] = unit;
          vertexViewF32[++vertexOffset] = tintEffect;
          vertexViewU32[++vertexOffset] = tintBR;
          vertexViewF32[++vertexOffset] = x3;
          vertexViewF32[++vertexOffset] = y3;
          vertexViewF32[++vertexOffset] = u1;
          vertexViewF32[++vertexOffset] = v0;
          vertexViewF32[++vertexOffset] = unit;
          vertexViewF32[++vertexOffset] = tintEffect;
          vertexViewU32[++vertexOffset] = tintTR;
          this.vertexCount += 6;
          this.currentBatch.count = this.vertexCount - this.currentBatch.start;
          this.onBatch(gameObject);
          return hasFlushed;
        },
        batchTri: function(gameObject, x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintEffect, texture, unit) {
          if (unit === void 0) {
            unit = this.currentUnit;
          }
          var hasFlushed = false;
          if (this.shouldFlush(3)) {
            this.flush();
            hasFlushed = true;
          }
          if (!this.currentBatch) {
            unit = this.setTexture2D(texture);
          }
          var vertexViewF32 = this.vertexViewF32;
          var vertexViewU32 = this.vertexViewU32;
          var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
          vertexViewF32[++vertexOffset] = x0;
          vertexViewF32[++vertexOffset] = y0;
          vertexViewF32[++vertexOffset] = u0;
          vertexViewF32[++vertexOffset] = v0;
          vertexViewF32[++vertexOffset] = unit;
          vertexViewF32[++vertexOffset] = tintEffect;
          vertexViewU32[++vertexOffset] = tintTL;
          vertexViewF32[++vertexOffset] = x1;
          vertexViewF32[++vertexOffset] = y1;
          vertexViewF32[++vertexOffset] = u0;
          vertexViewF32[++vertexOffset] = v1;
          vertexViewF32[++vertexOffset] = unit;
          vertexViewF32[++vertexOffset] = tintEffect;
          vertexViewU32[++vertexOffset] = tintTR;
          vertexViewF32[++vertexOffset] = x2;
          vertexViewF32[++vertexOffset] = y2;
          vertexViewF32[++vertexOffset] = u1;
          vertexViewF32[++vertexOffset] = v1;
          vertexViewF32[++vertexOffset] = unit;
          vertexViewF32[++vertexOffset] = tintEffect;
          vertexViewU32[++vertexOffset] = tintBL;
          this.vertexCount += 3;
          this.currentBatch.count = this.vertexCount - this.currentBatch.start;
          this.onBatch(gameObject);
          return hasFlushed;
        },
        drawFillRect: function(x, y, width, height, color, alpha, texture, flipUV) {
          if (texture === void 0) {
            texture = this.renderer.whiteTexture;
          }
          if (flipUV === void 0) {
            flipUV = true;
          }
          x = Math.floor(x);
          y = Math.floor(y);
          var xw = Math.floor(x + width);
          var yh = Math.floor(y + height);
          var unit = this.setTexture2D(texture);
          var tint = Utils.getTintAppendFloatAlphaAndSwap(color, alpha);
          var u0 = 0;
          var v0 = 0;
          var u1 = 1;
          var v1 = 1;
          if (flipUV) {
            v0 = 1;
            v1 = 0;
          }
          this.batchQuad(null, x, y, x, yh, xw, yh, xw, y, u0, v0, u1, v1, tint, tint, tint, tint, 0, texture, unit);
        },
        setTexture2D: function(texture) {
          if (texture === void 0) {
            texture = this.renderer.whiteTexture;
          }
          return this.pushBatch(texture);
        },
        bindTexture: function(texture, unit) {
          if (unit === void 0) {
            unit = 0;
          }
          var gl = this.gl;
          gl.activeTexture(gl.TEXTURE0 + unit);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          return this;
        },
        bindRenderTarget: function(target, unit) {
          return this.bindTexture(target.texture, unit);
        },
        setTime: function(uniform) {
          this.set1f(uniform, this.game.loop.getDuration());
          return this;
        },
        setBoolean: function(name, value, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.setBoolean(name, value);
          return this;
        },
        set1f: function(name, x, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.set1f(name, x);
          return this;
        },
        set2f: function(name, x, y, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.set2f(name, x, y);
          return this;
        },
        set3f: function(name, x, y, z, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.set3f(name, x, y, z);
          return this;
        },
        set4f: function(name, x, y, z, w, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.set4f(name, x, y, z, w);
          return this;
        },
        set1fv: function(name, arr, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.set1fv(name, arr);
          return this;
        },
        set2fv: function(name, arr, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.set2fv(name, arr);
          return this;
        },
        set3fv: function(name, arr, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.set3fv(name, arr);
          return this;
        },
        set4fv: function(name, arr, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.set4fv(name, arr);
          return this;
        },
        set1iv: function(name, arr, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.set1iv(name, arr);
          return this;
        },
        set2iv: function(name, arr, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.set2iv(name, arr);
          return this;
        },
        set3iv: function(name, arr, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.set3iv(name, arr);
          return this;
        },
        set4iv: function(name, arr, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.set4iv(name, arr);
          return this;
        },
        set1i: function(name, x, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.set1i(name, x);
          return this;
        },
        set2i: function(name, x, y, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.set2i(name, x, y);
          return this;
        },
        set3i: function(name, x, y, z, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.set3i(name, x, y, z);
          return this;
        },
        set4i: function(name, x, y, z, w, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.set4i(name, x, y, z, w);
          return this;
        },
        setMatrix2fv: function(name, transpose, matrix, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.setMatrix2fv(name, transpose, matrix);
          return this;
        },
        setMatrix3fv: function(name, transpose, matrix, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.setMatrix3fv(name, transpose, matrix);
          return this;
        },
        setMatrix4fv: function(name, transpose, matrix, shader) {
          if (shader === void 0) {
            shader = this.currentShader;
          }
          shader.setMatrix4fv(name, transpose, matrix);
          return this;
        },
        destroy: function() {
          this.emit(Events.DESTROY, this);
          var i;
          var shaders = this.shaders;
          for (i = 0; i < shaders.length; i++) {
            shaders[i].destroy();
          }
          var targets = this.renderTargets;
          for (i = 0; i < targets.length; i++) {
            targets[i].destroy();
          }
          this.gl.deleteBuffer(this.vertexBuffer);
          var renderer = this.renderer;
          renderer.off(RendererEvents.RESIZE, this.resize, this);
          renderer.off(RendererEvents.PRE_RENDER, this.onPreRender, this);
          renderer.off(RendererEvents.RENDER, this.onRender, this);
          renderer.off(RendererEvents.POST_RENDER, this.onPostRender, this);
          this.removeAllListeners();
          this.game = null;
          this.renderer = null;
          this.manager = null;
          this.gl = null;
          this.view = null;
          this.shaders = null;
          this.renderTargets = null;
          this.bytes = null;
          this.vertexViewF32 = null;
          this.vertexViewU32 = null;
          this.vertexData = null;
          this.vertexBuffer = null;
          this.currentShader = null;
          this.currentRenderTarget = null;
          this.activeTextures = null;
          return this;
        }
      });
      module.exports = WebGLPipeline;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/BitmapMaskPipeline.js
  var require_BitmapMaskPipeline = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/BitmapMaskPipeline.js": function(exports, module) {
      var Class = require_Class();
      var GetFastValue = require_GetFastValue();
      var ShaderSourceFS = require_BitmapMask_frag();
      var ShaderSourceVS = require_BitmapMask_vert();
      var WEBGL_CONST = require_const7();
      var WebGLPipeline = require_WebGLPipeline();
      var BitmapMaskPipeline = new Class({
        Extends: WebGLPipeline,
        initialize: function BitmapMaskPipeline2(config) {
          config.fragShader = GetFastValue(config, "fragShader", ShaderSourceFS), config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS), config.batchSize = GetFastValue(config, "batchSize", 1), config.vertices = GetFastValue(config, "vertices", [-1, 1, -1, -7, 7, 1]), config.attributes = GetFastValue(config, "attributes", [
            {
              name: "inPosition",
              size: 2,
              type: WEBGL_CONST.FLOAT
            }
          ]);
          WebGLPipeline.call(this, config);
        },
        boot: function() {
          WebGLPipeline.prototype.boot.call(this);
          this.set1i("uMainSampler", 0);
          this.set1i("uMaskSampler", 1);
        },
        resize: function(width, height) {
          WebGLPipeline.prototype.resize.call(this, width, height);
          this.set2f("uResolution", width, height);
        },
        beginMask: function(mask, maskedObject, camera) {
          this.renderer.beginBitmapMask(mask, camera);
        },
        endMask: function(mask, camera, renderTarget) {
          var gl = this.gl;
          var renderer = this.renderer;
          var bitmapMask = mask.bitmapMask;
          if (bitmapMask && gl) {
            renderer.drawBitmapMask(bitmapMask, camera, this);
            if (renderTarget) {
              this.set2f("uResolution", renderTarget.width, renderTarget.height);
            }
            this.set1i("uInvertMaskAlpha", mask.invertAlpha);
            gl.drawArrays(this.topology, 0, 3);
            if (renderTarget) {
              this.set2f("uResolution", this.width, this.height);
            }
            gl.bindTexture(gl.TEXTURE_2D, null);
          }
        }
      });
      module.exports = BitmapMaskPipeline;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/shaders/Light-frag.js
  var require_Light_frag = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/shaders/Light-frag.js": function(exports, module) {
      module.exports = [
        "#define SHADER_NAME PHASER_LIGHT_FS",
        "",
        "precision mediump float;",
        "",
        "struct Light",
        "{",
        "    vec2 position;",
        "    vec3 color;",
        "    float intensity;",
        "    float radius;",
        "};",
        "",
        "const int kMaxLights = %LIGHT_COUNT%;",
        "",
        "uniform vec4 uCamera; /* x, y, rotation, zoom */",
        "uniform vec2 uResolution;",
        "uniform sampler2D uMainSampler;",
        "uniform sampler2D uNormSampler;",
        "uniform vec3 uAmbientLightColor;",
        "uniform Light uLights[kMaxLights];",
        "uniform mat3 uInverseRotationMatrix;",
        "uniform int uLightCount;",
        "",
        "varying vec2 outTexCoord;",
        "varying float outTexId;",
        "varying float outTintEffect;",
        "varying vec4 outTint;",
        "",
        "void main ()",
        "{",
        "    vec3 finalColor = vec3(0.0, 0.0, 0.0);",
        "",
        "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);",
        "    vec4 texture = texture2D(uMainSampler, outTexCoord);",
        "    //  Multiply texture tint",
        "    vec4 color = texture * texel;",
        "",
        "    if (outTintEffect == 1.0)",
        "    {",
        "        //  Solid color + texture alpha",
        "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);",
        "    }",
        "    else if (outTintEffect == 2.0)",
        "    {",
        "        //  Solid color, no texture",
        "        color = texel;",
        "    }",
        "",
        "    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;",
        "    vec3 normal = normalize(uInverseRotationMatrix * vec3(normalMap * 2.0 - 1.0));",
        "    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;",
        "",
        "    for (int index = 0; index < kMaxLights; ++index)",
        "    {",
        "        if (index < uLightCount)",
        "        {",
        "            Light light = uLights[index];",
        "            vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);",
        "            vec3 lightNormal = normalize(lightDir);",
        "            float distToSurf = length(lightDir) * uCamera.w;",
        "            float diffuseFactor = max(dot(normal, lightNormal), 0.0);",
        "            float radius = (light.radius / res.x * uCamera.w) * uCamera.w;",
        "            float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);",
        "            vec3 diffuse = light.color * diffuseFactor;",
        "            finalColor += (attenuation * diffuse) * light.intensity;",
        "        }",
        "    }",
        "",
        "    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);",
        "",
        "    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);",
        "}",
        ""
      ].join("\n");
    }
  });

  // ../../node_modules/phaser/src/geom/polygon/Earcut.js
  var require_Earcut = __commonJS({
    "../../node_modules/phaser/src/geom/polygon/Earcut.js": function(exports, module) {
      "use strict";
      function earcut(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX)
              minX = x;
            if (y < minY)
              minY = y;
            if (x > maxX)
              maxX = x;
            if (y > maxY)
              maxY = y;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 32767 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
        return triangles;
      }
      function linkedList(data, start, end, dim, clockwise) {
        var i, last;
        if (clockwise === signedArea(data, start, end, dim) > 0) {
          for (i = start; i < end; i += dim)
            last = insertNode(i, data[i], data[i + 1], last);
        } else {
          for (i = end - dim; i >= start; i -= dim)
            last = insertNode(i, data[i], data[i + 1], last);
        }
        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start, end) {
        if (!start)
          return start;
        if (!end)
          end = start;
        var p = start, again;
        do {
          again = false;
          if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next)
              break;
            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0)
          return false;
        var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var p = c.next;
        while (p !== a) {
          if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0)
          return false;
        var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
        var p = ear.prevZ, n = ear.nextZ;
        while (p && p.z >= minZ && n && n.z <= maxZ) {
          if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
          if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        while (p && p.z >= minZ) {
          if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
        }
        while (n && n.z <= maxZ) {
          if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
          var a = p.prev, b = p.next.next;
          if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);
            removeNode(p);
            removeNode(p.next);
            p = start = b;
          }
          p = p.next;
        } while (p !== start);
        return filterPoints(p);
      }
      function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        var a = start;
        do {
          var b = a.next.next;
          while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
              var c = splitPolygon(a, b);
              a = filterPoints(a, a.next);
              c = filterPoints(c, c.next);
              earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
              earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
              return;
            }
            b = b.next;
          }
          a = a.next;
        } while (a !== start);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
          start = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          list = linkedList(data, start, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i = 0; i < queue.length; i++) {
          outerNode = eliminateHole(queue[i], outerNode);
        }
        return outerNode;
      }
      function compareX(a, b) {
        return a.x - b.x;
      }
      function eliminateHole(hole, outerNode) {
        var bridge = findHoleBridge(hole, outerNode);
        if (!bridge) {
          return outerNode;
        }
        var bridgeReverse = splitPolygon(bridge, hole);
        filterPoints(bridgeReverse, bridgeReverse.next);
        return filterPoints(bridge, bridge.next);
      }
      function findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        do {
          if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
              qx = x;
              m = p.x < p.next.x ? p : p.next;
              if (x === hx)
                return m;
            }
          }
          p = p.next;
        } while (p !== outerNode);
        if (!m)
          return null;
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
        p = m;
        do {
          if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x);
            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
              m = p;
              tanMin = tan;
            }
          }
          p = p.next;
        } while (p !== stop);
        return m;
      }
      function sectorContainsSector(m, p) {
        return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
      }
      function indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
          if (p.z === 0)
            p.z = zOrder(p.x, p.y, minX, minY, invSize);
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
      }
      function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e;
              else
                list = e;
              e.prevZ = tail;
              tail = e;
            }
            p = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x, y, minX, minY, invSize) {
        x = (x - minX) * invSize | 0;
        y = (y - minY) * invSize | 0;
        x = (x | x << 8) & 16711935;
        x = (x | x << 4) & 252645135;
        x = (x | x << 2) & 858993459;
        x = (x | x << 1) & 1431655765;
        y = (y | y << 8) & 16711935;
        y = (y | y << 4) & 252645135;
        y = (y | y << 2) & 858993459;
        y = (y | y << 1) & 1431655765;
        return x | y << 1;
      }
      function getLeftmost(start) {
        var p = start, leftmost = start;
        do {
          if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
            leftmost = p;
          p = p.next;
        } while (p !== start);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
      }
      function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
      }
      function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      }
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects(p1, q1, p2, q2) {
        var o1 = sign(area(p1, q1, p2));
        var o2 = sign(area(p1, q1, q2));
        var o3 = sign(area(p2, q2, p1));
        var o4 = sign(area(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment(p1, p2, q1))
          return true;
        if (o2 === 0 && onSegment(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment(p2, p1, q2))
          return true;
        if (o4 === 0 && onSegment(p2, q1, q2))
          return true;
        return false;
      }
      function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
      }
      function sign(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a, b) {
        var p = a;
        do {
          if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
            return true;
          p = p.next;
        } while (p !== a);
        return false;
      }
      function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
      }
      function middleInside(a, b) {
        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
          if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
            inside = !inside;
          p = p.next;
        } while (p !== a);
        return inside;
      }
      function splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }
      function insertNode(i, x, y, last) {
        var p = new Node(i, x, y);
        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }
        return p;
      }
      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ)
          p.prevZ.nextZ = p.nextZ;
        if (p.nextZ)
          p.nextZ.prevZ = p.prevZ;
      }
      function Node(i, x, y) {
        this.i = i;
        this.x = x;
        this.y = y;
        this.prev = null;
        this.next = null;
        this.z = 0;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i = 0; i < triangles.length; i += 3) {
          var a = triangles[i] * dim;
          var b = triangles[i + 1] * dim;
          var c = triangles[i + 2] * dim;
          trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
      };
      function signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
          sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
          j = i;
        }
        return sum;
      }
      earcut.flatten = function(data) {
        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
        for (var i = 0; i < data.length; i++) {
          for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++)
              result.vertices.push(data[i][j][d]);
          }
          if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
      module.exports = earcut;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/shaders/Multi-frag.js
  var require_Multi_frag = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/shaders/Multi-frag.js": function(exports, module) {
      module.exports = [
        "#define SHADER_NAME PHASER_MULTI_FS",
        "",
        "#ifdef GL_FRAGMENT_PRECISION_HIGH",
        "precision highp float;",
        "#else",
        "precision mediump float;",
        "#endif",
        "",
        "uniform sampler2D uMainSampler[%count%];",
        "",
        "varying vec2 outTexCoord;",
        "varying float outTexId;",
        "varying float outTintEffect;",
        "varying vec4 outTint;",
        "",
        "void main ()",
        "{",
        "    vec4 texture;",
        "",
        "    %forloop%",
        "",
        "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);",
        "",
        "    //  Multiply texture tint",
        "    vec4 color = texture * texel;",
        "",
        "    if (outTintEffect == 1.0)",
        "    {",
        "        //  Solid color + texture alpha",
        "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);",
        "    }",
        "    else if (outTintEffect == 2.0)",
        "    {",
        "        //  Solid color, no texture",
        "        color = texel;",
        "    }",
        "",
        "    gl_FragColor = color;",
        "}",
        ""
      ].join("\n");
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/shaders/Multi-vert.js
  var require_Multi_vert = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/shaders/Multi-vert.js": function(exports, module) {
      module.exports = [
        "#define SHADER_NAME PHASER_MULTI_VS",
        "",
        "#ifdef GL_FRAGMENT_PRECISION_HIGH",
        "precision highp float;",
        "#else",
        "precision mediump float;",
        "#endif",
        "",
        "uniform mat4 uProjectionMatrix;",
        "",
        "attribute vec2 inPosition;",
        "attribute vec2 inTexCoord;",
        "attribute float inTexId;",
        "attribute float inTintEffect;",
        "attribute vec4 inTint;",
        "",
        "varying vec2 outTexCoord;",
        "varying float outTexId;",
        "varying float outTintEffect;",
        "varying vec4 outTint;",
        "",
        "void main ()",
        "{",
        "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
        "",
        "    outTexCoord = inTexCoord;",
        "    outTexId = inTexId;",
        "    outTint = inTint;",
        "    outTintEffect = inTintEffect;",
        "}",
        ""
      ].join("\n");
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/MultiPipeline.js
  var require_MultiPipeline = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/MultiPipeline.js": function(exports, module) {
      var Class = require_Class();
      var Earcut = require_Earcut();
      var GetFastValue = require_GetFastValue();
      var ShaderSourceFS = require_Multi_frag();
      var ShaderSourceVS = require_Multi_vert();
      var TransformMatrix = require_TransformMatrix();
      var Utils = require_Utils();
      var WEBGL_CONST = require_const7();
      var WebGLPipeline = require_WebGLPipeline();
      var MultiPipeline = new Class({
        Extends: WebGLPipeline,
        initialize: function MultiPipeline2(config) {
          var renderer = config.game.renderer;
          var fragmentShaderSource = GetFastValue(config, "fragShader", ShaderSourceFS);
          config.fragShader = Utils.parseFragmentShaderMaxTextures(fragmentShaderSource, renderer.maxTextures);
          config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS);
          config.attributes = GetFastValue(config, "attributes", [
            {
              name: "inPosition",
              size: 2
            },
            {
              name: "inTexCoord",
              size: 2
            },
            {
              name: "inTexId"
            },
            {
              name: "inTintEffect"
            },
            {
              name: "inTint",
              size: 4,
              type: WEBGL_CONST.UNSIGNED_BYTE,
              normalized: true
            }
          ]);
          WebGLPipeline.call(this, config);
          this._tempMatrix1 = new TransformMatrix();
          this._tempMatrix2 = new TransformMatrix();
          this._tempMatrix3 = new TransformMatrix();
          this.calcMatrix = new TransformMatrix();
          this.tempTriangle = [
            { x: 0, y: 0, width: 0 },
            { x: 0, y: 0, width: 0 },
            { x: 0, y: 0, width: 0 },
            { x: 0, y: 0, width: 0 }
          ];
          this.strokeTint = { TL: 0, TR: 0, BL: 0, BR: 0 };
          this.fillTint = { TL: 0, TR: 0, BL: 0, BR: 0 };
          this.currentFrame = { u0: 0, v0: 0, u1: 1, v1: 1 };
          this.firstQuad = [0, 0, 0, 0, 0];
          this.prevQuad = [0, 0, 0, 0, 0];
          this.polygonCache = [];
        },
        boot: function() {
          WebGLPipeline.prototype.boot.call(this);
          this.currentShader.set1iv("uMainSampler", this.renderer.textureIndexes);
        },
        batchSprite: function(gameObject, camera, parentTransformMatrix) {
          this.manager.set(this, gameObject);
          var camMatrix = this._tempMatrix1;
          var spriteMatrix = this._tempMatrix2;
          var calcMatrix = this._tempMatrix3;
          var frame = gameObject.frame;
          var texture = frame.glTexture;
          var u0 = frame.u0;
          var v0 = frame.v0;
          var u1 = frame.u1;
          var v1 = frame.v1;
          var frameX = frame.x;
          var frameY = frame.y;
          var frameWidth = frame.cutWidth;
          var frameHeight = frame.cutHeight;
          var customPivot = frame.customPivot;
          var displayOriginX = gameObject.displayOriginX;
          var displayOriginY = gameObject.displayOriginY;
          var x = -displayOriginX + frameX;
          var y = -displayOriginY + frameY;
          if (gameObject.isCropped) {
            var crop = gameObject._crop;
            if (crop.flipX !== gameObject.flipX || crop.flipY !== gameObject.flipY) {
              frame.updateCropUVs(crop, gameObject.flipX, gameObject.flipY);
            }
            u0 = crop.u0;
            v0 = crop.v0;
            u1 = crop.u1;
            v1 = crop.v1;
            frameWidth = crop.width;
            frameHeight = crop.height;
            frameX = crop.x;
            frameY = crop.y;
            x = -displayOriginX + frameX;
            y = -displayOriginY + frameY;
          }
          var flipX = 1;
          var flipY = 1;
          if (gameObject.flipX) {
            if (!customPivot) {
              x += -frame.realWidth + displayOriginX * 2;
            }
            flipX = -1;
          }
          if (gameObject.flipY || frame.source.isGLTexture && !texture.flipY) {
            if (!customPivot) {
              y += -frame.realHeight + displayOriginY * 2;
            }
            flipY = -1;
          }
          var gx = gameObject.x;
          var gy = gameObject.y;
          if (camera.roundPixels) {
            gx = Math.floor(gx);
            gy = Math.floor(gy);
          }
          spriteMatrix.applyITRS(gx, gy, gameObject.rotation, gameObject.scaleX * flipX, gameObject.scaleY * flipY);
          camMatrix.copyFrom(camera.matrix);
          if (parentTransformMatrix) {
            camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * gameObject.scrollFactorX, -camera.scrollY * gameObject.scrollFactorY);
            spriteMatrix.e = gx;
            spriteMatrix.f = gy;
          } else {
            spriteMatrix.e -= camera.scrollX * gameObject.scrollFactorX;
            spriteMatrix.f -= camera.scrollY * gameObject.scrollFactorY;
          }
          camMatrix.multiply(spriteMatrix, calcMatrix);
          var quad = calcMatrix.setQuad(x, y, x + frameWidth, y + frameHeight, false);
          var getTint = Utils.getTintAppendFloatAlpha;
          var cameraAlpha = camera.alpha;
          var tintTL = getTint(gameObject.tintTopLeft, cameraAlpha * gameObject._alphaTL);
          var tintTR = getTint(gameObject.tintTopRight, cameraAlpha * gameObject._alphaTR);
          var tintBL = getTint(gameObject.tintBottomLeft, cameraAlpha * gameObject._alphaBL);
          var tintBR = getTint(gameObject.tintBottomRight, cameraAlpha * gameObject._alphaBR);
          if (this.shouldFlush(6)) {
            this.flush();
          }
          var unit = this.setGameObject(gameObject, frame);
          this.manager.preBatch(gameObject);
          this.batchQuad(gameObject, quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7], u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, gameObject.tintFill, texture, unit);
          this.manager.postBatch(gameObject);
        },
        batchTexture: function(gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip, textureUnit) {
          this.manager.set(this, gameObject);
          var camMatrix = this._tempMatrix1;
          var spriteMatrix = this._tempMatrix2;
          var calcMatrix = this._tempMatrix3;
          var u0 = frameX / textureWidth + uOffset;
          var v0 = frameY / textureHeight + vOffset;
          var u1 = (frameX + frameWidth) / textureWidth + uOffset;
          var v1 = (frameY + frameHeight) / textureHeight + vOffset;
          var width = srcWidth;
          var height = srcHeight;
          var x = -displayOriginX;
          var y = -displayOriginY;
          if (gameObject.isCropped) {
            var crop = gameObject._crop;
            var cropWidth = crop.width;
            var cropHeight = crop.height;
            width = cropWidth;
            height = cropHeight;
            srcWidth = cropWidth;
            srcHeight = cropHeight;
            frameX = crop.x;
            frameY = crop.y;
            var ox = frameX;
            var oy = frameY;
            if (flipX) {
              ox = frameWidth - crop.x - cropWidth;
            }
            if (flipY) {
              oy = frameHeight - crop.y - cropHeight;
            }
            u0 = ox / textureWidth + uOffset;
            v0 = oy / textureHeight + vOffset;
            u1 = (ox + cropWidth) / textureWidth + uOffset;
            v1 = (oy + cropHeight) / textureHeight + vOffset;
            x = -displayOriginX + frameX;
            y = -displayOriginY + frameY;
          }
          flipY = flipY ^ (!skipFlip && texture.isRenderTexture ? 1 : 0);
          if (flipX) {
            width *= -1;
            x += srcWidth;
          }
          if (flipY) {
            height *= -1;
            y += srcHeight;
          }
          if (camera.roundPixels) {
            srcX = Math.floor(srcX);
            srcY = Math.floor(srcY);
          }
          spriteMatrix.applyITRS(srcX, srcY, rotation, scaleX, scaleY);
          camMatrix.copyFrom(camera.matrix);
          if (parentTransformMatrix) {
            camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);
            spriteMatrix.e = srcX;
            spriteMatrix.f = srcY;
          } else {
            spriteMatrix.e -= camera.scrollX * scrollFactorX;
            spriteMatrix.f -= camera.scrollY * scrollFactorY;
          }
          camMatrix.multiply(spriteMatrix, calcMatrix);
          var quad = calcMatrix.setQuad(x, y, x + width, y + height, false);
          if (textureUnit === void 0) {
            textureUnit = this.setTexture2D(texture);
          }
          if (gameObject) {
            this.manager.preBatch(gameObject);
          }
          this.batchQuad(gameObject, quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7], u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
          if (gameObject) {
            this.manager.postBatch(gameObject);
          }
        },
        batchTextureFrame: function(frame, x, y, tint, alpha, transformMatrix, parentTransformMatrix) {
          this.manager.set(this);
          var spriteMatrix = this._tempMatrix1.copyFrom(transformMatrix);
          var calcMatrix = this._tempMatrix2;
          if (parentTransformMatrix) {
            spriteMatrix.multiply(parentTransformMatrix, calcMatrix);
          } else {
            calcMatrix = spriteMatrix;
          }
          var quad = calcMatrix.setQuad(x, y, x + frame.width, y + frame.height, false);
          var unit = this.setTexture2D(frame.source.glTexture);
          tint = Utils.getTintAppendFloatAlpha(tint, alpha);
          this.batchQuad(null, quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7], frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, 0, frame.glTexture, unit);
        },
        batchFillRect: function(x, y, width, height, currentMatrix, parentMatrix) {
          this.renderer.pipelines.set(this);
          var calcMatrix = this.calcMatrix;
          if (parentMatrix) {
            parentMatrix.multiply(currentMatrix, calcMatrix);
          }
          var quad = calcMatrix.setQuad(x, y, x + width, y + height, false);
          var tint = this.fillTint;
          this.batchQuad(null, quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7], 0, 0, 1, 1, tint.TL, tint.TR, tint.BL, tint.BR, 2);
        },
        batchFillTriangle: function(x0, y0, x1, y1, x2, y2, currentMatrix, parentMatrix) {
          this.renderer.pipelines.set(this);
          var calcMatrix = this.calcMatrix;
          if (parentMatrix) {
            parentMatrix.multiply(currentMatrix, calcMatrix);
          }
          var tx0 = calcMatrix.getX(x0, y0);
          var ty0 = calcMatrix.getY(x0, y0);
          var tx1 = calcMatrix.getX(x1, y1);
          var ty1 = calcMatrix.getY(x1, y1);
          var tx2 = calcMatrix.getX(x2, y2);
          var ty2 = calcMatrix.getY(x2, y2);
          var tint = this.fillTint;
          this.batchTri(null, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, tint.TL, tint.TR, tint.BL, 2);
        },
        batchStrokeTriangle: function(x0, y0, x1, y1, x2, y2, lineWidth, currentMatrix, parentMatrix) {
          var tempTriangle = this.tempTriangle;
          tempTriangle[0].x = x0;
          tempTriangle[0].y = y0;
          tempTriangle[0].width = lineWidth;
          tempTriangle[1].x = x1;
          tempTriangle[1].y = y1;
          tempTriangle[1].width = lineWidth;
          tempTriangle[2].x = x2;
          tempTriangle[2].y = y2;
          tempTriangle[2].width = lineWidth;
          tempTriangle[3].x = x0;
          tempTriangle[3].y = y0;
          tempTriangle[3].width = lineWidth;
          this.batchStrokePath(tempTriangle, lineWidth, false, currentMatrix, parentMatrix);
        },
        batchFillPath: function(path, currentMatrix, parentMatrix) {
          this.renderer.pipelines.set(this);
          var calcMatrix = this.calcMatrix;
          if (parentMatrix) {
            parentMatrix.multiply(currentMatrix, calcMatrix);
          }
          var length = path.length;
          var polygonCache = this.polygonCache;
          var polygonIndexArray;
          var point;
          var tintTL = this.fillTint.TL;
          var tintTR = this.fillTint.TR;
          var tintBL = this.fillTint.BL;
          for (var pathIndex = 0; pathIndex < length; ++pathIndex) {
            point = path[pathIndex];
            polygonCache.push(point.x, point.y);
          }
          polygonIndexArray = Earcut(polygonCache);
          length = polygonIndexArray.length;
          for (var index = 0; index < length; index += 3) {
            var p0 = polygonIndexArray[index + 0] * 2;
            var p1 = polygonIndexArray[index + 1] * 2;
            var p2 = polygonIndexArray[index + 2] * 2;
            var x0 = polygonCache[p0 + 0];
            var y0 = polygonCache[p0 + 1];
            var x1 = polygonCache[p1 + 0];
            var y1 = polygonCache[p1 + 1];
            var x2 = polygonCache[p2 + 0];
            var y2 = polygonCache[p2 + 1];
            var tx0 = calcMatrix.getX(x0, y0);
            var ty0 = calcMatrix.getY(x0, y0);
            var tx1 = calcMatrix.getX(x1, y1);
            var ty1 = calcMatrix.getY(x1, y1);
            var tx2 = calcMatrix.getX(x2, y2);
            var ty2 = calcMatrix.getY(x2, y2);
            this.batchTri(null, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, tintTL, tintTR, tintBL, 2);
          }
          polygonCache.length = 0;
        },
        batchStrokePath: function(path, lineWidth, pathOpen, currentMatrix, parentMatrix) {
          this.renderer.pipelines.set(this);
          this.prevQuad[4] = 0;
          this.firstQuad[4] = 0;
          var pathLength = path.length - 1;
          for (var pathIndex = 0; pathIndex < pathLength; pathIndex++) {
            var point0 = path[pathIndex];
            var point1 = path[pathIndex + 1];
            this.batchLine(point0.x, point0.y, point1.x, point1.y, point0.width / 2, point1.width / 2, lineWidth, pathIndex, !pathOpen && pathIndex === pathLength - 1, currentMatrix, parentMatrix);
          }
        },
        batchLine: function(ax, ay, bx, by, aLineWidth, bLineWidth, lineWidth, index, closePath, currentMatrix, parentMatrix) {
          this.renderer.pipelines.set(this);
          var calcMatrix = this.calcMatrix;
          if (parentMatrix) {
            parentMatrix.multiply(currentMatrix, calcMatrix);
          }
          var dx = bx - ax;
          var dy = by - ay;
          var len = Math.sqrt(dx * dx + dy * dy);
          if (len === 0) {
            return;
          }
          var al0 = aLineWidth * (by - ay) / len;
          var al1 = aLineWidth * (ax - bx) / len;
          var bl0 = bLineWidth * (by - ay) / len;
          var bl1 = bLineWidth * (ax - bx) / len;
          var lx0 = bx - bl0;
          var ly0 = by - bl1;
          var lx1 = ax - al0;
          var ly1 = ay - al1;
          var lx2 = bx + bl0;
          var ly2 = by + bl1;
          var lx3 = ax + al0;
          var ly3 = ay + al1;
          var brX = calcMatrix.getX(lx0, ly0);
          var brY = calcMatrix.getY(lx0, ly0);
          var blX = calcMatrix.getX(lx1, ly1);
          var blY = calcMatrix.getY(lx1, ly1);
          var trX = calcMatrix.getX(lx2, ly2);
          var trY = calcMatrix.getY(lx2, ly2);
          var tlX = calcMatrix.getX(lx3, ly3);
          var tlY = calcMatrix.getY(lx3, ly3);
          var tint = this.strokeTint;
          var tintTL = tint.TL;
          var tintTR = tint.TR;
          var tintBL = tint.BL;
          var tintBR = tint.BR;
          this.batchQuad(null, tlX, tlY, blX, blY, brX, brY, trX, trY, 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);
          if (lineWidth <= 2) {
            return;
          }
          var prev = this.prevQuad;
          var first = this.firstQuad;
          if (index > 0 && prev[4]) {
            this.batchQuad(null, tlX, tlY, blX, blY, prev[0], prev[1], prev[2], prev[3], 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);
          } else {
            first[0] = tlX;
            first[1] = tlY;
            first[2] = blX;
            first[3] = blY;
            first[4] = 1;
          }
          if (closePath && first[4]) {
            this.batchQuad(null, brX, brY, trX, trY, first[0], first[1], first[2], first[3], 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);
          } else {
            prev[0] = brX;
            prev[1] = brY;
            prev[2] = trX;
            prev[3] = trY;
            prev[4] = 1;
          }
        },
        destroy: function() {
          this._tempMatrix1.destroy();
          this._tempMatrix2.destroy();
          this._tempMatrix3.destroy();
          this._tempMatrix1 = null;
          this._tempMatrix1 = null;
          this._tempMatrix1 = null;
          WebGLPipeline.prototype.destroy.call(this);
          return this;
        }
      });
      module.exports = MultiPipeline;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/LightPipeline.js
  var require_LightPipeline = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/LightPipeline.js": function(exports, module) {
      var Class = require_Class();
      var GetFastValue = require_GetFastValue();
      var LightShaderSourceFS = require_Light_frag();
      var MultiPipeline = require_MultiPipeline();
      var TransformMatrix = require_TransformMatrix();
      var Vec2 = require_Vector2();
      var WebGLPipeline = require_WebGLPipeline();
      var LightPipeline = new Class({
        Extends: MultiPipeline,
        initialize: function LightPipeline2(config) {
          var fragShader = GetFastValue(config, "fragShader", LightShaderSourceFS);
          config.fragShader = fragShader.replace("%LIGHT_COUNT%", config.game.renderer.config.maxLights);
          MultiPipeline.call(this, config);
          this.inverseRotationMatrix = new Float32Array([
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ]);
          this.defaultNormalMap;
          this.currentNormalMap;
          this.lightsActive = true;
          this.tempVec2 = new Vec2();
          this._tempMatrix = new TransformMatrix();
          this._tempMatrix2 = new TransformMatrix();
        },
        boot: function() {
          WebGLPipeline.prototype.boot.call(this);
          var gl = this.gl;
          var tempTexture = gl.createTexture();
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, tempTexture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([127, 127, 255, 255]));
          this.defaultNormalMap = { glTexture: tempTexture };
        },
        onRender: function(scene, camera) {
          var lightManager = scene.sys.lights;
          this.lightsActive = false;
          if (!lightManager || !lightManager.active) {
            return;
          }
          var lights = lightManager.getLights(camera);
          var lightsCount = lights.length;
          this.lightsActive = true;
          var i;
          var renderer = this.renderer;
          var height = renderer.height;
          var cameraMatrix = camera.matrix;
          var tempVec2 = this.tempVec2;
          this.set1i("uMainSampler", 0);
          this.set1i("uNormSampler", 1);
          this.set2f("uResolution", this.width / 2, this.height / 2);
          this.set4f("uCamera", camera.x, camera.y, camera.rotation, camera.zoom);
          this.set3f("uAmbientLightColor", lightManager.ambientColor.r, lightManager.ambientColor.g, lightManager.ambientColor.b);
          this.set1i("uLightCount", lightsCount);
          for (i = 0; i < lightsCount; i++) {
            var light = lights[i].light;
            var color = light.color;
            var lightName = "uLights[" + i + "].";
            cameraMatrix.transformPoint(light.x, light.y, tempVec2);
            this.set2f(lightName + "position", tempVec2.x - camera.scrollX * light.scrollFactorX * camera.zoom, height - (tempVec2.y - camera.scrollY * light.scrollFactorY * camera.zoom));
            this.set3f(lightName + "color", color.r, color.g, color.b);
            this.set1f(lightName + "intensity", light.intensity);
            this.set1f(lightName + "radius", light.radius);
          }
          this.currentNormalMapRotation = null;
        },
        setNormalMapRotation: function(rotation) {
          if (rotation !== this.currentNormalMapRotation || this.vertexCount === 0) {
            if (this.vertexCount > 0) {
              this.flush();
            }
            var inverseRotationMatrix = this.inverseRotationMatrix;
            if (rotation) {
              var rot = -rotation;
              var c = Math.cos(rot);
              var s = Math.sin(rot);
              inverseRotationMatrix[1] = s;
              inverseRotationMatrix[3] = -s;
              inverseRotationMatrix[0] = inverseRotationMatrix[4] = c;
            } else {
              inverseRotationMatrix[0] = inverseRotationMatrix[4] = 1;
              inverseRotationMatrix[1] = inverseRotationMatrix[3] = 0;
            }
            this.setMatrix3fv("uInverseRotationMatrix", false, inverseRotationMatrix);
            this.currentNormalMapRotation = rotation;
          }
        },
        setTexture2D: function(texture, gameObject) {
          var renderer = this.renderer;
          if (texture === void 0) {
            texture = renderer.whiteTexture;
          }
          var normalMap = this.getNormalMap(gameObject);
          if (this.isNewNormalMap(texture, normalMap)) {
            this.flush();
            this.createBatch(texture);
            this.addTextureToBatch(normalMap);
            this.currentNormalMap = normalMap;
          }
          var rotation = 0;
          if (gameObject && gameObject.parentContainer) {
            var matrix = gameObject.getWorldTransformMatrix(this._tempMatrix, this._tempMatrix2);
            rotation = matrix.rotationNormalized;
          } else if (gameObject) {
            rotation = gameObject.rotation;
          }
          this.setNormalMapRotation(rotation);
          return 0;
        },
        setGameObject: function(gameObject, frame) {
          if (frame === void 0) {
            frame = gameObject.frame;
          }
          var texture = frame.glTexture;
          var normalMap = this.getNormalMap(gameObject);
          if (this.isNewNormalMap(texture, normalMap)) {
            this.flush();
            this.createBatch(texture);
            this.addTextureToBatch(normalMap);
            this.currentNormalMap = normalMap;
          }
          if (gameObject.parentContainer) {
            var matrix = gameObject.getWorldTransformMatrix(this._tempMatrix, this._tempMatrix2);
            this.setNormalMapRotation(matrix.rotationNormalized);
          } else {
            this.setNormalMapRotation(gameObject.rotation);
          }
          return 0;
        },
        isNewNormalMap: function(texture, normalMap) {
          return this.currentTexture !== texture || this.currentNormalMap !== normalMap;
        },
        getNormalMap: function(gameObject) {
          var normalMap;
          if (!gameObject) {
            normalMap = this.defaultNormalMap;
          } else if (gameObject.displayTexture) {
            normalMap = gameObject.displayTexture.dataSource[gameObject.displayFrame.sourceIndex];
          } else if (gameObject.texture) {
            normalMap = gameObject.texture.dataSource[gameObject.frame.sourceIndex];
          } else if (gameObject.tileset) {
            if (Array.isArray(gameObject.tileset)) {
              normalMap = gameObject.tileset[0].image.dataSource[0];
            } else {
              normalMap = gameObject.tileset.image.dataSource[0];
            }
          }
          if (!normalMap) {
            normalMap = this.defaultNormalMap;
          }
          return normalMap.glTexture;
        },
        batchSprite: function(gameObject, camera, parentTransformMatrix) {
          if (this.lightsActive) {
            MultiPipeline.prototype.batchSprite.call(this, gameObject, camera, parentTransformMatrix);
          }
        },
        batchTexture: function(gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip, textureUnit) {
          if (this.lightsActive) {
            MultiPipeline.prototype.batchTexture.call(this, gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip, textureUnit);
          }
        },
        batchTextureFrame: function(frame, x, y, tint, alpha, transformMatrix, parentTransformMatrix) {
          if (this.lightsActive) {
            MultiPipeline.prototype.batchTextureFrame.call(this, frame, x, y, tint, alpha, transformMatrix, parentTransformMatrix);
          }
        }
      });
      module.exports = LightPipeline;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/shaders/Single-frag.js
  var require_Single_frag = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/shaders/Single-frag.js": function(exports, module) {
      module.exports = [
        "#define SHADER_NAME PHASER_SINGLE_FS",
        "",
        "#ifdef GL_FRAGMENT_PRECISION_HIGH",
        "precision highp float;",
        "#else",
        "precision mediump float;",
        "#endif",
        "",
        "uniform sampler2D uMainSampler;",
        "",
        "varying vec2 outTexCoord;",
        "varying float outTintEffect;",
        "varying vec4 outTint;",
        "",
        "void main ()",
        "{",
        "    vec4 texture = texture2D(uMainSampler, outTexCoord);",
        "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);",
        "",
        "    //  Multiply texture tint",
        "    vec4 color = texture * texel;",
        "",
        "    if (outTintEffect == 1.0)",
        "    {",
        "        //  Solid color + texture alpha",
        "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);",
        "    }",
        "    else if (outTintEffect == 2.0)",
        "    {",
        "        //  Solid color, no texture",
        "        color = texel;",
        "    }",
        "",
        "    gl_FragColor = color;",
        "}",
        ""
      ].join("\n");
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/shaders/Single-vert.js
  var require_Single_vert = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/shaders/Single-vert.js": function(exports, module) {
      module.exports = [
        "#define SHADER_NAME PHASER_SINGLE_VS",
        "",
        "precision mediump float;",
        "",
        "uniform mat4 uProjectionMatrix;",
        "",
        "attribute vec2 inPosition;",
        "attribute vec2 inTexCoord;",
        "attribute float inTexId;",
        "attribute float inTintEffect;",
        "attribute vec4 inTint;",
        "",
        "varying vec2 outTexCoord;",
        "varying float outTintEffect;",
        "varying vec4 outTint;",
        "",
        "void main ()",
        "{",
        "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
        "",
        "    outTexCoord = inTexCoord;",
        "    outTint = inTint;",
        "    outTintEffect = inTintEffect;",
        "}",
        ""
      ].join("\n");
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/MobilePipeline.js
  var require_MobilePipeline = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/MobilePipeline.js": function(exports, module) {
      var Class = require_Class();
      var GetFastValue = require_GetFastValue();
      var MultiPipeline = require_MultiPipeline();
      var ShaderSourceFS = require_Single_frag();
      var ShaderSourceVS = require_Single_vert();
      var WEBGL_CONST = require_const7();
      var WebGLPipeline = require_WebGLPipeline();
      var MobilePipeline = new Class({
        Extends: MultiPipeline,
        initialize: function MobilePipeline2(config) {
          config.fragShader = GetFastValue(config, "fragShader", ShaderSourceFS);
          config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS);
          config.attributes = GetFastValue(config, "attributes", [
            {
              name: "inPosition",
              size: 2
            },
            {
              name: "inTexCoord",
              size: 2
            },
            {
              name: "inTexId"
            },
            {
              name: "inTintEffect"
            },
            {
              name: "inTint",
              size: 4,
              type: WEBGL_CONST.UNSIGNED_BYTE,
              normalized: true
            }
          ]);
          config.forceZero = true;
          MultiPipeline.call(this, config);
        },
        boot: function() {
          WebGLPipeline.prototype.boot.call(this);
          this.set1i("uMainSampler", 0);
        }
      });
      module.exports = MobilePipeline;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/shaders/PointLight-frag.js
  var require_PointLight_frag = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/shaders/PointLight-frag.js": function(exports, module) {
      module.exports = [
        "#define SHADER_NAME PHASER_POINTLIGHT_FS",
        "",
        "precision mediump float;",
        "",
        "uniform vec2 uResolution;",
        "uniform float uCameraZoom;",
        "",
        "varying vec4 lightPosition;",
        "varying vec4 lightColor;",
        "varying float lightRadius;",
        "varying float lightAttenuation;",
        "",
        "void main ()",
        "{",
        "    vec2 center = (lightPosition.xy + 1.0) * (uResolution.xy * 0.5);",
        "",
        "    float distToSurf = length(center - gl_FragCoord.xy);",
        "",
        "    float radius = 1.0 - distToSurf / (lightRadius * uCameraZoom);",
        "",
        "    float intensity = smoothstep(0.0, 1.0, radius * lightAttenuation);",
        "",
        "    vec4 color = vec4(intensity, intensity, intensity, 0.0) * lightColor;",
        "",
        "    gl_FragColor = vec4(color.rgb * lightColor.a, color.a);",
        "}",
        ""
      ].join("\n");
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/shaders/PointLight-vert.js
  var require_PointLight_vert = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/shaders/PointLight-vert.js": function(exports, module) {
      module.exports = [
        "#define SHADER_NAME PHASER_POINTLIGHT_VS",
        "",
        "precision mediump float;",
        "",
        "uniform mat4 uProjectionMatrix;",
        "",
        "attribute vec2 inPosition;",
        "attribute vec2 inLightPosition;",
        "attribute vec4 inLightColor;",
        "attribute float inLightRadius;",
        "attribute float inLightAttenuation;",
        "",
        "varying vec4 lightPosition;",
        "varying vec4 lightColor;",
        "varying float lightRadius;",
        "varying float lightAttenuation;",
        "",
        "void main ()",
        "{",
        "    lightColor = inLightColor;",
        "    lightRadius = inLightRadius;",
        "    lightAttenuation = inLightAttenuation;",
        "    lightPosition = uProjectionMatrix * vec4(inLightPosition, 1.0, 1.0);",
        "",
        "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
        "}",
        ""
      ].join("\n");
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/PointLightPipeline.js
  var require_PointLightPipeline = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/PointLightPipeline.js": function(exports, module) {
      var Class = require_Class();
      var GetFastValue = require_GetFastValue();
      var PointLightShaderSourceFS = require_PointLight_frag();
      var PointLightShaderSourceVS = require_PointLight_vert();
      var WebGLPipeline = require_WebGLPipeline();
      var PointLightPipeline = new Class({
        Extends: WebGLPipeline,
        initialize: function PointLightPipeline2(config) {
          config.vertShader = GetFastValue(config, "vertShader", PointLightShaderSourceVS);
          config.fragShader = GetFastValue(config, "fragShader", PointLightShaderSourceFS);
          config.attributes = GetFastValue(config, "attributes", [
            {
              name: "inPosition",
              size: 2
            },
            {
              name: "inLightPosition",
              size: 2
            },
            {
              name: "inLightRadius"
            },
            {
              name: "inLightAttenuation"
            },
            {
              name: "inLightColor",
              size: 4
            }
          ]);
          WebGLPipeline.call(this, config);
        },
        onRender: function(scene, camera) {
          this.set2f("uResolution", this.width, this.height);
          this.set1f("uCameraZoom", camera.zoom);
        },
        batchPointLight: function(light, camera, x0, y0, x1, y1, x2, y2, x3, y3, lightX, lightY) {
          var color = light.color;
          var intensity = light.intensity;
          var radius = light.radius;
          var attenuation = light.attenuation;
          var r = color.r * intensity;
          var g = color.g * intensity;
          var b = color.b * intensity;
          var a = camera.alpha * light.alpha;
          if (this.shouldFlush(6)) {
            this.flush();
          }
          if (!this.currentBatch) {
            this.setTexture2D();
          }
          this.batchLightVert(x0, y0, lightX, lightY, radius, attenuation, r, g, b, a);
          this.batchLightVert(x1, y1, lightX, lightY, radius, attenuation, r, g, b, a);
          this.batchLightVert(x2, y2, lightX, lightY, radius, attenuation, r, g, b, a);
          this.batchLightVert(x0, y0, lightX, lightY, radius, attenuation, r, g, b, a);
          this.batchLightVert(x2, y2, lightX, lightY, radius, attenuation, r, g, b, a);
          this.batchLightVert(x3, y3, lightX, lightY, radius, attenuation, r, g, b, a);
          this.currentBatch.count = this.vertexCount - this.currentBatch.start;
        },
        batchLightVert: function(x, y, lightX, lightY, radius, attenuation, r, g, b, a) {
          var vertexViewF32 = this.vertexViewF32;
          var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
          vertexViewF32[++vertexOffset] = x;
          vertexViewF32[++vertexOffset] = y;
          vertexViewF32[++vertexOffset] = lightX;
          vertexViewF32[++vertexOffset] = lightY;
          vertexViewF32[++vertexOffset] = radius;
          vertexViewF32[++vertexOffset] = attenuation;
          vertexViewF32[++vertexOffset] = r;
          vertexViewF32[++vertexOffset] = g;
          vertexViewF32[++vertexOffset] = b;
          vertexViewF32[++vertexOffset] = a;
          this.vertexCount++;
        }
      });
      module.exports = PointLightPipeline;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/RopePipeline.js
  var require_RopePipeline = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/RopePipeline.js": function(exports, module) {
      var Class = require_Class();
      var GetFastValue = require_GetFastValue();
      var MultiPipeline = require_MultiPipeline();
      var RopePipeline = new Class({
        Extends: MultiPipeline,
        initialize: function RopePipeline2(config) {
          config.topology = 5;
          config.batchSize = GetFastValue(config, "batchSize", 256);
          MultiPipeline.call(this, config);
        }
      });
      module.exports = RopePipeline;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/SinglePipeline.js
  var require_SinglePipeline = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/SinglePipeline.js": function(exports, module) {
      var Class = require_Class();
      var GetFastValue = require_GetFastValue();
      var MultiPipeline = require_MultiPipeline();
      var ShaderSourceFS = require_Single_frag();
      var ShaderSourceVS = require_Single_vert();
      var WebGLPipeline = require_WebGLPipeline();
      var SinglePipeline = new Class({
        Extends: MultiPipeline,
        initialize: function SinglePipeline2(config) {
          config.fragShader = GetFastValue(config, "fragShader", ShaderSourceFS), config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS), config.forceZero = true;
          MultiPipeline.call(this, config);
        },
        boot: function() {
          WebGLPipeline.prototype.boot.call(this);
          this.set1i("uMainSampler", 0);
        }
      });
      module.exports = SinglePipeline;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/shaders/AddBlend-frag.js
  var require_AddBlend_frag = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/shaders/AddBlend-frag.js": function(exports, module) {
      module.exports = [
        "#define SHADER_NAME PHASER_ADD_BLEND_FS",
        "",
        "precision mediump float;",
        "",
        "uniform sampler2D uMainSampler1;",
        "uniform sampler2D uMainSampler2;",
        "uniform float uStrength;",
        "",
        "varying vec2 outTexCoord;",
        "",
        "void main ()",
        "{",
        "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);",
        "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);",
        "",
        "    gl_FragColor = frame1 + frame2 * uStrength;",
        "}",
        ""
      ].join("\n");
    }
  });

  // ../../node_modules/phaser/src/display/ColorMatrix.js
  var require_ColorMatrix = __commonJS({
    "../../node_modules/phaser/src/display/ColorMatrix.js": function(exports, module) {
      var Class = require_Class();
      var tempMatrix = new Float32Array(20);
      var ColorMatrix = new Class({
        initialize: function ColorMatrix2() {
          this._matrix = new Float32Array(20);
          this.alpha = 1;
          this._dirty = true;
          this._data = new Float32Array(20);
          this.reset();
        },
        set: function(value) {
          this._matrix.set(value);
          this._dirty = true;
          return this;
        },
        reset: function() {
          var m = this._matrix;
          m.fill(0);
          m[0] = 1;
          m[6] = 1;
          m[12] = 1;
          m[18] = 1;
          this.alpha = 1;
          this._dirty = true;
          return this;
        },
        getData: function() {
          var data = this._data;
          if (this._dirty) {
            data.set(this._matrix);
            data[4] /= 255;
            data[9] /= 255;
            data[14] /= 255;
            data[19] /= 255;
            this._dirty = false;
          }
          return data;
        },
        brightness: function(value, multiply) {
          if (value === void 0) {
            value = 0;
          }
          if (multiply === void 0) {
            multiply = false;
          }
          var b = value;
          return this.multiply([
            b,
            0,
            0,
            0,
            0,
            0,
            b,
            0,
            0,
            0,
            0,
            0,
            b,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ], multiply);
        },
        saturate: function(value, multiply) {
          if (value === void 0) {
            value = 0;
          }
          if (multiply === void 0) {
            multiply = false;
          }
          var x = value * 2 / 3 + 1;
          var y = (x - 1) * -0.5;
          return this.multiply([
            x,
            y,
            y,
            0,
            0,
            y,
            x,
            y,
            0,
            0,
            y,
            y,
            x,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ], multiply);
        },
        desaturate: function(multiply) {
          if (multiply === void 0) {
            multiply = false;
          }
          return this.saturate(-1, multiply);
        },
        hue: function(rotation, multiply) {
          if (rotation === void 0) {
            rotation = 0;
          }
          if (multiply === void 0) {
            multiply = false;
          }
          rotation = rotation / 180 * Math.PI;
          var cos = Math.cos(rotation);
          var sin = Math.sin(rotation);
          var lumR = 0.213;
          var lumG = 0.715;
          var lumB = 0.072;
          return this.multiply([
            lumR + cos * (1 - lumR) + sin * -lumR,
            lumG + cos * -lumG + sin * -lumG,
            lumB + cos * -lumB + sin * (1 - lumB),
            0,
            0,
            lumR + cos * -lumR + sin * 0.143,
            lumG + cos * (1 - lumG) + sin * 0.14,
            lumB + cos * -lumB + sin * -0.283,
            0,
            0,
            lumR + cos * -lumR + sin * -(1 - lumR),
            lumG + cos * -lumG + sin * lumG,
            lumB + cos * (1 - lumB) + sin * lumB,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ], multiply);
        },
        grayscale: function(value, multiply) {
          if (value === void 0) {
            value = 1;
          }
          if (multiply === void 0) {
            multiply = false;
          }
          return this.saturate(-value, multiply);
        },
        blackWhite: function(multiply) {
          if (multiply === void 0) {
            multiply = false;
          }
          return this.multiply(ColorMatrix.BLACK_WHITE, multiply);
        },
        contrast: function(value, multiply) {
          if (value === void 0) {
            value = 0;
          }
          if (multiply === void 0) {
            multiply = false;
          }
          var v = value + 1;
          var o = -0.5 * (v - 1);
          return this.multiply([
            v,
            0,
            0,
            0,
            o,
            0,
            v,
            0,
            0,
            o,
            0,
            0,
            v,
            0,
            o,
            0,
            0,
            0,
            1,
            0
          ], multiply);
        },
        negative: function(multiply) {
          if (multiply === void 0) {
            multiply = false;
          }
          return this.multiply(ColorMatrix.NEGATIVE, multiply);
        },
        desaturateLuminance: function(multiply) {
          if (multiply === void 0) {
            multiply = false;
          }
          return this.multiply(ColorMatrix.DESATURATE_LUMINANCE, multiply);
        },
        sepia: function(multiply) {
          if (multiply === void 0) {
            multiply = false;
          }
          return this.multiply(ColorMatrix.SEPIA, multiply);
        },
        night: function(intensity, multiply) {
          if (intensity === void 0) {
            intensity = 0.1;
          }
          if (multiply === void 0) {
            multiply = false;
          }
          return this.multiply([
            intensity * -2,
            -intensity,
            0,
            0,
            0,
            -intensity,
            0,
            intensity,
            0,
            0,
            0,
            intensity,
            intensity * 2,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ], multiply);
        },
        lsd: function(multiply) {
          if (multiply === void 0) {
            multiply = false;
          }
          return this.multiply(ColorMatrix.LSD, multiply);
        },
        brown: function(multiply) {
          if (multiply === void 0) {
            multiply = false;
          }
          return this.multiply(ColorMatrix.BROWN, multiply);
        },
        vintagePinhole: function(multiply) {
          if (multiply === void 0) {
            multiply = false;
          }
          return this.multiply(ColorMatrix.VINTAGE, multiply);
        },
        kodachrome: function(multiply) {
          if (multiply === void 0) {
            multiply = false;
          }
          return this.multiply(ColorMatrix.KODACHROME, multiply);
        },
        technicolor: function(multiply) {
          if (multiply === void 0) {
            multiply = false;
          }
          return this.multiply(ColorMatrix.TECHNICOLOR, multiply);
        },
        polaroid: function(multiply) {
          if (multiply === void 0) {
            multiply = false;
          }
          return this.multiply(ColorMatrix.POLAROID, multiply);
        },
        shiftToBGR: function(multiply) {
          if (multiply === void 0) {
            multiply = false;
          }
          return this.multiply(ColorMatrix.SHIFT_BGR, multiply);
        },
        multiply: function(a, multiply) {
          if (multiply === void 0) {
            multiply = false;
          }
          if (!multiply) {
            this.reset();
          }
          var m = this._matrix;
          var c = tempMatrix;
          c.set(m);
          m.set([
            c[0] * a[0] + c[1] * a[5] + c[2] * a[10] + c[3] * a[15],
            c[0] * a[1] + c[1] * a[6] + c[2] * a[11] + c[3] * a[16],
            c[0] * a[2] + c[1] * a[7] + c[2] * a[12] + c[3] * a[17],
            c[0] * a[3] + c[1] * a[8] + c[2] * a[13] + c[3] * a[18],
            c[0] * a[4] + c[1] * a[9] + c[2] * a[14] + c[3] * a[19] + c[4],
            c[5] * a[0] + c[6] * a[5] + c[7] * a[10] + c[8] * a[15],
            c[5] * a[1] + c[6] * a[6] + c[7] * a[11] + c[8] * a[16],
            c[5] * a[2] + c[6] * a[7] + c[7] * a[12] + c[8] * a[17],
            c[5] * a[3] + c[6] * a[8] + c[7] * a[13] + c[8] * a[18],
            c[5] * a[4] + c[6] * a[9] + c[7] * a[14] + c[8] * a[19] + c[9],
            c[10] * a[0] + c[11] * a[5] + c[12] * a[10] + c[13] * a[15],
            c[10] * a[1] + c[11] * a[6] + c[12] * a[11] + c[13] * a[16],
            c[10] * a[2] + c[11] * a[7] + c[12] * a[12] + c[13] * a[17],
            c[10] * a[3] + c[11] * a[8] + c[12] * a[13] + c[13] * a[18],
            c[10] * a[4] + c[11] * a[9] + c[12] * a[14] + c[13] * a[19] + c[14],
            c[15] * a[0] + c[16] * a[5] + c[17] * a[10] + c[18] * a[15],
            c[15] * a[1] + c[16] * a[6] + c[17] * a[11] + c[18] * a[16],
            c[15] * a[2] + c[16] * a[7] + c[17] * a[12] + c[18] * a[17],
            c[15] * a[3] + c[16] * a[8] + c[17] * a[13] + c[18] * a[18],
            c[15] * a[4] + c[16] * a[9] + c[17] * a[14] + c[18] * a[19] + c[19]
          ]);
          this._dirty = true;
          return this;
        }
      });
      ColorMatrix.BLACK_WHITE = [0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1, 0];
      ColorMatrix.NEGATIVE = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0];
      ColorMatrix.DESATURATE_LUMINANCE = [0.2764723, 0.929708, 0.0938197, 0, -37.1, 0.2764723, 0.929708, 0.0938197, 0, -37.1, 0.2764723, 0.929708, 0.0938197, 0, -37.1, 0, 0, 0, 1, 0];
      ColorMatrix.SEPIA = [0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0];
      ColorMatrix.LSD = [2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0];
      ColorMatrix.BROWN = [0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0];
      ColorMatrix.VINTAGE = [0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0];
      ColorMatrix.KODACHROME = [1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0];
      ColorMatrix.TECHNICOLOR = [1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0];
      ColorMatrix.POLAROID = [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0];
      ColorMatrix.SHIFT_BGR = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
      module.exports = ColorMatrix;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/shaders/ColorMatrix-frag.js
  var require_ColorMatrix_frag = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/shaders/ColorMatrix-frag.js": function(exports, module) {
      module.exports = [
        "#define SHADER_NAME PHASER_COLORMATRIX_FS",
        "",
        "precision mediump float;",
        "",
        "uniform sampler2D uMainSampler;",
        "uniform float uColorMatrix[20];",
        "uniform float uAlpha;",
        "",
        "varying vec2 outTexCoord;",
        "",
        "void main ()",
        "{",
        "    vec4 c = texture2D(uMainSampler, outTexCoord);",
        "",
        "    if (uAlpha == 0.0)",
        "    {",
        "        gl_FragColor = c;",
        "",
        "        return;",
        "    }",
        "",
        "    if (c.a > 0.0)",
        "    {",
        "        c.rgb /= c.a;",
        "    }",
        "",
        "    vec4 result;",
        "",
        "    result.r = (uColorMatrix[0] * c.r) + (uColorMatrix[1] * c.g) + (uColorMatrix[2] * c.b) + (uColorMatrix[3] * c.a) + uColorMatrix[4];",
        "    result.g = (uColorMatrix[5] * c.r) + (uColorMatrix[6] * c.g) + (uColorMatrix[7] * c.b) + (uColorMatrix[8] * c.a) + uColorMatrix[9];",
        "    result.b = (uColorMatrix[10] * c.r) + (uColorMatrix[11] * c.g) + (uColorMatrix[12] * c.b) + (uColorMatrix[13] * c.a) + uColorMatrix[14];",
        "    result.a = (uColorMatrix[15] * c.r) + (uColorMatrix[16] * c.g) + (uColorMatrix[17] * c.b) + (uColorMatrix[18] * c.a) + uColorMatrix[19];",
        "",
        "    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);",
        "",
        "    rgb *= result.a;",
        "",
        "    gl_FragColor = vec4(rgb, result.a);",
        "}",
        ""
      ].join("\n");
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/shaders/Copy-frag.js
  var require_Copy_frag = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/shaders/Copy-frag.js": function(exports, module) {
      module.exports = [
        "#define SHADER_NAME PHASER_COPY_FS",
        "",
        "precision mediump float;",
        "",
        "uniform sampler2D uMainSampler;",
        "uniform float uBrightness;",
        "",
        "varying vec2 outTexCoord;",
        "",
        "void main ()",
        "{",
        "    gl_FragColor = texture2D(uMainSampler, outTexCoord) * uBrightness;",
        "}",
        ""
      ].join("\n");
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/shaders/LinearBlend-frag.js
  var require_LinearBlend_frag = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/shaders/LinearBlend-frag.js": function(exports, module) {
      module.exports = [
        "#define SHADER_NAME PHASER_LINEAR_BLEND_FS",
        "",
        "precision mediump float;",
        "",
        "uniform sampler2D uMainSampler1;",
        "uniform sampler2D uMainSampler2;",
        "uniform float uStrength;",
        "",
        "varying vec2 outTexCoord;",
        "",
        "void main ()",
        "{",
        "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);",
        "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);",
        "",
        "    gl_FragColor = mix(frame1, frame2 * uStrength, 0.5);",
        "}",
        ""
      ].join("\n");
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/shaders/Quad-vert.js
  var require_Quad_vert = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/shaders/Quad-vert.js": function(exports, module) {
      module.exports = [
        "#define SHADER_NAME PHASER_QUAD_VS",
        "",
        "precision mediump float;",
        "",
        "attribute vec2 inPosition;",
        "attribute vec2 inTexCoord;",
        "",
        "varying vec2 outFragCoord;",
        "varying vec2 outTexCoord;",
        "",
        "void main ()",
        "{",
        "    outFragCoord = inPosition.xy * 0.5 + 0.5;",
        "    outTexCoord = inTexCoord;",
        "",
        "    gl_Position = vec4(inPosition, 0, 1);",
        "}",
        ""
      ].join("\n");
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/UtilityPipeline.js
  var require_UtilityPipeline = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/UtilityPipeline.js": function(exports, module) {
      var AddBlendFS = require_AddBlend_frag();
      var BlendModes = require_BlendModes();
      var Class = require_Class();
      var ColorMatrix = require_ColorMatrix();
      var ColorMatrixFS = require_ColorMatrix_frag();
      var CopyFS = require_Copy_frag();
      var GetFastValue = require_GetFastValue();
      var LinearBlendFS = require_LinearBlend_frag();
      var QuadVS = require_Quad_vert();
      var WebGLPipeline = require_WebGLPipeline();
      var UtilityPipeline = new Class({
        Extends: WebGLPipeline,
        initialize: function UtilityPipeline2(config) {
          config.renderTarget = GetFastValue(config, "renderTarget", [
            {
              scale: 1
            },
            {
              scale: 1
            },
            {
              scale: 0.5
            },
            {
              scale: 0.5
            }
          ]);
          config.vertShader = GetFastValue(config, "vertShader", QuadVS);
          config.shaders = GetFastValue(config, "shaders", [
            {
              name: "Copy",
              fragShader: CopyFS
            },
            {
              name: "AddBlend",
              fragShader: AddBlendFS
            },
            {
              name: "LinearBlend",
              fragShader: LinearBlendFS
            },
            {
              name: "ColorMatrix",
              fragShader: ColorMatrixFS
            }
          ]);
          config.attributes = GetFastValue(config, "attributes", [
            {
              name: "inPosition",
              size: 2
            },
            {
              name: "inTexCoord",
              size: 2
            }
          ]);
          config.vertices = [
            -1,
            -1,
            0,
            0,
            -1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            -1,
            -1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            -1,
            1,
            0
          ];
          config.batchSize = 1;
          WebGLPipeline.call(this, config);
          this.colorMatrix = new ColorMatrix();
          this.copyShader;
          this.addShader;
          this.linearShader;
          this.colorMatrixShader;
          this.fullFrame1;
          this.fullFrame2;
          this.halfFrame1;
          this.halfFrame2;
        },
        boot: function() {
          WebGLPipeline.prototype.boot.call(this);
          var shaders = this.shaders;
          var targets = this.renderTargets;
          this.copyShader = shaders[0];
          this.addShader = shaders[1];
          this.linearShader = shaders[2];
          this.colorMatrixShader = shaders[3];
          this.fullFrame1 = targets[0];
          this.fullFrame2 = targets[1];
          this.halfFrame1 = targets[2];
          this.halfFrame2 = targets[3];
        },
        copyFrame: function(source, target, brightness, clear, clearAlpha) {
          if (brightness === void 0) {
            brightness = 1;
          }
          if (clear === void 0) {
            clear = true;
          }
          if (clearAlpha === void 0) {
            clearAlpha = true;
          }
          var gl = this.gl;
          this.setShader(this.copyShader);
          this.set1i("uMainSampler", 0);
          this.set1f("uBrightness", brightness);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, source.texture);
          if (target) {
            gl.viewport(0, 0, target.width, target.height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
          } else {
            gl.viewport(0, 0, source.width, source.height);
          }
          if (clear) {
            if (clearAlpha) {
              gl.clearColor(0, 0, 0, 0);
            } else {
              gl.clearColor(0, 0, 0, 1);
            }
            gl.clear(gl.COLOR_BUFFER_BIT);
          }
          gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
          gl.drawArrays(gl.TRIANGLES, 0, 6);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.bindTexture(gl.TEXTURE_2D, null);
        },
        blitFrame: function(source, target, brightness, clear, clearAlpha, eraseMode, flipY) {
          if (brightness === void 0) {
            brightness = 1;
          }
          if (clear === void 0) {
            clear = true;
          }
          if (clearAlpha === void 0) {
            clearAlpha = true;
          }
          if (eraseMode === void 0) {
            eraseMode = false;
          }
          if (flipY === void 0) {
            flipY = false;
          }
          var gl = this.gl;
          this.setShader(this.copyShader);
          this.set1i("uMainSampler", 0);
          this.set1f("uBrightness", brightness);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, source.texture);
          if (source.height > target.height) {
            gl.viewport(0, 0, source.width, source.height);
            this.setTargetUVs(source, target);
          } else {
            var diff = target.height - source.height;
            gl.viewport(0, diff, source.width, source.height);
          }
          gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
          if (clear) {
            if (clearAlpha) {
              gl.clearColor(0, 0, 0, 0);
            } else {
              gl.clearColor(0, 0, 0, 1);
            }
            gl.clear(gl.COLOR_BUFFER_BIT);
          }
          if (eraseMode) {
            var blendMode = this.renderer.currentBlendMode;
            this.renderer.setBlendMode(BlendModes.ERASE);
          }
          if (flipY) {
            this.flipY();
          }
          gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
          gl.drawArrays(gl.TRIANGLES, 0, 6);
          if (eraseMode) {
            this.renderer.setBlendMode(blendMode);
          }
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.bindTexture(gl.TEXTURE_2D, null);
          this.resetUVs();
        },
        copyFrameRect: function(source, target, x, y, width, height, clear, clearAlpha) {
          if (clear === void 0) {
            clear = true;
          }
          if (clearAlpha === void 0) {
            clearAlpha = true;
          }
          var gl = this.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, source.framebuffer);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, source.texture, 0);
          if (clear) {
            if (clearAlpha) {
              gl.clearColor(0, 0, 0, 0);
            } else {
              gl.clearColor(0, 0, 0, 1);
            }
            gl.clear(gl.COLOR_BUFFER_BIT);
          }
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, target.texture);
          gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, y, width, height);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.bindTexture(gl.TEXTURE_2D, null);
        },
        copyToGame: function(source) {
          var gl = this.gl;
          this.setShader(this.copyShader);
          this.set1i("uMainSampler", 0);
          this.set1f("uBrightness", 1);
          this.renderer.popFramebuffer();
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, source.texture);
          gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
          gl.drawArrays(gl.TRIANGLES, 0, 6);
        },
        drawFrame: function(source, target, clearAlpha, colorMatrix) {
          if (clearAlpha === void 0) {
            clearAlpha = true;
          }
          if (colorMatrix === void 0) {
            colorMatrix = this.colorMatrix;
          }
          var gl = this.gl;
          this.setShader(this.colorMatrixShader);
          this.set1i("uMainSampler", 0);
          this.set1fv("uColorMatrix", colorMatrix.getData());
          this.set1f("uAlpha", colorMatrix.alpha);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, source.texture);
          if (target) {
            gl.viewport(0, 0, target.width, target.height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
          } else {
            gl.viewport(0, 0, source.width, source.height);
          }
          if (clearAlpha) {
            gl.clearColor(0, 0, 0, 0);
          } else {
            gl.clearColor(0, 0, 0, 1);
          }
          gl.clear(gl.COLOR_BUFFER_BIT);
          gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
          gl.drawArrays(gl.TRIANGLES, 0, 6);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.bindTexture(gl.TEXTURE_2D, null);
        },
        blendFrames: function(source1, source2, target, strength, clearAlpha, blendShader) {
          if (strength === void 0) {
            strength = 1;
          }
          if (clearAlpha === void 0) {
            clearAlpha = true;
          }
          if (blendShader === void 0) {
            blendShader = this.linearShader;
          }
          var gl = this.gl;
          this.setShader(blendShader);
          this.set1i("uMainSampler1", 0);
          this.set1i("uMainSampler2", 1);
          this.set1f("uStrength", strength);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, source1.texture);
          gl.activeTexture(gl.TEXTURE1);
          gl.bindTexture(gl.TEXTURE_2D, source2.texture);
          if (target) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
            gl.viewport(0, 0, target.width, target.height);
          } else {
            gl.viewport(0, 0, source1.width, source1.height);
          }
          if (clearAlpha) {
            gl.clearColor(0, 0, 0, 0);
          } else {
            gl.clearColor(0, 0, 0, 1);
          }
          gl.clear(gl.COLOR_BUFFER_BIT);
          gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
          gl.drawArrays(gl.TRIANGLES, 0, 6);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.bindTexture(gl.TEXTURE_2D, null);
        },
        blendFramesAdditive: function(source1, source2, target, strength, clearAlpha) {
          this.blendFrames(source1, source2, target, strength, clearAlpha, this.addShader);
        },
        clearFrame: function(target, clearAlpha) {
          if (clearAlpha === void 0) {
            clearAlpha = true;
          }
          var gl = this.gl;
          gl.viewport(0, 0, target.width, target.height);
          gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
          if (clearAlpha) {
            gl.clearColor(0, 0, 0, 0);
          } else {
            gl.clearColor(0, 0, 0, 1);
          }
          gl.clear(gl.COLOR_BUFFER_BIT);
          var fbo = this.renderer.currentFramebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        },
        setUVs: function(uA, vA, uB, vB, uC, vC, uD, vD) {
          var vertexViewF32 = this.vertexViewF32;
          vertexViewF32[2] = uA;
          vertexViewF32[3] = vA;
          vertexViewF32[6] = uB;
          vertexViewF32[7] = vB;
          vertexViewF32[10] = uC;
          vertexViewF32[11] = vC;
          vertexViewF32[14] = uA;
          vertexViewF32[15] = vA;
          vertexViewF32[18] = uC;
          vertexViewF32[19] = vC;
          vertexViewF32[22] = uD;
          vertexViewF32[23] = vD;
        },
        setTargetUVs: function(source, target) {
          var diff = target.height / source.height;
          if (diff > 0.5) {
            diff = 0.5 - (diff - 0.5);
          } else {
            diff = 0.5 + (0.5 - diff);
          }
          this.setUVs(0, diff, 0, 1 + diff, 1, 1 + diff, 1, diff);
        },
        flipX: function() {
          this.setUVs(1, 0, 1, 1, 0, 1, 0, 0);
        },
        flipY: function() {
          this.setUVs(0, 1, 0, 0, 1, 0, 1, 1);
        },
        resetUVs: function() {
          this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);
        }
      });
      module.exports = UtilityPipeline;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/PipelineManager.js
  var require_PipelineManager = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/PipelineManager.js": function(exports, module) {
      var Class = require_Class();
      var CONST = require_const6();
      var CustomMap = require_Map();
      var Device = require_device();
      var GetFastValue = require_GetFastValue();
      var RenderTarget = require_RenderTarget();
      var SnapCeil = require_SnapCeil();
      var BitmapMaskPipeline = require_BitmapMaskPipeline();
      var LightPipeline = require_LightPipeline();
      var MobilePipeline = require_MobilePipeline();
      var MultiPipeline = require_MultiPipeline();
      var PointLightPipeline = require_PointLightPipeline();
      var RopePipeline = require_RopePipeline();
      var SinglePipeline = require_SinglePipeline();
      var UtilityPipeline = require_UtilityPipeline();
      var PipelineManager = new Class({
        initialize: function PipelineManager2(renderer) {
          this.game = renderer.game;
          this.renderer = renderer;
          this.classes = new CustomMap([
            [CONST.UTILITY_PIPELINE, UtilityPipeline],
            [CONST.MULTI_PIPELINE, MultiPipeline],
            [CONST.BITMAPMASK_PIPELINE, BitmapMaskPipeline],
            [CONST.SINGLE_PIPELINE, SinglePipeline],
            [CONST.ROPE_PIPELINE, RopePipeline],
            [CONST.LIGHT_PIPELINE, LightPipeline],
            [CONST.POINTLIGHT_PIPELINE, PointLightPipeline],
            [CONST.MOBILE_PIPELINE, MobilePipeline]
          ]);
          this.postPipelineClasses = new CustomMap();
          this.pipelines = new CustomMap();
          this.default = null;
          this.current = null;
          this.previous = null;
          this.MULTI_PIPELINE = null;
          this.BITMAPMASK_PIPELINE = null;
          this.UTILITY_PIPELINE = null;
          this.MOBILE_PIPELINE = null;
          this.fullFrame1;
          this.fullFrame2;
          this.halfFrame1;
          this.halfFrame2;
          this.renderTargets = [];
          this.maxDimension = 0;
          this.frameInc = 32;
          this.targetIndex = 0;
        },
        boot: function(pipelineConfig, defaultPipeline, autoMobilePipeline) {
          var renderer = this.renderer;
          var targets = this.renderTargets;
          this.frameInc = Math.floor(GetFastValue(pipelineConfig, "frameInc", 32));
          var renderWidth = renderer.width;
          var renderHeight = renderer.height;
          var minDimension = Math.min(renderWidth, renderHeight);
          var qty = Math.ceil(minDimension / this.frameInc);
          for (var i = 1; i < qty; i++) {
            var targetWidth = i * this.frameInc;
            targets.push(new RenderTarget(renderer, targetWidth, targetWidth));
            targets.push(new RenderTarget(renderer, targetWidth, targetWidth));
            targets.push(new RenderTarget(renderer, targetWidth, targetWidth));
          }
          targets.push(new RenderTarget(renderer, renderWidth, renderHeight, 1, 0, true, true));
          targets.push(new RenderTarget(renderer, renderWidth, renderHeight, 1, 0, true, true));
          targets.push(new RenderTarget(renderer, renderWidth, renderHeight, 1, 0, true, true));
          this.maxDimension = (qty - 1) * this.frameInc;
          var instance;
          var pipelineName;
          var _this = this;
          var game = this.game;
          this.classes.each(function(pipelineName2, pipeline) {
            instance = _this.add(pipelineName2, new pipeline({ game: game }));
            if (pipelineName2 === CONST.UTILITY_PIPELINE) {
              _this.UTILITY_PIPELINE = instance;
              _this.fullFrame1 = instance.fullFrame1;
              _this.fullFrame2 = instance.fullFrame2;
              _this.halfFrame1 = instance.halfFrame1;
              _this.halfFrame2 = instance.halfFrame2;
            }
          });
          this.MULTI_PIPELINE = this.get(CONST.MULTI_PIPELINE);
          this.BITMAPMASK_PIPELINE = this.get(CONST.BITMAPMASK_PIPELINE);
          this.MOBILE_PIPELINE = this.get(CONST.MOBILE_PIPELINE);
          if (pipelineConfig) {
            for (pipelineName in pipelineConfig) {
              var pipelineClass = pipelineConfig[pipelineName];
              instance = new pipelineClass(game);
              instance.name = pipelineName;
              if (instance.isPostFX) {
                this.postPipelineClasses.set(pipelineName, pipelineClass);
              } else if (!this.has(pipelineName)) {
                this.classes.set(pipelineName, pipelineClass);
                this.add(pipelineName, instance);
              }
            }
          }
          this.default = this.get(defaultPipeline);
          if (autoMobilePipeline && !Device.os.desktop) {
            this.default = this.MOBILE_PIPELINE;
          }
        },
        setDefaultPipeline: function(pipeline) {
          var instance = this.get(pipeline);
          if (instance) {
            this.default = instance;
          }
          return instance;
        },
        add: function(name, pipeline) {
          if (pipeline.isPostFX) {
            console.warn(name + " is a Post Pipeline. Use `addPostPipeline` instead");
            return;
          }
          var pipelines = this.pipelines;
          var renderer = this.renderer;
          if (!pipelines.has(name)) {
            pipeline.name = name;
            pipeline.manager = this;
            pipelines.set(name, pipeline);
          } else {
            console.warn("Pipeline exists: " + name);
          }
          if (!pipeline.hasBooted) {
            pipeline.boot();
          }
          if (renderer.width !== 0 && renderer.height !== 0 && !pipeline.isSpriteFX) {
            pipeline.resize(renderer.width, renderer.height);
          }
          return pipeline;
        },
        addPostPipeline: function(name, pipeline) {
          if (!this.postPipelineClasses.has(name)) {
            this.postPipelineClasses.set(name, pipeline);
          }
        },
        flush: function() {
          if (this.current) {
            this.current.flush();
          }
        },
        has: function(pipeline) {
          var pipelines = this.pipelines;
          if (typeof pipeline === "string") {
            return pipelines.has(pipeline);
          } else if (pipelines.contains(pipeline)) {
            return true;
          }
          return false;
        },
        get: function(pipeline) {
          var pipelines = this.pipelines;
          if (typeof pipeline === "string") {
            return pipelines.get(pipeline);
          } else if (pipelines.contains(pipeline)) {
            return pipeline;
          }
        },
        getPostPipeline: function(pipeline, gameObject) {
          var pipelineClasses = this.postPipelineClasses;
          var instance;
          var pipelineName = "";
          if (typeof pipeline === "string") {
            instance = pipelineClasses.get(pipeline);
            pipelineName = pipeline;
          } else if (typeof pipeline === "function") {
            if (pipelineClasses.contains(pipeline)) {
              instance = pipeline;
            }
            pipelineName = pipeline.name;
          } else if (typeof pipeline === "object") {
            instance = pipelineClasses.get(pipeline.name);
            pipelineName = pipeline.name;
          }
          if (instance) {
            var newPipeline = new instance(this.game);
            newPipeline.name = pipelineName;
            if (gameObject) {
              newPipeline.gameObject = gameObject;
            }
            return newPipeline;
          }
        },
        remove: function(name, removeClass, removePostPipelineClass) {
          if (removeClass === void 0) {
            removeClass = true;
          }
          if (removePostPipelineClass === void 0) {
            removePostPipelineClass = true;
          }
          this.pipelines.delete(name);
          if (removeClass) {
            this.classes.delete(name);
          }
          if (removePostPipelineClass) {
            this.postPipelineClasses.delete(name);
          }
        },
        set: function(pipeline, gameObject, currentShader) {
          if (pipeline.isPostFX) {
            return;
          }
          if (!this.isCurrent(pipeline, currentShader)) {
            this.flush();
            if (this.current) {
              this.current.unbind();
            }
            this.current = pipeline;
            pipeline.bind(currentShader);
          }
          pipeline.updateProjectionMatrix();
          pipeline.onBind(gameObject);
          return pipeline;
        },
        preBatch: function(gameObject) {
          if (gameObject.hasPostPipeline) {
            this.flush();
            var pipelines = gameObject.postPipelines;
            for (var i = pipelines.length - 1; i >= 0; i--) {
              var pipeline = pipelines[i];
              if (pipeline.active) {
                pipeline.preBatch(gameObject);
              }
            }
          }
        },
        postBatch: function(gameObject) {
          if (gameObject.hasPostPipeline) {
            this.flush();
            var pipelines = gameObject.postPipelines;
            for (var i = 0; i < pipelines.length; i++) {
              var pipeline = pipelines[i];
              if (pipeline.active) {
                pipeline.postBatch(gameObject);
              }
            }
          }
        },
        preBatchCamera: function(camera) {
          if (camera.hasPostPipeline) {
            this.flush();
            var pipelines = camera.postPipelines;
            for (var i = pipelines.length - 1; i >= 0; i--) {
              var pipeline = pipelines[i];
              if (pipeline.active) {
                pipeline.preBatch(camera);
              }
            }
          }
        },
        postBatchCamera: function(camera) {
          if (camera.hasPostPipeline) {
            this.flush();
            var pipelines = camera.postPipelines;
            for (var i = 0; i < pipelines.length; i++) {
              var pipeline = pipelines[i];
              if (pipeline.active) {
                pipeline.postBatch(camera);
              }
            }
          }
        },
        isCurrent: function(pipeline, currentShader) {
          var renderer = this.renderer;
          var current = this.current;
          if (current && !currentShader) {
            currentShader = current.currentShader;
          }
          return !(current !== pipeline || currentShader.program !== renderer.currentProgram);
        },
        copyFrame: function(source, target, brightness, clear, clearAlpha) {
          this.setUtility(this.UTILITY_PIPELINE.copyShader).copyFrame(source, target, brightness, clear, clearAlpha);
          return this;
        },
        copyToGame: function(source) {
          this.setUtility(this.UTILITY_PIPELINE.copyShader).copyToGame(source);
          return this;
        },
        drawFrame: function(source, target, clearAlpha, colorMatrix) {
          this.setUtility(this.UTILITY_PIPELINE.colorMatrixShader).drawFrame(source, target, clearAlpha, colorMatrix);
          return this;
        },
        blendFrames: function(source1, source2, target, strength, clearAlpha) {
          this.setUtility(this.UTILITY_PIPELINE.linearShader).blendFrames(source1, source2, target, strength, clearAlpha);
          return this;
        },
        blendFramesAdditive: function(source1, source2, target, strength, clearAlpha) {
          this.setUtility(this.UTILITY_PIPELINE.addShader).blendFramesAdditive(source1, source2, target, strength, clearAlpha);
          return this;
        },
        clearFrame: function(target, clearAlpha) {
          this.UTILITY_PIPELINE.clearFrame(target, clearAlpha);
          return this;
        },
        blitFrame: function(source, target, brightness, clear, clearAlpha, eraseMode) {
          this.setUtility(this.UTILITY_PIPELINE.copyShader).blitFrame(source, target, brightness, clear, clearAlpha, eraseMode);
          return this;
        },
        copyFrameRect: function(source, target, x, y, width, height, clear, clearAlpha) {
          this.UTILITY_PIPELINE.copyFrameRect(source, target, x, y, width, height, clear, clearAlpha);
          return this;
        },
        forceZero: function() {
          return this.current && this.current.forceZero;
        },
        setMulti: function() {
          return this.set(this.MULTI_PIPELINE);
        },
        setUtility: function(currentShader) {
          return this.UTILITY_PIPELINE.bind(currentShader);
        },
        rebind: function(pipeline) {
          if (pipeline === void 0 && this.previous) {
            pipeline = this.previous;
          }
          var renderer = this.renderer;
          var gl = renderer.gl;
          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.CULL_FACE);
          if (renderer.hasActiveStencilMask()) {
            gl.clear(gl.DEPTH_BUFFER_BIT);
          } else {
            gl.disable(gl.STENCIL_TEST);
            gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
          }
          gl.viewport(0, 0, renderer.width, renderer.height);
          renderer.currentProgram = null;
          renderer.setBlendMode(0, true);
          var vao = renderer.vaoExtension;
          if (vao) {
            vao.bindVertexArrayOES(null);
          }
          var entries = this.pipelines.entries;
          for (var key in entries) {
            entries[key].glReset = true;
          }
          if (pipeline) {
            this.current = pipeline;
            pipeline.rebind();
          }
        },
        clear: function() {
          var renderer = this.renderer;
          this.flush();
          if (this.current) {
            this.current.unbind();
            this.previous = this.current;
            this.current = null;
          } else {
            this.previous = null;
          }
          renderer.currentProgram = null;
          renderer.setBlendMode(0, true);
          var vao = renderer.vaoExtension;
          if (vao) {
            vao.bindVertexArrayOES(null);
          }
        },
        getRenderTarget: function(size) {
          var targets = this.renderTargets;
          var offset = 3;
          if (size > this.maxDimension) {
            this.targetIndex = targets.length - offset;
            return targets[this.targetIndex];
          } else {
            var index = (SnapCeil(size, this.frameInc, 0, true) - 1) * offset;
            this.targetIndex = index;
            return targets[index];
          }
        },
        getSwapRenderTarget: function() {
          return this.renderTargets[this.targetIndex + 1];
        },
        getAltSwapRenderTarget: function() {
          return this.renderTargets[this.targetIndex + 2];
        },
        destroy: function() {
          this.flush();
          this.classes.clear();
          this.postPipelineClasses.clear();
          this.pipelines.clear();
          this.renderer = null;
          this.game = null;
          this.classes = null;
          this.postPipelineClasses = null;
          this.pipelines = null;
          this.default = null;
          this.current = null;
          this.previous = null;
        }
      });
      module.exports = PipelineManager;
    }
  });

  // ../../node_modules/phaser/src/renderer/snapshot/WebGLSnapshot.js
  var require_WebGLSnapshot = __commonJS({
    "../../node_modules/phaser/src/renderer/snapshot/WebGLSnapshot.js": function(exports, module) {
      var CanvasPool = require_CanvasPool();
      var Color = require_Color();
      var GetFastValue = require_GetFastValue();
      var WebGLSnapshot = function(sourceContext, config) {
        var gl = sourceContext;
        var callback = GetFastValue(config, "callback");
        var type = GetFastValue(config, "type", "image/png");
        var encoderOptions = GetFastValue(config, "encoder", 0.92);
        var x = Math.abs(Math.round(GetFastValue(config, "x", 0)));
        var y = Math.abs(Math.round(GetFastValue(config, "y", 0)));
        var getPixel = GetFastValue(config, "getPixel", false);
        var isFramebuffer = GetFastValue(config, "isFramebuffer", false);
        var bufferWidth = isFramebuffer ? GetFastValue(config, "bufferWidth", 1) : gl.drawingBufferWidth;
        var bufferHeight = isFramebuffer ? GetFastValue(config, "bufferHeight", 1) : gl.drawingBufferHeight;
        if (getPixel) {
          var pixel = new Uint8Array(4);
          var destY = isFramebuffer ? y : bufferHeight - y;
          gl.readPixels(x, destY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
          callback.call(null, new Color(pixel[0], pixel[1], pixel[2], pixel[3]));
        } else {
          var width = Math.floor(GetFastValue(config, "width", bufferWidth));
          var height = Math.floor(GetFastValue(config, "height", bufferHeight));
          var total = width * height * 4;
          var pixels = new Uint8Array(total);
          gl.readPixels(x, bufferHeight - y - height, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
          var canvas = CanvasPool.createWebGL(this, width, height);
          var ctx = canvas.getContext("2d", { willReadFrequently: true });
          var imageData = ctx.getImageData(0, 0, width, height);
          var data = imageData.data;
          for (var py = 0; py < height; py++) {
            for (var px = 0; px < width; px++) {
              var sourceIndex = ((height - py - 1) * width + px) * 4;
              var destIndex = isFramebuffer ? total - (py * width + (width - px)) * 4 : (py * width + px) * 4;
              data[destIndex + 0] = pixels[sourceIndex + 0];
              data[destIndex + 1] = pixels[sourceIndex + 1];
              data[destIndex + 2] = pixels[sourceIndex + 2];
              data[destIndex + 3] = pixels[sourceIndex + 3];
            }
          }
          ctx.putImageData(imageData, 0, 0);
          var image = new Image();
          image.onerror = function() {
            callback.call(null);
            CanvasPool.remove(canvas);
          };
          image.onload = function() {
            callback.call(null, image);
            CanvasPool.remove(canvas);
          };
          image.src = canvas.toDataURL(type, encoderOptions);
        }
      };
      module.exports = WebGLSnapshot;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/WebGLRenderer.js
  var require_WebGLRenderer = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/WebGLRenderer.js": function(exports, module) {
      var ArrayRemove = require_Remove();
      var CameraEvents = require_events6();
      var Class = require_Class();
      var CONST = require_const();
      var EventEmitter = require_eventemitter3();
      var Events = require_events8();
      var IsSizePowerOfTwo = require_IsSizePowerOfTwo();
      var Matrix4 = require_Matrix4();
      var NOOP = require_NOOP();
      var PipelineManager = require_PipelineManager();
      var RenderTarget = require_RenderTarget();
      var ScaleEvents = require_events7();
      var TextureEvents = require_events9();
      var Utils = require_Utils();
      var WebGLSnapshot = require_WebGLSnapshot();
      var DEBUG = false;
      if (false) {
        SPECTOR = __require("phaser3spectorjs");
        DEBUG = true;
      }
      var SPECTOR;
      var WebGLRenderer = new Class({
        Extends: EventEmitter,
        initialize: function WebGLRenderer2(game) {
          EventEmitter.call(this);
          var gameConfig = game.config;
          var contextCreationConfig = {
            alpha: gameConfig.transparent,
            desynchronized: gameConfig.desynchronized,
            depth: false,
            antialias: gameConfig.antialiasGL,
            premultipliedAlpha: gameConfig.premultipliedAlpha,
            stencil: true,
            failIfMajorPerformanceCaveat: gameConfig.failIfMajorPerformanceCaveat,
            powerPreference: gameConfig.powerPreference,
            preserveDrawingBuffer: gameConfig.preserveDrawingBuffer,
            willReadFrequently: false
          };
          this.config = {
            clearBeforeRender: gameConfig.clearBeforeRender,
            antialias: gameConfig.antialias,
            backgroundColor: gameConfig.backgroundColor,
            contextCreation: contextCreationConfig,
            roundPixels: gameConfig.roundPixels,
            maxTextures: gameConfig.maxTextures,
            maxTextureSize: gameConfig.maxTextureSize,
            batchSize: gameConfig.batchSize,
            maxLights: gameConfig.maxLights,
            mipmapFilter: gameConfig.mipmapFilter
          };
          this.game = game;
          this.type = CONST.WEBGL;
          this.pipelines = null;
          this.width = 0;
          this.height = 0;
          this.canvas = game.canvas;
          this.blendModes = [];
          this.contextLost = false;
          this.snapshotState = {
            x: 0,
            y: 0,
            width: 1,
            height: 1,
            getPixel: false,
            callback: null,
            type: "image/png",
            encoder: 0.92,
            isFramebuffer: false,
            bufferWidth: 0,
            bufferHeight: 0
          };
          this.maxTextures = 0;
          this.textureIndexes;
          this.currentFramebuffer = null;
          this.fboStack = [];
          this.currentProgram = null;
          this.currentBlendMode = Infinity;
          this.currentScissorEnabled = false;
          this.currentScissor = null;
          this.scissorStack = [];
          this.contextLostHandler = NOOP;
          this.contextRestoredHandler = NOOP;
          this.gl = null;
          this.supportedExtensions = null;
          this.instancedArraysExtension = null;
          this.vaoExtension = null;
          this.extensions = {};
          this.glFormats;
          this.compression;
          this.drawingBufferHeight = 0;
          this.blankTexture = null;
          this.whiteTexture = null;
          this.maskCount = 0;
          this.maskStack = [];
          this.currentMask = { mask: null, camera: null };
          this.currentCameraMask = { mask: null, camera: null };
          this.glFuncMap = null;
          this.currentType = "";
          this.newType = false;
          this.nextTypeMatch = false;
          this.finalType = false;
          this.mipmapFilter = null;
          this.defaultScissor = [0, 0, 0, 0];
          this.isBooted = false;
          this.renderTarget = null;
          this.projectionMatrix;
          this.projectionWidth = 0;
          this.projectionHeight = 0;
          this.maskSource = null;
          this.maskTarget = null;
          this.spector = null;
          this._debugCapture = false;
          this.init(this.config);
        },
        init: function(config) {
          var gl;
          var game = this.game;
          var canvas = this.canvas;
          var clearColor = config.backgroundColor;
          if (DEBUG) {
            this.spector = new SPECTOR.Spector();
            this.spector.onCapture.add(this.onCapture.bind(this));
          }
          if (game.config.context) {
            gl = game.config.context;
          } else {
            gl = canvas.getContext("webgl", config.contextCreation) || canvas.getContext("experimental-webgl", config.contextCreation);
          }
          if (!gl || gl.isContextLost()) {
            this.contextLost = true;
            throw new Error("WebGL unsupported");
          }
          this.gl = gl;
          var _this = this;
          this.contextLostHandler = function(event) {
            _this.contextLost = true;
            if (console) {
              console.warn("WebGL Context lost. Renderer disabled");
            }
            event.preventDefault();
          };
          canvas.addEventListener("webglcontextlost", this.contextLostHandler, false);
          game.context = gl;
          for (var i = 0; i <= 27; i++) {
            this.blendModes.push({ func: [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], equation: gl.FUNC_ADD });
          }
          this.blendModes[1].func = [gl.ONE, gl.DST_ALPHA];
          this.blendModes[2].func = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
          this.blendModes[3].func = [gl.ONE, gl.ONE_MINUS_SRC_COLOR];
          this.blendModes[17] = { func: [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA], equation: gl.FUNC_REVERSE_SUBTRACT };
          this.glFormats = [gl.BYTE, gl.SHORT, gl.UNSIGNED_BYTE, gl.UNSIGNED_SHORT, gl.FLOAT];
          this.glFuncMap = {
            mat2: { func: gl.uniformMatrix2fv, length: 1, matrix: true },
            mat3: { func: gl.uniformMatrix3fv, length: 1, matrix: true },
            mat4: { func: gl.uniformMatrix4fv, length: 1, matrix: true },
            "1f": { func: gl.uniform1f, length: 1 },
            "1fv": { func: gl.uniform1fv, length: 1 },
            "1i": { func: gl.uniform1i, length: 1 },
            "1iv": { func: gl.uniform1iv, length: 1 },
            "2f": { func: gl.uniform2f, length: 2 },
            "2fv": { func: gl.uniform2fv, length: 1 },
            "2i": { func: gl.uniform2i, length: 2 },
            "2iv": { func: gl.uniform2iv, length: 1 },
            "3f": { func: gl.uniform3f, length: 3 },
            "3fv": { func: gl.uniform3fv, length: 1 },
            "3i": { func: gl.uniform3i, length: 3 },
            "3iv": { func: gl.uniform3iv, length: 1 },
            "4f": { func: gl.uniform4f, length: 4 },
            "4fv": { func: gl.uniform4fv, length: 1 },
            "4i": { func: gl.uniform4i, length: 4 },
            "4iv": { func: gl.uniform4iv, length: 1 }
          };
          var exts = gl.getSupportedExtensions();
          if (!config.maxTextures || config.maxTextures === -1) {
            config.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
          }
          if (!config.maxTextureSize) {
            config.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
          }
          this.compression = this.getCompressedTextures();
          this.supportedExtensions = exts;
          var angleString = "ANGLE_instanced_arrays";
          this.instancedArraysExtension = exts.indexOf(angleString) > -1 ? gl.getExtension(angleString) : null;
          var vaoString = "OES_vertex_array_object";
          this.vaoExtension = exts.indexOf(vaoString) > -1 ? gl.getExtension(vaoString) : null;
          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.CULL_FACE);
          gl.enable(gl.BLEND);
          gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);
          if (config.mipmapFilter !== "") {
            this.mipmapFilter = gl[config.mipmapFilter];
          }
          this.maxTextures = Utils.checkShaderMax(gl, config.maxTextures);
          this.textureIndexes = [];
          for (var index = 0; index < this.maxTextures; index++) {
            var tempTexture = gl.createTexture();
            gl.activeTexture(gl.TEXTURE0 + index);
            gl.bindTexture(gl.TEXTURE_2D, tempTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));
            this.textureIndexes.push(index);
          }
          this.pipelines = new PipelineManager(this);
          this.setBlendMode(CONST.BlendModes.NORMAL);
          this.projectionMatrix = new Matrix4().identity();
          game.textures.once(TextureEvents.READY, this.boot, this);
          return this;
        },
        boot: function() {
          var game = this.game;
          var pipelineManager = this.pipelines;
          var baseSize = game.scale.baseSize;
          var width = baseSize.width;
          var height = baseSize.height;
          this.width = width;
          this.height = height;
          this.isBooted = true;
          this.renderTarget = new RenderTarget(this, width, height, 1, 0, true, true);
          this.maskTarget = new RenderTarget(this, width, height, 1, 0, true, true);
          this.maskSource = new RenderTarget(this, width, height, 1, 0, true, true);
          var config = game.config;
          pipelineManager.boot(config.pipeline, config.defaultPipeline, config.autoMobilePipeline);
          this.blankTexture = game.textures.getFrame("__DEFAULT").glTexture;
          this.whiteTexture = game.textures.getFrame("__WHITE").glTexture;
          var gl = this.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.enable(gl.SCISSOR_TEST);
          game.scale.on(ScaleEvents.RESIZE, this.onResize, this);
          this.resize(width, height);
        },
        captureFrame: function(quickCapture, fullCapture) {
          if (quickCapture === void 0) {
            quickCapture = false;
          }
          if (fullCapture === void 0) {
            fullCapture = false;
          }
          if (DEBUG && this.spector && !this._debugCapture) {
            this.spector.captureCanvas(this.canvas, 0, quickCapture, fullCapture);
            this._debugCapture = true;
          }
        },
        captureNextFrame: function() {
          if (DEBUG && this.spector && !this._debugCapture) {
            this._debugCapture = true;
            this.spector.captureNextFrame(this.canvas);
          }
        },
        getFps: function() {
          if (DEBUG && this.spector) {
            return this.spector.getFps();
          }
        },
        startCapture: function(commandCount, quickCapture, fullCapture) {
          if (commandCount === void 0) {
            commandCount = 0;
          }
          if (quickCapture === void 0) {
            quickCapture = false;
          }
          if (fullCapture === void 0) {
            fullCapture = false;
          }
          if (DEBUG && this.spector && !this._debugCapture) {
            this.spector.startCapture(this.canvas, commandCount, quickCapture, fullCapture);
            this._debugCapture = true;
          }
        },
        stopCapture: function() {
          if (DEBUG && this.spector && this._debugCapture) {
            this.spector.stopCapture();
          }
        },
        onCapture: function(capture) {
          if (DEBUG) {
            var view = this.spector.getResultUI();
            view.display(capture);
            this._debugCapture = false;
          }
        },
        onResize: function(gameSize, baseSize) {
          if (baseSize.width !== this.width || baseSize.height !== this.height) {
            this.resize(baseSize.width, baseSize.height);
          }
        },
        beginCapture: function(width, height) {
          if (width === void 0) {
            width = this.width;
          }
          if (height === void 0) {
            height = this.height;
          }
          this.renderTarget.bind(true, width, height);
          this.setProjectionMatrix(width, height);
        },
        endCapture: function() {
          this.renderTarget.unbind(true);
          this.resetProjectionMatrix();
          return this.renderTarget;
        },
        resize: function(width, height) {
          var gl = this.gl;
          this.width = width;
          this.height = height;
          this.setProjectionMatrix(width, height);
          gl.viewport(0, 0, width, height);
          this.drawingBufferHeight = gl.drawingBufferHeight;
          gl.scissor(0, gl.drawingBufferHeight - height, width, height);
          this.defaultScissor[2] = width;
          this.defaultScissor[3] = height;
          this.emit(Events.RESIZE, width, height);
          return this;
        },
        getCompressedTextures: function() {
          var extString = "WEBGL_compressed_texture_";
          var wkExtString = "WEBKIT_" + extString;
          var hasExt = function(gl2, format) {
            var results = gl2.getExtension(extString + format) || gl2.getExtension(wkExtString + format);
            if (results) {
              var glEnums = {};
              for (var key in results) {
                glEnums[results[key]] = key;
              }
              return glEnums;
            }
          };
          var gl = this.gl;
          return {
            ETC: hasExt(gl, "etc"),
            ETC1: hasExt(gl, "etc1"),
            ATC: hasExt(gl, "atc"),
            ASTC: hasExt(gl, "astc"),
            BPTC: hasExt(gl, "bptc"),
            RGTC: hasExt(gl, "rgtc"),
            PVRTC: hasExt(gl, "pvrtc"),
            S3TC: hasExt(gl, "s3tc"),
            S3TCSRGB: hasExt(gl, "s3tc_srgb"),
            IMG: true
          };
        },
        getCompressedTextureName: function(baseFormat, format) {
          var supportedFormats = this.compression[baseFormat.toUpperCase()];
          if (format in supportedFormats) {
            return supportedFormats[format];
          }
        },
        supportsCompressedTexture: function(baseFormat, format) {
          var supportedFormats = this.compression[baseFormat.toUpperCase()];
          if (supportedFormats) {
            if (format) {
              return format in supportedFormats;
            } else {
              return true;
            }
          }
          return false;
        },
        getAspectRatio: function() {
          return this.width / this.height;
        },
        setProjectionMatrix: function(width, height) {
          if (width !== this.projectionWidth || height !== this.projectionHeight) {
            this.projectionWidth = width;
            this.projectionHeight = height;
            this.projectionMatrix.ortho(0, width, height, 0, -1e3, 1e3);
          }
          return this;
        },
        resetProjectionMatrix: function() {
          return this.setProjectionMatrix(this.width, this.height);
        },
        hasExtension: function(extensionName) {
          return this.supportedExtensions ? this.supportedExtensions.indexOf(extensionName) : false;
        },
        getExtension: function(extensionName) {
          if (!this.hasExtension(extensionName)) {
            return null;
          }
          if (!(extensionName in this.extensions)) {
            this.extensions[extensionName] = this.gl.getExtension(extensionName);
          }
          return this.extensions[extensionName];
        },
        flush: function() {
          this.pipelines.flush();
        },
        pushScissor: function(x, y, width, height, drawingBufferHeight) {
          if (drawingBufferHeight === void 0) {
            drawingBufferHeight = this.drawingBufferHeight;
          }
          var scissorStack = this.scissorStack;
          var scissor = [x, y, width, height];
          scissorStack.push(scissor);
          this.setScissor(x, y, width, height, drawingBufferHeight);
          this.currentScissor = scissor;
          return scissor;
        },
        setScissor: function(x, y, width, height, drawingBufferHeight) {
          if (drawingBufferHeight === void 0) {
            drawingBufferHeight = this.drawingBufferHeight;
          }
          var gl = this.gl;
          var current = this.currentScissor;
          var setScissor = width > 0 && height > 0;
          if (current && setScissor) {
            var cx = current[0];
            var cy = current[1];
            var cw = current[2];
            var ch = current[3];
            setScissor = cx !== x || cy !== y || cw !== width || ch !== height;
          }
          if (setScissor) {
            this.flush();
            gl.scissor(x, drawingBufferHeight - y - height, width, height);
          }
        },
        resetScissor: function() {
          var gl = this.gl;
          gl.enable(gl.SCISSOR_TEST);
          var current = this.currentScissor;
          if (current) {
            var x = current[0];
            var y = current[1];
            var width = current[2];
            var height = current[3];
            if (width > 0 && height > 0) {
              gl.scissor(x, this.drawingBufferHeight - y - height, width, height);
            }
          }
        },
        popScissor: function() {
          var scissorStack = this.scissorStack;
          scissorStack.pop();
          var scissor = scissorStack[scissorStack.length - 1];
          if (scissor) {
            this.setScissor(scissor[0], scissor[1], scissor[2], scissor[3]);
          }
          this.currentScissor = scissor;
        },
        hasActiveStencilMask: function() {
          var mask = this.currentMask.mask;
          var camMask = this.currentCameraMask.mask;
          return mask && mask.isStencil || camMask && camMask.isStencil;
        },
        resetViewport: function() {
          var gl = this.gl;
          gl.viewport(0, 0, this.width, this.height);
          this.drawingBufferHeight = gl.drawingBufferHeight;
        },
        setBlendMode: function(blendModeId, force) {
          if (force === void 0) {
            force = false;
          }
          var gl = this.gl;
          var blendMode = this.blendModes[blendModeId];
          if (force || blendModeId !== CONST.BlendModes.SKIP_CHECK && this.currentBlendMode !== blendModeId) {
            this.flush();
            gl.enable(gl.BLEND);
            gl.blendEquation(blendMode.equation);
            if (blendMode.func.length > 2) {
              gl.blendFuncSeparate(blendMode.func[0], blendMode.func[1], blendMode.func[2], blendMode.func[3]);
            } else {
              gl.blendFunc(blendMode.func[0], blendMode.func[1]);
            }
            this.currentBlendMode = blendModeId;
            return true;
          }
          return false;
        },
        addBlendMode: function(func, equation) {
          var index = this.blendModes.push({ func: func, equation: equation });
          return index - 1;
        },
        updateBlendMode: function(index, func, equation) {
          if (this.blendModes[index]) {
            this.blendModes[index].func = func;
            if (equation) {
              this.blendModes[index].equation = equation;
            }
          }
          return this;
        },
        removeBlendMode: function(index) {
          if (index > 17 && this.blendModes[index]) {
            this.blendModes.splice(index, 1);
          }
          return this;
        },
        pushFramebuffer: function(framebuffer, updateScissor, setViewport) {
          if (framebuffer === this.currentFramebuffer) {
            return this;
          }
          this.fboStack.push(framebuffer);
          return this.setFramebuffer(framebuffer, updateScissor, setViewport);
        },
        setFramebuffer: function(framebuffer, updateScissor, setViewport) {
          if (updateScissor === void 0) {
            updateScissor = false;
          }
          if (setViewport === void 0) {
            setViewport = true;
          }
          if (framebuffer === this.currentFramebuffer) {
            return this;
          }
          var gl = this.gl;
          var width = this.width;
          var height = this.height;
          if (framebuffer && framebuffer.renderTexture && setViewport) {
            width = framebuffer.renderTexture.width;
            height = framebuffer.renderTexture.height;
          } else {
            this.flush();
          }
          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
          if (setViewport) {
            gl.viewport(0, 0, width, height);
          }
          if (updateScissor) {
            if (framebuffer) {
              this.drawingBufferHeight = height;
              this.pushScissor(0, 0, width, height);
            } else {
              this.drawingBufferHeight = this.height;
              this.popScissor();
            }
          }
          this.currentFramebuffer = framebuffer;
          return this;
        },
        popFramebuffer: function(updateScissor, setViewport) {
          if (updateScissor === void 0) {
            updateScissor = false;
          }
          if (setViewport === void 0) {
            setViewport = true;
          }
          var fboStack = this.fboStack;
          fboStack.pop();
          var framebuffer = fboStack[fboStack.length - 1];
          if (!framebuffer) {
            framebuffer = null;
          }
          this.setFramebuffer(framebuffer, updateScissor, setViewport);
          return framebuffer;
        },
        setProgram: function(program) {
          if (program !== this.currentProgram) {
            this.flush();
            this.gl.useProgram(program);
            this.currentProgram = program;
            return true;
          }
          return false;
        },
        resetProgram: function() {
          this.gl.useProgram(this.currentProgram);
          return this;
        },
        createTextureFromSource: function(source, width, height, scaleMode, forceClamp) {
          if (forceClamp === void 0) {
            forceClamp = false;
          }
          var gl = this.gl;
          var minFilter = gl.NEAREST;
          var magFilter = gl.NEAREST;
          var wrap = gl.CLAMP_TO_EDGE;
          var texture = null;
          width = source ? source.width : width;
          height = source ? source.height : height;
          var pow = IsSizePowerOfTwo(width, height);
          if (pow && !forceClamp) {
            wrap = gl.REPEAT;
          }
          if (scaleMode === CONST.ScaleModes.LINEAR && this.config.antialias) {
            minFilter = pow && this.mipmapFilter ? this.mipmapFilter : gl.LINEAR;
            magFilter = gl.LINEAR;
          }
          if (source && source.compressed) {
            minFilter = gl.LINEAR;
            magFilter = gl.LINEAR;
          }
          if (!source && typeof width === "number" && typeof height === "number") {
            texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, null, width, height);
          } else {
            texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, source);
          }
          return texture;
        },
        createTexture2D: function(mipLevel, minFilter, magFilter, wrapT, wrapS, format, pixels, width, height, pma, forceSize, flipY) {
          pma = pma === void 0 || pma === null ? true : pma;
          if (forceSize === void 0) {
            forceSize = false;
          }
          if (flipY === void 0) {
            flipY = false;
          }
          var gl = this.gl;
          var texture = gl.createTexture();
          gl.activeTexture(gl.TEXTURE0);
          var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, pma);
          if (flipY) {
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          }
          var generateMipmap = false;
          if (pixels === null || pixels === void 0) {
            gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, width, height, 0, format, gl.UNSIGNED_BYTE, null);
            generateMipmap = IsSizePowerOfTwo(width, height);
          } else if (pixels.compressed) {
            width = pixels.width;
            height = pixels.height;
            generateMipmap = pixels.generateMipmap;
            for (var i = 0; i < pixels.mipmaps.length; i++) {
              gl.compressedTexImage2D(gl.TEXTURE_2D, i, pixels.internalFormat, pixels.mipmaps[i].width, pixels.mipmaps[i].height, 0, pixels.mipmaps[i].data);
            }
          } else {
            if (!forceSize) {
              width = pixels.width;
              height = pixels.height;
            }
            gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, format, gl.UNSIGNED_BYTE, pixels);
            generateMipmap = IsSizePowerOfTwo(width, height);
          }
          if (generateMipmap) {
            gl.generateMipmap(gl.TEXTURE_2D);
          }
          if (currentTexture) {
            gl.bindTexture(gl.TEXTURE_2D, currentTexture);
          }
          texture.isAlphaPremultiplied = pma;
          texture.isRenderTexture = false;
          texture.width = width;
          texture.height = height;
          return texture;
        },
        createFramebuffer: function(width, height, renderTexture, addDepthStencilBuffer) {
          var gl = this.gl;
          var framebuffer = gl.createFramebuffer();
          var complete = 0;
          this.setFramebuffer(framebuffer);
          if (addDepthStencilBuffer) {
            var depthStencilBuffer = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilBuffer);
          }
          renderTexture.isRenderTexture = true;
          renderTexture.isAlphaPremultiplied = false;
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture, 0);
          complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
          if (complete !== gl.FRAMEBUFFER_COMPLETE) {
            var errors = {
              36054: "Incomplete Attachment",
              36055: "Missing Attachment",
              36057: "Incomplete Dimensions",
              36061: "Framebuffer Unsupported"
            };
            throw new Error("Framebuffer status: " + (errors[complete] || complete));
          }
          framebuffer.renderTexture = renderTexture;
          this.setFramebuffer(null);
          return framebuffer;
        },
        beginBitmapMask: function(bitmapMask, camera) {
          var gl = this.gl;
          if (gl) {
            this.flush();
            this.maskTarget.bind();
            if (this.currentCameraMask.mask !== bitmapMask) {
              this.currentMask.mask = bitmapMask;
              this.currentMask.camera = camera;
            }
          }
        },
        drawBitmapMask: function(bitmapMask, camera, bitmapMaskPipeline) {
          this.flush();
          this.maskSource.bind();
          this.setBlendMode(0, true);
          bitmapMask.renderWebGL(this, bitmapMask, camera);
          this.maskSource.unbind(true);
          this.maskTarget.unbind();
          var gl = this.gl;
          var prev = this.getCurrentStencilMask();
          if (prev) {
            gl.enable(gl.STENCIL_TEST);
            prev.mask.applyStencil(this, prev.camera, true);
          } else {
            this.currentMask.mask = null;
          }
          this.pipelines.set(bitmapMaskPipeline);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, this.maskTarget.texture);
          gl.activeTexture(gl.TEXTURE1);
          gl.bindTexture(gl.TEXTURE_2D, this.maskSource.texture);
        },
        createProgram: function(vertexShader, fragmentShader) {
          var gl = this.gl;
          var program = gl.createProgram();
          var vs = gl.createShader(gl.VERTEX_SHADER);
          var fs = gl.createShader(gl.FRAGMENT_SHADER);
          gl.shaderSource(vs, vertexShader);
          gl.shaderSource(fs, fragmentShader);
          gl.compileShader(vs);
          gl.compileShader(fs);
          var failed = "Shader failed:\n";
          if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
            throw new Error("Vertex " + failed + gl.getShaderInfoLog(vs));
          }
          if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
            throw new Error("Fragment " + failed + gl.getShaderInfoLog(fs));
          }
          gl.attachShader(program, vs);
          gl.attachShader(program, fs);
          gl.linkProgram(program);
          if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            throw new Error("Link " + failed + gl.getProgramInfoLog(program));
          }
          gl.useProgram(program);
          return program;
        },
        createVertexBuffer: function(initialDataOrSize, bufferUsage) {
          var gl = this.gl;
          var vertexBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, initialDataOrSize, bufferUsage);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          return vertexBuffer;
        },
        createIndexBuffer: function(initialDataOrSize, bufferUsage) {
          var gl = this.gl;
          var indexBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, initialDataOrSize, bufferUsage);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          return indexBuffer;
        },
        deleteTexture: function(texture) {
          if (texture) {
            this.gl.deleteTexture(texture);
          }
          return this;
        },
        deleteFramebuffer: function(framebuffer) {
          if (framebuffer) {
            var gl = this.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            var renderBuffer = gl.getParameter(gl.RENDERBUFFER_BINDING);
            if (renderBuffer) {
              gl.deleteRenderbuffer(renderBuffer);
            }
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.deleteFramebuffer(framebuffer);
            ArrayRemove(this.fboStack, framebuffer);
            if (this.currentFramebuffer === framebuffer) {
              this.currentFramebuffer = null;
            }
          }
          return this;
        },
        deleteProgram: function(program) {
          if (program) {
            this.gl.deleteProgram(program);
          }
          return this;
        },
        deleteBuffer: function(buffer) {
          this.gl.deleteBuffer(buffer);
          return this;
        },
        preRenderCamera: function(camera) {
          var cx = camera.x;
          var cy = camera.y;
          var cw = camera.width;
          var ch = camera.height;
          var color = camera.backgroundColor;
          camera.emit(CameraEvents.PRE_RENDER, camera);
          this.pipelines.preBatchCamera(camera);
          this.pushScissor(cx, cy, cw, ch);
          if (camera.mask) {
            this.currentCameraMask.mask = camera.mask;
            this.currentCameraMask.camera = camera._maskCamera;
            camera.mask.preRenderWebGL(this, camera, camera._maskCamera);
          }
          if (color.alphaGL > 0) {
            var pipeline = this.pipelines.setMulti();
            pipeline.drawFillRect(cx, cy, cw, ch, Utils.getTintFromFloats(color.blueGL, color.greenGL, color.redGL, 1), color.alphaGL);
          }
        },
        getCurrentStencilMask: function() {
          var prev = null;
          var stack = this.maskStack;
          var cameraMask = this.currentCameraMask;
          if (stack.length > 0) {
            prev = stack[stack.length - 1];
          } else if (cameraMask.mask && cameraMask.mask.isStencil) {
            prev = cameraMask;
          }
          return prev;
        },
        postRenderCamera: function(camera) {
          var flashEffect = camera.flashEffect;
          var fadeEffect = camera.fadeEffect;
          if (flashEffect.isRunning || (fadeEffect.isRunning || fadeEffect.isComplete)) {
            var pipeline = this.pipelines.setMulti();
            flashEffect.postRenderWebGL(pipeline, Utils.getTintFromFloats);
            fadeEffect.postRenderWebGL(pipeline, Utils.getTintFromFloats);
          }
          camera.dirty = false;
          this.popScissor();
          if (camera.mask) {
            this.currentCameraMask.mask = null;
            camera.mask.postRenderWebGL(this, camera._maskCamera);
          }
          this.pipelines.postBatchCamera(camera);
          camera.emit(CameraEvents.POST_RENDER, camera);
        },
        preRender: function() {
          if (this.contextLost) {
            return;
          }
          var gl = this.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          if (this.config.clearBeforeRender) {
            var clearColor = this.config.backgroundColor;
            gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
          }
          gl.enable(gl.SCISSOR_TEST);
          this.currentScissor = this.defaultScissor;
          this.scissorStack.length = 0;
          this.scissorStack.push(this.currentScissor);
          if (this.game.scene.customViewports) {
            gl.scissor(0, this.drawingBufferHeight - this.height, this.width, this.height);
          }
          this.currentMask.mask = null;
          this.currentCameraMask.mask = null;
          this.maskStack.length = 0;
          this.emit(Events.PRE_RENDER);
        },
        render: function(scene, children, camera) {
          if (this.contextLost) {
            return;
          }
          var childCount = children.length;
          this.emit(Events.RENDER, scene, camera);
          this.preRenderCamera(camera);
          if (childCount === 0) {
            this.setBlendMode(CONST.BlendModes.NORMAL);
            this.postRenderCamera(camera);
            return;
          }
          this.currentType = "";
          var current = this.currentMask;
          for (var i = 0; i < childCount; i++) {
            this.finalType = i === childCount - 1;
            var child = children[i];
            var mask = child.mask;
            current = this.currentMask;
            if (current.mask && current.mask !== mask) {
              current.mask.postRenderWebGL(this, current.camera);
            }
            if (mask && current.mask !== mask) {
              mask.preRenderWebGL(this, child, camera);
            }
            if (child.blendMode !== this.currentBlendMode) {
              this.setBlendMode(child.blendMode);
            }
            var type = child.type;
            if (type !== this.currentType) {
              this.newType = true;
              this.currentType = type;
            }
            if (!this.finalType) {
              this.nextTypeMatch = children[i + 1].type === this.currentType;
            } else {
              this.nextTypeMatch = false;
            }
            child.renderWebGL(this, child, camera);
            this.newType = false;
          }
          current = this.currentMask;
          if (current.mask) {
            current.mask.postRenderWebGL(this, current.camera);
          }
          this.setBlendMode(CONST.BlendModes.NORMAL);
          this.postRenderCamera(camera);
        },
        postRender: function() {
          if (this.contextLost) {
            return;
          }
          this.flush();
          this.emit(Events.POST_RENDER);
          var state = this.snapshotState;
          if (state.callback) {
            WebGLSnapshot(this.gl, state);
            state.callback = null;
          }
        },
        snapshot: function(callback, type, encoderOptions) {
          return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, callback, type, encoderOptions);
        },
        snapshotArea: function(x, y, width, height, callback, type, encoderOptions) {
          var state = this.snapshotState;
          state.callback = callback;
          state.type = type;
          state.encoder = encoderOptions;
          state.getPixel = false;
          state.x = x;
          state.y = y;
          state.width = width;
          state.height = height;
          return this;
        },
        snapshotPixel: function(x, y, callback) {
          this.snapshotArea(x, y, 1, 1, callback);
          this.snapshotState.getPixel = true;
          return this;
        },
        snapshotFramebuffer: function(framebuffer, bufferWidth, bufferHeight, callback, getPixel, x, y, width, height, type, encoderOptions) {
          if (getPixel === void 0) {
            getPixel = false;
          }
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (width === void 0) {
            width = bufferWidth;
          }
          if (height === void 0) {
            height = bufferHeight;
          }
          if (type === "pixel") {
            getPixel = true;
            type = "image/png";
          }
          var currentFramebuffer = this.currentFramebuffer;
          this.snapshotArea(x, y, width, height, callback, type, encoderOptions);
          var state = this.snapshotState;
          state.getPixel = getPixel;
          state.isFramebuffer = true;
          state.bufferWidth = bufferWidth;
          state.bufferHeight = bufferHeight;
          state.width = Math.min(state.width, bufferWidth);
          state.height = Math.min(state.height, bufferHeight);
          this.setFramebuffer(framebuffer);
          WebGLSnapshot(this.gl, state);
          this.setFramebuffer(currentFramebuffer);
          state.callback = null;
          state.isFramebuffer = false;
          return this;
        },
        canvasToTexture: function(srcCanvas, dstTexture, noRepeat, flipY) {
          if (noRepeat === void 0) {
            noRepeat = false;
          }
          if (flipY === void 0) {
            flipY = false;
          }
          if (!dstTexture) {
            return this.createCanvasTexture(srcCanvas, noRepeat, flipY);
          } else {
            return this.updateCanvasTexture(srcCanvas, dstTexture, flipY);
          }
        },
        createCanvasTexture: function(srcCanvas, noRepeat, flipY) {
          if (noRepeat === void 0) {
            noRepeat = false;
          }
          if (flipY === void 0) {
            flipY = false;
          }
          var gl = this.gl;
          var minFilter = gl.NEAREST;
          var magFilter = gl.NEAREST;
          var width = srcCanvas.width;
          var height = srcCanvas.height;
          var wrapping = gl.CLAMP_TO_EDGE;
          var pow = IsSizePowerOfTwo(width, height);
          if (!noRepeat && pow) {
            wrapping = gl.REPEAT;
          }
          if (this.config.antialias) {
            minFilter = pow && this.mipmapFilter ? this.mipmapFilter : gl.LINEAR;
            magFilter = gl.LINEAR;
          }
          return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcCanvas, width, height, true, false, flipY);
        },
        updateCanvasTexture: function(srcCanvas, dstTexture, flipY) {
          if (flipY === void 0) {
            flipY = false;
          }
          var gl = this.gl;
          var width = srcCanvas.width;
          var height = srcCanvas.height;
          if (width > 0 && height > 0) {
            gl.activeTexture(gl.TEXTURE0);
            var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
            gl.bindTexture(gl.TEXTURE_2D, dstTexture);
            if (flipY) {
              gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            }
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);
            dstTexture.width = width;
            dstTexture.height = height;
            if (currentTexture) {
              gl.bindTexture(gl.TEXTURE_2D, currentTexture);
            }
          }
          return dstTexture;
        },
        createVideoTexture: function(srcVideo, noRepeat, flipY) {
          if (noRepeat === void 0) {
            noRepeat = false;
          }
          if (flipY === void 0) {
            flipY = false;
          }
          var gl = this.gl;
          var minFilter = gl.NEAREST;
          var magFilter = gl.NEAREST;
          var width = srcVideo.videoWidth;
          var height = srcVideo.videoHeight;
          var wrapping = gl.CLAMP_TO_EDGE;
          var pow = IsSizePowerOfTwo(width, height);
          if (!noRepeat && pow) {
            wrapping = gl.REPEAT;
          }
          if (this.config.antialias) {
            minFilter = pow && this.mipmapFilter ? this.mipmapFilter : gl.LINEAR;
            magFilter = gl.LINEAR;
          }
          return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcVideo, width, height, true, true, flipY);
        },
        updateVideoTexture: function(srcVideo, dstTexture, flipY) {
          if (flipY === void 0) {
            flipY = false;
          }
          var gl = this.gl;
          var width = srcVideo.videoWidth;
          var height = srcVideo.videoHeight;
          if (width > 0 && height > 0) {
            gl.activeTexture(gl.TEXTURE0);
            var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
            gl.bindTexture(gl.TEXTURE_2D, dstTexture);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcVideo);
            dstTexture.width = width;
            dstTexture.height = height;
            if (currentTexture) {
              gl.bindTexture(gl.TEXTURE_2D, currentTexture);
            }
          }
          return dstTexture;
        },
        setTextureFilter: function(texture, filter) {
          var gl = this.gl;
          var glFilter = [gl.LINEAR, gl.NEAREST][filter];
          gl.activeTexture(gl.TEXTURE0);
          var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glFilter);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glFilter);
          if (currentTexture) {
            gl.bindTexture(gl.TEXTURE_2D, currentTexture);
          }
          return this;
        },
        getMaxTextureSize: function() {
          return this.config.maxTextureSize;
        },
        destroy: function() {
          this.canvas.removeEventListener("webglcontextlost", this.contextLostHandler, false);
          this.maskTarget.destroy();
          this.maskSource.destroy();
          this.pipelines.destroy();
          this.removeAllListeners();
          this.fboStack = [];
          this.maskStack = [];
          this.extensions = {};
          this.textureIndexes = [];
          this.gl = null;
          this.game = null;
          this.canvas = null;
          this.contextLost = true;
          this.currentMask = null;
          this.currentCameraMask = null;
        }
      });
      module.exports = WebGLRenderer;
    }
  });

  // ../../node_modules/phaser/src/core/CreateRenderer.js
  var require_CreateRenderer = __commonJS({
    "../../node_modules/phaser/src/core/CreateRenderer.js": function(exports, module) {
      var CanvasInterpolation = require_CanvasInterpolation();
      var CanvasPool = require_CanvasPool();
      var CONST = require_const();
      var Features = require_Features();
      var CreateRenderer = function(game) {
        var config = game.config;
        if ((config.customEnvironment || config.canvas) && config.renderType === CONST.AUTO) {
          throw new Error("Must set explicit renderType in custom environment");
        }
        if (!config.customEnvironment && !config.canvas && config.renderType !== CONST.HEADLESS) {
          if (config.renderType === CONST.AUTO) {
            config.renderType = Features.webGL ? CONST.WEBGL : CONST.CANVAS;
          }
          if (config.renderType === CONST.WEBGL) {
            if (!Features.webGL) {
              throw new Error("Cannot create WebGL context, aborting.");
            }
          } else if (config.renderType === CONST.CANVAS) {
            if (!Features.canvas) {
              throw new Error("Cannot create Canvas context, aborting.");
            }
          } else {
            throw new Error("Unknown value for renderer type: " + config.renderType);
          }
        }
        if (!config.antialias) {
          CanvasPool.disableSmoothing();
        }
        var baseSize = game.scale.baseSize;
        var width = baseSize.width;
        var height = baseSize.height;
        if (config.canvas) {
          game.canvas = config.canvas;
          game.canvas.width = width;
          game.canvas.height = height;
        } else {
          game.canvas = CanvasPool.create(game, width, height, config.renderType);
        }
        if (config.canvasStyle) {
          game.canvas.style = config.canvasStyle;
        }
        if (!config.antialias) {
          CanvasInterpolation.setCrisp(game.canvas);
        }
        if (config.renderType === CONST.HEADLESS) {
          return;
        }
        var CanvasRenderer;
        var WebGLRenderer;
        if (true && true) {
          CanvasRenderer = require_CanvasRenderer();
          WebGLRenderer = require_WebGLRenderer();
          if (config.renderType === CONST.WEBGL) {
            game.renderer = new WebGLRenderer(game);
          } else {
            game.renderer = new CanvasRenderer(game);
            game.context = game.renderer.gameContext;
          }
        }
        if (true && !true) {
          WebGLRenderer = null;
          config.renderType = CONST.WEBGL;
          game.renderer = new WebGLRenderer(game);
        }
        if (!true) {
          CanvasRenderer = null;
          config.renderType = CONST.CANVAS;
          game.renderer = new CanvasRenderer(game);
          game.context = game.renderer.gameContext;
        }
      };
      module.exports = CreateRenderer;
    }
  });

  // ../../node_modules/phaser/src/core/DebugHeader.js
  var require_DebugHeader = __commonJS({
    "../../node_modules/phaser/src/core/DebugHeader.js": function(exports, module) {
      var CONST = require_const();
      var DebugHeader = function(game) {
        var config = game.config;
        if (config.hideBanner) {
          return;
        }
        var renderType = "WebGL";
        if (config.renderType === CONST.CANVAS) {
          renderType = "Canvas";
        } else if (config.renderType === CONST.HEADLESS) {
          renderType = "Headless";
        }
        var audioConfig = config.audio;
        var deviceAudio = game.device.audio;
        var audioType;
        if (deviceAudio.webAudio && !audioConfig.disableWebAudio) {
          audioType = "Web Audio";
        } else if (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
          audioType = "No Audio";
        } else {
          audioType = "HTML5 Audio";
        }
        if (!game.device.browser.ie) {
          var c = "";
          var args = [c];
          if (Array.isArray(config.bannerBackgroundColor)) {
            var lastColor;
            config.bannerBackgroundColor.forEach(function(color) {
              c = c.concat("%c ");
              args.push("background: " + color);
              lastColor = color;
            });
            args[args.length - 1] = "color: " + config.bannerTextColor + "; background: " + lastColor;
          } else {
            c = c.concat("%c ");
            args.push("color: " + config.bannerTextColor + "; background: " + config.bannerBackgroundColor);
          }
          args.push("background: transparent");
          if (config.gameTitle) {
            c = c.concat(config.gameTitle);
            if (config.gameVersion) {
              c = c.concat(" v" + config.gameVersion);
            }
            if (!config.hidePhaser) {
              c = c.concat(" / ");
            }
          }
          var fb = false ? "-FB" : "";
          if (!config.hidePhaser) {
            c = c.concat("Phaser v" + CONST.VERSION + fb + " (" + renderType + " | " + audioType + ")");
          }
          c = c.concat(" %c " + config.gameURL);
          args[0] = c;
          console.log.apply(console, args);
        } else if (window["console"]) {
          console.log("Phaser v" + CONST.VERSION + " / https://phaser.io");
        }
      };
      module.exports = DebugHeader;
    }
  });

  // ../../node_modules/phaser/src/dom/RequestAnimationFrame.js
  var require_RequestAnimationFrame = __commonJS({
    "../../node_modules/phaser/src/dom/RequestAnimationFrame.js": function(exports, module) {
      var Class = require_Class();
      var NOOP = require_NOOP();
      var RequestAnimationFrame = new Class({
        initialize: function RequestAnimationFrame2() {
          this.isRunning = false;
          this.callback = NOOP;
          this.isSetTimeOut = false;
          this.timeOutID = null;
          this.delay = 0;
          var _this = this;
          this.step = function step(time) {
            _this.callback(time);
            if (_this.isRunning) {
              _this.timeOutID = window.requestAnimationFrame(step);
            }
          };
          this.stepTimeout = function stepTimeout() {
            if (_this.isRunning) {
              _this.timeOutID = window.setTimeout(stepTimeout, _this.delay);
            }
            _this.callback(window.performance.now());
          };
        },
        start: function(callback, forceSetTimeOut, delay) {
          if (this.isRunning) {
            return;
          }
          this.callback = callback;
          this.isSetTimeOut = forceSetTimeOut;
          this.delay = delay;
          this.isRunning = true;
          this.timeOutID = forceSetTimeOut ? window.setTimeout(this.stepTimeout, 0) : window.requestAnimationFrame(this.step);
        },
        stop: function() {
          this.isRunning = false;
          if (this.isSetTimeOut) {
            clearTimeout(this.timeOutID);
          } else {
            window.cancelAnimationFrame(this.timeOutID);
          }
        },
        destroy: function() {
          this.stop();
          this.callback = NOOP;
        }
      });
      module.exports = RequestAnimationFrame;
    }
  });

  // ../../node_modules/phaser/src/core/TimeStep.js
  var require_TimeStep = __commonJS({
    "../../node_modules/phaser/src/core/TimeStep.js": function(exports, module) {
      var Class = require_Class();
      var GetValue = require_GetValue();
      var NOOP = require_NOOP();
      var RequestAnimationFrame = require_RequestAnimationFrame();
      var TimeStep = new Class({
        initialize: function TimeStep2(game, config) {
          this.game = game;
          this.raf = new RequestAnimationFrame();
          this.started = false;
          this.running = false;
          this.minFps = GetValue(config, "min", 5);
          this.targetFps = GetValue(config, "target", 60);
          this.fpsLimit = GetValue(config, "limit", 0);
          this.hasFpsLimit = this.fpsLimit > 0;
          this._limitRate = this.hasFpsLimit ? 1e3 / this.fpsLimit : 0;
          this._min = 1e3 / this.minFps;
          this._target = 1e3 / this.targetFps;
          this.actualFps = this.targetFps;
          this.nextFpsUpdate = 0;
          this.framesThisSecond = 0;
          this.callback = NOOP;
          this.forceSetTimeOut = GetValue(config, "forceSetTimeOut", false);
          this.time = 0;
          this.startTime = 0;
          this.lastTime = 0;
          this.frame = 0;
          this.inFocus = true;
          this._pauseTime = 0;
          this._coolDown = 0;
          this.delta = 0;
          this.deltaIndex = 0;
          this.deltaHistory = [];
          this.deltaSmoothingMax = GetValue(config, "deltaHistory", 10);
          this.panicMax = GetValue(config, "panicMax", 120);
          this.rawDelta = 0;
          this.now = 0;
          this.smoothStep = GetValue(config, "smoothStep", true);
        },
        blur: function() {
          this.inFocus = false;
        },
        focus: function() {
          this.inFocus = true;
          this.resetDelta();
        },
        pause: function() {
          this._pauseTime = window.performance.now();
        },
        resume: function() {
          this.resetDelta();
          this.startTime += this.time - this._pauseTime;
        },
        resetDelta: function() {
          var now = window.performance.now();
          this.time = now;
          this.lastTime = now;
          this.nextFpsUpdate = now + 1e3;
          this.framesThisSecond = 0;
          for (var i = 0; i < this.deltaSmoothingMax; i++) {
            this.deltaHistory[i] = Math.min(this._target, this.deltaHistory[i]);
          }
          this.delta = 0;
          this.deltaIndex = 0;
          this._coolDown = this.panicMax;
        },
        start: function(callback) {
          if (this.started) {
            return this;
          }
          this.started = true;
          this.running = true;
          for (var i = 0; i < this.deltaSmoothingMax; i++) {
            this.deltaHistory[i] = this._target;
          }
          this.resetDelta();
          this.startTime = window.performance.now();
          this.callback = callback;
          var step = this.hasFpsLimit ? this.stepLimitFPS.bind(this) : this.step.bind(this);
          this.raf.start(step, this.forceSetTimeOut, this._target);
        },
        smoothDelta: function(delta) {
          var idx = this.deltaIndex;
          var history = this.deltaHistory;
          var max = this.deltaSmoothingMax;
          if (this._coolDown > 0 || !this.inFocus) {
            this._coolDown--;
            delta = Math.min(delta, this._target);
          }
          if (delta > this._min) {
            delta = history[idx];
            delta = Math.min(delta, this._min);
          }
          history[idx] = delta;
          this.deltaIndex++;
          if (this.deltaIndex >= max) {
            this.deltaIndex = 0;
          }
          var avg = 0;
          for (var i = 0; i < max; i++) {
            avg += history[i];
          }
          avg /= max;
          return avg;
        },
        updateFPS: function(time) {
          this.actualFps = 0.25 * this.framesThisSecond + 0.75 * this.actualFps;
          this.nextFpsUpdate = time + 1e3;
          this.framesThisSecond = 0;
        },
        stepLimitFPS: function(time) {
          this.now = time;
          var delta = Math.max(0, time - this.lastTime);
          this.rawDelta = delta;
          this.time += this.rawDelta;
          if (this.smoothStep) {
            delta = this.smoothDelta(delta);
          }
          this.delta += delta;
          if (time >= this.nextFpsUpdate) {
            this.updateFPS(time);
          }
          this.framesThisSecond++;
          if (this.delta >= this._limitRate) {
            this.callback(time, this.delta);
            this.delta = 0;
          }
          this.lastTime = time;
          this.frame++;
        },
        step: function(time) {
          this.now = time;
          var delta = Math.max(0, time - this.lastTime);
          this.rawDelta = delta;
          this.time += this.rawDelta;
          if (this.smoothStep) {
            delta = this.smoothDelta(delta);
          }
          this.delta = delta;
          if (time >= this.nextFpsUpdate) {
            this.updateFPS(time);
          }
          this.framesThisSecond++;
          this.callback(time, delta);
          this.lastTime = time;
          this.frame++;
        },
        tick: function() {
          var now = window.performance.now();
          if (this.hasFpsLimit) {
            this.stepLimitFPS(now);
          } else {
            this.step(now);
          }
        },
        sleep: function() {
          if (this.running) {
            this.raf.stop();
            this.running = false;
          }
        },
        wake: function(seamless) {
          if (seamless === void 0) {
            seamless = false;
          }
          var now = window.performance.now();
          if (this.running) {
            return;
          } else if (seamless) {
            this.startTime += -this.lastTime + (this.lastTime + now);
          }
          var step = this.hasFpsLimit ? this.stepLimitFPS.bind(this) : this.step.bind(this);
          this.raf.start(step, this.forceSetTimeOut, this._target);
          this.running = true;
          this.nextFpsUpdate = now + 1e3;
          this.framesThisSecond = 0;
          this.fpsLimitTriggered = false;
          this.tick();
        },
        getDuration: function() {
          return Math.round(this.lastTime - this.startTime) / 1e3;
        },
        getDurationMS: function() {
          return Math.round(this.lastTime - this.startTime);
        },
        stop: function() {
          this.running = false;
          this.started = false;
          this.raf.stop();
          return this;
        },
        destroy: function() {
          this.stop();
          this.raf.destroy();
          this.raf = null;
          this.game = null;
          this.callback = null;
        }
      });
      module.exports = TimeStep;
    }
  });

  // ../../node_modules/phaser/src/core/VisibilityHandler.js
  var require_VisibilityHandler = __commonJS({
    "../../node_modules/phaser/src/core/VisibilityHandler.js": function(exports, module) {
      var Events = require_events5();
      var VisibilityHandler = function(game) {
        var hiddenVar;
        var eventEmitter = game.events;
        if (document.hidden !== void 0) {
          hiddenVar = "visibilitychange";
        } else {
          var vendors = ["webkit", "moz", "ms"];
          vendors.forEach(function(prefix) {
            if (document[prefix + "Hidden"] !== void 0) {
              document.hidden = function() {
                return document[prefix + "Hidden"];
              };
              hiddenVar = prefix + "visibilitychange";
            }
          });
        }
        var onChange = function(event) {
          if (document.hidden || event.type === "pause") {
            eventEmitter.emit(Events.HIDDEN);
          } else {
            eventEmitter.emit(Events.VISIBLE);
          }
        };
        if (hiddenVar) {
          document.addEventListener(hiddenVar, onChange, false);
        }
        window.onblur = function() {
          eventEmitter.emit(Events.BLUR);
        };
        window.onfocus = function() {
          eventEmitter.emit(Events.FOCUS);
        };
        if (window.focus && game.config.autoFocus) {
          window.focus();
        }
      };
      module.exports = VisibilityHandler;
    }
  });

  // ../../node_modules/phaser/src/core/index.js
  var require_core = __commonJS({
    "../../node_modules/phaser/src/core/index.js": function(exports, module) {
      module.exports = {
        Config: require_Config(),
        CreateRenderer: require_CreateRenderer(),
        DebugHeader: require_DebugHeader(),
        Events: require_events5(),
        TimeStep: require_TimeStep(),
        VisibilityHandler: require_VisibilityHandler()
      };
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/FromPoints.js
  var require_FromPoints = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/FromPoints.js": function(exports, module) {
      var Rectangle = require_Rectangle();
      var MATH_CONST = require_const4();
      var FromPoints = function(points, out) {
        if (out === void 0) {
          out = new Rectangle();
        }
        if (points.length === 0) {
          return out;
        }
        var minX = Number.MAX_VALUE;
        var minY = Number.MAX_VALUE;
        var maxX = MATH_CONST.MIN_SAFE_INTEGER;
        var maxY = MATH_CONST.MIN_SAFE_INTEGER;
        var p;
        var px;
        var py;
        for (var i = 0; i < points.length; i++) {
          p = points[i];
          if (Array.isArray(p)) {
            px = p[0];
            py = p[1];
          } else {
            px = p.x;
            py = p.y;
          }
          minX = Math.min(minX, px);
          minY = Math.min(minY, py);
          maxX = Math.max(maxX, px);
          maxY = Math.max(maxY, py);
        }
        out.x = minX;
        out.y = minY;
        out.width = maxX - minX;
        out.height = maxY - minY;
        return out;
      };
      module.exports = FromPoints;
    }
  });

  // ../../node_modules/phaser/src/curves/Curve.js
  var require_Curve = __commonJS({
    "../../node_modules/phaser/src/curves/Curve.js": function(exports, module) {
      var Class = require_Class();
      var FromPoints = require_FromPoints();
      var Rectangle = require_Rectangle();
      var Vector2 = require_Vector2();
      var Curve = new Class({
        initialize: function Curve2(type) {
          this.type = type;
          this.defaultDivisions = 5;
          this.arcLengthDivisions = 100;
          this.cacheArcLengths = [];
          this.needsUpdate = true;
          this.active = true;
          this._tmpVec2A = new Vector2();
          this._tmpVec2B = new Vector2();
        },
        draw: function(graphics, pointsTotal) {
          if (pointsTotal === void 0) {
            pointsTotal = 32;
          }
          return graphics.strokePoints(this.getPoints(pointsTotal));
        },
        getBounds: function(out, accuracy) {
          if (!out) {
            out = new Rectangle();
          }
          if (accuracy === void 0) {
            accuracy = 16;
          }
          var len = this.getLength();
          if (accuracy > len) {
            accuracy = len / 2;
          }
          var spaced = Math.max(1, Math.round(len / accuracy));
          return FromPoints(this.getSpacedPoints(spaced), out);
        },
        getDistancePoints: function(distance) {
          var len = this.getLength();
          var spaced = Math.max(1, len / distance);
          return this.getSpacedPoints(spaced);
        },
        getEndPoint: function(out) {
          if (out === void 0) {
            out = new Vector2();
          }
          return this.getPointAt(1, out);
        },
        getLength: function() {
          var lengths = this.getLengths();
          return lengths[lengths.length - 1];
        },
        getLengths: function(divisions) {
          if (divisions === void 0) {
            divisions = this.arcLengthDivisions;
          }
          if (this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
            return this.cacheArcLengths;
          }
          this.needsUpdate = false;
          var cache = [];
          var current;
          var last = this.getPoint(0, this._tmpVec2A);
          var sum = 0;
          cache.push(0);
          for (var p = 1; p <= divisions; p++) {
            current = this.getPoint(p / divisions, this._tmpVec2B);
            sum += current.distance(last);
            cache.push(sum);
            last.copy(current);
          }
          this.cacheArcLengths = cache;
          return cache;
        },
        getPointAt: function(u, out) {
          var t = this.getUtoTmapping(u);
          return this.getPoint(t, out);
        },
        getPoints: function(divisions, stepRate, out) {
          if (out === void 0) {
            out = [];
          }
          if (!divisions) {
            if (!stepRate) {
              divisions = this.defaultDivisions;
            } else {
              divisions = this.getLength() / stepRate;
            }
          }
          for (var d = 0; d <= divisions; d++) {
            out.push(this.getPoint(d / divisions));
          }
          return out;
        },
        getRandomPoint: function(out) {
          if (out === void 0) {
            out = new Vector2();
          }
          return this.getPoint(Math.random(), out);
        },
        getSpacedPoints: function(divisions, stepRate, out) {
          if (out === void 0) {
            out = [];
          }
          if (!divisions) {
            if (!stepRate) {
              divisions = this.defaultDivisions;
            } else {
              divisions = this.getLength() / stepRate;
            }
          }
          for (var d = 0; d <= divisions; d++) {
            var t = this.getUtoTmapping(d / divisions, null, divisions);
            out.push(this.getPoint(t));
          }
          return out;
        },
        getStartPoint: function(out) {
          if (out === void 0) {
            out = new Vector2();
          }
          return this.getPointAt(0, out);
        },
        getTangent: function(t, out) {
          if (out === void 0) {
            out = new Vector2();
          }
          var delta = 1e-4;
          var t1 = t - delta;
          var t2 = t + delta;
          if (t1 < 0) {
            t1 = 0;
          }
          if (t2 > 1) {
            t2 = 1;
          }
          this.getPoint(t1, this._tmpVec2A);
          this.getPoint(t2, out);
          return out.subtract(this._tmpVec2A).normalize();
        },
        getTangentAt: function(u, out) {
          var t = this.getUtoTmapping(u);
          return this.getTangent(t, out);
        },
        getTFromDistance: function(distance, divisions) {
          if (distance <= 0) {
            return 0;
          }
          return this.getUtoTmapping(0, distance, divisions);
        },
        getUtoTmapping: function(u, distance, divisions) {
          var arcLengths = this.getLengths(divisions);
          var i = 0;
          var il = arcLengths.length;
          var targetArcLength;
          if (distance) {
            targetArcLength = Math.min(distance, arcLengths[il - 1]);
          } else {
            targetArcLength = u * arcLengths[il - 1];
          }
          var low = 0;
          var high = il - 1;
          var comparison;
          while (low <= high) {
            i = Math.floor(low + (high - low) / 2);
            comparison = arcLengths[i] - targetArcLength;
            if (comparison < 0) {
              low = i + 1;
            } else if (comparison > 0) {
              high = i - 1;
            } else {
              high = i;
              break;
            }
          }
          i = high;
          if (arcLengths[i] === targetArcLength) {
            return i / (il - 1);
          }
          var lengthBefore = arcLengths[i];
          var lengthAfter = arcLengths[i + 1];
          var segmentLength = lengthAfter - lengthBefore;
          var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
          return (i + segmentFraction) / (il - 1);
        },
        updateArcLengths: function() {
          this.needsUpdate = true;
          this.getLengths();
        }
      });
      module.exports = Curve;
    }
  });

  // ../../node_modules/phaser/src/curves/SplineCurve.js
  var require_SplineCurve = __commonJS({
    "../../node_modules/phaser/src/curves/SplineCurve.js": function(exports, module) {
      var CatmullRom = require_CatmullRom();
      var Class = require_Class();
      var Curve = require_Curve();
      var Vector2 = require_Vector2();
      var SplineCurve = new Class({
        Extends: Curve,
        initialize: function SplineCurve2(points) {
          if (points === void 0) {
            points = [];
          }
          Curve.call(this, "SplineCurve");
          this.points = [];
          this.addPoints(points);
        },
        addPoints: function(points) {
          for (var i = 0; i < points.length; i++) {
            var p = new Vector2();
            if (typeof points[i] === "number") {
              p.x = points[i];
              p.y = points[i + 1];
              i++;
            } else if (Array.isArray(points[i])) {
              p.x = points[i][0];
              p.y = points[i][1];
            } else {
              p.x = points[i].x;
              p.y = points[i].y;
            }
            this.points.push(p);
          }
          return this;
        },
        addPoint: function(x, y) {
          var vec = new Vector2(x, y);
          this.points.push(vec);
          return vec;
        },
        getStartPoint: function(out) {
          if (out === void 0) {
            out = new Vector2();
          }
          return out.copy(this.points[0]);
        },
        getResolution: function(divisions) {
          return divisions * this.points.length;
        },
        getPoint: function(t, out) {
          if (out === void 0) {
            out = new Vector2();
          }
          var points = this.points;
          var point = (points.length - 1) * t;
          var intPoint = Math.floor(point);
          var weight = point - intPoint;
          var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
          var p1 = points[intPoint];
          var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
          var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
          return out.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
        },
        toJSON: function() {
          var points = [];
          for (var i = 0; i < this.points.length; i++) {
            points.push(this.points[i].x);
            points.push(this.points[i].y);
          }
          return {
            type: this.type,
            points: points
          };
        }
      });
      SplineCurve.fromJSON = function(data) {
        return new SplineCurve(data.points);
      };
      module.exports = SplineCurve;
    }
  });

  // ../../node_modules/phaser/src/curves/EllipseCurve.js
  var require_EllipseCurve = __commonJS({
    "../../node_modules/phaser/src/curves/EllipseCurve.js": function(exports, module) {
      var Class = require_Class();
      var Curve = require_Curve();
      var DegToRad = require_DegToRad();
      var GetValue = require_GetValue();
      var RadToDeg = require_RadToDeg();
      var Vector2 = require_Vector2();
      var EllipseCurve = new Class({
        Extends: Curve,
        initialize: function EllipseCurve2(x, y, xRadius, yRadius, startAngle, endAngle, clockwise, rotation) {
          if (typeof x === "object") {
            var config = x;
            x = GetValue(config, "x", 0);
            y = GetValue(config, "y", 0);
            xRadius = GetValue(config, "xRadius", 0);
            yRadius = GetValue(config, "yRadius", xRadius);
            startAngle = GetValue(config, "startAngle", 0);
            endAngle = GetValue(config, "endAngle", 360);
            clockwise = GetValue(config, "clockwise", false);
            rotation = GetValue(config, "rotation", 0);
          } else {
            if (yRadius === void 0) {
              yRadius = xRadius;
            }
            if (startAngle === void 0) {
              startAngle = 0;
            }
            if (endAngle === void 0) {
              endAngle = 360;
            }
            if (clockwise === void 0) {
              clockwise = false;
            }
            if (rotation === void 0) {
              rotation = 0;
            }
          }
          Curve.call(this, "EllipseCurve");
          this.p0 = new Vector2(x, y);
          this._xRadius = xRadius;
          this._yRadius = yRadius;
          this._startAngle = DegToRad(startAngle);
          this._endAngle = DegToRad(endAngle);
          this._clockwise = clockwise;
          this._rotation = DegToRad(rotation);
        },
        getStartPoint: function(out) {
          if (out === void 0) {
            out = new Vector2();
          }
          return this.getPoint(0, out);
        },
        getResolution: function(divisions) {
          return divisions * 2;
        },
        getPoint: function(t, out) {
          if (out === void 0) {
            out = new Vector2();
          }
          var twoPi = Math.PI * 2;
          var deltaAngle = this._endAngle - this._startAngle;
          var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
          while (deltaAngle < 0) {
            deltaAngle += twoPi;
          }
          while (deltaAngle > twoPi) {
            deltaAngle -= twoPi;
          }
          if (deltaAngle < Number.EPSILON) {
            if (samePoints) {
              deltaAngle = 0;
            } else {
              deltaAngle = twoPi;
            }
          }
          if (this._clockwise && !samePoints) {
            if (deltaAngle === twoPi) {
              deltaAngle = -twoPi;
            } else {
              deltaAngle = deltaAngle - twoPi;
            }
          }
          var angle = this._startAngle + t * deltaAngle;
          var x = this.p0.x + this._xRadius * Math.cos(angle);
          var y = this.p0.y + this._yRadius * Math.sin(angle);
          if (this._rotation !== 0) {
            var cos = Math.cos(this._rotation);
            var sin = Math.sin(this._rotation);
            var tx = x - this.p0.x;
            var ty = y - this.p0.y;
            x = tx * cos - ty * sin + this.p0.x;
            y = tx * sin + ty * cos + this.p0.y;
          }
          return out.set(x, y);
        },
        setXRadius: function(value) {
          this.xRadius = value;
          return this;
        },
        setYRadius: function(value) {
          this.yRadius = value;
          return this;
        },
        setWidth: function(value) {
          this.xRadius = value / 2;
          return this;
        },
        setHeight: function(value) {
          this.yRadius = value / 2;
          return this;
        },
        setStartAngle: function(value) {
          this.startAngle = value;
          return this;
        },
        setEndAngle: function(value) {
          this.endAngle = value;
          return this;
        },
        setClockwise: function(value) {
          this.clockwise = value;
          return this;
        },
        setRotation: function(value) {
          this.rotation = value;
          return this;
        },
        x: {
          get: function() {
            return this.p0.x;
          },
          set: function(value) {
            this.p0.x = value;
          }
        },
        y: {
          get: function() {
            return this.p0.y;
          },
          set: function(value) {
            this.p0.y = value;
          }
        },
        xRadius: {
          get: function() {
            return this._xRadius;
          },
          set: function(value) {
            this._xRadius = value;
          }
        },
        yRadius: {
          get: function() {
            return this._yRadius;
          },
          set: function(value) {
            this._yRadius = value;
          }
        },
        startAngle: {
          get: function() {
            return RadToDeg(this._startAngle);
          },
          set: function(value) {
            this._startAngle = DegToRad(value);
          }
        },
        endAngle: {
          get: function() {
            return RadToDeg(this._endAngle);
          },
          set: function(value) {
            this._endAngle = DegToRad(value);
          }
        },
        clockwise: {
          get: function() {
            return this._clockwise;
          },
          set: function(value) {
            this._clockwise = value;
          }
        },
        angle: {
          get: function() {
            return RadToDeg(this._rotation);
          },
          set: function(value) {
            this._rotation = DegToRad(value);
          }
        },
        rotation: {
          get: function() {
            return this._rotation;
          },
          set: function(value) {
            this._rotation = value;
          }
        },
        toJSON: function() {
          return {
            type: this.type,
            x: this.p0.x,
            y: this.p0.y,
            xRadius: this._xRadius,
            yRadius: this._yRadius,
            startAngle: RadToDeg(this._startAngle),
            endAngle: RadToDeg(this._endAngle),
            clockwise: this._clockwise,
            rotation: RadToDeg(this._rotation)
          };
        }
      });
      EllipseCurve.fromJSON = function(data) {
        return new EllipseCurve(data);
      };
      module.exports = EllipseCurve;
    }
  });

  // ../../node_modules/phaser/src/data/DataManagerPlugin.js
  var require_DataManagerPlugin = __commonJS({
    "../../node_modules/phaser/src/data/DataManagerPlugin.js": function(exports, module) {
      var Class = require_Class();
      var DataManager = require_DataManager();
      var PluginCache = require_PluginCache();
      var SceneEvents = require_events();
      var DataManagerPlugin = new Class({
        Extends: DataManager,
        initialize: function DataManagerPlugin2(scene) {
          DataManager.call(this, scene, scene.sys.events);
          this.scene = scene;
          this.systems = scene.sys;
          scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
          scene.sys.events.on(SceneEvents.START, this.start, this);
        },
        boot: function() {
          this.events = this.systems.events;
          this.events.once(SceneEvents.DESTROY, this.destroy, this);
        },
        start: function() {
          this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        shutdown: function() {
          this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        destroy: function() {
          DataManager.prototype.destroy.call(this);
          this.events.off(SceneEvents.START, this.start, this);
          this.scene = null;
          this.systems = null;
        }
      });
      PluginCache.register("DataManagerPlugin", DataManagerPlugin, "data");
      module.exports = DataManagerPlugin;
    }
  });

  // ../../node_modules/phaser/src/data/index.js
  var require_data = __commonJS({
    "../../node_modules/phaser/src/data/index.js": function(exports, module) {
      module.exports = {
        DataManager: require_DataManager(),
        DataManagerPlugin: require_DataManagerPlugin(),
        Events: require_events2()
      };
    }
  });

  // ../../node_modules/phaser/src/display/align/in/index.js
  var require_in = __commonJS({
    "../../node_modules/phaser/src/display/align/in/index.js": function(exports, module) {
      module.exports = {
        BottomCenter: require_BottomCenter(),
        BottomLeft: require_BottomLeft(),
        BottomRight: require_BottomRight(),
        Center: require_Center(),
        LeftCenter: require_LeftCenter(),
        QuickSet: require_QuickSet(),
        RightCenter: require_RightCenter(),
        TopCenter: require_TopCenter(),
        TopLeft: require_TopLeft(),
        TopRight: require_TopRight()
      };
    }
  });

  // ../../node_modules/phaser/src/display/align/to/BottomCenter.js
  var require_BottomCenter2 = __commonJS({
    "../../node_modules/phaser/src/display/align/to/BottomCenter.js": function(exports, module) {
      var GetBottom = require_GetBottom();
      var GetCenterX = require_GetCenterX();
      var SetCenterX = require_SetCenterX();
      var SetTop = require_SetTop();
      var BottomCenter = function(gameObject, alignTo, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetCenterX(gameObject, GetCenterX(alignTo) + offsetX);
        SetTop(gameObject, GetBottom(alignTo) + offsetY);
        return gameObject;
      };
      module.exports = BottomCenter;
    }
  });

  // ../../node_modules/phaser/src/display/align/to/BottomLeft.js
  var require_BottomLeft2 = __commonJS({
    "../../node_modules/phaser/src/display/align/to/BottomLeft.js": function(exports, module) {
      var GetBottom = require_GetBottom();
      var GetLeft = require_GetLeft();
      var SetLeft = require_SetLeft();
      var SetTop = require_SetTop();
      var BottomLeft = function(gameObject, alignTo, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetLeft(gameObject, GetLeft(alignTo) - offsetX);
        SetTop(gameObject, GetBottom(alignTo) + offsetY);
        return gameObject;
      };
      module.exports = BottomLeft;
    }
  });

  // ../../node_modules/phaser/src/display/align/to/BottomRight.js
  var require_BottomRight2 = __commonJS({
    "../../node_modules/phaser/src/display/align/to/BottomRight.js": function(exports, module) {
      var GetBottom = require_GetBottom();
      var GetRight = require_GetRight();
      var SetRight = require_SetRight();
      var SetTop = require_SetTop();
      var BottomRight = function(gameObject, alignTo, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetRight(gameObject, GetRight(alignTo) + offsetX);
        SetTop(gameObject, GetBottom(alignTo) + offsetY);
        return gameObject;
      };
      module.exports = BottomRight;
    }
  });

  // ../../node_modules/phaser/src/display/align/to/LeftBottom.js
  var require_LeftBottom = __commonJS({
    "../../node_modules/phaser/src/display/align/to/LeftBottom.js": function(exports, module) {
      var GetBottom = require_GetBottom();
      var GetLeft = require_GetLeft();
      var SetBottom = require_SetBottom();
      var SetRight = require_SetRight();
      var LeftBottom = function(gameObject, alignTo, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetRight(gameObject, GetLeft(alignTo) - offsetX);
        SetBottom(gameObject, GetBottom(alignTo) + offsetY);
        return gameObject;
      };
      module.exports = LeftBottom;
    }
  });

  // ../../node_modules/phaser/src/display/align/to/LeftCenter.js
  var require_LeftCenter2 = __commonJS({
    "../../node_modules/phaser/src/display/align/to/LeftCenter.js": function(exports, module) {
      var GetCenterY = require_GetCenterY();
      var GetLeft = require_GetLeft();
      var SetCenterY = require_SetCenterY();
      var SetRight = require_SetRight();
      var LeftCenter = function(gameObject, alignTo, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetRight(gameObject, GetLeft(alignTo) - offsetX);
        SetCenterY(gameObject, GetCenterY(alignTo) + offsetY);
        return gameObject;
      };
      module.exports = LeftCenter;
    }
  });

  // ../../node_modules/phaser/src/display/align/to/LeftTop.js
  var require_LeftTop = __commonJS({
    "../../node_modules/phaser/src/display/align/to/LeftTop.js": function(exports, module) {
      var GetLeft = require_GetLeft();
      var GetTop = require_GetTop();
      var SetRight = require_SetRight();
      var SetTop = require_SetTop();
      var LeftTop = function(gameObject, alignTo, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetRight(gameObject, GetLeft(alignTo) - offsetX);
        SetTop(gameObject, GetTop(alignTo) - offsetY);
        return gameObject;
      };
      module.exports = LeftTop;
    }
  });

  // ../../node_modules/phaser/src/display/align/to/RightBottom.js
  var require_RightBottom = __commonJS({
    "../../node_modules/phaser/src/display/align/to/RightBottom.js": function(exports, module) {
      var GetBottom = require_GetBottom();
      var GetRight = require_GetRight();
      var SetBottom = require_SetBottom();
      var SetLeft = require_SetLeft();
      var RightBottom = function(gameObject, alignTo, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetLeft(gameObject, GetRight(alignTo) + offsetX);
        SetBottom(gameObject, GetBottom(alignTo) + offsetY);
        return gameObject;
      };
      module.exports = RightBottom;
    }
  });

  // ../../node_modules/phaser/src/display/align/to/RightCenter.js
  var require_RightCenter2 = __commonJS({
    "../../node_modules/phaser/src/display/align/to/RightCenter.js": function(exports, module) {
      var GetCenterY = require_GetCenterY();
      var GetRight = require_GetRight();
      var SetCenterY = require_SetCenterY();
      var SetLeft = require_SetLeft();
      var RightCenter = function(gameObject, alignTo, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetLeft(gameObject, GetRight(alignTo) + offsetX);
        SetCenterY(gameObject, GetCenterY(alignTo) + offsetY);
        return gameObject;
      };
      module.exports = RightCenter;
    }
  });

  // ../../node_modules/phaser/src/display/align/to/RightTop.js
  var require_RightTop = __commonJS({
    "../../node_modules/phaser/src/display/align/to/RightTop.js": function(exports, module) {
      var GetRight = require_GetRight();
      var GetTop = require_GetTop();
      var SetLeft = require_SetLeft();
      var SetTop = require_SetTop();
      var RightTop = function(gameObject, alignTo, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetLeft(gameObject, GetRight(alignTo) + offsetX);
        SetTop(gameObject, GetTop(alignTo) - offsetY);
        return gameObject;
      };
      module.exports = RightTop;
    }
  });

  // ../../node_modules/phaser/src/display/align/to/TopCenter.js
  var require_TopCenter2 = __commonJS({
    "../../node_modules/phaser/src/display/align/to/TopCenter.js": function(exports, module) {
      var GetCenterX = require_GetCenterX();
      var GetTop = require_GetTop();
      var SetBottom = require_SetBottom();
      var SetCenterX = require_SetCenterX();
      var TopCenter = function(gameObject, alignTo, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetCenterX(gameObject, GetCenterX(alignTo) + offsetX);
        SetBottom(gameObject, GetTop(alignTo) - offsetY);
        return gameObject;
      };
      module.exports = TopCenter;
    }
  });

  // ../../node_modules/phaser/src/display/align/to/TopLeft.js
  var require_TopLeft2 = __commonJS({
    "../../node_modules/phaser/src/display/align/to/TopLeft.js": function(exports, module) {
      var GetLeft = require_GetLeft();
      var GetTop = require_GetTop();
      var SetBottom = require_SetBottom();
      var SetLeft = require_SetLeft();
      var TopLeft = function(gameObject, alignTo, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetLeft(gameObject, GetLeft(alignTo) - offsetX);
        SetBottom(gameObject, GetTop(alignTo) - offsetY);
        return gameObject;
      };
      module.exports = TopLeft;
    }
  });

  // ../../node_modules/phaser/src/display/align/to/TopRight.js
  var require_TopRight2 = __commonJS({
    "../../node_modules/phaser/src/display/align/to/TopRight.js": function(exports, module) {
      var GetRight = require_GetRight();
      var GetTop = require_GetTop();
      var SetBottom = require_SetBottom();
      var SetRight = require_SetRight();
      var TopRight = function(gameObject, alignTo, offsetX, offsetY) {
        if (offsetX === void 0) {
          offsetX = 0;
        }
        if (offsetY === void 0) {
          offsetY = 0;
        }
        SetRight(gameObject, GetRight(alignTo) + offsetX);
        SetBottom(gameObject, GetTop(alignTo) - offsetY);
        return gameObject;
      };
      module.exports = TopRight;
    }
  });

  // ../../node_modules/phaser/src/display/align/to/QuickSet.js
  var require_QuickSet2 = __commonJS({
    "../../node_modules/phaser/src/display/align/to/QuickSet.js": function(exports, module) {
      var ALIGN_CONST = require_const2();
      var AlignToMap = [];
      AlignToMap[ALIGN_CONST.BOTTOM_CENTER] = require_BottomCenter2();
      AlignToMap[ALIGN_CONST.BOTTOM_LEFT] = require_BottomLeft2();
      AlignToMap[ALIGN_CONST.BOTTOM_RIGHT] = require_BottomRight2();
      AlignToMap[ALIGN_CONST.LEFT_BOTTOM] = require_LeftBottom();
      AlignToMap[ALIGN_CONST.LEFT_CENTER] = require_LeftCenter2();
      AlignToMap[ALIGN_CONST.LEFT_TOP] = require_LeftTop();
      AlignToMap[ALIGN_CONST.RIGHT_BOTTOM] = require_RightBottom();
      AlignToMap[ALIGN_CONST.RIGHT_CENTER] = require_RightCenter2();
      AlignToMap[ALIGN_CONST.RIGHT_TOP] = require_RightTop();
      AlignToMap[ALIGN_CONST.TOP_CENTER] = require_TopCenter2();
      AlignToMap[ALIGN_CONST.TOP_LEFT] = require_TopLeft2();
      AlignToMap[ALIGN_CONST.TOP_RIGHT] = require_TopRight2();
      var QuickSet = function(child, alignTo, position, offsetX, offsetY) {
        return AlignToMap[position](child, alignTo, offsetX, offsetY);
      };
      module.exports = QuickSet;
    }
  });

  // ../../node_modules/phaser/src/display/align/to/index.js
  var require_to = __commonJS({
    "../../node_modules/phaser/src/display/align/to/index.js": function(exports, module) {
      module.exports = {
        BottomCenter: require_BottomCenter2(),
        BottomLeft: require_BottomLeft2(),
        BottomRight: require_BottomRight2(),
        LeftBottom: require_LeftBottom(),
        LeftCenter: require_LeftCenter2(),
        LeftTop: require_LeftTop(),
        QuickSet: require_QuickSet2(),
        RightBottom: require_RightBottom(),
        RightCenter: require_RightCenter2(),
        RightTop: require_RightTop(),
        TopCenter: require_TopCenter2(),
        TopLeft: require_TopLeft2(),
        TopRight: require_TopRight2()
      };
    }
  });

  // ../../node_modules/phaser/src/display/align/index.js
  var require_align = __commonJS({
    "../../node_modules/phaser/src/display/align/index.js": function(exports, module) {
      var CONST = require_const2();
      var Extend = require_Extend();
      var Align = {
        In: require_in(),
        To: require_to()
      };
      Align = Extend(false, Align, CONST);
      module.exports = Align;
    }
  });

  // ../../node_modules/phaser/src/display/bounds/GetBounds.js
  var require_GetBounds2 = __commonJS({
    "../../node_modules/phaser/src/display/bounds/GetBounds.js": function(exports, module) {
      var GetBottom = require_GetBottom();
      var GetLeft = require_GetLeft();
      var GetRight = require_GetRight();
      var GetTop = require_GetTop();
      var GetBounds = function(gameObject, output) {
        if (output === void 0) {
          output = {};
        }
        var left = GetLeft(gameObject);
        var top = GetTop(gameObject);
        output.x = left;
        output.y = top;
        output.width = GetRight(gameObject) - left;
        output.height = GetBottom(gameObject) - top;
        return output;
      };
      module.exports = GetBounds;
    }
  });

  // ../../node_modules/phaser/src/display/bounds/GetOffsetX.js
  var require_GetOffsetX = __commonJS({
    "../../node_modules/phaser/src/display/bounds/GetOffsetX.js": function(exports, module) {
      var GetOffsetX = function(gameObject) {
        return gameObject.width * gameObject.originX;
      };
      module.exports = GetOffsetX;
    }
  });

  // ../../node_modules/phaser/src/display/bounds/GetOffsetY.js
  var require_GetOffsetY = __commonJS({
    "../../node_modules/phaser/src/display/bounds/GetOffsetY.js": function(exports, module) {
      var GetOffsetY = function(gameObject) {
        return gameObject.height * gameObject.originY;
      };
      module.exports = GetOffsetY;
    }
  });

  // ../../node_modules/phaser/src/display/bounds/index.js
  var require_bounds = __commonJS({
    "../../node_modules/phaser/src/display/bounds/index.js": function(exports, module) {
      module.exports = {
        CenterOn: require_CenterOn(),
        GetBottom: require_GetBottom(),
        GetBounds: require_GetBounds2(),
        GetCenterX: require_GetCenterX(),
        GetCenterY: require_GetCenterY(),
        GetLeft: require_GetLeft(),
        GetOffsetX: require_GetOffsetX(),
        GetOffsetY: require_GetOffsetY(),
        GetRight: require_GetRight(),
        GetTop: require_GetTop(),
        SetBottom: require_SetBottom(),
        SetCenterX: require_SetCenterX(),
        SetCenterY: require_SetCenterY(),
        SetLeft: require_SetLeft(),
        SetRight: require_SetRight(),
        SetTop: require_SetTop()
      };
    }
  });

  // ../../node_modules/phaser/src/display/mask/index.js
  var require_mask = __commonJS({
    "../../node_modules/phaser/src/display/mask/index.js": function(exports, module) {
      module.exports = {
        BitmapMask: require_BitmapMask(),
        GeometryMask: require_GeometryMask()
      };
    }
  });

  // ../../node_modules/phaser/src/display/canvas/TouchAction.js
  var require_TouchAction = __commonJS({
    "../../node_modules/phaser/src/display/canvas/TouchAction.js": function(exports, module) {
      var TouchAction = function(canvas, value) {
        if (value === void 0) {
          value = "none";
        }
        canvas.style["msTouchAction"] = value;
        canvas.style["ms-touch-action"] = value;
        canvas.style["touch-action"] = value;
        return canvas;
      };
      module.exports = TouchAction;
    }
  });

  // ../../node_modules/phaser/src/display/canvas/UserSelect.js
  var require_UserSelect = __commonJS({
    "../../node_modules/phaser/src/display/canvas/UserSelect.js": function(exports, module) {
      var UserSelect = function(canvas, value) {
        if (value === void 0) {
          value = "none";
        }
        var vendors = [
          "-webkit-",
          "-khtml-",
          "-moz-",
          "-ms-",
          ""
        ];
        vendors.forEach(function(vendor) {
          canvas.style[vendor + "user-select"] = value;
        });
        canvas.style["-webkit-touch-callout"] = value;
        canvas.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)";
        return canvas;
      };
      module.exports = UserSelect;
    }
  });

  // ../../node_modules/phaser/src/display/canvas/index.js
  var require_canvas = __commonJS({
    "../../node_modules/phaser/src/display/canvas/index.js": function(exports, module) {
      module.exports = {
        CanvasInterpolation: require_CanvasInterpolation(),
        CanvasPool: require_CanvasPool(),
        Smoothing: require_Smoothing(),
        TouchAction: require_TouchAction(),
        UserSelect: require_UserSelect()
      };
    }
  });

  // ../../node_modules/phaser/src/display/color/ColorSpectrum.js
  var require_ColorSpectrum = __commonJS({
    "../../node_modules/phaser/src/display/color/ColorSpectrum.js": function(exports, module) {
      var GetColor = require_GetColor();
      var ColorSpectrum = function(limit) {
        if (limit === void 0) {
          limit = 1024;
        }
        var colors = [];
        var range = 255;
        var i;
        var r = 255;
        var g = 0;
        var b = 0;
        for (i = 0; i <= range; i++) {
          colors.push({ r: r, g: i, b: b, color: GetColor(r, i, b) });
        }
        g = 255;
        for (i = range; i >= 0; i--) {
          colors.push({ r: i, g: g, b: b, color: GetColor(i, g, b) });
        }
        r = 0;
        for (i = 0; i <= range; i++, g--) {
          colors.push({ r: r, g: g, b: i, color: GetColor(r, g, i) });
        }
        g = 0;
        b = 255;
        for (i = 0; i <= range; i++, b--, r++) {
          colors.push({ r: r, g: g, b: b, color: GetColor(r, g, b) });
        }
        if (limit === 1024) {
          return colors;
        } else {
          var out = [];
          var t = 0;
          var inc = 1024 / limit;
          for (i = 0; i < limit; i++) {
            out.push(colors[Math.floor(t)]);
            t += inc;
          }
          return out;
        }
      };
      module.exports = ColorSpectrum;
    }
  });

  // ../../node_modules/phaser/src/display/color/ColorToRGBA.js
  var require_ColorToRGBA = __commonJS({
    "../../node_modules/phaser/src/display/color/ColorToRGBA.js": function(exports, module) {
      var ColorToRGBA = function(color) {
        var output = {
          r: color >> 16 & 255,
          g: color >> 8 & 255,
          b: color & 255,
          a: 255
        };
        if (color > 16777215) {
          output.a = color >>> 24;
        }
        return output;
      };
      module.exports = ColorToRGBA;
    }
  });

  // ../../node_modules/phaser/src/display/color/ComponentToHex.js
  var require_ComponentToHex = __commonJS({
    "../../node_modules/phaser/src/display/color/ComponentToHex.js": function(exports, module) {
      var ComponentToHex = function(color) {
        var hex = color.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      };
      module.exports = ComponentToHex;
    }
  });

  // ../../node_modules/phaser/src/display/color/HueToComponent.js
  var require_HueToComponent = __commonJS({
    "../../node_modules/phaser/src/display/color/HueToComponent.js": function(exports, module) {
      var HueToComponent = function(p, q, t) {
        if (t < 0) {
          t += 1;
        }
        if (t > 1) {
          t -= 1;
        }
        if (t < 1 / 6) {
          return p + (q - p) * 6 * t;
        }
        if (t < 1 / 2) {
          return q;
        }
        if (t < 2 / 3) {
          return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
      };
      module.exports = HueToComponent;
    }
  });

  // ../../node_modules/phaser/src/display/color/HSLToColor.js
  var require_HSLToColor = __commonJS({
    "../../node_modules/phaser/src/display/color/HSLToColor.js": function(exports, module) {
      var Color = require_Color();
      var HueToComponent = require_HueToComponent();
      var HSLToColor = function(h, s, l) {
        var r = l;
        var g = l;
        var b = l;
        if (s !== 0) {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = HueToComponent(p, q, h + 1 / 3);
          g = HueToComponent(p, q, h);
          b = HueToComponent(p, q, h - 1 / 3);
        }
        var color = new Color();
        return color.setGLTo(r, g, b, 1);
      };
      module.exports = HSLToColor;
    }
  });

  // ../../node_modules/phaser/src/display/color/HSVColorWheel.js
  var require_HSVColorWheel = __commonJS({
    "../../node_modules/phaser/src/display/color/HSVColorWheel.js": function(exports, module) {
      var HSVToRGB = require_HSVToRGB();
      var HSVColorWheel = function(s, v) {
        if (s === void 0) {
          s = 1;
        }
        if (v === void 0) {
          v = 1;
        }
        var colors = [];
        for (var c = 0; c <= 359; c++) {
          colors.push(HSVToRGB(c / 359, s, v));
        }
        return colors;
      };
      module.exports = HSVColorWheel;
    }
  });

  // ../../node_modules/phaser/src/display/color/Interpolate.js
  var require_Interpolate = __commonJS({
    "../../node_modules/phaser/src/display/color/Interpolate.js": function(exports, module) {
      var Linear = require_Linear2();
      var RGBWithRGB = function(r1, g1, b1, r2, g2, b2, length, index) {
        if (length === void 0) {
          length = 100;
        }
        if (index === void 0) {
          index = 0;
        }
        var t = index / length;
        return {
          r: Linear(r1, r2, t),
          g: Linear(g1, g2, t),
          b: Linear(b1, b2, t)
        };
      };
      var ColorWithColor = function(color1, color2, length, index) {
        if (length === void 0) {
          length = 100;
        }
        if (index === void 0) {
          index = 0;
        }
        return RGBWithRGB(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b, length, index);
      };
      var ColorWithRGB = function(color, r, g, b, length, index) {
        if (length === void 0) {
          length = 100;
        }
        if (index === void 0) {
          index = 0;
        }
        return RGBWithRGB(color.r, color.g, color.b, r, g, b, length, index);
      };
      module.exports = {
        RGBWithRGB: RGBWithRGB,
        ColorWithRGB: ColorWithRGB,
        ColorWithColor: ColorWithColor
      };
    }
  });

  // ../../node_modules/phaser/src/display/color/RandomRGB.js
  var require_RandomRGB = __commonJS({
    "../../node_modules/phaser/src/display/color/RandomRGB.js": function(exports, module) {
      var Between = require_Between2();
      var Color = require_Color();
      var RandomRGB = function(min, max) {
        if (min === void 0) {
          min = 0;
        }
        if (max === void 0) {
          max = 255;
        }
        return new Color(Between(min, max), Between(min, max), Between(min, max));
      };
      module.exports = RandomRGB;
    }
  });

  // ../../node_modules/phaser/src/display/color/RGBToString.js
  var require_RGBToString = __commonJS({
    "../../node_modules/phaser/src/display/color/RGBToString.js": function(exports, module) {
      var ComponentToHex = require_ComponentToHex();
      var RGBToString = function(r, g, b, a, prefix) {
        if (a === void 0) {
          a = 255;
        }
        if (prefix === void 0) {
          prefix = "#";
        }
        if (prefix === "#") {
          return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1, 7);
        } else {
          return "0x" + ComponentToHex(a) + ComponentToHex(r) + ComponentToHex(g) + ComponentToHex(b);
        }
      };
      module.exports = RGBToString;
    }
  });

  // ../../node_modules/phaser/src/display/color/index.js
  var require_color = __commonJS({
    "../../node_modules/phaser/src/display/color/index.js": function(exports, module) {
      var Color = require_Color();
      Color.ColorSpectrum = require_ColorSpectrum();
      Color.ColorToRGBA = require_ColorToRGBA();
      Color.ComponentToHex = require_ComponentToHex();
      Color.GetColor = require_GetColor();
      Color.GetColor32 = require_GetColor32();
      Color.HexStringToColor = require_HexStringToColor();
      Color.HSLToColor = require_HSLToColor();
      Color.HSVColorWheel = require_HSVColorWheel();
      Color.HSVToRGB = require_HSVToRGB();
      Color.HueToComponent = require_HueToComponent();
      Color.IntegerToColor = require_IntegerToColor();
      Color.IntegerToRGB = require_IntegerToRGB();
      Color.Interpolate = require_Interpolate();
      Color.ObjectToColor = require_ObjectToColor();
      Color.RandomRGB = require_RandomRGB();
      Color.RGBStringToColor = require_RGBStringToColor();
      Color.RGBToHSV = require_RGBToHSV();
      Color.RGBToString = require_RGBToString();
      Color.ValueToColor = require_ValueToColor();
      module.exports = Color;
    }
  });

  // ../../node_modules/phaser/src/events/EventEmitter.js
  var require_EventEmitter = __commonJS({
    "../../node_modules/phaser/src/events/EventEmitter.js": function(exports, module) {
      var Class = require_Class();
      var EE = require_eventemitter3();
      var PluginCache = require_PluginCache();
      var EventEmitter = new Class({
        Extends: EE,
        initialize: function EventEmitter2() {
          EE.call(this);
        },
        shutdown: function() {
          this.removeAllListeners();
        },
        destroy: function() {
          this.removeAllListeners();
        }
      });
      PluginCache.register("EventEmitter", EventEmitter, "events");
      module.exports = EventEmitter;
    }
  });

  // ../../node_modules/phaser/src/events/index.js
  var require_events11 = __commonJS({
    "../../node_modules/phaser/src/events/index.js": function(exports, module) {
      module.exports = { EventEmitter: require_EventEmitter() };
    }
  });

  // ../../node_modules/phaser/src/dom/AddToDOM.js
  var require_AddToDOM = __commonJS({
    "../../node_modules/phaser/src/dom/AddToDOM.js": function(exports, module) {
      var AddToDOM = function(element, parent) {
        var target;
        if (parent) {
          if (typeof parent === "string") {
            target = document.getElementById(parent);
          } else if (typeof parent === "object" && parent.nodeType === 1) {
            target = parent;
          }
        } else if (element.parentElement || parent === null) {
          return element;
        }
        if (!target) {
          target = document.body;
        }
        target.appendChild(element);
        return element;
      };
      module.exports = AddToDOM;
    }
  });

  // ../../node_modules/phaser/src/animations/events/ADD_ANIMATION_EVENT.js
  var require_ADD_ANIMATION_EVENT = __commonJS({
    "../../node_modules/phaser/src/animations/events/ADD_ANIMATION_EVENT.js": function(exports, module) {
      module.exports = "add";
    }
  });

  // ../../node_modules/phaser/src/animations/events/ANIMATION_COMPLETE_EVENT.js
  var require_ANIMATION_COMPLETE_EVENT = __commonJS({
    "../../node_modules/phaser/src/animations/events/ANIMATION_COMPLETE_EVENT.js": function(exports, module) {
      module.exports = "animationcomplete";
    }
  });

  // ../../node_modules/phaser/src/animations/events/ANIMATION_COMPLETE_KEY_EVENT.js
  var require_ANIMATION_COMPLETE_KEY_EVENT = __commonJS({
    "../../node_modules/phaser/src/animations/events/ANIMATION_COMPLETE_KEY_EVENT.js": function(exports, module) {
      module.exports = "animationcomplete-";
    }
  });

  // ../../node_modules/phaser/src/animations/events/ANIMATION_REPEAT_EVENT.js
  var require_ANIMATION_REPEAT_EVENT = __commonJS({
    "../../node_modules/phaser/src/animations/events/ANIMATION_REPEAT_EVENT.js": function(exports, module) {
      module.exports = "animationrepeat";
    }
  });

  // ../../node_modules/phaser/src/animations/events/ANIMATION_RESTART_EVENT.js
  var require_ANIMATION_RESTART_EVENT = __commonJS({
    "../../node_modules/phaser/src/animations/events/ANIMATION_RESTART_EVENT.js": function(exports, module) {
      module.exports = "animationrestart";
    }
  });

  // ../../node_modules/phaser/src/animations/events/ANIMATION_START_EVENT.js
  var require_ANIMATION_START_EVENT = __commonJS({
    "../../node_modules/phaser/src/animations/events/ANIMATION_START_EVENT.js": function(exports, module) {
      module.exports = "animationstart";
    }
  });

  // ../../node_modules/phaser/src/animations/events/ANIMATION_STOP_EVENT.js
  var require_ANIMATION_STOP_EVENT = __commonJS({
    "../../node_modules/phaser/src/animations/events/ANIMATION_STOP_EVENT.js": function(exports, module) {
      module.exports = "animationstop";
    }
  });

  // ../../node_modules/phaser/src/animations/events/ANIMATION_UPDATE_EVENT.js
  var require_ANIMATION_UPDATE_EVENT = __commonJS({
    "../../node_modules/phaser/src/animations/events/ANIMATION_UPDATE_EVENT.js": function(exports, module) {
      module.exports = "animationupdate";
    }
  });

  // ../../node_modules/phaser/src/animations/events/PAUSE_ALL_EVENT.js
  var require_PAUSE_ALL_EVENT = __commonJS({
    "../../node_modules/phaser/src/animations/events/PAUSE_ALL_EVENT.js": function(exports, module) {
      module.exports = "pauseall";
    }
  });

  // ../../node_modules/phaser/src/animations/events/REMOVE_ANIMATION_EVENT.js
  var require_REMOVE_ANIMATION_EVENT = __commonJS({
    "../../node_modules/phaser/src/animations/events/REMOVE_ANIMATION_EVENT.js": function(exports, module) {
      module.exports = "remove";
    }
  });

  // ../../node_modules/phaser/src/animations/events/RESUME_ALL_EVENT.js
  var require_RESUME_ALL_EVENT = __commonJS({
    "../../node_modules/phaser/src/animations/events/RESUME_ALL_EVENT.js": function(exports, module) {
      module.exports = "resumeall";
    }
  });

  // ../../node_modules/phaser/src/animations/events/index.js
  var require_events12 = __commonJS({
    "../../node_modules/phaser/src/animations/events/index.js": function(exports, module) {
      module.exports = {
        ADD_ANIMATION: require_ADD_ANIMATION_EVENT(),
        ANIMATION_COMPLETE: require_ANIMATION_COMPLETE_EVENT(),
        ANIMATION_COMPLETE_KEY: require_ANIMATION_COMPLETE_KEY_EVENT(),
        ANIMATION_REPEAT: require_ANIMATION_REPEAT_EVENT(),
        ANIMATION_RESTART: require_ANIMATION_RESTART_EVENT(),
        ANIMATION_START: require_ANIMATION_START_EVENT(),
        ANIMATION_STOP: require_ANIMATION_STOP_EVENT(),
        ANIMATION_UPDATE: require_ANIMATION_UPDATE_EVENT(),
        PAUSE_ALL: require_PAUSE_ALL_EVENT(),
        REMOVE_ANIMATION: require_REMOVE_ANIMATION_EVENT(),
        RESUME_ALL: require_RESUME_ALL_EVENT()
      };
    }
  });

  // ../../node_modules/phaser/src/utils/array/FindClosestInSorted.js
  var require_FindClosestInSorted = __commonJS({
    "../../node_modules/phaser/src/utils/array/FindClosestInSorted.js": function(exports, module) {
      var FindClosestInSorted = function(value, array, key) {
        if (!array.length) {
          return NaN;
        } else if (array.length === 1) {
          return array[0];
        }
        var i = 1;
        var low;
        var high;
        if (key) {
          if (value < array[0][key]) {
            return array[0];
          }
          while (array[i][key] < value) {
            i++;
          }
        } else {
          while (array[i] < value) {
            i++;
          }
        }
        if (i > array.length) {
          i = array.length;
        }
        if (key) {
          low = array[i - 1][key];
          high = array[i][key];
          return high - value <= value - low ? array[i] : array[i - 1];
        } else {
          low = array[i - 1];
          high = array[i];
          return high - value <= value - low ? high : low;
        }
      };
      module.exports = FindClosestInSorted;
    }
  });

  // ../../node_modules/phaser/src/animations/AnimationFrame.js
  var require_AnimationFrame = __commonJS({
    "../../node_modules/phaser/src/animations/AnimationFrame.js": function(exports, module) {
      var Class = require_Class();
      var AnimationFrame = new Class({
        initialize: function AnimationFrame2(textureKey, textureFrame, index, frame, isKeyFrame) {
          if (isKeyFrame === void 0) {
            isKeyFrame = false;
          }
          this.textureKey = textureKey;
          this.textureFrame = textureFrame;
          this.index = index;
          this.frame = frame;
          this.isFirst = false;
          this.isLast = false;
          this.prevFrame = null;
          this.nextFrame = null;
          this.duration = 0;
          this.progress = 0;
          this.isKeyFrame = isKeyFrame;
        },
        toJSON: function() {
          return {
            key: this.textureKey,
            frame: this.textureFrame,
            duration: this.duration,
            keyframe: this.isKeyFrame
          };
        },
        destroy: function() {
          this.frame = void 0;
        }
      });
      module.exports = AnimationFrame;
    }
  });

  // ../../node_modules/phaser/src/utils/array/SortByDigits.js
  var require_SortByDigits = __commonJS({
    "../../node_modules/phaser/src/utils/array/SortByDigits.js": function(exports, module) {
      var SortByDigits = function(array) {
        var re = /\D/g;
        array.sort(function(a, b) {
          return parseInt(a.replace(re, ""), 10) - parseInt(b.replace(re, ""), 10);
        });
        return array;
      };
      module.exports = SortByDigits;
    }
  });

  // ../../node_modules/phaser/src/animations/Animation.js
  var require_Animation = __commonJS({
    "../../node_modules/phaser/src/animations/Animation.js": function(exports, module) {
      var Clamp = require_Clamp();
      var Class = require_Class();
      var Events = require_events12();
      var FindClosestInSorted = require_FindClosestInSorted();
      var Frame = require_AnimationFrame();
      var GetValue = require_GetValue();
      var SortByDigits = require_SortByDigits();
      var Animation = new Class({
        initialize: function Animation2(manager, key, config) {
          this.manager = manager;
          this.key = key;
          this.type = "frame";
          this.frames = this.getFrames(manager.textureManager, GetValue(config, "frames", []), GetValue(config, "defaultTextureKey", null), GetValue(config, "sortFrames", true));
          this.frameRate = GetValue(config, "frameRate", null);
          this.duration = GetValue(config, "duration", null);
          this.msPerFrame;
          this.skipMissedFrames = GetValue(config, "skipMissedFrames", true);
          this.delay = GetValue(config, "delay", 0);
          this.repeat = GetValue(config, "repeat", 0);
          this.repeatDelay = GetValue(config, "repeatDelay", 0);
          this.yoyo = GetValue(config, "yoyo", false);
          this.showBeforeDelay = GetValue(config, "showBeforeDelay", false);
          this.showOnStart = GetValue(config, "showOnStart", false);
          this.hideOnComplete = GetValue(config, "hideOnComplete", false);
          this.paused = false;
          this.calculateDuration(this, this.getTotalFrames(), this.duration, this.frameRate);
          if (this.manager.on) {
            this.manager.on(Events.PAUSE_ALL, this.pause, this);
            this.manager.on(Events.RESUME_ALL, this.resume, this);
          }
        },
        getTotalFrames: function() {
          return this.frames.length;
        },
        calculateDuration: function(target, totalFrames, duration, frameRate) {
          if (duration === null && frameRate === null) {
            target.frameRate = 24;
            target.duration = 24 / totalFrames * 1e3;
          } else if (duration && frameRate === null) {
            target.duration = duration;
            target.frameRate = totalFrames / (duration / 1e3);
          } else {
            target.frameRate = frameRate;
            target.duration = totalFrames / frameRate * 1e3;
          }
          target.msPerFrame = 1e3 / target.frameRate;
        },
        addFrame: function(config) {
          return this.addFrameAt(this.frames.length, config);
        },
        addFrameAt: function(index, config) {
          var newFrames = this.getFrames(this.manager.textureManager, config);
          if (newFrames.length > 0) {
            if (index === 0) {
              this.frames = newFrames.concat(this.frames);
            } else if (index === this.frames.length) {
              this.frames = this.frames.concat(newFrames);
            } else {
              var pre = this.frames.slice(0, index);
              var post = this.frames.slice(index);
              this.frames = pre.concat(newFrames, post);
            }
            this.updateFrameSequence();
          }
          return this;
        },
        checkFrame: function(index) {
          return index >= 0 && index < this.frames.length;
        },
        getFirstTick: function(state) {
          state.accumulator = 0;
          state.nextTick = state.msPerFrame + state.currentFrame.duration;
        },
        getFrameAt: function(index) {
          return this.frames[index];
        },
        getFrames: function(textureManager, frames, defaultTextureKey, sortFrames) {
          if (sortFrames === void 0) {
            sortFrames = true;
          }
          var out = [];
          var prev;
          var animationFrame;
          var index = 1;
          var i;
          var textureKey;
          if (typeof frames === "string") {
            textureKey = frames;
            if (!textureManager.exists(textureKey)) {
              console.warn('Texture "%s" not found', textureKey);
              return out;
            }
            var texture = textureManager.get(textureKey);
            var frameKeys = texture.getFrameNames();
            if (sortFrames) {
              SortByDigits(frameKeys);
            }
            frames = [];
            frameKeys.forEach(function(value) {
              frames.push({ key: textureKey, frame: value });
            });
          }
          if (!Array.isArray(frames) || frames.length === 0) {
            return out;
          }
          for (i = 0; i < frames.length; i++) {
            var item = frames[i];
            var key = GetValue(item, "key", defaultTextureKey);
            if (!key) {
              continue;
            }
            var frame = GetValue(item, "frame", 0);
            var textureFrame = textureManager.getFrame(key, frame);
            if (!textureFrame) {
              console.warn('Texture "%s" not found', key);
              continue;
            }
            animationFrame = new Frame(key, frame, index, textureFrame);
            animationFrame.duration = GetValue(item, "duration", 0);
            animationFrame.isFirst = !prev;
            if (prev) {
              prev.nextFrame = animationFrame;
              animationFrame.prevFrame = prev;
            }
            out.push(animationFrame);
            prev = animationFrame;
            index++;
          }
          if (out.length > 0) {
            animationFrame.isLast = true;
            animationFrame.nextFrame = out[0];
            out[0].prevFrame = animationFrame;
            var slice = 1 / (out.length - 1);
            for (i = 0; i < out.length; i++) {
              out[i].progress = i * slice;
            }
          }
          return out;
        },
        getNextTick: function(state) {
          state.accumulator -= state.nextTick;
          state.nextTick = state.msPerFrame + state.currentFrame.duration;
        },
        getFrameByProgress: function(value) {
          value = Clamp(value, 0, 1);
          return FindClosestInSorted(value, this.frames, "progress");
        },
        nextFrame: function(state) {
          var frame = state.currentFrame;
          if (frame.isLast) {
            if (state.yoyo) {
              this.handleYoyoFrame(state, false);
            } else if (state.repeatCounter > 0) {
              if (state.inReverse && state.forward) {
                state.forward = false;
              } else {
                this.repeatAnimation(state);
              }
            } else {
              state.complete();
            }
          } else {
            this.updateAndGetNextTick(state, frame.nextFrame);
          }
        },
        handleYoyoFrame: function(state, isReverse) {
          if (!isReverse) {
            isReverse = false;
          }
          if (state.inReverse === !isReverse && state.repeatCounter > 0) {
            if (state.repeatDelay === 0 || state.pendingRepeat) {
              state.forward = isReverse;
            }
            this.repeatAnimation(state);
            return;
          }
          if (state.inReverse !== isReverse && state.repeatCounter === 0) {
            state.complete();
            return;
          }
          state.forward = isReverse;
          var frame = isReverse ? state.currentFrame.nextFrame : state.currentFrame.prevFrame;
          this.updateAndGetNextTick(state, frame);
        },
        getLastFrame: function() {
          return this.frames[this.frames.length - 1];
        },
        previousFrame: function(state) {
          var frame = state.currentFrame;
          if (frame.isFirst) {
            if (state.yoyo) {
              this.handleYoyoFrame(state, true);
            } else if (state.repeatCounter > 0) {
              if (state.inReverse && !state.forward) {
                this.repeatAnimation(state);
              } else {
                state.forward = true;
                this.repeatAnimation(state);
              }
            } else {
              state.complete();
            }
          } else {
            this.updateAndGetNextTick(state, frame.prevFrame);
          }
        },
        updateAndGetNextTick: function(state, frame) {
          state.setCurrentFrame(frame);
          this.getNextTick(state);
        },
        removeFrame: function(frame) {
          var index = this.frames.indexOf(frame);
          if (index !== -1) {
            this.removeFrameAt(index);
          }
          return this;
        },
        removeFrameAt: function(index) {
          this.frames.splice(index, 1);
          this.updateFrameSequence();
          return this;
        },
        repeatAnimation: function(state) {
          if (state._pendingStop === 2) {
            if (state._pendingStopValue === 0) {
              return state.stop();
            } else {
              state._pendingStopValue--;
            }
          }
          if (state.repeatDelay > 0 && !state.pendingRepeat) {
            state.pendingRepeat = true;
            state.accumulator -= state.nextTick;
            state.nextTick += state.repeatDelay;
          } else {
            state.repeatCounter--;
            if (state.forward) {
              state.setCurrentFrame(state.currentFrame.nextFrame);
            } else {
              state.setCurrentFrame(state.currentFrame.prevFrame);
            }
            if (state.isPlaying) {
              this.getNextTick(state);
              state.handleRepeat();
            }
          }
        },
        toJSON: function() {
          var output = {
            key: this.key,
            type: this.type,
            frames: [],
            frameRate: this.frameRate,
            duration: this.duration,
            skipMissedFrames: this.skipMissedFrames,
            delay: this.delay,
            repeat: this.repeat,
            repeatDelay: this.repeatDelay,
            yoyo: this.yoyo,
            showBeforeDelay: this.showBeforeDelay,
            showOnStart: this.showOnStart,
            hideOnComplete: this.hideOnComplete
          };
          this.frames.forEach(function(frame) {
            output.frames.push(frame.toJSON());
          });
          return output;
        },
        updateFrameSequence: function() {
          var len = this.frames.length;
          var slice = 1 / (len - 1);
          var frame;
          for (var i = 0; i < len; i++) {
            frame = this.frames[i];
            frame.index = i + 1;
            frame.isFirst = false;
            frame.isLast = false;
            frame.progress = i * slice;
            if (i === 0) {
              frame.isFirst = true;
              if (len === 1) {
                frame.isLast = true;
                frame.nextFrame = frame;
                frame.prevFrame = frame;
              } else {
                frame.isLast = false;
                frame.prevFrame = this.frames[len - 1];
                frame.nextFrame = this.frames[i + 1];
              }
            } else if (i === len - 1 && len > 1) {
              frame.isLast = true;
              frame.prevFrame = this.frames[len - 2];
              frame.nextFrame = this.frames[0];
            } else if (len > 1) {
              frame.prevFrame = this.frames[i - 1];
              frame.nextFrame = this.frames[i + 1];
            }
          }
          return this;
        },
        pause: function() {
          this.paused = true;
          return this;
        },
        resume: function() {
          this.paused = false;
          return this;
        },
        destroy: function() {
          if (this.manager.off) {
            this.manager.off(Events.PAUSE_ALL, this.pause, this);
            this.manager.off(Events.RESUME_ALL, this.resume, this);
          }
          this.manager.remove(this.key);
          for (var i = 0; i < this.frames.length; i++) {
            this.frames[i].destroy();
          }
          this.frames = [];
          this.manager = null;
        }
      });
      module.exports = Animation;
    }
  });

  // ../../node_modules/phaser/src/utils/array/NumberArray.js
  var require_NumberArray = __commonJS({
    "../../node_modules/phaser/src/utils/array/NumberArray.js": function(exports, module) {
      var NumberArray = function(start, end, prefix, suffix) {
        var result = [];
        var i;
        var asString = false;
        if (prefix || suffix) {
          asString = true;
          if (!prefix) {
            prefix = "";
          }
          if (!suffix) {
            suffix = "";
          }
        }
        if (end < start) {
          for (i = start; i >= end; i--) {
            if (asString) {
              result.push(prefix + i.toString() + suffix);
            } else {
              result.push(i);
            }
          }
        } else {
          for (i = start; i <= end; i++) {
            if (asString) {
              result.push(prefix + i.toString() + suffix);
            } else {
              result.push(i);
            }
          }
        }
        return result;
      };
      module.exports = NumberArray;
    }
  });

  // ../../node_modules/phaser/src/utils/string/Pad.js
  var require_Pad = __commonJS({
    "../../node_modules/phaser/src/utils/string/Pad.js": function(exports, module) {
      var Pad = function(str, len, pad, dir) {
        if (len === void 0) {
          len = 0;
        }
        if (pad === void 0) {
          pad = " ";
        }
        if (dir === void 0) {
          dir = 3;
        }
        str = str.toString();
        var padlen = 0;
        if (len + 1 >= str.length) {
          switch (dir) {
            case 1:
              str = new Array(len + 1 - str.length).join(pad) + str;
              break;
            case 3:
              var right = Math.ceil((padlen = len - str.length) / 2);
              var left = padlen - right;
              str = new Array(left + 1).join(pad) + str + new Array(right + 1).join(pad);
              break;
            default:
              str = str + new Array(len + 1 - str.length).join(pad);
              break;
          }
        }
        return str;
      };
      module.exports = Pad;
    }
  });

  // ../../node_modules/phaser/src/animations/AnimationManager.js
  var require_AnimationManager = __commonJS({
    "../../node_modules/phaser/src/animations/AnimationManager.js": function(exports, module) {
      var Animation = require_Animation();
      var Class = require_Class();
      var CustomMap = require_Map();
      var EventEmitter = require_eventemitter3();
      var Events = require_events12();
      var GameEvents = require_events5();
      var GetFastValue = require_GetFastValue();
      var GetValue = require_GetValue();
      var MATH_CONST = require_const4();
      var NumberArray = require_NumberArray();
      var Pad = require_Pad();
      var AnimationManager = new Class({
        Extends: EventEmitter,
        initialize: function AnimationManager2(game) {
          EventEmitter.call(this);
          this.game = game;
          this.textureManager = null;
          this.globalTimeScale = 1;
          this.anims = new CustomMap();
          this.mixes = new CustomMap();
          this.paused = false;
          this.name = "AnimationManager";
          game.events.once(GameEvents.BOOT, this.boot, this);
        },
        boot: function() {
          this.textureManager = this.game.textures;
          this.game.events.once(GameEvents.DESTROY, this.destroy, this);
        },
        addMix: function(animA, animB, delay) {
          var anims = this.anims;
          var mixes = this.mixes;
          var keyA = typeof animA === "string" ? animA : animA.key;
          var keyB = typeof animB === "string" ? animB : animB.key;
          if (anims.has(keyA) && anims.has(keyB)) {
            var mixObj = mixes.get(keyA);
            if (!mixObj) {
              mixObj = {};
            }
            mixObj[keyB] = delay;
            mixes.set(keyA, mixObj);
          }
          return this;
        },
        removeMix: function(animA, animB) {
          var mixes = this.mixes;
          var keyA = typeof animA === "string" ? animA : animA.key;
          var mixObj = mixes.get(keyA);
          if (mixObj) {
            if (animB) {
              var keyB = typeof animB === "string" ? animB : animB.key;
              if (mixObj.hasOwnProperty(keyB)) {
                delete mixObj[keyB];
              }
            } else if (!animB) {
              mixes.delete(keyA);
            }
          }
          return this;
        },
        getMix: function(animA, animB) {
          var mixes = this.mixes;
          var keyA = typeof animA === "string" ? animA : animA.key;
          var keyB = typeof animB === "string" ? animB : animB.key;
          var mixObj = mixes.get(keyA);
          if (mixObj && mixObj.hasOwnProperty(keyB)) {
            return mixObj[keyB];
          } else {
            return 0;
          }
        },
        add: function(key, animation) {
          if (this.anims.has(key)) {
            console.warn("Animation key exists: " + key);
            return this;
          }
          animation.key = key;
          this.anims.set(key, animation);
          this.emit(Events.ADD_ANIMATION, key, animation);
          return this;
        },
        exists: function(key) {
          return this.anims.has(key);
        },
        createFromAseprite: function(key, tags, target) {
          var output = [];
          var data = this.game.cache.json.get(key);
          if (!data) {
            return output;
          }
          var _this = this;
          var meta = GetValue(data, "meta", null);
          var frames = GetValue(data, "frames", null);
          if (meta && frames) {
            var frameTags = GetValue(meta, "frameTags", []);
            frameTags.forEach(function(tag) {
              var animFrames = [];
              var name = GetFastValue(tag, "name", null);
              var from = GetFastValue(tag, "from", 0);
              var to = GetFastValue(tag, "to", 0);
              var direction = GetFastValue(tag, "direction", "forward");
              if (!name) {
                return;
              }
              if (!tags || tags && tags.indexOf(name) > -1) {
                var totalDuration = 0;
                for (var i = from; i <= to; i++) {
                  var frameKey = i.toString();
                  var frame = frames[frameKey];
                  if (frame) {
                    var frameDuration = GetFastValue(frame, "duration", MATH_CONST.MAX_SAFE_INTEGER);
                    animFrames.push({ key: key, frame: frameKey, duration: frameDuration });
                    totalDuration += frameDuration;
                  }
                }
                var msPerFrame = totalDuration / animFrames.length;
                animFrames.forEach(function(entry) {
                  entry.duration -= msPerFrame;
                });
                if (direction === "reverse") {
                  animFrames = animFrames.reverse();
                }
                var createConfig = {
                  key: name,
                  frames: animFrames,
                  duration: totalDuration,
                  yoyo: direction === "pingpong"
                };
                var result;
                if (target) {
                  if (target.anims) {
                    result = target.anims.create(createConfig);
                  }
                } else {
                  result = _this.create(createConfig);
                }
                if (result) {
                  output.push(result);
                }
              }
            });
          }
          return output;
        },
        create: function(config) {
          var key = config.key;
          var anim = false;
          if (key) {
            anim = this.get(key);
            if (!anim) {
              anim = new Animation(this, key, config);
              this.anims.set(key, anim);
              this.emit(Events.ADD_ANIMATION, key, anim);
            }
          }
          return anim;
        },
        fromJSON: function(data, clearCurrentAnimations) {
          if (clearCurrentAnimations === void 0) {
            clearCurrentAnimations = false;
          }
          if (clearCurrentAnimations) {
            this.anims.clear();
          }
          if (typeof data === "string") {
            data = JSON.parse(data);
          }
          var output = [];
          if (data.hasOwnProperty("anims") && Array.isArray(data.anims)) {
            for (var i = 0; i < data.anims.length; i++) {
              output.push(this.create(data.anims[i]));
            }
            if (data.hasOwnProperty("globalTimeScale")) {
              this.globalTimeScale = data.globalTimeScale;
            }
          } else if (data.hasOwnProperty("key") && data.type === "frame") {
            output.push(this.create(data));
          }
          return output;
        },
        generateFrameNames: function(key, config) {
          var prefix = GetValue(config, "prefix", "");
          var start = GetValue(config, "start", 0);
          var end = GetValue(config, "end", 0);
          var suffix = GetValue(config, "suffix", "");
          var zeroPad = GetValue(config, "zeroPad", 0);
          var out = GetValue(config, "outputArray", []);
          var frames = GetValue(config, "frames", false);
          if (!this.textureManager.exists(key)) {
            console.warn('Texture "%s" not found', key);
            return out;
          }
          var texture = this.textureManager.get(key);
          if (!texture) {
            return out;
          }
          var i;
          if (!config) {
            frames = texture.getFrameNames();
            for (i = 0; i < frames.length; i++) {
              out.push({ key: key, frame: frames[i] });
            }
          } else {
            if (!frames) {
              frames = NumberArray(start, end);
            }
            for (i = 0; i < frames.length; i++) {
              var frame = prefix + Pad(frames[i], zeroPad, "0", 1) + suffix;
              if (texture.has(frame)) {
                out.push({ key: key, frame: frame });
              } else {
                console.warn('Frame "%s" not found in texture "%s"', frame, key);
              }
            }
          }
          return out;
        },
        generateFrameNumbers: function(key, config) {
          var start = GetValue(config, "start", 0);
          var end = GetValue(config, "end", -1);
          var first = GetValue(config, "first", false);
          var out = GetValue(config, "outputArray", []);
          var frames = GetValue(config, "frames", false);
          if (!this.textureManager.exists(key)) {
            console.warn('Texture "%s" not found', key);
            return out;
          }
          var texture = this.textureManager.get(key);
          if (!texture) {
            return out;
          }
          if (first && texture.has(first)) {
            out.push({ key: key, frame: first });
          }
          if (!frames) {
            if (end === -1) {
              end = texture.frameTotal - 2;
            }
            frames = NumberArray(start, end);
          }
          for (var i = 0; i < frames.length; i++) {
            var frameName = frames[i];
            if (texture.has(frameName)) {
              out.push({ key: key, frame: frameName });
            } else {
              console.warn('Frame "%s" not found in texture "%s"', frameName, key);
            }
          }
          return out;
        },
        get: function(key) {
          return this.anims.get(key);
        },
        getAnimsFromTexture: function(key) {
          var texture = this.textureManager.get(key);
          var match = texture.key;
          var anims = this.anims.getArray();
          var out = [];
          for (var i = 0; i < anims.length; i++) {
            var anim = anims[i];
            var frames = anim.frames;
            for (var c = 0; c < frames.length; c++) {
              if (frames[c].textureKey === match) {
                out.push(anim.key);
                break;
              }
            }
          }
          return out;
        },
        pauseAll: function() {
          if (!this.paused) {
            this.paused = true;
            this.emit(Events.PAUSE_ALL);
          }
          return this;
        },
        play: function(key, children) {
          if (!Array.isArray(children)) {
            children = [children];
          }
          for (var i = 0; i < children.length; i++) {
            children[i].anims.play(key);
          }
          return this;
        },
        staggerPlay: function(key, children, stagger, staggerFirst) {
          if (stagger === void 0) {
            stagger = 0;
          }
          if (staggerFirst === void 0) {
            staggerFirst = true;
          }
          if (!Array.isArray(children)) {
            children = [children];
          }
          var len = children.length;
          if (!staggerFirst) {
            len--;
          }
          for (var i = 0; i < children.length; i++) {
            var time = stagger < 0 ? Math.abs(stagger) * (len - i) : stagger * i;
            children[i].anims.playAfterDelay(key, time);
          }
          return this;
        },
        remove: function(key) {
          var anim = this.get(key);
          if (anim) {
            this.emit(Events.REMOVE_ANIMATION, key, anim);
            this.anims.delete(key);
            this.removeMix(key);
          }
          return anim;
        },
        resumeAll: function() {
          if (this.paused) {
            this.paused = false;
            this.emit(Events.RESUME_ALL);
          }
          return this;
        },
        toJSON: function(key) {
          var output = {
            anims: [],
            globalTimeScale: this.globalTimeScale
          };
          if (key !== void 0 && key !== "") {
            output.anims.push(this.anims.get(key).toJSON());
          } else {
            this.anims.each(function(animationKey, animation) {
              output.anims.push(animation.toJSON());
            });
          }
          return output;
        },
        destroy: function() {
          this.anims.clear();
          this.mixes.clear();
          this.textureManager = null;
          this.game = null;
        }
      });
      module.exports = AnimationManager;
    }
  });

  // ../../node_modules/phaser/src/dom/CreateDOMContainer.js
  var require_CreateDOMContainer = __commonJS({
    "../../node_modules/phaser/src/dom/CreateDOMContainer.js": function(exports, module) {
      var AddToDOM = require_AddToDOM();
      var CreateDOMContainer = function(game) {
        var config = game.config;
        if (!config.parent || !config.domCreateContainer) {
          return;
        }
        var div = document.createElement("div");
        div.style.cssText = [
          "display: block;",
          "width: " + game.scale.width + "px;",
          "height: " + game.scale.height + "px;",
          "padding: 0; margin: 0;",
          "position: absolute;",
          "overflow: hidden;",
          "pointer-events: " + config.domPointerEvents + ";",
          "transform: scale(1);",
          "transform-origin: left top;"
        ].join(" ");
        game.domContainer = div;
        AddToDOM(div, config.parent);
      };
      module.exports = CreateDOMContainer;
    }
  });

  // ../../node_modules/phaser/src/dom/DOMContentLoaded.js
  var require_DOMContentLoaded = __commonJS({
    "../../node_modules/phaser/src/dom/DOMContentLoaded.js": function(exports, module) {
      var OS = require_OS();
      var DOMContentLoaded = function(callback) {
        if (document.readyState === "complete" || document.readyState === "interactive") {
          callback();
          return;
        }
        var check = function() {
          document.removeEventListener("deviceready", check, true);
          document.removeEventListener("DOMContentLoaded", check, true);
          window.removeEventListener("load", check, true);
          callback();
        };
        if (!document.body) {
          window.setTimeout(check, 20);
        } else if (OS.cordova) {
          document.addEventListener("deviceready", check, false);
        } else {
          document.addEventListener("DOMContentLoaded", check, true);
          window.addEventListener("load", check, true);
        }
      };
      module.exports = DOMContentLoaded;
    }
  });

  // ../../node_modules/phaser/src/input/const.js
  var require_const8 = __commonJS({
    "../../node_modules/phaser/src/input/const.js": function(exports, module) {
      var INPUT_CONST = {
        MOUSE_DOWN: 0,
        MOUSE_MOVE: 1,
        MOUSE_UP: 2,
        TOUCH_START: 3,
        TOUCH_MOVE: 4,
        TOUCH_END: 5,
        POINTER_LOCK_CHANGE: 6,
        TOUCH_CANCEL: 7,
        MOUSE_WHEEL: 8
      };
      module.exports = INPUT_CONST;
    }
  });

  // ../../node_modules/phaser/src/input/events/BOOT_EVENT.js
  var require_BOOT_EVENT4 = __commonJS({
    "../../node_modules/phaser/src/input/events/BOOT_EVENT.js": function(exports, module) {
      module.exports = "boot";
    }
  });

  // ../../node_modules/phaser/src/input/events/DESTROY_EVENT.js
  var require_DESTROY_EVENT7 = __commonJS({
    "../../node_modules/phaser/src/input/events/DESTROY_EVENT.js": function(exports, module) {
      module.exports = "destroy";
    }
  });

  // ../../node_modules/phaser/src/input/events/DRAG_END_EVENT.js
  var require_DRAG_END_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/DRAG_END_EVENT.js": function(exports, module) {
      module.exports = "dragend";
    }
  });

  // ../../node_modules/phaser/src/input/events/DRAG_ENTER_EVENT.js
  var require_DRAG_ENTER_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/DRAG_ENTER_EVENT.js": function(exports, module) {
      module.exports = "dragenter";
    }
  });

  // ../../node_modules/phaser/src/input/events/DRAG_EVENT.js
  var require_DRAG_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/DRAG_EVENT.js": function(exports, module) {
      module.exports = "drag";
    }
  });

  // ../../node_modules/phaser/src/input/events/DRAG_LEAVE_EVENT.js
  var require_DRAG_LEAVE_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/DRAG_LEAVE_EVENT.js": function(exports, module) {
      module.exports = "dragleave";
    }
  });

  // ../../node_modules/phaser/src/input/events/DRAG_OVER_EVENT.js
  var require_DRAG_OVER_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/DRAG_OVER_EVENT.js": function(exports, module) {
      module.exports = "dragover";
    }
  });

  // ../../node_modules/phaser/src/input/events/DRAG_START_EVENT.js
  var require_DRAG_START_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/DRAG_START_EVENT.js": function(exports, module) {
      module.exports = "dragstart";
    }
  });

  // ../../node_modules/phaser/src/input/events/DROP_EVENT.js
  var require_DROP_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/DROP_EVENT.js": function(exports, module) {
      module.exports = "drop";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAME_OUT_EVENT.js
  var require_GAME_OUT_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAME_OUT_EVENT.js": function(exports, module) {
      module.exports = "gameout";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAME_OVER_EVENT.js
  var require_GAME_OVER_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAME_OVER_EVENT.js": function(exports, module) {
      module.exports = "gameover";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_DOWN_EVENT.js
  var require_GAMEOBJECT_DOWN_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_DOWN_EVENT.js": function(exports, module) {
      module.exports = "gameobjectdown";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_DRAG_END_EVENT.js
  var require_GAMEOBJECT_DRAG_END_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_DRAG_END_EVENT.js": function(exports, module) {
      module.exports = "dragend";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_DRAG_ENTER_EVENT.js
  var require_GAMEOBJECT_DRAG_ENTER_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_DRAG_ENTER_EVENT.js": function(exports, module) {
      module.exports = "dragenter";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_DRAG_EVENT.js
  var require_GAMEOBJECT_DRAG_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_DRAG_EVENT.js": function(exports, module) {
      module.exports = "drag";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_DRAG_LEAVE_EVENT.js
  var require_GAMEOBJECT_DRAG_LEAVE_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_DRAG_LEAVE_EVENT.js": function(exports, module) {
      module.exports = "dragleave";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_DRAG_OVER_EVENT.js
  var require_GAMEOBJECT_DRAG_OVER_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_DRAG_OVER_EVENT.js": function(exports, module) {
      module.exports = "dragover";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_DRAG_START_EVENT.js
  var require_GAMEOBJECT_DRAG_START_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_DRAG_START_EVENT.js": function(exports, module) {
      module.exports = "dragstart";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_DROP_EVENT.js
  var require_GAMEOBJECT_DROP_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_DROP_EVENT.js": function(exports, module) {
      module.exports = "drop";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_MOVE_EVENT.js
  var require_GAMEOBJECT_MOVE_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_MOVE_EVENT.js": function(exports, module) {
      module.exports = "gameobjectmove";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_OUT_EVENT.js
  var require_GAMEOBJECT_OUT_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_OUT_EVENT.js": function(exports, module) {
      module.exports = "gameobjectout";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_OVER_EVENT.js
  var require_GAMEOBJECT_OVER_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_OVER_EVENT.js": function(exports, module) {
      module.exports = "gameobjectover";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_POINTER_DOWN_EVENT.js
  var require_GAMEOBJECT_POINTER_DOWN_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_POINTER_DOWN_EVENT.js": function(exports, module) {
      module.exports = "pointerdown";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_POINTER_MOVE_EVENT.js
  var require_GAMEOBJECT_POINTER_MOVE_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_POINTER_MOVE_EVENT.js": function(exports, module) {
      module.exports = "pointermove";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_POINTER_OUT_EVENT.js
  var require_GAMEOBJECT_POINTER_OUT_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_POINTER_OUT_EVENT.js": function(exports, module) {
      module.exports = "pointerout";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_POINTER_OVER_EVENT.js
  var require_GAMEOBJECT_POINTER_OVER_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_POINTER_OVER_EVENT.js": function(exports, module) {
      module.exports = "pointerover";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_POINTER_UP_EVENT.js
  var require_GAMEOBJECT_POINTER_UP_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_POINTER_UP_EVENT.js": function(exports, module) {
      module.exports = "pointerup";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_POINTER_WHEEL_EVENT.js
  var require_GAMEOBJECT_POINTER_WHEEL_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_POINTER_WHEEL_EVENT.js": function(exports, module) {
      module.exports = "wheel";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_UP_EVENT.js
  var require_GAMEOBJECT_UP_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_UP_EVENT.js": function(exports, module) {
      module.exports = "gameobjectup";
    }
  });

  // ../../node_modules/phaser/src/input/events/GAMEOBJECT_WHEEL_EVENT.js
  var require_GAMEOBJECT_WHEEL_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/GAMEOBJECT_WHEEL_EVENT.js": function(exports, module) {
      module.exports = "gameobjectwheel";
    }
  });

  // ../../node_modules/phaser/src/input/events/MANAGER_BOOT_EVENT.js
  var require_MANAGER_BOOT_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/MANAGER_BOOT_EVENT.js": function(exports, module) {
      module.exports = "boot";
    }
  });

  // ../../node_modules/phaser/src/input/events/MANAGER_PROCESS_EVENT.js
  var require_MANAGER_PROCESS_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/MANAGER_PROCESS_EVENT.js": function(exports, module) {
      module.exports = "process";
    }
  });

  // ../../node_modules/phaser/src/input/events/MANAGER_UPDATE_EVENT.js
  var require_MANAGER_UPDATE_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/MANAGER_UPDATE_EVENT.js": function(exports, module) {
      module.exports = "update";
    }
  });

  // ../../node_modules/phaser/src/input/events/POINTER_DOWN_EVENT.js
  var require_POINTER_DOWN_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/POINTER_DOWN_EVENT.js": function(exports, module) {
      module.exports = "pointerdown";
    }
  });

  // ../../node_modules/phaser/src/input/events/POINTER_DOWN_OUTSIDE_EVENT.js
  var require_POINTER_DOWN_OUTSIDE_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/POINTER_DOWN_OUTSIDE_EVENT.js": function(exports, module) {
      module.exports = "pointerdownoutside";
    }
  });

  // ../../node_modules/phaser/src/input/events/POINTER_MOVE_EVENT.js
  var require_POINTER_MOVE_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/POINTER_MOVE_EVENT.js": function(exports, module) {
      module.exports = "pointermove";
    }
  });

  // ../../node_modules/phaser/src/input/events/POINTER_OUT_EVENT.js
  var require_POINTER_OUT_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/POINTER_OUT_EVENT.js": function(exports, module) {
      module.exports = "pointerout";
    }
  });

  // ../../node_modules/phaser/src/input/events/POINTER_OVER_EVENT.js
  var require_POINTER_OVER_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/POINTER_OVER_EVENT.js": function(exports, module) {
      module.exports = "pointerover";
    }
  });

  // ../../node_modules/phaser/src/input/events/POINTER_UP_EVENT.js
  var require_POINTER_UP_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/POINTER_UP_EVENT.js": function(exports, module) {
      module.exports = "pointerup";
    }
  });

  // ../../node_modules/phaser/src/input/events/POINTER_UP_OUTSIDE_EVENT.js
  var require_POINTER_UP_OUTSIDE_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/POINTER_UP_OUTSIDE_EVENT.js": function(exports, module) {
      module.exports = "pointerupoutside";
    }
  });

  // ../../node_modules/phaser/src/input/events/POINTER_WHEEL_EVENT.js
  var require_POINTER_WHEEL_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/POINTER_WHEEL_EVENT.js": function(exports, module) {
      module.exports = "wheel";
    }
  });

  // ../../node_modules/phaser/src/input/events/POINTERLOCK_CHANGE_EVENT.js
  var require_POINTERLOCK_CHANGE_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/events/POINTERLOCK_CHANGE_EVENT.js": function(exports, module) {
      module.exports = "pointerlockchange";
    }
  });

  // ../../node_modules/phaser/src/input/events/PRE_UPDATE_EVENT.js
  var require_PRE_UPDATE_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/input/events/PRE_UPDATE_EVENT.js": function(exports, module) {
      module.exports = "preupdate";
    }
  });

  // ../../node_modules/phaser/src/input/events/SHUTDOWN_EVENT.js
  var require_SHUTDOWN_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/input/events/SHUTDOWN_EVENT.js": function(exports, module) {
      module.exports = "shutdown";
    }
  });

  // ../../node_modules/phaser/src/input/events/START_EVENT.js
  var require_START_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/input/events/START_EVENT.js": function(exports, module) {
      module.exports = "start";
    }
  });

  // ../../node_modules/phaser/src/input/events/UPDATE_EVENT.js
  var require_UPDATE_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/input/events/UPDATE_EVENT.js": function(exports, module) {
      module.exports = "update";
    }
  });

  // ../../node_modules/phaser/src/input/events/index.js
  var require_events13 = __commonJS({
    "../../node_modules/phaser/src/input/events/index.js": function(exports, module) {
      module.exports = {
        BOOT: require_BOOT_EVENT4(),
        DESTROY: require_DESTROY_EVENT7(),
        DRAG_END: require_DRAG_END_EVENT(),
        DRAG_ENTER: require_DRAG_ENTER_EVENT(),
        DRAG: require_DRAG_EVENT(),
        DRAG_LEAVE: require_DRAG_LEAVE_EVENT(),
        DRAG_OVER: require_DRAG_OVER_EVENT(),
        DRAG_START: require_DRAG_START_EVENT(),
        DROP: require_DROP_EVENT(),
        GAME_OUT: require_GAME_OUT_EVENT(),
        GAME_OVER: require_GAME_OVER_EVENT(),
        GAMEOBJECT_DOWN: require_GAMEOBJECT_DOWN_EVENT(),
        GAMEOBJECT_DRAG_END: require_GAMEOBJECT_DRAG_END_EVENT(),
        GAMEOBJECT_DRAG_ENTER: require_GAMEOBJECT_DRAG_ENTER_EVENT(),
        GAMEOBJECT_DRAG: require_GAMEOBJECT_DRAG_EVENT(),
        GAMEOBJECT_DRAG_LEAVE: require_GAMEOBJECT_DRAG_LEAVE_EVENT(),
        GAMEOBJECT_DRAG_OVER: require_GAMEOBJECT_DRAG_OVER_EVENT(),
        GAMEOBJECT_DRAG_START: require_GAMEOBJECT_DRAG_START_EVENT(),
        GAMEOBJECT_DROP: require_GAMEOBJECT_DROP_EVENT(),
        GAMEOBJECT_MOVE: require_GAMEOBJECT_MOVE_EVENT(),
        GAMEOBJECT_OUT: require_GAMEOBJECT_OUT_EVENT(),
        GAMEOBJECT_OVER: require_GAMEOBJECT_OVER_EVENT(),
        GAMEOBJECT_POINTER_DOWN: require_GAMEOBJECT_POINTER_DOWN_EVENT(),
        GAMEOBJECT_POINTER_MOVE: require_GAMEOBJECT_POINTER_MOVE_EVENT(),
        GAMEOBJECT_POINTER_OUT: require_GAMEOBJECT_POINTER_OUT_EVENT(),
        GAMEOBJECT_POINTER_OVER: require_GAMEOBJECT_POINTER_OVER_EVENT(),
        GAMEOBJECT_POINTER_UP: require_GAMEOBJECT_POINTER_UP_EVENT(),
        GAMEOBJECT_POINTER_WHEEL: require_GAMEOBJECT_POINTER_WHEEL_EVENT(),
        GAMEOBJECT_UP: require_GAMEOBJECT_UP_EVENT(),
        GAMEOBJECT_WHEEL: require_GAMEOBJECT_WHEEL_EVENT(),
        MANAGER_BOOT: require_MANAGER_BOOT_EVENT(),
        MANAGER_PROCESS: require_MANAGER_PROCESS_EVENT(),
        MANAGER_UPDATE: require_MANAGER_UPDATE_EVENT(),
        POINTER_DOWN: require_POINTER_DOWN_EVENT(),
        POINTER_DOWN_OUTSIDE: require_POINTER_DOWN_OUTSIDE_EVENT(),
        POINTER_MOVE: require_POINTER_MOVE_EVENT(),
        POINTER_OUT: require_POINTER_OUT_EVENT(),
        POINTER_OVER: require_POINTER_OVER_EVENT(),
        POINTER_UP: require_POINTER_UP_EVENT(),
        POINTER_UP_OUTSIDE: require_POINTER_UP_OUTSIDE_EVENT(),
        POINTER_WHEEL: require_POINTER_WHEEL_EVENT(),
        POINTERLOCK_CHANGE: require_POINTERLOCK_CHANGE_EVENT(),
        PRE_UPDATE: require_PRE_UPDATE_EVENT2(),
        SHUTDOWN: require_SHUTDOWN_EVENT2(),
        START: require_START_EVENT2(),
        UPDATE: require_UPDATE_EVENT2()
      };
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/keys/KeyCodes.js
  var require_KeyCodes = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/keys/KeyCodes.js": function(exports, module) {
      var KeyCodes = {
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        PAUSE: 19,
        CAPS_LOCK: 20,
        ESC: 27,
        SPACE: 32,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        PRINT_SCREEN: 42,
        INSERT: 45,
        DELETE: 46,
        ZERO: 48,
        ONE: 49,
        TWO: 50,
        THREE: 51,
        FOUR: 52,
        FIVE: 53,
        SIX: 54,
        SEVEN: 55,
        EIGHT: 56,
        NINE: 57,
        NUMPAD_ZERO: 96,
        NUMPAD_ONE: 97,
        NUMPAD_TWO: 98,
        NUMPAD_THREE: 99,
        NUMPAD_FOUR: 100,
        NUMPAD_FIVE: 101,
        NUMPAD_SIX: 102,
        NUMPAD_SEVEN: 103,
        NUMPAD_EIGHT: 104,
        NUMPAD_NINE: 105,
        NUMPAD_ADD: 107,
        NUMPAD_SUBTRACT: 109,
        A: 65,
        B: 66,
        C: 67,
        D: 68,
        E: 69,
        F: 70,
        G: 71,
        H: 72,
        I: 73,
        J: 74,
        K: 75,
        L: 76,
        M: 77,
        N: 78,
        O: 79,
        P: 80,
        Q: 81,
        R: 82,
        S: 83,
        T: 84,
        U: 85,
        V: 86,
        W: 87,
        X: 88,
        Y: 89,
        Z: 90,
        F1: 112,
        F2: 113,
        F3: 114,
        F4: 115,
        F5: 116,
        F6: 117,
        F7: 118,
        F8: 119,
        F9: 120,
        F10: 121,
        F11: 122,
        F12: 123,
        SEMICOLON: 186,
        PLUS: 187,
        COMMA: 188,
        MINUS: 189,
        PERIOD: 190,
        FORWARD_SLASH: 191,
        BACK_SLASH: 220,
        QUOTES: 222,
        BACKTICK: 192,
        OPEN_BRACKET: 219,
        CLOSED_BRACKET: 221,
        SEMICOLON_FIREFOX: 59,
        COLON: 58,
        COMMA_FIREFOX_WINDOWS: 60,
        COMMA_FIREFOX: 62,
        BRACKET_RIGHT_FIREFOX: 174,
        BRACKET_LEFT_FIREFOX: 175
      };
      module.exports = KeyCodes;
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/KeyboardManager.js
  var require_KeyboardManager = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/KeyboardManager.js": function(exports, module) {
      var ArrayRemove = require_Remove();
      var Class = require_Class();
      var GameEvents = require_events5();
      var InputEvents = require_events13();
      var KeyCodes = require_KeyCodes();
      var NOOP = require_NOOP();
      var KeyboardManager = new Class({
        initialize: function KeyboardManager2(inputManager) {
          this.manager = inputManager;
          this.queue = [];
          this.preventDefault = true;
          this.captures = [];
          this.enabled = false;
          this.target;
          this.onKeyDown = NOOP;
          this.onKeyUp = NOOP;
          inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
        },
        boot: function() {
          var config = this.manager.config;
          this.enabled = config.inputKeyboard;
          this.target = config.inputKeyboardEventTarget;
          this.addCapture(config.inputKeyboardCapture);
          if (!this.target && window) {
            this.target = window;
          }
          if (this.enabled && this.target) {
            this.startListeners();
          }
          this.manager.game.events.on(GameEvents.POST_STEP, this.postUpdate, this);
        },
        startListeners: function() {
          var _this = this;
          this.onKeyDown = function(event) {
            if (event.defaultPrevented || !_this.enabled || !_this.manager) {
              return;
            }
            _this.queue.push(event);
            _this.manager.events.emit(InputEvents.MANAGER_PROCESS);
            var modified = event.altKey || event.ctrlKey || event.shiftKey || event.metaKey;
            if (_this.preventDefault && !modified && _this.captures.indexOf(event.keyCode) > -1) {
              event.preventDefault();
            }
          };
          this.onKeyUp = function(event) {
            if (event.defaultPrevented || !_this.enabled || !_this.manager) {
              return;
            }
            _this.queue.push(event);
            _this.manager.events.emit(InputEvents.MANAGER_PROCESS);
            var modified = event.altKey || event.ctrlKey || event.shiftKey || event.metaKey;
            if (_this.preventDefault && !modified && _this.captures.indexOf(event.keyCode) > -1) {
              event.preventDefault();
            }
          };
          var target = this.target;
          if (target) {
            target.addEventListener("keydown", this.onKeyDown, false);
            target.addEventListener("keyup", this.onKeyUp, false);
            this.enabled = true;
          }
        },
        stopListeners: function() {
          var target = this.target;
          target.removeEventListener("keydown", this.onKeyDown, false);
          target.removeEventListener("keyup", this.onKeyUp, false);
          this.enabled = false;
        },
        postUpdate: function() {
          this.queue = [];
        },
        addCapture: function(keycode) {
          if (typeof keycode === "string") {
            keycode = keycode.split(",");
          }
          if (!Array.isArray(keycode)) {
            keycode = [keycode];
          }
          var captures = this.captures;
          for (var i = 0; i < keycode.length; i++) {
            var code = keycode[i];
            if (typeof code === "string") {
              code = KeyCodes[code.trim().toUpperCase()];
            }
            if (captures.indexOf(code) === -1) {
              captures.push(code);
            }
          }
          this.preventDefault = captures.length > 0;
        },
        removeCapture: function(keycode) {
          if (typeof keycode === "string") {
            keycode = keycode.split(",");
          }
          if (!Array.isArray(keycode)) {
            keycode = [keycode];
          }
          var captures = this.captures;
          for (var i = 0; i < keycode.length; i++) {
            var code = keycode[i];
            if (typeof code === "string") {
              code = KeyCodes[code.toUpperCase()];
            }
            ArrayRemove(captures, code);
          }
          this.preventDefault = captures.length > 0;
        },
        clearCaptures: function() {
          this.captures = [];
          this.preventDefault = false;
        },
        destroy: function() {
          this.stopListeners();
          this.clearCaptures();
          this.queue = [];
          this.manager.game.events.off(GameEvents.POST_RENDER, this.postUpdate, this);
          this.target = null;
          this.enabled = false;
          this.manager = null;
        }
      });
      module.exports = KeyboardManager;
    }
  });

  // ../../node_modules/phaser/src/input/mouse/MouseManager.js
  var require_MouseManager = __commonJS({
    "../../node_modules/phaser/src/input/mouse/MouseManager.js": function(exports, module) {
      var Class = require_Class();
      var Features = require_Features();
      var InputEvents = require_events13();
      var NOOP = require_NOOP();
      var MouseManager = new Class({
        initialize: function MouseManager2(inputManager) {
          this.manager = inputManager;
          this.preventDefaultDown = true;
          this.preventDefaultUp = true;
          this.preventDefaultMove = true;
          this.preventDefaultWheel = false;
          this.enabled = false;
          this.target;
          this.locked = false;
          this.onMouseMove = NOOP;
          this.onMouseDown = NOOP;
          this.onMouseUp = NOOP;
          this.onMouseDownWindow = NOOP;
          this.onMouseUpWindow = NOOP;
          this.onMouseOver = NOOP;
          this.onMouseOut = NOOP;
          this.onMouseWheel = NOOP;
          this.pointerLockChange = NOOP;
          this.isTop = true;
          inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
        },
        boot: function() {
          var config = this.manager.config;
          this.enabled = config.inputMouse;
          this.target = config.inputMouseEventTarget;
          this.passive = config.inputMousePassive;
          this.preventDefaultDown = config.inputMousePreventDefaultDown;
          this.preventDefaultUp = config.inputMousePreventDefaultUp;
          this.preventDefaultMove = config.inputMousePreventDefaultMove;
          this.preventDefaultWheel = config.inputMousePreventDefaultWheel;
          if (!this.target) {
            this.target = this.manager.game.canvas;
          } else if (typeof this.target === "string") {
            this.target = document.getElementById(this.target);
          }
          if (config.disableContextMenu) {
            this.disableContextMenu();
          }
          if (this.enabled && this.target) {
            this.startListeners();
          }
        },
        disableContextMenu: function() {
          this.target.addEventListener("contextmenu", function(event) {
            event.preventDefault();
            return false;
          });
          return this;
        },
        requestPointerLock: function() {
          if (Features.pointerLock) {
            var element = this.target;
            element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
            element.requestPointerLock();
          }
        },
        releasePointerLock: function() {
          if (Features.pointerLock) {
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
            document.exitPointerLock();
          }
        },
        startListeners: function() {
          var target = this.target;
          if (!target) {
            return;
          }
          var _this = this;
          var manager = this.manager;
          var canvas = manager.canvas;
          var autoFocus = window && window.focus && manager.game.config.autoFocus;
          this.onMouseMove = function(event) {
            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
              manager.onMouseMove(event);
              if (_this.preventDefaultMove) {
                event.preventDefault();
              }
            }
          };
          this.onMouseDown = function(event) {
            if (autoFocus) {
              window.focus();
            }
            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
              manager.onMouseDown(event);
              if (_this.preventDefaultDown && event.target === canvas) {
                event.preventDefault();
              }
            }
          };
          this.onMouseDownWindow = function(event) {
            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas) {
              manager.onMouseDown(event);
            }
          };
          this.onMouseUp = function(event) {
            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
              manager.onMouseUp(event);
              if (_this.preventDefaultUp && event.target === canvas) {
                event.preventDefault();
              }
            }
          };
          this.onMouseUpWindow = function(event) {
            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas) {
              manager.onMouseUp(event);
            }
          };
          this.onMouseOver = function(event) {
            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
              manager.setCanvasOver(event);
            }
          };
          this.onMouseOut = function(event) {
            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
              manager.setCanvasOut(event);
            }
          };
          this.onMouseWheel = function(event) {
            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
              manager.onMouseWheel(event);
            }
            if (_this.preventDefaultWheel && event.target === canvas) {
              event.preventDefault();
            }
          };
          var passive = { passive: true };
          target.addEventListener("mousemove", this.onMouseMove);
          target.addEventListener("mousedown", this.onMouseDown);
          target.addEventListener("mouseup", this.onMouseUp);
          target.addEventListener("mouseover", this.onMouseOver, passive);
          target.addEventListener("mouseout", this.onMouseOut, passive);
          if (this.preventDefaultWheel) {
            target.addEventListener("wheel", this.onMouseWheel, { passive: false });
          } else {
            target.addEventListener("wheel", this.onMouseWheel, passive);
          }
          if (window && manager.game.config.inputWindowEvents) {
            try {
              window.top.addEventListener("mousedown", this.onMouseDownWindow, passive);
              window.top.addEventListener("mouseup", this.onMouseUpWindow, passive);
            } catch (exception) {
              window.addEventListener("mousedown", this.onMouseDownWindow, passive);
              window.addEventListener("mouseup", this.onMouseUpWindow, passive);
              this.isTop = false;
            }
          }
          if (Features.pointerLock) {
            this.pointerLockChange = function(event) {
              var element = _this.target;
              _this.locked = document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ? true : false;
              manager.onPointerLockChange(event);
            };
            document.addEventListener("pointerlockchange", this.pointerLockChange, true);
            document.addEventListener("mozpointerlockchange", this.pointerLockChange, true);
            document.addEventListener("webkitpointerlockchange", this.pointerLockChange, true);
          }
          this.enabled = true;
        },
        stopListeners: function() {
          var target = this.target;
          target.removeEventListener("mousemove", this.onMouseMove);
          target.removeEventListener("mousedown", this.onMouseDown);
          target.removeEventListener("mouseup", this.onMouseUp);
          target.removeEventListener("mouseover", this.onMouseOver);
          target.removeEventListener("mouseout", this.onMouseOut);
          if (window) {
            target = this.isTop ? window.top : window;
            target.removeEventListener("mousedown", this.onMouseDownWindow);
            target.removeEventListener("mouseup", this.onMouseUpWindow);
          }
          if (Features.pointerLock) {
            document.removeEventListener("pointerlockchange", this.pointerLockChange, true);
            document.removeEventListener("mozpointerlockchange", this.pointerLockChange, true);
            document.removeEventListener("webkitpointerlockchange", this.pointerLockChange, true);
          }
        },
        destroy: function() {
          this.stopListeners();
          this.target = null;
          this.enabled = false;
          this.manager = null;
        }
      });
      module.exports = MouseManager;
    }
  });

  // ../../node_modules/phaser/src/input/Pointer.js
  var require_Pointer = __commonJS({
    "../../node_modules/phaser/src/input/Pointer.js": function(exports, module) {
      var Angle = require_Between();
      var Class = require_Class();
      var Distance = require_DistanceBetween();
      var FuzzyEqual = require_Equal();
      var SmoothStepInterpolation = require_SmoothStepInterpolation();
      var Vector2 = require_Vector2();
      var OS = require_OS();
      var Pointer = new Class({
        initialize: function Pointer2(manager, id) {
          this.manager = manager;
          this.id = id;
          this.event;
          this.downElement;
          this.upElement;
          this.camera = null;
          this.button = 0;
          this.buttons = 0;
          this.position = new Vector2();
          this.prevPosition = new Vector2();
          this.midPoint = new Vector2(-1, -1);
          this.velocity = new Vector2();
          this.angle = 0;
          this.distance = 0;
          this.smoothFactor = 0;
          this.motionFactor = 0.2;
          this.worldX = 0;
          this.worldY = 0;
          this.moveTime = 0;
          this.downX = 0;
          this.downY = 0;
          this.downTime = 0;
          this.upX = 0;
          this.upY = 0;
          this.upTime = 0;
          this.primaryDown = false;
          this.isDown = false;
          this.wasTouch = false;
          this.wasCanceled = false;
          this.movementX = 0;
          this.movementY = 0;
          this.identifier = 0;
          this.pointerId = null;
          this.active = id === 0 ? true : false;
          this.locked = false;
          this.deltaX = 0;
          this.deltaY = 0;
          this.deltaZ = 0;
        },
        updateWorldPoint: function(camera) {
          var temp = camera.getWorldPoint(this.x, this.y);
          this.worldX = temp.x;
          this.worldY = temp.y;
          return this;
        },
        positionToCamera: function(camera, output) {
          return camera.getWorldPoint(this.x, this.y, output);
        },
        updateMotion: function() {
          var cx = this.position.x;
          var cy = this.position.y;
          var mx = this.midPoint.x;
          var my = this.midPoint.y;
          if (cx === mx && cy === my) {
            return;
          }
          var vx = SmoothStepInterpolation(this.motionFactor, mx, cx);
          var vy = SmoothStepInterpolation(this.motionFactor, my, cy);
          if (FuzzyEqual(vx, cx, 0.1)) {
            vx = cx;
          }
          if (FuzzyEqual(vy, cy, 0.1)) {
            vy = cy;
          }
          this.midPoint.set(vx, vy);
          var dx = cx - vx;
          var dy = cy - vy;
          this.velocity.set(dx, dy);
          this.angle = Angle(vx, vy, cx, cy);
          this.distance = Math.sqrt(dx * dx + dy * dy);
        },
        up: function(event) {
          if ("buttons" in event) {
            this.buttons = event.buttons;
          }
          this.event = event;
          this.button = event.button;
          this.upElement = event.target;
          this.manager.transformPointer(this, event.pageX, event.pageY, false);
          if (event.button === 0) {
            this.primaryDown = false;
            this.upX = this.x;
            this.upY = this.y;
          }
          if (this.buttons === 0) {
            this.isDown = false;
            this.upTime = event.timeStamp;
            this.wasTouch = false;
          }
        },
        down: function(event) {
          if ("buttons" in event) {
            this.buttons = event.buttons;
          }
          this.event = event;
          this.button = event.button;
          this.downElement = event.target;
          this.manager.transformPointer(this, event.pageX, event.pageY, false);
          if (event.button === 0) {
            this.primaryDown = true;
            this.downX = this.x;
            this.downY = this.y;
          }
          if (OS.macOS && event.ctrlKey) {
            this.buttons = 2;
            this.primaryDown = false;
          }
          if (!this.isDown) {
            this.isDown = true;
            this.downTime = event.timeStamp;
          }
          this.wasTouch = false;
        },
        move: function(event) {
          if ("buttons" in event) {
            this.buttons = event.buttons;
          }
          this.event = event;
          this.manager.transformPointer(this, event.pageX, event.pageY, true);
          if (this.locked) {
            this.movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            this.movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
          }
          this.moveTime = event.timeStamp;
          this.wasTouch = false;
        },
        wheel: function(event) {
          if ("buttons" in event) {
            this.buttons = event.buttons;
          }
          this.event = event;
          this.manager.transformPointer(this, event.pageX, event.pageY, false);
          this.deltaX = event.deltaX;
          this.deltaY = event.deltaY;
          this.deltaZ = event.deltaZ;
          this.wasTouch = false;
        },
        touchstart: function(touch, event) {
          if (touch["pointerId"]) {
            this.pointerId = touch.pointerId;
          }
          this.identifier = touch.identifier;
          this.target = touch.target;
          this.active = true;
          this.buttons = 1;
          this.event = event;
          this.downElement = touch.target;
          this.manager.transformPointer(this, touch.pageX, touch.pageY, false);
          this.primaryDown = true;
          this.downX = this.x;
          this.downY = this.y;
          this.downTime = event.timeStamp;
          this.isDown = true;
          this.wasTouch = true;
          this.wasCanceled = false;
          this.updateMotion();
        },
        touchmove: function(touch, event) {
          this.event = event;
          this.manager.transformPointer(this, touch.pageX, touch.pageY, true);
          this.moveTime = event.timeStamp;
          this.wasTouch = true;
          this.updateMotion();
        },
        touchend: function(touch, event) {
          this.buttons = 0;
          this.event = event;
          this.upElement = touch.target;
          this.manager.transformPointer(this, touch.pageX, touch.pageY, false);
          this.primaryDown = false;
          this.upX = this.x;
          this.upY = this.y;
          this.upTime = event.timeStamp;
          this.isDown = false;
          this.wasTouch = true;
          this.wasCanceled = false;
          this.active = false;
          this.updateMotion();
        },
        touchcancel: function(touch, event) {
          this.buttons = 0;
          this.event = event;
          this.upElement = touch.target;
          this.manager.transformPointer(this, touch.pageX, touch.pageY, false);
          this.primaryDown = false;
          this.upX = this.x;
          this.upY = this.y;
          this.upTime = event.timeStamp;
          this.isDown = false;
          this.wasTouch = true;
          this.wasCanceled = true;
          this.active = false;
        },
        noButtonDown: function() {
          return this.buttons === 0;
        },
        leftButtonDown: function() {
          return this.buttons & 1 ? true : false;
        },
        rightButtonDown: function() {
          return this.buttons & 2 ? true : false;
        },
        middleButtonDown: function() {
          return this.buttons & 4 ? true : false;
        },
        backButtonDown: function() {
          return this.buttons & 8 ? true : false;
        },
        forwardButtonDown: function() {
          return this.buttons & 16 ? true : false;
        },
        leftButtonReleased: function() {
          return this.button === 0 && !this.isDown;
        },
        rightButtonReleased: function() {
          return this.button === 2 && !this.isDown;
        },
        middleButtonReleased: function() {
          return this.button === 1 && !this.isDown;
        },
        backButtonReleased: function() {
          return this.button === 3 && !this.isDown;
        },
        forwardButtonReleased: function() {
          return this.button === 4 && !this.isDown;
        },
        getDistance: function() {
          if (this.isDown) {
            return Distance(this.downX, this.downY, this.x, this.y);
          } else {
            return Distance(this.downX, this.downY, this.upX, this.upY);
          }
        },
        getDistanceX: function() {
          if (this.isDown) {
            return Math.abs(this.downX - this.x);
          } else {
            return Math.abs(this.downX - this.upX);
          }
        },
        getDistanceY: function() {
          if (this.isDown) {
            return Math.abs(this.downY - this.y);
          } else {
            return Math.abs(this.downY - this.upY);
          }
        },
        getDuration: function() {
          if (this.isDown) {
            return this.manager.time - this.downTime;
          } else {
            return this.upTime - this.downTime;
          }
        },
        getAngle: function() {
          if (this.isDown) {
            return Angle(this.downX, this.downY, this.x, this.y);
          } else {
            return Angle(this.downX, this.downY, this.upX, this.upY);
          }
        },
        getInterpolatedPosition: function(steps, out) {
          if (steps === void 0) {
            steps = 10;
          }
          if (out === void 0) {
            out = [];
          }
          var prevX = this.prevPosition.x;
          var prevY = this.prevPosition.y;
          var curX = this.position.x;
          var curY = this.position.y;
          for (var i = 0; i < steps; i++) {
            var t = 1 / steps * i;
            out[i] = { x: SmoothStepInterpolation(t, prevX, curX), y: SmoothStepInterpolation(t, prevY, curY) };
          }
          return out;
        },
        reset: function() {
          this.event = null;
          this.downElement = null;
          this.upElement = null;
          this.button = 0;
          this.buttons = 0;
          this.position.set(0, 0);
          this.prevPosition.set(0, 0);
          this.midPoint.set(-1, -1);
          this.velocity.set(0, 0);
          this.angle = 0;
          this.distance = 0;
          this.worldX = 0;
          this.worldY = 0;
          this.downX = 0;
          this.downY = 0;
          this.upX = 0;
          this.upY = 0;
          this.moveTime = 0;
          this.upTime = 0;
          this.downTime = 0;
          this.primaryDown = false;
          this.isDown = false;
          this.wasTouch = false;
          this.wasCanceled = false;
          this.movementX = 0;
          this.movementY = 0;
          this.identifier = 0;
          this.pointerId = null;
          this.deltaX = 0;
          this.deltaY = 0;
          this.deltaZ = 0;
          this.active = this.id === 0 ? true : false;
        },
        destroy: function() {
          this.camera = null;
          this.manager = null;
          this.position = null;
        },
        x: {
          get: function() {
            return this.position.x;
          },
          set: function(value) {
            this.position.x = value;
          }
        },
        y: {
          get: function() {
            return this.position.y;
          },
          set: function(value) {
            this.position.y = value;
          }
        },
        time: {
          get: function() {
            return this.event ? this.event.timeStamp : 0;
          }
        }
      });
      module.exports = Pointer;
    }
  });

  // ../../node_modules/phaser/src/input/touch/TouchManager.js
  var require_TouchManager = __commonJS({
    "../../node_modules/phaser/src/input/touch/TouchManager.js": function(exports, module) {
      var Class = require_Class();
      var InputEvents = require_events13();
      var NOOP = require_NOOP();
      var TouchManager = new Class({
        initialize: function TouchManager2(inputManager) {
          this.manager = inputManager;
          this.capture = true;
          this.enabled = false;
          this.target;
          this.onTouchStart = NOOP;
          this.onTouchStartWindow = NOOP;
          this.onTouchMove = NOOP;
          this.onTouchEnd = NOOP;
          this.onTouchEndWindow = NOOP;
          this.onTouchCancel = NOOP;
          this.onTouchCancelWindow = NOOP;
          this.isTop = true;
          inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
        },
        boot: function() {
          var config = this.manager.config;
          this.enabled = config.inputTouch;
          this.target = config.inputTouchEventTarget;
          this.capture = config.inputTouchCapture;
          if (!this.target) {
            this.target = this.manager.game.canvas;
          } else if (typeof this.target === "string") {
            this.target = document.getElementById(this.target);
          }
          if (config.disableContextMenu) {
            this.disableContextMenu();
          }
          if (this.enabled && this.target) {
            this.startListeners();
          }
        },
        disableContextMenu: function() {
          this.target.addEventListener("contextmenu", function(event) {
            event.preventDefault();
            return false;
          });
          return this;
        },
        startListeners: function() {
          var target = this.target;
          if (!target) {
            return;
          }
          var _this = this;
          var manager = this.manager;
          var canvas = manager.canvas;
          var autoFocus = window && window.focus && manager.game.config.autoFocus;
          this.onTouchMove = function(event) {
            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
              manager.onTouchMove(event);
              if (_this.capture && event.cancelable) {
                event.preventDefault();
              }
            }
          };
          this.onTouchStart = function(event) {
            if (autoFocus) {
              window.focus();
            }
            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
              manager.onTouchStart(event);
              if (_this.capture && event.cancelable && event.target === canvas) {
                event.preventDefault();
              }
            }
          };
          this.onTouchStartWindow = function(event) {
            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas) {
              manager.onTouchStart(event);
            }
          };
          this.onTouchEnd = function(event) {
            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
              manager.onTouchEnd(event);
              if (_this.capture && event.cancelable && event.target === canvas) {
                event.preventDefault();
              }
            }
          };
          this.onTouchEndWindow = function(event) {
            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas) {
              manager.onTouchEnd(event);
            }
          };
          this.onTouchCancel = function(event) {
            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
              manager.onTouchCancel(event);
              if (_this.capture) {
                event.preventDefault();
              }
            }
          };
          this.onTouchCancelWindow = function(event) {
            if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
              manager.onTouchCancel(event);
            }
          };
          var capture = this.capture;
          var passive = { passive: true };
          var nonPassive = { passive: false };
          target.addEventListener("touchstart", this.onTouchStart, capture ? nonPassive : passive);
          target.addEventListener("touchmove", this.onTouchMove, capture ? nonPassive : passive);
          target.addEventListener("touchend", this.onTouchEnd, capture ? nonPassive : passive);
          target.addEventListener("touchcancel", this.onTouchCancel, capture ? nonPassive : passive);
          if (window && manager.game.config.inputWindowEvents) {
            try {
              window.top.addEventListener("touchstart", this.onTouchStartWindow, nonPassive);
              window.top.addEventListener("touchend", this.onTouchEndWindow, nonPassive);
              window.top.addEventListener("touchcancel", this.onTouchCancelWindow, nonPassive);
            } catch (exception) {
              window.addEventListener("touchstart", this.onTouchStartWindow, nonPassive);
              window.addEventListener("touchend", this.onTouchEndWindow, nonPassive);
              window.addEventListener("touchcancel", this.onTouchCancelWindow, nonPassive);
              this.isTop = false;
            }
          }
          this.enabled = true;
        },
        stopListeners: function() {
          var target = this.target;
          target.removeEventListener("touchstart", this.onTouchStart);
          target.removeEventListener("touchmove", this.onTouchMove);
          target.removeEventListener("touchend", this.onTouchEnd);
          target.removeEventListener("touchcancel", this.onTouchCancel);
          if (window) {
            target = this.isTop ? window.top : window;
            target.removeEventListener("touchstart", this.onTouchStartWindow);
            target.removeEventListener("touchend", this.onTouchEndWindow);
            target.removeEventListener("touchcancel", this.onTouchCancelWindow);
          }
        },
        destroy: function() {
          this.stopListeners();
          this.target = null;
          this.enabled = false;
          this.manager = null;
        }
      });
      module.exports = TouchManager;
    }
  });

  // ../../node_modules/phaser/src/input/InputManager.js
  var require_InputManager = __commonJS({
    "../../node_modules/phaser/src/input/InputManager.js": function(exports, module) {
      var Class = require_Class();
      var CONST = require_const8();
      var EventEmitter = require_eventemitter3();
      var Events = require_events13();
      var GameEvents = require_events5();
      var Keyboard = require_KeyboardManager();
      var Mouse = require_MouseManager();
      var Pointer = require_Pointer();
      var Touch = require_TouchManager();
      var TransformMatrix = require_TransformMatrix();
      var TransformXY = require_TransformXY();
      var InputManager = new Class({
        initialize: function InputManager2(game, config) {
          this.game = game;
          this.scaleManager;
          this.canvas;
          this.config = config;
          this.enabled = true;
          this.events = new EventEmitter();
          this.isOver = true;
          this.defaultCursor = "";
          this.keyboard = config.inputKeyboard ? new Keyboard(this) : null;
          this.mouse = config.inputMouse ? new Mouse(this) : null;
          this.touch = config.inputTouch ? new Touch(this) : null;
          this.pointers = [];
          this.pointersTotal = config.inputActivePointers;
          if (config.inputTouch && this.pointersTotal === 1) {
            this.pointersTotal = 2;
          }
          for (var i = 0; i <= this.pointersTotal; i++) {
            var pointer = new Pointer(this, i);
            pointer.smoothFactor = config.inputSmoothFactor;
            this.pointers.push(pointer);
          }
          this.mousePointer = config.inputMouse ? this.pointers[0] : null;
          this.activePointer = this.pointers[0];
          this.globalTopOnly = true;
          this.time = 0;
          this._tempPoint = { x: 0, y: 0 };
          this._tempHitTest = [];
          this._tempMatrix = new TransformMatrix();
          this._tempMatrix2 = new TransformMatrix();
          this._tempSkip = false;
          this.mousePointerContainer = [this.mousePointer];
          game.events.once(GameEvents.BOOT, this.boot, this);
        },
        boot: function() {
          var game = this.game;
          var events = game.events;
          this.canvas = game.canvas;
          this.scaleManager = game.scale;
          this.events.emit(Events.MANAGER_BOOT);
          events.on(GameEvents.PRE_RENDER, this.preRender, this);
          events.once(GameEvents.DESTROY, this.destroy, this);
        },
        setCanvasOver: function(event) {
          this.isOver = true;
          this.events.emit(Events.GAME_OVER, event);
        },
        setCanvasOut: function(event) {
          this.isOver = false;
          this.events.emit(Events.GAME_OUT, event);
        },
        preRender: function() {
          var time = this.game.loop.now;
          var delta = this.game.loop.delta;
          var scenes = this.game.scene.getScenes(true, true);
          this.time = time;
          this.events.emit(Events.MANAGER_UPDATE);
          for (var i = 0; i < scenes.length; i++) {
            var scene = scenes[i];
            if (scene.sys.input && scene.sys.input.updatePoll(time, delta) && this.globalTopOnly) {
              return;
            }
          }
        },
        setDefaultCursor: function(cursor) {
          this.defaultCursor = cursor;
          if (this.canvas.style.cursor !== cursor) {
            this.canvas.style.cursor = cursor;
          }
        },
        setCursor: function(interactiveObject) {
          if (interactiveObject.cursor) {
            this.canvas.style.cursor = interactiveObject.cursor;
          }
        },
        resetCursor: function(interactiveObject) {
          if (interactiveObject.cursor && this.canvas) {
            this.canvas.style.cursor = this.defaultCursor;
          }
        },
        addPointer: function(quantity) {
          if (quantity === void 0) {
            quantity = 1;
          }
          var output = [];
          if (this.pointersTotal + quantity > 10) {
            quantity = 10 - this.pointersTotal;
          }
          for (var i = 0; i < quantity; i++) {
            var id = this.pointers.length;
            var pointer = new Pointer(this, id);
            pointer.smoothFactor = this.config.inputSmoothFactor;
            this.pointers.push(pointer);
            this.pointersTotal++;
            output.push(pointer);
          }
          return output;
        },
        updateInputPlugins: function(type, pointers) {
          var scenes = this.game.scene.getScenes(false, true);
          this._tempSkip = false;
          for (var i = 0; i < scenes.length; i++) {
            var scene = scenes[i];
            if (scene.sys.input) {
              var capture = scene.sys.input.update(type, pointers);
              if (capture && this.globalTopOnly || this._tempSkip) {
                return;
              }
            }
          }
        },
        onTouchStart: function(event) {
          var pointers = this.pointers;
          var changed = [];
          for (var c = 0; c < event.changedTouches.length; c++) {
            var changedTouch = event.changedTouches[c];
            for (var i = 1; i < this.pointersTotal; i++) {
              var pointer = pointers[i];
              if (!pointer.active) {
                pointer.touchstart(changedTouch, event);
                this.activePointer = pointer;
                changed.push(pointer);
                break;
              }
            }
          }
          this.updateInputPlugins(CONST.TOUCH_START, changed);
        },
        onTouchMove: function(event) {
          var pointers = this.pointers;
          var changed = [];
          for (var c = 0; c < event.changedTouches.length; c++) {
            var changedTouch = event.changedTouches[c];
            for (var i = 1; i < this.pointersTotal; i++) {
              var pointer = pointers[i];
              if (pointer.active && pointer.identifier === changedTouch.identifier) {
                var element = document.elementFromPoint(changedTouch.pageX, changedTouch.pageY);
                var overCanvas = element === this.canvas;
                if (!this.isOver && overCanvas) {
                  this.setCanvasOver(event);
                } else if (this.isOver && !overCanvas) {
                  this.setCanvasOut(event);
                }
                if (this.isOver) {
                  pointer.touchmove(changedTouch, event);
                  this.activePointer = pointer;
                  changed.push(pointer);
                }
                break;
              }
            }
          }
          this.updateInputPlugins(CONST.TOUCH_MOVE, changed);
        },
        onTouchEnd: function(event) {
          var pointers = this.pointers;
          var changed = [];
          for (var c = 0; c < event.changedTouches.length; c++) {
            var changedTouch = event.changedTouches[c];
            for (var i = 1; i < this.pointersTotal; i++) {
              var pointer = pointers[i];
              if (pointer.active && pointer.identifier === changedTouch.identifier) {
                pointer.touchend(changedTouch, event);
                changed.push(pointer);
                break;
              }
            }
          }
          this.updateInputPlugins(CONST.TOUCH_END, changed);
        },
        onTouchCancel: function(event) {
          var pointers = this.pointers;
          var changed = [];
          for (var c = 0; c < event.changedTouches.length; c++) {
            var changedTouch = event.changedTouches[c];
            for (var i = 1; i < this.pointersTotal; i++) {
              var pointer = pointers[i];
              if (pointer.active && pointer.identifier === changedTouch.identifier) {
                pointer.touchcancel(changedTouch, event);
                changed.push(pointer);
                break;
              }
            }
          }
          this.updateInputPlugins(CONST.TOUCH_CANCEL, changed);
        },
        onMouseDown: function(event) {
          var mousePointer = this.mousePointer;
          mousePointer.down(event);
          mousePointer.updateMotion();
          this.activePointer = mousePointer;
          this.updateInputPlugins(CONST.MOUSE_DOWN, this.mousePointerContainer);
        },
        onMouseMove: function(event) {
          var mousePointer = this.mousePointer;
          mousePointer.move(event);
          mousePointer.updateMotion();
          this.activePointer = mousePointer;
          this.updateInputPlugins(CONST.MOUSE_MOVE, this.mousePointerContainer);
        },
        onMouseUp: function(event) {
          var mousePointer = this.mousePointer;
          mousePointer.up(event);
          mousePointer.updateMotion();
          this.activePointer = mousePointer;
          this.updateInputPlugins(CONST.MOUSE_UP, this.mousePointerContainer);
        },
        onMouseWheel: function(event) {
          var mousePointer = this.mousePointer;
          mousePointer.wheel(event);
          this.activePointer = mousePointer;
          this.updateInputPlugins(CONST.MOUSE_WHEEL, this.mousePointerContainer);
        },
        onPointerLockChange: function(event) {
          var isLocked = this.mouse.locked;
          this.mousePointer.locked = isLocked;
          this.events.emit(Events.POINTERLOCK_CHANGE, event, isLocked);
        },
        inputCandidate: function(gameObject, camera) {
          var input = gameObject.input;
          if (!input || !input.enabled || !gameObject.willRender(camera)) {
            return false;
          }
          var visible = true;
          var parent = gameObject.parentContainer;
          if (parent) {
            do {
              if (!parent.willRender(camera)) {
                visible = false;
                break;
              }
              parent = parent.parentContainer;
            } while (parent);
          }
          return visible;
        },
        hitTest: function(pointer, gameObjects, camera, output) {
          if (output === void 0) {
            output = this._tempHitTest;
          }
          var tempPoint = this._tempPoint;
          var csx = camera.scrollX;
          var csy = camera.scrollY;
          output.length = 0;
          var x = pointer.x;
          var y = pointer.y;
          camera.getWorldPoint(x, y, tempPoint);
          pointer.worldX = tempPoint.x;
          pointer.worldY = tempPoint.y;
          var point = { x: 0, y: 0 };
          var matrix = this._tempMatrix;
          var parentMatrix = this._tempMatrix2;
          for (var i = 0; i < gameObjects.length; i++) {
            var gameObject = gameObjects[i];
            if (!this.inputCandidate(gameObject, camera)) {
              continue;
            }
            var px = tempPoint.x + csx * gameObject.scrollFactorX - csx;
            var py = tempPoint.y + csy * gameObject.scrollFactorY - csy;
            if (gameObject.parentContainer) {
              gameObject.getWorldTransformMatrix(matrix, parentMatrix);
              matrix.applyInverse(px, py, point);
            } else {
              TransformXY(px, py, gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY, point);
            }
            if (this.pointWithinHitArea(gameObject, point.x, point.y)) {
              output.push(gameObject);
            }
          }
          return output;
        },
        pointWithinHitArea: function(gameObject, x, y) {
          x += gameObject.displayOriginX;
          y += gameObject.displayOriginY;
          var input = gameObject.input;
          if (input && input.hitAreaCallback(input.hitArea, x, y, gameObject)) {
            input.localX = x;
            input.localY = y;
            return true;
          } else {
            return false;
          }
        },
        pointWithinInteractiveObject: function(object, x, y) {
          if (!object.hitArea) {
            return false;
          }
          x += object.gameObject.displayOriginX;
          y += object.gameObject.displayOriginY;
          object.localX = x;
          object.localY = y;
          return object.hitAreaCallback(object.hitArea, x, y, object);
        },
        transformPointer: function(pointer, pageX, pageY, wasMove) {
          var p0 = pointer.position;
          var p1 = pointer.prevPosition;
          p1.x = p0.x;
          p1.y = p0.y;
          var x = this.scaleManager.transformX(pageX);
          var y = this.scaleManager.transformY(pageY);
          var a = pointer.smoothFactor;
          if (!wasMove || a === 0) {
            p0.x = x;
            p0.y = y;
          } else {
            p0.x = x * a + p1.x * (1 - a);
            p0.y = y * a + p1.y * (1 - a);
          }
        },
        destroy: function() {
          this.events.removeAllListeners();
          this.game.events.off(GameEvents.PRE_RENDER);
          if (this.keyboard) {
            this.keyboard.destroy();
          }
          if (this.mouse) {
            this.mouse.destroy();
          }
          if (this.touch) {
            this.touch.destroy();
          }
          for (var i = 0; i < this.pointers.length; i++) {
            this.pointers[i].destroy();
          }
          this.pointers = [];
          this._tempHitTest = [];
          this._tempMatrix.destroy();
          this.canvas = null;
          this.game = null;
        }
      });
      module.exports = InputManager;
    }
  });

  // ../../node_modules/phaser/src/loader/FileTypesManager.js
  var require_FileTypesManager = __commonJS({
    "../../node_modules/phaser/src/loader/FileTypesManager.js": function(exports, module) {
      var types = {};
      var FileTypesManager = {
        install: function(loader) {
          for (var key in types) {
            loader[key] = types[key];
          }
        },
        register: function(key, factoryFunction) {
          types[key] = factoryFunction;
        },
        destroy: function() {
          types = {};
        }
      };
      module.exports = FileTypesManager;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/GameObjectCreator.js
  var require_GameObjectCreator = __commonJS({
    "../../node_modules/phaser/src/gameobjects/GameObjectCreator.js": function(exports, module) {
      var Class = require_Class();
      var PluginCache = require_PluginCache();
      var SceneEvents = require_events();
      var GameObjectCreator = new Class({
        initialize: function GameObjectCreator2(scene) {
          this.scene = scene;
          this.systems = scene.sys;
          this.events = scene.sys.events;
          this.displayList;
          this.updateList;
          this.events.once(SceneEvents.BOOT, this.boot, this);
          this.events.on(SceneEvents.START, this.start, this);
        },
        boot: function() {
          this.displayList = this.systems.displayList;
          this.updateList = this.systems.updateList;
          this.events.once(SceneEvents.DESTROY, this.destroy, this);
        },
        start: function() {
          this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        shutdown: function() {
          this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        destroy: function() {
          this.shutdown();
          this.events.off(SceneEvents.START, this.start, this);
          this.scene = null;
          this.systems = null;
          this.events = null;
          this.displayList = null;
          this.updateList = null;
        }
      });
      GameObjectCreator.register = function(factoryType, factoryFunction) {
        if (!GameObjectCreator.prototype.hasOwnProperty(factoryType)) {
          GameObjectCreator.prototype[factoryType] = factoryFunction;
        }
      };
      GameObjectCreator.remove = function(factoryType) {
        if (GameObjectCreator.prototype.hasOwnProperty(factoryType)) {
          delete GameObjectCreator.prototype[factoryType];
        }
      };
      PluginCache.register("GameObjectCreator", GameObjectCreator, "make");
      module.exports = GameObjectCreator;
    }
  });

  // ../../node_modules/phaser/src/plugins/PluginManager.js
  var require_PluginManager = __commonJS({
    "../../node_modules/phaser/src/plugins/PluginManager.js": function(exports, module) {
      var Class = require_Class();
      var GameEvents = require_events5();
      var EventEmitter = require_eventemitter3();
      var FileTypesManager = require_FileTypesManager();
      var GameObjectCreator = require_GameObjectCreator();
      var GameObjectFactory = require_GameObjectFactory();
      var GetFastValue = require_GetFastValue();
      var PluginCache = require_PluginCache();
      var Remove = require_Remove();
      var PluginManager = new Class({
        Extends: EventEmitter,
        initialize: function PluginManager2(game) {
          EventEmitter.call(this);
          this.game = game;
          this.plugins = [];
          this.scenePlugins = [];
          this._pendingGlobal = [];
          this._pendingScene = [];
          if (game.isBooted) {
            this.boot();
          } else {
            game.events.once(GameEvents.BOOT, this.boot, this);
          }
        },
        boot: function() {
          var i;
          var entry;
          var key;
          var plugin;
          var start;
          var mapping;
          var data;
          var config = this.game.config;
          var list = config.installGlobalPlugins;
          list = list.concat(this._pendingGlobal);
          for (i = 0; i < list.length; i++) {
            entry = list[i];
            key = GetFastValue(entry, "key", null);
            plugin = GetFastValue(entry, "plugin", null);
            start = GetFastValue(entry, "start", false);
            mapping = GetFastValue(entry, "mapping", null);
            data = GetFastValue(entry, "data", null);
            if (key) {
              if (plugin) {
                this.install(key, plugin, start, mapping, data);
              } else {
                console.warn("Missing `plugin` for key: " + key);
              }
            }
          }
          list = config.installScenePlugins;
          list = list.concat(this._pendingScene);
          for (i = 0; i < list.length; i++) {
            entry = list[i];
            key = GetFastValue(entry, "key", null);
            plugin = GetFastValue(entry, "plugin", null);
            mapping = GetFastValue(entry, "mapping", null);
            if (key) {
              if (plugin) {
                this.installScenePlugin(key, plugin, mapping);
              } else {
                console.warn("Missing `plugin` for key: " + key);
              }
            }
          }
          this._pendingGlobal = [];
          this._pendingScene = [];
          this.game.events.once(GameEvents.DESTROY, this.destroy, this);
        },
        addToScene: function(sys, globalPlugins, scenePlugins) {
          var i;
          var pluginKey;
          var pluginList;
          var game = this.game;
          var scene = sys.scene;
          var map = sys.settings.map;
          var isBooted = sys.settings.isBooted;
          for (i = 0; i < globalPlugins.length; i++) {
            pluginKey = globalPlugins[i];
            if (game[pluginKey]) {
              sys[pluginKey] = game[pluginKey];
              if (map.hasOwnProperty(pluginKey)) {
                scene[map[pluginKey]] = sys[pluginKey];
              }
            } else if (pluginKey === "game" && map.hasOwnProperty(pluginKey)) {
              scene[map[pluginKey]] = game;
            }
          }
          for (var s = 0; s < scenePlugins.length; s++) {
            pluginList = scenePlugins[s];
            for (i = 0; i < pluginList.length; i++) {
              pluginKey = pluginList[i];
              if (!PluginCache.hasCore(pluginKey)) {
                continue;
              }
              var source = PluginCache.getCore(pluginKey);
              var mapKey = source.mapping;
              var plugin = new source.plugin(scene, this, mapKey);
              sys[mapKey] = plugin;
              if (source.custom) {
                scene[mapKey] = plugin;
              } else if (map.hasOwnProperty(mapKey)) {
                scene[map[mapKey]] = plugin;
              }
              if (isBooted) {
                plugin.boot();
              }
            }
          }
          pluginList = this.plugins;
          for (i = 0; i < pluginList.length; i++) {
            var entry = pluginList[i];
            if (entry.mapping) {
              scene[entry.mapping] = entry.plugin;
            }
          }
        },
        getDefaultScenePlugins: function() {
          var list = this.game.config.defaultPlugins;
          list = list.concat(this.scenePlugins);
          return list;
        },
        installScenePlugin: function(key, plugin, mapping, addToScene, fromLoader) {
          if (fromLoader === void 0) {
            fromLoader = false;
          }
          if (typeof plugin !== "function") {
            console.warn("Invalid Scene Plugin: " + key);
            return;
          }
          if (!PluginCache.hasCore(key)) {
            PluginCache.register(key, plugin, mapping, true);
          }
          if (this.scenePlugins.indexOf(key) === -1) {
            this.scenePlugins.push(key);
          } else if (!fromLoader && PluginCache.hasCore(key)) {
            console.warn("Scene Plugin key in use: " + key);
            return;
          }
          if (addToScene) {
            var instance = new plugin(addToScene, this, key);
            addToScene.sys[key] = instance;
            if (mapping && mapping !== "") {
              addToScene[mapping] = instance;
            }
            instance.boot();
          }
        },
        install: function(key, plugin, start, mapping, data) {
          if (start === void 0) {
            start = false;
          }
          if (mapping === void 0) {
            mapping = null;
          }
          if (data === void 0) {
            data = null;
          }
          if (typeof plugin !== "function") {
            console.warn("Invalid Plugin: " + key);
            return null;
          }
          if (PluginCache.hasCustom(key)) {
            console.warn("Plugin key in use: " + key);
            return null;
          }
          if (mapping !== null) {
            start = true;
          }
          if (!this.game.isBooted) {
            this._pendingGlobal.push({ key: key, plugin: plugin, start: start, mapping: mapping, data: data });
          } else {
            PluginCache.registerCustom(key, plugin, mapping, data);
            if (start) {
              return this.start(key);
            }
          }
          return null;
        },
        getIndex: function(key) {
          var list = this.plugins;
          for (var i = 0; i < list.length; i++) {
            var entry = list[i];
            if (entry.key === key) {
              return i;
            }
          }
          return -1;
        },
        getEntry: function(key) {
          var idx = this.getIndex(key);
          if (idx !== -1) {
            return this.plugins[idx];
          }
        },
        isActive: function(key) {
          var entry = this.getEntry(key);
          return entry && entry.active;
        },
        start: function(key, runAs) {
          if (runAs === void 0) {
            runAs = key;
          }
          var entry = this.getEntry(runAs);
          if (entry && !entry.active) {
            entry.active = true;
            entry.plugin.start();
          } else if (!entry) {
            entry = this.createEntry(key, runAs);
          }
          return entry ? entry.plugin : null;
        },
        createEntry: function(key, runAs) {
          var entry = PluginCache.getCustom(key);
          if (entry) {
            var instance = new entry.plugin(this);
            entry = {
              key: runAs,
              plugin: instance,
              active: true,
              mapping: entry.mapping,
              data: entry.data
            };
            this.plugins.push(entry);
            instance.init(entry.data);
            instance.start();
          }
          return entry;
        },
        stop: function(key) {
          var entry = this.getEntry(key);
          if (entry && entry.active) {
            entry.active = false;
            entry.plugin.stop();
          }
          return this;
        },
        get: function(key, autoStart) {
          if (autoStart === void 0) {
            autoStart = true;
          }
          var entry = this.getEntry(key);
          if (entry) {
            return entry.plugin;
          } else {
            var plugin = this.getClass(key);
            if (plugin && autoStart) {
              entry = this.createEntry(key, key);
              return entry ? entry.plugin : null;
            } else if (plugin) {
              return plugin;
            }
          }
          return null;
        },
        getClass: function(key) {
          return PluginCache.getCustomClass(key);
        },
        removeGlobalPlugin: function(key) {
          var entry = this.getEntry(key);
          if (entry) {
            Remove(this.plugins, entry);
          }
          PluginCache.removeCustom(key);
        },
        removeScenePlugin: function(key) {
          Remove(this.scenePlugins, key);
          PluginCache.remove(key);
        },
        registerGameObject: function(key, factoryCallback, creatorCallback) {
          if (factoryCallback) {
            GameObjectFactory.register(key, factoryCallback);
          }
          if (creatorCallback) {
            GameObjectCreator.register(key, creatorCallback);
          }
          return this;
        },
        removeGameObject: function(key, removeFromFactory, removeFromCreator) {
          if (removeFromFactory === void 0) {
            removeFromFactory = true;
          }
          if (removeFromCreator === void 0) {
            removeFromCreator = true;
          }
          if (removeFromFactory) {
            GameObjectFactory.remove(key);
          }
          if (removeFromCreator) {
            GameObjectCreator.remove(key);
          }
          return this;
        },
        registerFileType: function(key, callback, addToScene) {
          FileTypesManager.register(key, callback);
          if (addToScene && addToScene.sys.load) {
            addToScene.sys.load[key] = callback;
          }
        },
        destroy: function() {
          for (var i = 0; i < this.plugins.length; i++) {
            this.plugins[i].plugin.destroy();
          }
          PluginCache.destroyCustomPlugins();
          if (this.game.noReturn) {
            PluginCache.destroyCorePlugins();
          }
          this.game = null;
          this.plugins = [];
          this.scenePlugins = [];
        }
      });
      module.exports = PluginManager;
    }
  });

  // ../../node_modules/phaser/src/scale/const/CENTER_CONST.js
  var require_CENTER_CONST = __commonJS({
    "../../node_modules/phaser/src/scale/const/CENTER_CONST.js": function(exports, module) {
      module.exports = {
        NO_CENTER: 0,
        CENTER_BOTH: 1,
        CENTER_HORIZONTALLY: 2,
        CENTER_VERTICALLY: 3
      };
    }
  });

  // ../../node_modules/phaser/src/scale/const/ORIENTATION_CONST.js
  var require_ORIENTATION_CONST = __commonJS({
    "../../node_modules/phaser/src/scale/const/ORIENTATION_CONST.js": function(exports, module) {
      module.exports = {
        LANDSCAPE: "landscape-primary",
        PORTRAIT: "portrait-primary"
      };
    }
  });

  // ../../node_modules/phaser/src/scale/const/SCALE_MODE_CONST.js
  var require_SCALE_MODE_CONST = __commonJS({
    "../../node_modules/phaser/src/scale/const/SCALE_MODE_CONST.js": function(exports, module) {
      module.exports = {
        NONE: 0,
        WIDTH_CONTROLS_HEIGHT: 1,
        HEIGHT_CONTROLS_WIDTH: 2,
        FIT: 3,
        ENVELOP: 4,
        RESIZE: 5
      };
    }
  });

  // ../../node_modules/phaser/src/scale/const/ZOOM_CONST.js
  var require_ZOOM_CONST = __commonJS({
    "../../node_modules/phaser/src/scale/const/ZOOM_CONST.js": function(exports, module) {
      module.exports = {
        NO_ZOOM: 1,
        ZOOM_2X: 2,
        ZOOM_4X: 4,
        MAX_ZOOM: -1
      };
    }
  });

  // ../../node_modules/phaser/src/scale/const/index.js
  var require_const9 = __commonJS({
    "../../node_modules/phaser/src/scale/const/index.js": function(exports, module) {
      var CONST = {
        CENTER: require_CENTER_CONST(),
        ORIENTATION: require_ORIENTATION_CONST(),
        SCALE_MODE: require_SCALE_MODE_CONST(),
        ZOOM: require_ZOOM_CONST()
      };
      module.exports = CONST;
    }
  });

  // ../../node_modules/phaser/src/dom/GetInnerHeight.js
  var require_GetInnerHeight = __commonJS({
    "../../node_modules/phaser/src/dom/GetInnerHeight.js": function(exports, module) {
      var GetInnerHeight = function(iOS) {
        if (!iOS) {
          return window.innerHeight;
        }
        var axis = Math.abs(window.orientation);
        var size = { w: 0, h: 0 };
        var ruler = document.createElement("div");
        ruler.setAttribute("style", "position: fixed; height: 100vh; width: 0; top: 0");
        document.documentElement.appendChild(ruler);
        size.w = axis === 90 ? ruler.offsetHeight : window.innerWidth;
        size.h = axis === 90 ? window.innerWidth : ruler.offsetHeight;
        document.documentElement.removeChild(ruler);
        ruler = null;
        if (Math.abs(window.orientation) !== 90) {
          return size.h;
        } else {
          return size.w;
        }
      };
      module.exports = GetInnerHeight;
    }
  });

  // ../../node_modules/phaser/src/dom/GetTarget.js
  var require_GetTarget = __commonJS({
    "../../node_modules/phaser/src/dom/GetTarget.js": function(exports, module) {
      var GetTarget = function(element) {
        var target;
        if (element !== "") {
          if (typeof element === "string") {
            target = document.getElementById(element);
          } else if (element && element.nodeType === 1) {
            target = element;
          }
        }
        if (!target) {
          target = document.body;
        }
        return target;
      };
      module.exports = GetTarget;
    }
  });

  // ../../node_modules/phaser/src/dom/GetScreenOrientation.js
  var require_GetScreenOrientation = __commonJS({
    "../../node_modules/phaser/src/dom/GetScreenOrientation.js": function(exports, module) {
      var CONST = require_const9();
      var GetScreenOrientation = function(width, height) {
        var screen2 = window.screen;
        var orientation = screen2 ? screen2.orientation || screen2.mozOrientation || screen2.msOrientation : false;
        if (orientation && typeof orientation.type === "string") {
          return orientation.type;
        } else if (typeof orientation === "string") {
          return orientation;
        }
        if (typeof window.orientation === "number") {
          return window.orientation === 0 || window.orientation === 180 ? CONST.ORIENTATION.PORTRAIT : CONST.ORIENTATION.LANDSCAPE;
        } else if (window.matchMedia) {
          if (window.matchMedia("(orientation: portrait)").matches) {
            return CONST.ORIENTATION.PORTRAIT;
          } else if (window.matchMedia("(orientation: landscape)").matches) {
            return CONST.ORIENTATION.LANDSCAPE;
          }
        } else {
          return height > width ? CONST.ORIENTATION.PORTRAIT : CONST.ORIENTATION.LANDSCAPE;
        }
      };
      module.exports = GetScreenOrientation;
    }
  });

  // ../../node_modules/phaser/src/structs/Size.js
  var require_Size2 = __commonJS({
    "../../node_modules/phaser/src/structs/Size.js": function(exports, module) {
      var Clamp = require_Clamp();
      var Class = require_Class();
      var SnapFloor = require_SnapFloor();
      var Vector2 = require_Vector2();
      var Size = new Class({
        initialize: function Size2(width, height, aspectMode, parent) {
          if (width === void 0) {
            width = 0;
          }
          if (height === void 0) {
            height = width;
          }
          if (aspectMode === void 0) {
            aspectMode = 0;
          }
          if (parent === void 0) {
            parent = null;
          }
          this._width = width;
          this._height = height;
          this._parent = parent;
          this.aspectMode = aspectMode;
          this.aspectRatio = height === 0 ? 1 : width / height;
          this.minWidth = 0;
          this.minHeight = 0;
          this.maxWidth = Number.MAX_VALUE;
          this.maxHeight = Number.MAX_VALUE;
          this.snapTo = new Vector2();
        },
        setAspectMode: function(value) {
          if (value === void 0) {
            value = 0;
          }
          this.aspectMode = value;
          return this.setSize(this._width, this._height);
        },
        setSnap: function(snapWidth, snapHeight) {
          if (snapWidth === void 0) {
            snapWidth = 0;
          }
          if (snapHeight === void 0) {
            snapHeight = snapWidth;
          }
          this.snapTo.set(snapWidth, snapHeight);
          return this.setSize(this._width, this._height);
        },
        setParent: function(parent) {
          this._parent = parent;
          return this.setSize(this._width, this._height);
        },
        setMin: function(width, height) {
          if (width === void 0) {
            width = 0;
          }
          if (height === void 0) {
            height = width;
          }
          this.minWidth = Clamp(width, 0, this.maxWidth);
          this.minHeight = Clamp(height, 0, this.maxHeight);
          return this.setSize(this._width, this._height);
        },
        setMax: function(width, height) {
          if (width === void 0) {
            width = Number.MAX_VALUE;
          }
          if (height === void 0) {
            height = width;
          }
          this.maxWidth = Clamp(width, this.minWidth, Number.MAX_VALUE);
          this.maxHeight = Clamp(height, this.minHeight, Number.MAX_VALUE);
          return this.setSize(this._width, this._height);
        },
        setSize: function(width, height) {
          if (width === void 0) {
            width = 0;
          }
          if (height === void 0) {
            height = width;
          }
          switch (this.aspectMode) {
            case Size.NONE:
              this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
              this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
              this.aspectRatio = this._height === 0 ? 1 : this._width / this._height;
              break;
            case Size.WIDTH_CONTROLS_HEIGHT:
              this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
              this._height = this.getNewHeight(this._width * (1 / this.aspectRatio), false);
              break;
            case Size.HEIGHT_CONTROLS_WIDTH:
              this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
              this._width = this.getNewWidth(this._height * this.aspectRatio, false);
              break;
            case Size.FIT:
              this.constrain(width, height, true);
              break;
            case Size.ENVELOP:
              this.constrain(width, height, false);
              break;
          }
          return this;
        },
        setAspectRatio: function(ratio) {
          this.aspectRatio = ratio;
          return this.setSize(this._width, this._height);
        },
        resize: function(width, height) {
          this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
          this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
          this.aspectRatio = this._height === 0 ? 1 : this._width / this._height;
          return this;
        },
        getNewWidth: function(value, checkParent) {
          if (checkParent === void 0) {
            checkParent = true;
          }
          value = Clamp(value, this.minWidth, this.maxWidth);
          if (checkParent && this._parent && value > this._parent.width) {
            value = Math.max(this.minWidth, this._parent.width);
          }
          return value;
        },
        getNewHeight: function(value, checkParent) {
          if (checkParent === void 0) {
            checkParent = true;
          }
          value = Clamp(value, this.minHeight, this.maxHeight);
          if (checkParent && this._parent && value > this._parent.height) {
            value = Math.max(this.minHeight, this._parent.height);
          }
          return value;
        },
        constrain: function(width, height, fit) {
          if (width === void 0) {
            width = 0;
          }
          if (height === void 0) {
            height = width;
          }
          if (fit === void 0) {
            fit = true;
          }
          width = this.getNewWidth(width);
          height = this.getNewHeight(height);
          var snap = this.snapTo;
          var newRatio = height === 0 ? 1 : width / height;
          if (fit && this.aspectRatio > newRatio || !fit && this.aspectRatio < newRatio) {
            width = SnapFloor(width, snap.x);
            height = width / this.aspectRatio;
            if (snap.y > 0) {
              height = SnapFloor(height, snap.y);
              width = height * this.aspectRatio;
            }
          } else if (fit && this.aspectRatio < newRatio || !fit && this.aspectRatio > newRatio) {
            height = SnapFloor(height, snap.y);
            width = height * this.aspectRatio;
            if (snap.x > 0) {
              width = SnapFloor(width, snap.x);
              height = width * (1 / this.aspectRatio);
            }
          }
          this._width = width;
          this._height = height;
          return this;
        },
        fitTo: function(width, height) {
          return this.constrain(width, height, true);
        },
        envelop: function(width, height) {
          return this.constrain(width, height, false);
        },
        setWidth: function(value) {
          return this.setSize(value, this._height);
        },
        setHeight: function(value) {
          return this.setSize(this._width, value);
        },
        toString: function() {
          return "[{ Size (width=" + this._width + " height=" + this._height + " aspectRatio=" + this.aspectRatio + " aspectMode=" + this.aspectMode + ") }]";
        },
        setCSS: function(element) {
          if (element && element.style) {
            element.style.width = this._width + "px";
            element.style.height = this._height + "px";
          }
        },
        copy: function(destination) {
          destination.setAspectMode(this.aspectMode);
          destination.aspectRatio = this.aspectRatio;
          return destination.setSize(this.width, this.height);
        },
        destroy: function() {
          this._parent = null;
          this.snapTo = null;
        },
        width: {
          get: function() {
            return this._width;
          },
          set: function(value) {
            this.setSize(value, this._height);
          }
        },
        height: {
          get: function() {
            return this._height;
          },
          set: function(value) {
            this.setSize(this._width, value);
          }
        }
      });
      Size.NONE = 0;
      Size.WIDTH_CONTROLS_HEIGHT = 1;
      Size.HEIGHT_CONTROLS_WIDTH = 2;
      Size.FIT = 3;
      Size.ENVELOP = 4;
      module.exports = Size;
    }
  });

  // ../../node_modules/phaser/src/scale/ScaleManager.js
  var require_ScaleManager = __commonJS({
    "../../node_modules/phaser/src/scale/ScaleManager.js": function(exports, module) {
      var CONST = require_const9();
      var Class = require_Class();
      var EventEmitter = require_eventemitter3();
      var Events = require_events7();
      var GameEvents = require_events5();
      var GetInnerHeight = require_GetInnerHeight();
      var GetTarget = require_GetTarget();
      var GetScreenOrientation = require_GetScreenOrientation();
      var NOOP = require_NOOP();
      var Rectangle = require_Rectangle();
      var Size = require_Size2();
      var SnapFloor = require_SnapFloor();
      var Vector2 = require_Vector2();
      var Camera = require_Camera();
      var ScaleManager = new Class({
        Extends: EventEmitter,
        initialize: function ScaleManager2(game) {
          EventEmitter.call(this);
          this.game = game;
          this.canvas;
          this.canvasBounds = new Rectangle();
          this.parent = null;
          this.parentIsWindow = false;
          this.parentSize = new Size();
          this.gameSize = new Size();
          this.baseSize = new Size();
          this.displaySize = new Size();
          this.scaleMode = CONST.SCALE_MODE.NONE;
          this.zoom = 1;
          this._resetZoom = false;
          this.displayScale = new Vector2(1, 1);
          this.autoRound = false;
          this.autoCenter = CONST.CENTER.NO_CENTER;
          this.orientation = CONST.ORIENTATION.LANDSCAPE;
          this.fullscreen;
          this.fullscreenTarget = null;
          this._createdFullscreenTarget = false;
          this.dirty = false;
          this.resizeInterval = 500;
          this._lastCheck = 0;
          this._checkOrientation = false;
          this.domlisteners = {
            orientationChange: NOOP,
            windowResize: NOOP,
            fullScreenChange: NOOP,
            fullScreenError: NOOP
          };
        },
        preBoot: function() {
          this.parseConfig(this.game.config);
          this.game.events.once(GameEvents.BOOT, this.boot, this);
        },
        boot: function() {
          var game = this.game;
          this.canvas = game.canvas;
          this.fullscreen = game.device.fullscreen;
          if (this.scaleMode !== CONST.SCALE_MODE.RESIZE) {
            this.displaySize.setAspectMode(this.scaleMode);
          }
          if (this.scaleMode === CONST.SCALE_MODE.NONE) {
            this.resize(this.width, this.height);
          } else {
            this.getParentBounds();
            if (this.parentSize.width > 0 && this.parentSize.height > 0) {
              this.displaySize.setParent(this.parentSize);
            }
            this.refresh();
          }
          game.events.on(GameEvents.PRE_STEP, this.step, this);
          game.events.once(GameEvents.READY, this.refresh, this);
          game.events.once(GameEvents.DESTROY, this.destroy, this);
          this.startListeners();
        },
        parseConfig: function(config) {
          this.getParent(config);
          this.getParentBounds();
          var width = config.width;
          var height = config.height;
          var scaleMode = config.scaleMode;
          var zoom = config.zoom;
          var autoRound = config.autoRound;
          if (typeof width === "string") {
            var parentWidth = this.parentSize.width;
            if (parentWidth === 0) {
              parentWidth = window.innerWidth;
            }
            var parentScaleX = parseInt(width, 10) / 100;
            width = Math.floor(parentWidth * parentScaleX);
          }
          if (typeof height === "string") {
            var parentHeight = this.parentSize.height;
            if (parentHeight === 0) {
              parentHeight = window.innerHeight;
            }
            var parentScaleY = parseInt(height, 10) / 100;
            height = Math.floor(parentHeight * parentScaleY);
          }
          this.scaleMode = scaleMode;
          this.autoRound = autoRound;
          this.autoCenter = config.autoCenter;
          this.resizeInterval = config.resizeInterval;
          if (autoRound) {
            width = Math.floor(width);
            height = Math.floor(height);
          }
          this.gameSize.setSize(width, height);
          if (zoom === CONST.ZOOM.MAX_ZOOM) {
            zoom = this.getMaxZoom();
          }
          this.zoom = zoom;
          if (zoom !== 1) {
            this._resetZoom = true;
          }
          this.baseSize.setSize(width, height);
          if (autoRound) {
            this.baseSize.width = Math.floor(this.baseSize.width);
            this.baseSize.height = Math.floor(this.baseSize.height);
          }
          if (config.minWidth > 0) {
            this.displaySize.setMin(config.minWidth * zoom, config.minHeight * zoom);
          }
          if (config.maxWidth > 0) {
            this.displaySize.setMax(config.maxWidth * zoom, config.maxHeight * zoom);
          }
          this.displaySize.setSize(width, height);
          this.orientation = GetScreenOrientation(width, height);
        },
        getParent: function(config) {
          var parent = config.parent;
          if (parent === null) {
            return;
          }
          this.parent = GetTarget(parent);
          this.parentIsWindow = this.parent === document.body;
          if (config.expandParent && config.scaleMode !== CONST.SCALE_MODE.NONE) {
            var DOMRect = this.parent.getBoundingClientRect();
            if (this.parentIsWindow || DOMRect.height === 0) {
              document.documentElement.style.height = "100%";
              document.body.style.height = "100%";
              DOMRect = this.parent.getBoundingClientRect();
              if (!this.parentIsWindow && DOMRect.height === 0) {
                this.parent.style.overflow = "hidden";
                this.parent.style.width = "100%";
                this.parent.style.height = "100%";
              }
            }
          }
          if (config.fullscreenTarget && !this.fullscreenTarget) {
            this.fullscreenTarget = GetTarget(config.fullscreenTarget);
          }
        },
        getParentBounds: function() {
          if (!this.parent) {
            return false;
          }
          var parentSize = this.parentSize;
          var DOMRect = this.parent.getBoundingClientRect();
          if (this.parentIsWindow && this.game.device.os.iOS) {
            DOMRect.height = GetInnerHeight(true);
          }
          var newWidth = DOMRect.width;
          var newHeight = DOMRect.height;
          if (parentSize.width !== newWidth || parentSize.height !== newHeight) {
            parentSize.setSize(newWidth, newHeight);
            return true;
          } else if (this.canvas) {
            var canvasBounds = this.canvasBounds;
            var canvasRect = this.canvas.getBoundingClientRect();
            if (canvasRect.x !== canvasBounds.x || canvasRect.y !== canvasBounds.y) {
              return true;
            }
          }
          return false;
        },
        lockOrientation: function(orientation) {
          var lock = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;
          if (lock) {
            return lock.call(screen, orientation);
          }
          return false;
        },
        setParentSize: function(width, height) {
          this.parentSize.setSize(width, height);
          return this.refresh();
        },
        setGameSize: function(width, height) {
          var autoRound = this.autoRound;
          if (autoRound) {
            width = Math.floor(width);
            height = Math.floor(height);
          }
          var previousWidth = this.width;
          var previousHeight = this.height;
          this.gameSize.resize(width, height);
          this.baseSize.resize(width, height);
          if (autoRound) {
            this.baseSize.width = Math.floor(this.baseSize.width);
            this.baseSize.height = Math.floor(this.baseSize.height);
          }
          this.displaySize.setAspectRatio(width / height);
          this.canvas.width = this.baseSize.width;
          this.canvas.height = this.baseSize.height;
          return this.refresh(previousWidth, previousHeight);
        },
        resize: function(width, height) {
          var zoom = this.zoom;
          var autoRound = this.autoRound;
          if (autoRound) {
            width = Math.floor(width);
            height = Math.floor(height);
          }
          var previousWidth = this.width;
          var previousHeight = this.height;
          this.gameSize.resize(width, height);
          this.baseSize.resize(width, height);
          if (autoRound) {
            this.baseSize.width = Math.floor(this.baseSize.width);
            this.baseSize.height = Math.floor(this.baseSize.height);
          }
          this.displaySize.setSize(width * zoom, height * zoom);
          this.canvas.width = this.baseSize.width;
          this.canvas.height = this.baseSize.height;
          var style = this.canvas.style;
          var styleWidth = width * zoom;
          var styleHeight = height * zoom;
          if (autoRound) {
            styleWidth = Math.floor(styleWidth);
            styleHeight = Math.floor(styleHeight);
          }
          if (styleWidth !== width || styleHeight !== height) {
            style.width = styleWidth + "px";
            style.height = styleHeight + "px";
          }
          return this.refresh(previousWidth, previousHeight);
        },
        setZoom: function(value) {
          this.zoom = value;
          this._resetZoom = true;
          return this.refresh();
        },
        setMaxZoom: function() {
          this.zoom = this.getMaxZoom();
          this._resetZoom = true;
          return this.refresh();
        },
        refresh: function(previousWidth, previousHeight) {
          if (previousWidth === void 0) {
            previousWidth = this.width;
          }
          if (previousHeight === void 0) {
            previousHeight = this.height;
          }
          this.updateScale();
          this.updateBounds();
          this.updateOrientation();
          this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height);
          var domContainer = this.game.domContainer;
          if (domContainer) {
            this.baseSize.setCSS(domContainer);
            var canvasStyle = this.canvas.style;
            var domStyle = domContainer.style;
            domStyle.transform = "scale(" + this.displaySize.width / this.baseSize.width + "," + this.displaySize.height / this.baseSize.height + ")";
            domStyle.marginLeft = canvasStyle.marginLeft;
            domStyle.marginTop = canvasStyle.marginTop;
          }
          this.emit(Events.RESIZE, this.gameSize, this.baseSize, this.displaySize, previousWidth, previousHeight);
          return this;
        },
        updateOrientation: function() {
          if (this._checkOrientation) {
            this._checkOrientation = false;
            var newOrientation = GetScreenOrientation(this.width, this.height);
            if (newOrientation !== this.orientation) {
              this.orientation = newOrientation;
              this.emit(Events.ORIENTATION_CHANGE, newOrientation);
            }
          }
        },
        updateScale: function() {
          var style = this.canvas.style;
          var width = this.gameSize.width;
          var height = this.gameSize.height;
          var styleWidth;
          var styleHeight;
          var zoom = this.zoom;
          var autoRound = this.autoRound;
          if (this.scaleMode === CONST.SCALE_MODE.NONE) {
            this.displaySize.setSize(width * zoom, height * zoom);
            styleWidth = this.displaySize.width;
            styleHeight = this.displaySize.height;
            if (autoRound) {
              styleWidth = Math.floor(styleWidth);
              styleHeight = Math.floor(styleHeight);
            }
            if (this._resetZoom) {
              style.width = styleWidth + "px";
              style.height = styleHeight + "px";
              this._resetZoom = false;
            }
          } else if (this.scaleMode === CONST.SCALE_MODE.RESIZE) {
            this.displaySize.setSize(this.parentSize.width, this.parentSize.height);
            this.gameSize.setSize(this.displaySize.width, this.displaySize.height);
            this.baseSize.setSize(this.displaySize.width, this.displaySize.height);
            styleWidth = this.displaySize.width;
            styleHeight = this.displaySize.height;
            if (autoRound) {
              styleWidth = Math.floor(styleWidth);
              styleHeight = Math.floor(styleHeight);
            }
            this.canvas.width = styleWidth;
            this.canvas.height = styleHeight;
          } else {
            this.displaySize.setSize(this.parentSize.width, this.parentSize.height);
            styleWidth = this.displaySize.width;
            styleHeight = this.displaySize.height;
            if (autoRound) {
              styleWidth = Math.floor(styleWidth);
              styleHeight = Math.floor(styleHeight);
            }
            style.width = styleWidth + "px";
            style.height = styleHeight + "px";
          }
          this.getParentBounds();
          this.updateCenter();
        },
        getMaxZoom: function() {
          var zoomH = SnapFloor(this.parentSize.width, this.gameSize.width, 0, true);
          var zoomV = SnapFloor(this.parentSize.height, this.gameSize.height, 0, true);
          return Math.max(Math.min(zoomH, zoomV), 1);
        },
        updateCenter: function() {
          var autoCenter = this.autoCenter;
          if (autoCenter === CONST.CENTER.NO_CENTER) {
            return;
          }
          var canvas = this.canvas;
          var style = canvas.style;
          var bounds = canvas.getBoundingClientRect();
          var width = bounds.width;
          var height = bounds.height;
          var offsetX = Math.floor((this.parentSize.width - width) / 2);
          var offsetY = Math.floor((this.parentSize.height - height) / 2);
          if (autoCenter === CONST.CENTER.CENTER_HORIZONTALLY) {
            offsetY = 0;
          } else if (autoCenter === CONST.CENTER.CENTER_VERTICALLY) {
            offsetX = 0;
          }
          style.marginLeft = offsetX + "px";
          style.marginTop = offsetY + "px";
        },
        updateBounds: function() {
          var bounds = this.canvasBounds;
          var clientRect = this.canvas.getBoundingClientRect();
          bounds.x = clientRect.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0);
          bounds.y = clientRect.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0);
          bounds.width = clientRect.width;
          bounds.height = clientRect.height;
        },
        transformX: function(pageX) {
          return (pageX - this.canvasBounds.left) * this.displayScale.x;
        },
        transformY: function(pageY) {
          return (pageY - this.canvasBounds.top) * this.displayScale.y;
        },
        startFullscreen: function(fullscreenOptions) {
          if (fullscreenOptions === void 0) {
            fullscreenOptions = { navigationUI: "hide" };
          }
          var fullscreen = this.fullscreen;
          if (!fullscreen.available) {
            this.emit(Events.FULLSCREEN_UNSUPPORTED);
            return;
          }
          if (!fullscreen.active) {
            var fsTarget = this.getFullscreenTarget();
            if (fullscreen.keyboard) {
              fsTarget[fullscreen.request](Element.ALLOW_KEYBOARD_INPUT);
            } else {
              fsTarget[fullscreen.request](fullscreenOptions);
            }
          }
        },
        fullscreenSuccessHandler: function() {
          this.getParentBounds();
          this.refresh();
          this.emit(Events.ENTER_FULLSCREEN);
        },
        fullscreenErrorHandler: function(error) {
          this.removeFullscreenTarget();
          this.emit(Events.FULLSCREEN_FAILED, error);
        },
        getFullscreenTarget: function() {
          if (!this.fullscreenTarget) {
            var fsTarget = document.createElement("div");
            fsTarget.style.margin = "0";
            fsTarget.style.padding = "0";
            fsTarget.style.width = "100%";
            fsTarget.style.height = "100%";
            this.fullscreenTarget = fsTarget;
            this._createdFullscreenTarget = true;
          }
          if (this._createdFullscreenTarget) {
            var canvasParent = this.canvas.parentNode;
            canvasParent.insertBefore(this.fullscreenTarget, this.canvas);
            this.fullscreenTarget.appendChild(this.canvas);
          }
          return this.fullscreenTarget;
        },
        removeFullscreenTarget: function() {
          if (this._createdFullscreenTarget) {
            var fsTarget = this.fullscreenTarget;
            if (fsTarget && fsTarget.parentNode) {
              var parent = fsTarget.parentNode;
              parent.insertBefore(this.canvas, fsTarget);
              parent.removeChild(fsTarget);
            }
          }
        },
        stopFullscreen: function() {
          var fullscreen = this.fullscreen;
          if (!fullscreen.available) {
            this.emit(Events.FULLSCREEN_UNSUPPORTED);
            return false;
          }
          if (fullscreen.active) {
            document[fullscreen.cancel]();
          }
          this.removeFullscreenTarget();
          this.getParentBounds();
          this.emit(Events.LEAVE_FULLSCREEN);
          this.refresh();
        },
        toggleFullscreen: function(fullscreenOptions) {
          if (this.fullscreen.active) {
            this.stopFullscreen();
          } else {
            this.startFullscreen(fullscreenOptions);
          }
        },
        startListeners: function() {
          var _this = this;
          var listeners = this.domlisteners;
          listeners.orientationChange = function() {
            _this.updateBounds();
            _this._checkOrientation = true;
            _this.dirty = true;
          };
          listeners.windowResize = function() {
            _this.updateBounds();
            _this.dirty = true;
          };
          window.addEventListener("orientationchange", listeners.orientationChange, false);
          window.addEventListener("resize", listeners.windowResize, false);
          if (this.fullscreen.available) {
            listeners.fullScreenChange = function(event) {
              return _this.onFullScreenChange(event);
            };
            listeners.fullScreenError = function(event) {
              return _this.onFullScreenError(event);
            };
            var vendors = ["webkit", "moz", ""];
            vendors.forEach(function(prefix) {
              document.addEventListener(prefix + "fullscreenchange", listeners.fullScreenChange, false);
              document.addEventListener(prefix + "fullscreenerror", listeners.fullScreenError, false);
            });
            document.addEventListener("MSFullscreenChange", listeners.fullScreenChange, false);
            document.addEventListener("MSFullscreenError", listeners.fullScreenError, false);
          }
        },
        onFullScreenChange: function() {
          if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement) {
            this.fullscreenSuccessHandler();
          } else {
            this.stopFullscreen();
          }
        },
        onFullScreenError: function() {
          this.removeFullscreenTarget();
        },
        getViewPort: function(camera, out) {
          if (!(camera instanceof Camera)) {
            out = camera;
            camera = void 0;
          }
          if (out === void 0) {
            out = new Rectangle();
          }
          var baseSize = this.baseSize;
          var parentSize = this.parentSize;
          var canvasBounds = this.canvasBounds;
          var displayScale = this.displayScale;
          var x = canvasBounds.x >= 0 ? 0 : -(canvasBounds.x * displayScale.x);
          var y = canvasBounds.y >= 0 ? 0 : -(canvasBounds.y * displayScale.y);
          var width;
          if (parentSize.width >= canvasBounds.width) {
            width = baseSize.width;
          } else {
            width = baseSize.width - (canvasBounds.width - parentSize.width) * displayScale.x;
          }
          var height;
          if (parentSize.height >= canvasBounds.height) {
            height = baseSize.height;
          } else {
            height = baseSize.height - (canvasBounds.height - parentSize.height) * displayScale.y;
          }
          out.setTo(x, y, width, height);
          if (camera) {
            out.width /= camera.zoomX;
            out.height /= camera.zoomY;
            out.centerX = camera.centerX + camera.scrollX;
            out.centerY = camera.centerY + camera.scrollY;
          }
          return out;
        },
        step: function(time, delta) {
          if (!this.parent) {
            return;
          }
          this._lastCheck += delta;
          if (this.dirty || this._lastCheck > this.resizeInterval) {
            if (this.getParentBounds()) {
              this.refresh();
            }
            this.dirty = false;
            this._lastCheck = 0;
          }
        },
        stopListeners: function() {
          var listeners = this.domlisteners;
          window.removeEventListener("orientationchange", listeners.orientationChange, false);
          window.removeEventListener("resize", listeners.windowResize, false);
          var vendors = ["webkit", "moz", ""];
          vendors.forEach(function(prefix) {
            document.removeEventListener(prefix + "fullscreenchange", listeners.fullScreenChange, false);
            document.removeEventListener(prefix + "fullscreenerror", listeners.fullScreenError, false);
          });
          document.removeEventListener("MSFullscreenChange", listeners.fullScreenChange, false);
          document.removeEventListener("MSFullscreenError", listeners.fullScreenError, false);
        },
        destroy: function() {
          this.removeAllListeners();
          this.stopListeners();
          this.game = null;
          this.canvas = null;
          this.canvasBounds = null;
          this.parent = null;
          this.fullscreenTarget = null;
          this.parentSize.destroy();
          this.gameSize.destroy();
          this.baseSize.destroy();
          this.displaySize.destroy();
        },
        isFullscreen: {
          get: function() {
            return this.fullscreen.active;
          }
        },
        width: {
          get: function() {
            return this.gameSize.width;
          }
        },
        height: {
          get: function() {
            return this.gameSize.height;
          }
        },
        isPortrait: {
          get: function() {
            return this.orientation === CONST.ORIENTATION.PORTRAIT;
          }
        },
        isLandscape: {
          get: function() {
            return this.orientation === CONST.ORIENTATION.LANDSCAPE;
          }
        },
        isGamePortrait: {
          get: function() {
            return this.height > this.width;
          }
        },
        isGameLandscape: {
          get: function() {
            return this.width > this.height;
          }
        }
      });
      module.exports = ScaleManager;
    }
  });

  // ../../node_modules/phaser/src/scene/const.js
  var require_const10 = __commonJS({
    "../../node_modules/phaser/src/scene/const.js": function(exports, module) {
      var CONST = {
        PENDING: 0,
        INIT: 1,
        START: 2,
        LOADING: 3,
        CREATING: 4,
        RUNNING: 5,
        PAUSED: 6,
        SLEEPING: 7,
        SHUTDOWN: 8,
        DESTROYED: 9
      };
      module.exports = CONST;
    }
  });

  // ../../node_modules/phaser/src/loader/events/ADD_EVENT.js
  var require_ADD_EVENT3 = __commonJS({
    "../../node_modules/phaser/src/loader/events/ADD_EVENT.js": function(exports, module) {
      module.exports = "addfile";
    }
  });

  // ../../node_modules/phaser/src/loader/events/COMPLETE_EVENT.js
  var require_COMPLETE_EVENT = __commonJS({
    "../../node_modules/phaser/src/loader/events/COMPLETE_EVENT.js": function(exports, module) {
      module.exports = "complete";
    }
  });

  // ../../node_modules/phaser/src/loader/events/FILE_COMPLETE_EVENT.js
  var require_FILE_COMPLETE_EVENT = __commonJS({
    "../../node_modules/phaser/src/loader/events/FILE_COMPLETE_EVENT.js": function(exports, module) {
      module.exports = "filecomplete";
    }
  });

  // ../../node_modules/phaser/src/loader/events/FILE_KEY_COMPLETE_EVENT.js
  var require_FILE_KEY_COMPLETE_EVENT = __commonJS({
    "../../node_modules/phaser/src/loader/events/FILE_KEY_COMPLETE_EVENT.js": function(exports, module) {
      module.exports = "filecomplete-";
    }
  });

  // ../../node_modules/phaser/src/loader/events/FILE_LOAD_ERROR_EVENT.js
  var require_FILE_LOAD_ERROR_EVENT = __commonJS({
    "../../node_modules/phaser/src/loader/events/FILE_LOAD_ERROR_EVENT.js": function(exports, module) {
      module.exports = "loaderror";
    }
  });

  // ../../node_modules/phaser/src/loader/events/FILE_LOAD_EVENT.js
  var require_FILE_LOAD_EVENT = __commonJS({
    "../../node_modules/phaser/src/loader/events/FILE_LOAD_EVENT.js": function(exports, module) {
      module.exports = "load";
    }
  });

  // ../../node_modules/phaser/src/loader/events/FILE_PROGRESS_EVENT.js
  var require_FILE_PROGRESS_EVENT = __commonJS({
    "../../node_modules/phaser/src/loader/events/FILE_PROGRESS_EVENT.js": function(exports, module) {
      module.exports = "fileprogress";
    }
  });

  // ../../node_modules/phaser/src/loader/events/POST_PROCESS_EVENT.js
  var require_POST_PROCESS_EVENT = __commonJS({
    "../../node_modules/phaser/src/loader/events/POST_PROCESS_EVENT.js": function(exports, module) {
      module.exports = "postprocess";
    }
  });

  // ../../node_modules/phaser/src/loader/events/PROGRESS_EVENT.js
  var require_PROGRESS_EVENT = __commonJS({
    "../../node_modules/phaser/src/loader/events/PROGRESS_EVENT.js": function(exports, module) {
      module.exports = "progress";
    }
  });

  // ../../node_modules/phaser/src/loader/events/START_EVENT.js
  var require_START_EVENT3 = __commonJS({
    "../../node_modules/phaser/src/loader/events/START_EVENT.js": function(exports, module) {
      module.exports = "start";
    }
  });

  // ../../node_modules/phaser/src/loader/events/index.js
  var require_events14 = __commonJS({
    "../../node_modules/phaser/src/loader/events/index.js": function(exports, module) {
      module.exports = {
        ADD: require_ADD_EVENT3(),
        COMPLETE: require_COMPLETE_EVENT(),
        FILE_COMPLETE: require_FILE_COMPLETE_EVENT(),
        FILE_KEY_COMPLETE: require_FILE_KEY_COMPLETE_EVENT(),
        FILE_LOAD_ERROR: require_FILE_LOAD_ERROR_EVENT(),
        FILE_LOAD: require_FILE_LOAD_EVENT(),
        FILE_PROGRESS: require_FILE_PROGRESS_EVENT(),
        POST_PROCESS: require_POST_PROCESS_EVENT(),
        PROGRESS: require_PROGRESS_EVENT(),
        START: require_START_EVENT3()
      };
    }
  });

  // ../../node_modules/phaser/src/utils/string/UppercaseFirst.js
  var require_UppercaseFirst = __commonJS({
    "../../node_modules/phaser/src/utils/string/UppercaseFirst.js": function(exports, module) {
      var UppercaseFirst = function(str) {
        return str && str[0].toUpperCase() + str.slice(1);
      };
      module.exports = UppercaseFirst;
    }
  });

  // ../../node_modules/phaser/src/scene/GetPhysicsPlugins.js
  var require_GetPhysicsPlugins = __commonJS({
    "../../node_modules/phaser/src/scene/GetPhysicsPlugins.js": function(exports, module) {
      var GetFastValue = require_GetFastValue();
      var UppercaseFirst = require_UppercaseFirst();
      var GetPhysicsPlugins = function(sys) {
        var defaultSystem = sys.game.config.defaultPhysicsSystem;
        var sceneSystems = GetFastValue(sys.settings, "physics", false);
        if (!defaultSystem && !sceneSystems) {
          return;
        }
        var output = [];
        if (defaultSystem) {
          output.push(UppercaseFirst(defaultSystem + "Physics"));
        }
        if (sceneSystems) {
          for (var key in sceneSystems) {
            key = UppercaseFirst(key.concat("Physics"));
            if (output.indexOf(key) === -1) {
              output.push(key);
            }
          }
        }
        return output;
      };
      module.exports = GetPhysicsPlugins;
    }
  });

  // ../../node_modules/phaser/src/scene/GetScenePlugins.js
  var require_GetScenePlugins = __commonJS({
    "../../node_modules/phaser/src/scene/GetScenePlugins.js": function(exports, module) {
      var GetFastValue = require_GetFastValue();
      var GetScenePlugins = function(sys) {
        var defaultPlugins = sys.plugins.getDefaultScenePlugins();
        var scenePlugins = GetFastValue(sys.settings, "plugins", false);
        if (Array.isArray(scenePlugins)) {
          return scenePlugins;
        } else if (defaultPlugins) {
          return defaultPlugins;
        } else {
          return [];
        }
      };
      module.exports = GetScenePlugins;
    }
  });

  // ../../node_modules/phaser/src/utils/object/Clone.js
  var require_Clone = __commonJS({
    "../../node_modules/phaser/src/utils/object/Clone.js": function(exports, module) {
      var Clone = function(obj) {
        var clone = {};
        for (var key in obj) {
          if (Array.isArray(obj[key])) {
            clone[key] = obj[key].slice(0);
          } else {
            clone[key] = obj[key];
          }
        }
        return clone;
      };
      module.exports = Clone;
    }
  });

  // ../../node_modules/phaser/src/utils/object/Merge.js
  var require_Merge = __commonJS({
    "../../node_modules/phaser/src/utils/object/Merge.js": function(exports, module) {
      var Clone = require_Clone();
      var Merge = function(obj1, obj2) {
        var clone = Clone(obj1);
        for (var key in obj2) {
          if (!clone.hasOwnProperty(key)) {
            clone[key] = obj2[key];
          }
        }
        return clone;
      };
      module.exports = Merge;
    }
  });

  // ../../node_modules/phaser/src/scene/InjectionMap.js
  var require_InjectionMap = __commonJS({
    "../../node_modules/phaser/src/scene/InjectionMap.js": function(exports, module) {
      var InjectionMap = {
        game: "game",
        renderer: "renderer",
        anims: "anims",
        cache: "cache",
        plugins: "plugins",
        registry: "registry",
        scale: "scale",
        sound: "sound",
        textures: "textures",
        events: "events",
        cameras: "cameras",
        add: "add",
        make: "make",
        scenePlugin: "scene",
        displayList: "children",
        lights: "lights",
        data: "data",
        input: "input",
        load: "load",
        time: "time",
        tweens: "tweens",
        arcadePhysics: "physics",
        impactPhysics: "impact",
        matterPhysics: "matter"
      };
      if (false) {
        InjectionMap.cameras3d = "cameras3d";
      }
      if (false) {
        InjectionMap.facebook = "facebook";
      }
      module.exports = InjectionMap;
    }
  });

  // ../../node_modules/phaser/src/scene/Settings.js
  var require_Settings = __commonJS({
    "../../node_modules/phaser/src/scene/Settings.js": function(exports, module) {
      var CONST = require_const10();
      var GetValue = require_GetValue();
      var Merge = require_Merge();
      var InjectionMap = require_InjectionMap();
      var Settings = {
        create: function(config) {
          if (typeof config === "string") {
            config = { key: config };
          } else if (config === void 0) {
            config = {};
          }
          return {
            status: CONST.PENDING,
            key: GetValue(config, "key", ""),
            active: GetValue(config, "active", false),
            visible: GetValue(config, "visible", true),
            isBooted: false,
            isTransition: false,
            transitionFrom: null,
            transitionDuration: 0,
            transitionAllowInput: true,
            data: {},
            pack: GetValue(config, "pack", false),
            cameras: GetValue(config, "cameras", null),
            map: GetValue(config, "map", Merge(InjectionMap, GetValue(config, "mapAdd", {}))),
            physics: GetValue(config, "physics", {}),
            loader: GetValue(config, "loader", {}),
            plugins: GetValue(config, "plugins", false),
            input: GetValue(config, "input", {})
          };
        }
      };
      module.exports = Settings;
    }
  });

  // ../../node_modules/phaser/src/scene/Systems.js
  var require_Systems = __commonJS({
    "../../node_modules/phaser/src/scene/Systems.js": function(exports, module) {
      var Class = require_Class();
      var CONST = require_const10();
      var DefaultPlugins = require_DefaultPlugins();
      var Events = require_events();
      var GetPhysicsPlugins = require_GetPhysicsPlugins();
      var GetScenePlugins = require_GetScenePlugins();
      var NOOP = require_NOOP();
      var Settings = require_Settings();
      var Systems = new Class({
        initialize: function Systems2(scene, config) {
          this.scene = scene;
          this.game;
          this.renderer;
          if (false) {
            this.facebook;
          }
          this.config = config;
          this.settings = Settings.create(config);
          this.canvas;
          this.context;
          this.anims;
          this.cache;
          this.plugins;
          this.registry;
          this.scale;
          this.sound;
          this.textures;
          this.add;
          this.cameras;
          this.displayList;
          this.events;
          this.make;
          this.scenePlugin;
          this.updateList;
          this.sceneUpdate = NOOP;
        },
        init: function(game) {
          this.settings.status = CONST.INIT;
          this.sceneUpdate = NOOP;
          this.game = game;
          this.renderer = game.renderer;
          this.canvas = game.canvas;
          this.context = game.context;
          var pluginManager = game.plugins;
          this.plugins = pluginManager;
          pluginManager.addToScene(this, DefaultPlugins.Global, [DefaultPlugins.CoreScene, GetScenePlugins(this), GetPhysicsPlugins(this)]);
          this.events.emit(Events.BOOT, this);
          this.settings.isBooted = true;
        },
        step: function(time, delta) {
          var events = this.events;
          events.emit(Events.PRE_UPDATE, time, delta);
          events.emit(Events.UPDATE, time, delta);
          this.sceneUpdate.call(this.scene, time, delta);
          events.emit(Events.POST_UPDATE, time, delta);
        },
        render: function(renderer) {
          var displayList = this.displayList;
          displayList.depthSort();
          this.events.emit(Events.PRE_RENDER, renderer);
          this.cameras.render(renderer, displayList);
          this.events.emit(Events.RENDER, renderer);
        },
        queueDepthSort: function() {
          this.displayList.queueDepthSort();
        },
        depthSort: function() {
          this.displayList.depthSort();
        },
        pause: function(data) {
          var settings = this.settings;
          var status = this.getStatus();
          if (status !== CONST.CREATING && status !== CONST.RUNNING) {
            console.warn("Cannot pause non-running Scene", settings.key);
          } else if (this.settings.active) {
            settings.status = CONST.PAUSED;
            settings.active = false;
            this.events.emit(Events.PAUSE, this, data);
          }
          return this;
        },
        resume: function(data) {
          var events = this.events;
          var settings = this.settings;
          if (!this.settings.active) {
            settings.status = CONST.RUNNING;
            settings.active = true;
            events.emit(Events.RESUME, this, data);
          }
          return this;
        },
        sleep: function(data) {
          var settings = this.settings;
          var status = this.getStatus();
          if (status !== CONST.CREATING && status !== CONST.RUNNING) {
            console.warn("Cannot sleep non-running Scene", settings.key);
          } else {
            settings.status = CONST.SLEEPING;
            settings.active = false;
            settings.visible = false;
            this.events.emit(Events.SLEEP, this, data);
          }
          return this;
        },
        wake: function(data) {
          var events = this.events;
          var settings = this.settings;
          settings.status = CONST.RUNNING;
          settings.active = true;
          settings.visible = true;
          events.emit(Events.WAKE, this, data);
          if (settings.isTransition) {
            events.emit(Events.TRANSITION_WAKE, settings.transitionFrom, settings.transitionDuration);
          }
          return this;
        },
        getData: function() {
          return this.settings.data;
        },
        getStatus: function() {
          return this.settings.status;
        },
        canInput: function() {
          var status = this.settings.status;
          return status > CONST.PENDING && status <= CONST.RUNNING;
        },
        isSleeping: function() {
          return this.settings.status === CONST.SLEEPING;
        },
        isActive: function() {
          return this.settings.status === CONST.RUNNING;
        },
        isPaused: function() {
          return this.settings.status === CONST.PAUSED;
        },
        isTransitioning: function() {
          return this.settings.isTransition || this.scenePlugin._target !== null;
        },
        isTransitionOut: function() {
          return this.scenePlugin._target !== null && this.scenePlugin._duration > 0;
        },
        isTransitionIn: function() {
          return this.settings.isTransition;
        },
        isVisible: function() {
          return this.settings.visible;
        },
        setVisible: function(value) {
          this.settings.visible = value;
          return this;
        },
        setActive: function(value, data) {
          if (value) {
            return this.resume(data);
          } else {
            return this.pause(data);
          }
        },
        start: function(data) {
          var events = this.events;
          var settings = this.settings;
          if (data) {
            settings.data = data;
          }
          settings.status = CONST.START;
          settings.active = true;
          settings.visible = true;
          events.emit(Events.START, this);
          events.emit(Events.READY, this, data);
        },
        shutdown: function(data) {
          var events = this.events;
          var settings = this.settings;
          events.off(Events.TRANSITION_INIT);
          events.off(Events.TRANSITION_START);
          events.off(Events.TRANSITION_COMPLETE);
          events.off(Events.TRANSITION_OUT);
          settings.status = CONST.SHUTDOWN;
          settings.active = false;
          settings.visible = false;
          events.emit(Events.SHUTDOWN, this, data);
        },
        destroy: function() {
          var events = this.events;
          var settings = this.settings;
          settings.status = CONST.DESTROYED;
          settings.active = false;
          settings.visible = false;
          events.emit(Events.DESTROY, this);
          events.removeAllListeners();
          var props = ["scene", "game", "anims", "cache", "plugins", "registry", "sound", "textures", "add", "camera", "displayList", "events", "make", "scenePlugin", "updateList"];
          for (var i = 0; i < props.length; i++) {
            this[props[i]] = null;
          }
        }
      });
      module.exports = Systems;
    }
  });

  // ../../node_modules/phaser/src/scene/Scene.js
  var require_Scene = __commonJS({
    "../../node_modules/phaser/src/scene/Scene.js": function(exports, module) {
      var Class = require_Class();
      var Systems = require_Systems();
      var Scene = new Class({
        initialize: function Scene2(config) {
          this.sys = new Systems(this, config);
          this.game;
          this.anims;
          this.cache;
          this.registry;
          this.sound;
          this.textures;
          this.events;
          this.cameras;
          this.add;
          this.make;
          this.scene;
          this.children;
          this.lights;
          this.data;
          this.input;
          this.load;
          this.time;
          this.tweens;
          this.physics;
          this.matter;
          if (false) {
            this.facebook;
          }
          this.scale;
          this.plugins;
          this.renderer;
        },
        update: function() {
        }
      });
      module.exports = Scene;
    }
  });

  // ../../node_modules/phaser/src/scene/SceneManager.js
  var require_SceneManager = __commonJS({
    "../../node_modules/phaser/src/scene/SceneManager.js": function(exports, module) {
      var Class = require_Class();
      var CONST = require_const10();
      var Events = require_events();
      var GameEvents = require_events5();
      var GetValue = require_GetValue();
      var LoaderEvents = require_events14();
      var NOOP = require_NOOP();
      var Scene = require_Scene();
      var Systems = require_Systems();
      var SceneManager = new Class({
        initialize: function SceneManager2(game, sceneConfig) {
          this.game = game;
          this.keys = {};
          this.scenes = [];
          this._pending = [];
          this._start = [];
          this._queue = [];
          this._data = {};
          this.isProcessing = false;
          this.isBooted = false;
          this.customViewports = 0;
          this.systemScene;
          if (sceneConfig) {
            if (!Array.isArray(sceneConfig)) {
              sceneConfig = [sceneConfig];
            }
            for (var i = 0; i < sceneConfig.length; i++) {
              this._pending.push({
                key: "default",
                scene: sceneConfig[i],
                autoStart: i === 0,
                data: {}
              });
            }
          }
          game.events.once(GameEvents.READY, this.bootQueue, this);
        },
        bootQueue: function() {
          if (this.isBooted) {
            return;
          }
          this.systemScene = this.createSceneFromInstance("__SYSTEM", new Scene());
          var i;
          var entry;
          var key;
          var sceneConfig;
          for (i = 0; i < this._pending.length; i++) {
            entry = this._pending[i];
            key = entry.key;
            sceneConfig = entry.scene;
            var newScene;
            if (sceneConfig instanceof Scene) {
              newScene = this.createSceneFromInstance(key, sceneConfig);
            } else if (typeof sceneConfig === "object") {
              newScene = this.createSceneFromObject(key, sceneConfig);
            } else if (typeof sceneConfig === "function") {
              newScene = this.createSceneFromFunction(key, sceneConfig);
            }
            key = newScene.sys.settings.key;
            this.keys[key] = newScene;
            this.scenes.push(newScene);
            if (this._data[key]) {
              newScene.sys.settings.data = this._data[key].data;
              if (this._data[key].autoStart) {
                entry.autoStart = true;
              }
            }
            if (entry.autoStart || newScene.sys.settings.active) {
              this._start.push(key);
            }
          }
          this._pending.length = 0;
          this._data = {};
          this.isBooted = true;
          for (i = 0; i < this._start.length; i++) {
            entry = this._start[i];
            this.start(entry);
          }
          this._start.length = 0;
        },
        processQueue: function() {
          var pendingLength = this._pending.length;
          var queueLength = this._queue.length;
          if (pendingLength === 0 && queueLength === 0) {
            return;
          }
          var i;
          var entry;
          if (pendingLength) {
            for (i = 0; i < pendingLength; i++) {
              entry = this._pending[i];
              this.add(entry.key, entry.scene, entry.autoStart, entry.data);
            }
            for (i = 0; i < this._start.length; i++) {
              entry = this._start[i];
              this.start(entry);
            }
            this._start.length = 0;
            this._pending.length = 0;
          }
          for (i = 0; i < this._queue.length; i++) {
            entry = this._queue[i];
            this[entry.op](entry.keyA, entry.keyB);
          }
          this._queue.length = 0;
        },
        add: function(key, sceneConfig, autoStart, data) {
          if (autoStart === void 0) {
            autoStart = false;
          }
          if (data === void 0) {
            data = {};
          }
          if (this.isProcessing || !this.isBooted) {
            this._pending.push({
              key: key,
              scene: sceneConfig,
              autoStart: autoStart,
              data: data
            });
            if (!this.isBooted) {
              this._data[key] = { data: data };
            }
            return null;
          }
          key = this.getKey(key, sceneConfig);
          var newScene;
          if (sceneConfig instanceof Scene) {
            newScene = this.createSceneFromInstance(key, sceneConfig);
          } else if (typeof sceneConfig === "object") {
            sceneConfig.key = key;
            newScene = this.createSceneFromObject(key, sceneConfig);
          } else if (typeof sceneConfig === "function") {
            newScene = this.createSceneFromFunction(key, sceneConfig);
          }
          newScene.sys.settings.data = data;
          key = newScene.sys.settings.key;
          this.keys[key] = newScene;
          this.scenes.push(newScene);
          if (autoStart || newScene.sys.settings.active) {
            if (this._pending.length) {
              this._start.push(key);
            } else {
              this.start(key);
            }
          }
          return newScene;
        },
        remove: function(key) {
          if (this.isProcessing) {
            this._queue.push({ op: "remove", keyA: key, keyB: null });
          } else {
            var sceneToRemove = this.getScene(key);
            if (!sceneToRemove || sceneToRemove.sys.isTransitioning()) {
              return this;
            }
            var index = this.scenes.indexOf(sceneToRemove);
            var sceneKey = sceneToRemove.sys.settings.key;
            if (index > -1) {
              delete this.keys[sceneKey];
              this.scenes.splice(index, 1);
              if (this._start.indexOf(sceneKey) > -1) {
                index = this._start.indexOf(sceneKey);
                this._start.splice(index, 1);
              }
              sceneToRemove.sys.destroy();
            }
          }
          return this;
        },
        bootScene: function(scene) {
          var sys = scene.sys;
          var settings = sys.settings;
          sys.sceneUpdate = NOOP;
          if (scene.init) {
            scene.init.call(scene, settings.data);
            settings.status = CONST.INIT;
            if (settings.isTransition) {
              sys.events.emit(Events.TRANSITION_INIT, settings.transitionFrom, settings.transitionDuration);
            }
          }
          var loader;
          if (sys.load) {
            loader = sys.load;
            loader.reset();
          }
          if (loader && scene.preload) {
            scene.preload.call(scene);
            settings.status = CONST.LOADING;
            loader.once(LoaderEvents.COMPLETE, this.loadComplete, this);
            loader.start();
          } else {
            this.create(scene);
          }
        },
        loadComplete: function(loader) {
          if (this.game.sound && this.game.sound.onBlurPausedSounds) {
            this.game.sound.unlock();
          }
          this.create(loader.scene);
        },
        payloadComplete: function(loader) {
          this.bootScene(loader.scene);
        },
        update: function(time, delta) {
          this.processQueue();
          this.isProcessing = true;
          for (var i = this.scenes.length - 1; i >= 0; i--) {
            var sys = this.scenes[i].sys;
            if (sys.settings.status > CONST.START && sys.settings.status <= CONST.RUNNING) {
              sys.step(time, delta);
            }
            if (sys.scenePlugin._target) {
              sys.scenePlugin.step(time, delta);
            }
          }
        },
        render: function(renderer) {
          for (var i = 0; i < this.scenes.length; i++) {
            var sys = this.scenes[i].sys;
            if (sys.settings.visible && sys.settings.status >= CONST.LOADING && sys.settings.status < CONST.SLEEPING) {
              sys.render(renderer);
            }
          }
          this.isProcessing = false;
        },
        create: function(scene) {
          var sys = scene.sys;
          var settings = sys.settings;
          if (scene.create) {
            settings.status = CONST.CREATING;
            scene.create.call(scene, settings.data);
            if (settings.status === CONST.DESTROYED) {
              return;
            }
          }
          if (settings.isTransition) {
            sys.events.emit(Events.TRANSITION_START, settings.transitionFrom, settings.transitionDuration);
          }
          if (scene.update) {
            sys.sceneUpdate = scene.update;
          }
          settings.status = CONST.RUNNING;
          sys.events.emit(Events.CREATE, scene);
        },
        createSceneFromFunction: function(key, scene) {
          var newScene = new scene();
          if (newScene instanceof Scene) {
            var configKey = newScene.sys.settings.key;
            if (configKey !== "") {
              key = configKey;
            }
            if (this.keys.hasOwnProperty(key)) {
              throw new Error("Cannot add a Scene with duplicate key: " + key);
            }
            return this.createSceneFromInstance(key, newScene);
          } else {
            newScene.sys = new Systems(newScene);
            newScene.sys.settings.key = key;
            newScene.sys.init(this.game);
            return newScene;
          }
        },
        createSceneFromInstance: function(key, newScene) {
          var configKey = newScene.sys.settings.key;
          if (configKey === "") {
            newScene.sys.settings.key = key;
          }
          newScene.sys.init(this.game);
          return newScene;
        },
        createSceneFromObject: function(key, sceneConfig) {
          var newScene = new Scene(sceneConfig);
          var configKey = newScene.sys.settings.key;
          if (configKey !== "") {
            key = configKey;
          } else {
            newScene.sys.settings.key = key;
          }
          newScene.sys.init(this.game);
          var defaults = ["init", "preload", "create", "update", "render"];
          for (var i = 0; i < defaults.length; i++) {
            var sceneCallback = GetValue(sceneConfig, defaults[i], null);
            if (sceneCallback) {
              newScene[defaults[i]] = sceneCallback;
            }
          }
          if (sceneConfig.hasOwnProperty("extend")) {
            for (var propertyKey in sceneConfig.extend) {
              if (!sceneConfig.extend.hasOwnProperty(propertyKey)) {
                continue;
              }
              var value = sceneConfig.extend[propertyKey];
              if (propertyKey === "data" && newScene.hasOwnProperty("data") && typeof value === "object") {
                newScene.data.merge(value);
              } else if (propertyKey !== "sys") {
                newScene[propertyKey] = value;
              }
            }
          }
          return newScene;
        },
        getKey: function(key, sceneConfig) {
          if (!key) {
            key = "default";
          }
          if (typeof sceneConfig === "function") {
            return key;
          } else if (sceneConfig instanceof Scene) {
            key = sceneConfig.sys.settings.key;
          } else if (typeof sceneConfig === "object" && sceneConfig.hasOwnProperty("key")) {
            key = sceneConfig.key;
          }
          if (this.keys.hasOwnProperty(key)) {
            throw new Error("Cannot add a Scene with duplicate key: " + key);
          } else {
            return key;
          }
        },
        getScenes: function(isActive, inReverse) {
          if (isActive === void 0) {
            isActive = true;
          }
          if (inReverse === void 0) {
            inReverse = false;
          }
          var out = [];
          var scenes = this.scenes;
          for (var i = 0; i < scenes.length; i++) {
            var scene = scenes[i];
            if (scene && (!isActive || isActive && scene.sys.isActive())) {
              out.push(scene);
            }
          }
          return inReverse ? out.reverse() : out;
        },
        getScene: function(key) {
          if (typeof key === "string") {
            if (this.keys[key]) {
              return this.keys[key];
            }
          } else {
            for (var i = 0; i < this.scenes.length; i++) {
              if (key === this.scenes[i]) {
                return key;
              }
            }
          }
          return null;
        },
        isActive: function(key) {
          var scene = this.getScene(key);
          if (scene) {
            return scene.sys.isActive();
          }
          return null;
        },
        isPaused: function(key) {
          var scene = this.getScene(key);
          if (scene) {
            return scene.sys.isPaused();
          }
          return null;
        },
        isVisible: function(key) {
          var scene = this.getScene(key);
          if (scene) {
            return scene.sys.isVisible();
          }
          return null;
        },
        isSleeping: function(key) {
          var scene = this.getScene(key);
          if (scene) {
            return scene.sys.isSleeping();
          }
          return null;
        },
        pause: function(key, data) {
          var scene = this.getScene(key);
          if (scene) {
            scene.sys.pause(data);
          }
          return this;
        },
        resume: function(key, data) {
          var scene = this.getScene(key);
          if (scene) {
            scene.sys.resume(data);
          }
          return this;
        },
        sleep: function(key, data) {
          var scene = this.getScene(key);
          if (scene && !scene.sys.isTransitioning()) {
            scene.sys.sleep(data);
          }
          return this;
        },
        wake: function(key, data) {
          var scene = this.getScene(key);
          if (scene) {
            scene.sys.wake(data);
          }
          return this;
        },
        run: function(key, data) {
          var scene = this.getScene(key);
          if (!scene) {
            for (var i = 0; i < this._pending.length; i++) {
              if (this._pending[i].key === key) {
                this.queueOp("start", key, data);
                break;
              }
            }
            return this;
          }
          if (scene.sys.isSleeping()) {
            scene.sys.wake(data);
          } else if (scene.sys.isPaused()) {
            scene.sys.resume(data);
          } else {
            this.start(key, data);
          }
        },
        start: function(key, data) {
          if (!this.isBooted) {
            this._data[key] = {
              autoStart: true,
              data: data
            };
            return this;
          }
          var scene = this.getScene(key);
          if (!scene) {
            console.warn("Scene not found for key: " + key);
            return this;
          }
          var sys = scene.sys;
          var status = sys.settings.status;
          if (status >= CONST.START && status <= CONST.CREATING) {
            return this;
          } else if (status >= CONST.RUNNING && status <= CONST.SLEEPING) {
            sys.shutdown();
            sys.sceneUpdate = NOOP;
            sys.start(data);
          } else {
            sys.sceneUpdate = NOOP;
            sys.start(data);
            var loader;
            if (sys.load) {
              loader = sys.load;
            }
            if (loader && sys.settings.hasOwnProperty("pack")) {
              loader.reset();
              if (loader.addPack({ payload: sys.settings.pack })) {
                sys.settings.status = CONST.LOADING;
                loader.once(LoaderEvents.COMPLETE, this.payloadComplete, this);
                loader.start();
                return this;
              }
            }
          }
          this.bootScene(scene);
          return this;
        },
        stop: function(key, data) {
          var scene = this.getScene(key);
          if (scene && !scene.sys.isTransitioning() && scene.sys.settings.status !== CONST.SHUTDOWN) {
            var loader = scene.sys.load;
            loader.off(LoaderEvents.COMPLETE, this.loadComplete, this);
            loader.off(LoaderEvents.COMPLETE, this.payloadComplete, this);
            scene.sys.shutdown(data);
          }
          return this;
        },
        switch: function(from, to) {
          var sceneA = this.getScene(from);
          var sceneB = this.getScene(to);
          if (sceneA && sceneB && sceneA !== sceneB) {
            this.sleep(from);
            if (this.isSleeping(to)) {
              this.wake(to);
            } else {
              this.start(to);
            }
          }
          return this;
        },
        getAt: function(index) {
          return this.scenes[index];
        },
        getIndex: function(key) {
          var scene = this.getScene(key);
          return this.scenes.indexOf(scene);
        },
        bringToTop: function(key) {
          if (this.isProcessing) {
            this._queue.push({ op: "bringToTop", keyA: key, keyB: null });
          } else {
            var index = this.getIndex(key);
            if (index !== -1 && index < this.scenes.length) {
              var scene = this.getScene(key);
              this.scenes.splice(index, 1);
              this.scenes.push(scene);
            }
          }
          return this;
        },
        sendToBack: function(key) {
          if (this.isProcessing) {
            this._queue.push({ op: "sendToBack", keyA: key, keyB: null });
          } else {
            var index = this.getIndex(key);
            if (index !== -1 && index > 0) {
              var scene = this.getScene(key);
              this.scenes.splice(index, 1);
              this.scenes.unshift(scene);
            }
          }
          return this;
        },
        moveDown: function(key) {
          if (this.isProcessing) {
            this._queue.push({ op: "moveDown", keyA: key, keyB: null });
          } else {
            var indexA = this.getIndex(key);
            if (indexA > 0) {
              var indexB = indexA - 1;
              var sceneA = this.getScene(key);
              var sceneB = this.getAt(indexB);
              this.scenes[indexA] = sceneB;
              this.scenes[indexB] = sceneA;
            }
          }
          return this;
        },
        moveUp: function(key) {
          if (this.isProcessing) {
            this._queue.push({ op: "moveUp", keyA: key, keyB: null });
          } else {
            var indexA = this.getIndex(key);
            if (indexA < this.scenes.length - 1) {
              var indexB = indexA + 1;
              var sceneA = this.getScene(key);
              var sceneB = this.getAt(indexB);
              this.scenes[indexA] = sceneB;
              this.scenes[indexB] = sceneA;
            }
          }
          return this;
        },
        moveAbove: function(keyA, keyB) {
          if (keyA === keyB) {
            return this;
          }
          if (this.isProcessing) {
            this._queue.push({ op: "moveAbove", keyA: keyA, keyB: keyB });
          } else {
            var indexA = this.getIndex(keyA);
            var indexB = this.getIndex(keyB);
            if (indexA !== -1 && indexB !== -1 && indexB < indexA) {
              var tempScene = this.getAt(indexB);
              this.scenes.splice(indexB, 1);
              this.scenes.splice(indexA + (indexB > indexA), 0, tempScene);
            }
          }
          return this;
        },
        moveBelow: function(keyA, keyB) {
          if (keyA === keyB) {
            return this;
          }
          if (this.isProcessing) {
            this._queue.push({ op: "moveBelow", keyA: keyA, keyB: keyB });
          } else {
            var indexA = this.getIndex(keyA);
            var indexB = this.getIndex(keyB);
            if (indexA !== -1 && indexB !== -1 && indexB > indexA) {
              var tempScene = this.getAt(indexB);
              this.scenes.splice(indexB, 1);
              if (indexA === 0) {
                this.scenes.unshift(tempScene);
              } else {
                this.scenes.splice(indexA - (indexB < indexA), 0, tempScene);
              }
            }
          }
          return this;
        },
        queueOp: function(op, keyA, keyB) {
          this._queue.push({ op: op, keyA: keyA, keyB: keyB });
          return this;
        },
        swapPosition: function(keyA, keyB) {
          if (keyA === keyB) {
            return this;
          }
          if (this.isProcessing) {
            this._queue.push({ op: "swapPosition", keyA: keyA, keyB: keyB });
          } else {
            var indexA = this.getIndex(keyA);
            var indexB = this.getIndex(keyB);
            if (indexA !== indexB && indexA !== -1 && indexB !== -1) {
              var tempScene = this.getAt(indexA);
              this.scenes[indexA] = this.scenes[indexB];
              this.scenes[indexB] = tempScene;
            }
          }
          return this;
        },
        dump: function() {
          var out = [];
          var map = ["pending", "init", "start", "loading", "creating", "running", "paused", "sleeping", "shutdown", "destroyed"];
          for (var i = 0; i < this.scenes.length; i++) {
            var sys = this.scenes[i].sys;
            var key = sys.settings.visible && (sys.settings.status === CONST.RUNNING || sys.settings.status === CONST.PAUSED) ? "[*] " : "[-] ";
            key += sys.settings.key + " (" + map[sys.settings.status] + ")";
            out.push(key);
          }
          console.log(out.join("\n"));
        },
        destroy: function() {
          for (var i = 0; i < this.scenes.length; i++) {
            var sys = this.scenes[i].sys;
            sys.destroy();
          }
          this.systemScene.sys.destroy();
          this.update = NOOP;
          this.scenes = [];
          this._pending = [];
          this._start = [];
          this._queue = [];
          this.game = null;
          this.systemScene = null;
        }
      });
      module.exports = SceneManager;
    }
  });

  // ../../node_modules/phaser/src/textures/TextureSource.js
  var require_TextureSource = __commonJS({
    "../../node_modules/phaser/src/textures/TextureSource.js": function(exports, module) {
      var CanvasPool = require_CanvasPool();
      var Class = require_Class();
      var IsSizePowerOfTwo = require_IsSizePowerOfTwo();
      var ScaleModes = require_ScaleModes();
      var TextureSource = new Class({
        initialize: function TextureSource2(texture, source, width, height, flipY) {
          if (flipY === void 0) {
            flipY = false;
          }
          var game = texture.manager.game;
          this.renderer = game.renderer;
          this.texture = texture;
          this.source = source;
          this.image = source.compressed ? null : source;
          this.compressionAlgorithm = source.compressed ? source.format : null;
          this.resolution = 1;
          this.width = width || source.naturalWidth || source.videoWidth || source.width || 0;
          this.height = height || source.naturalHeight || source.videoHeight || source.height || 0;
          this.scaleMode = ScaleModes.DEFAULT;
          this.isCanvas = source instanceof HTMLCanvasElement;
          this.isVideo = window.hasOwnProperty("HTMLVideoElement") && source instanceof HTMLVideoElement;
          this.isRenderTexture = source.type === "RenderTexture" || source.type === "DynamicTexture";
          this.isGLTexture = window.hasOwnProperty("WebGLTexture") && source instanceof WebGLTexture;
          this.isPowerOf2 = IsSizePowerOfTwo(this.width, this.height);
          this.glTexture = null;
          this.flipY = flipY;
          this.init(game);
        },
        init: function(game) {
          var renderer = this.renderer;
          if (renderer) {
            var source = this.source;
            if (renderer.gl) {
              var image = this.image;
              var flipY = this.flipY;
              var width = this.width;
              var height = this.height;
              var scaleMode = this.scaleMode;
              if (this.isCanvas) {
                this.glTexture = renderer.createCanvasTexture(image, false, flipY);
              } else if (this.isVideo) {
                this.glTexture = renderer.createVideoTexture(image, false, flipY);
              } else if (this.isRenderTexture) {
                this.glTexture = renderer.createTextureFromSource(null, width, height, scaleMode);
              } else if (this.isGLTexture) {
                this.glTexture = source;
              } else if (this.compressionAlgorithm) {
                this.glTexture = renderer.createTextureFromSource(source);
              } else {
                this.glTexture = renderer.createTextureFromSource(image, width, height, scaleMode);
              }
              if (false) {
                this.glTexture.__SPECTOR_Metadata = { textureKey: this.texture.key };
              }
            } else if (this.isRenderTexture) {
              this.image = source.canvas;
            }
          }
          if (!game.config.antialias) {
            this.setFilter(1);
          }
        },
        setFilter: function(filterMode) {
          if (this.renderer.gl) {
            this.renderer.setTextureFilter(this.glTexture, filterMode);
          }
          this.scaleMode = filterMode;
        },
        setFlipY: function(value) {
          if (value === void 0) {
            value = true;
          }
          this.flipY = value;
          return this;
        },
        update: function() {
          var renderer = this.renderer;
          var image = this.image;
          var flipY = this.flipY;
          var gl = renderer.gl;
          if (gl && this.isCanvas) {
            this.glTexture = renderer.updateCanvasTexture(image, this.glTexture, flipY);
          } else if (gl && this.isVideo) {
            this.glTexture = renderer.updateVideoTexture(image, this.glTexture, flipY);
          }
        },
        destroy: function() {
          if (this.glTexture) {
            this.renderer.deleteTexture(this.glTexture, true);
          }
          if (this.isCanvas) {
            CanvasPool.remove(this.image);
          }
          this.renderer = null;
          this.texture = null;
          this.source = null;
          this.image = null;
          this.glTexture = null;
        }
      });
      module.exports = TextureSource;
    }
  });

  // ../../node_modules/phaser/src/textures/Texture.js
  var require_Texture2 = __commonJS({
    "../../node_modules/phaser/src/textures/Texture.js": function(exports, module) {
      var Class = require_Class();
      var Frame = require_Frame();
      var TextureSource = require_TextureSource();
      var TEXTURE_MISSING_ERROR = 'Texture "%s" has no frame "%s"';
      var Texture = new Class({
        initialize: function Texture2(manager, key, source, width, height) {
          if (!Array.isArray(source)) {
            source = [source];
          }
          this.manager = manager;
          this.key = key;
          this.source = [];
          this.dataSource = [];
          this.frames = {};
          this.customData = {};
          this.firstFrame = "__BASE";
          this.frameTotal = 0;
          for (var i = 0; i < source.length; i++) {
            this.source.push(new TextureSource(this, source[i], width, height));
          }
        },
        add: function(name, sourceIndex, x, y, width, height) {
          if (this.has(name)) {
            return null;
          }
          var frame = new Frame(this, name, sourceIndex, x, y, width, height);
          this.frames[name] = frame;
          if (this.firstFrame === "__BASE") {
            this.firstFrame = name;
          }
          this.frameTotal++;
          return frame;
        },
        remove: function(name) {
          if (this.has(name)) {
            var frame = this.get(name);
            frame.destroy();
            delete this.frames[name];
            return true;
          }
          return false;
        },
        has: function(name) {
          return this.frames.hasOwnProperty(name);
        },
        get: function(name) {
          if (!name) {
            name = this.firstFrame;
          }
          var frame = this.frames[name];
          if (!frame) {
            console.warn(TEXTURE_MISSING_ERROR, this.key, name);
            frame = this.frames[this.firstFrame];
          }
          return frame;
        },
        getTextureSourceIndex: function(source) {
          for (var i = 0; i < this.source.length; i++) {
            if (this.source[i] === source) {
              return i;
            }
          }
          return -1;
        },
        getFramesFromTextureSource: function(sourceIndex, includeBase) {
          if (includeBase === void 0) {
            includeBase = false;
          }
          var out = [];
          for (var frameName in this.frames) {
            if (frameName === "__BASE" && !includeBase) {
              continue;
            }
            var frame = this.frames[frameName];
            if (frame.sourceIndex === sourceIndex) {
              out.push(frame);
            }
          }
          return out;
        },
        getFrameNames: function(includeBase) {
          if (includeBase === void 0) {
            includeBase = false;
          }
          var out = Object.keys(this.frames);
          if (!includeBase) {
            var idx = out.indexOf("__BASE");
            if (idx !== -1) {
              out.splice(idx, 1);
            }
          }
          return out;
        },
        getSourceImage: function(name) {
          if (name === void 0 || name === null || this.frameTotal === 1) {
            name = "__BASE";
          }
          var frame = this.frames[name];
          if (frame) {
            return frame.source.image;
          } else {
            console.warn(TEXTURE_MISSING_ERROR, this.key, name);
            return this.frames["__BASE"].source.image;
          }
        },
        getDataSourceImage: function(name) {
          if (name === void 0 || name === null || this.frameTotal === 1) {
            name = "__BASE";
          }
          var frame = this.frames[name];
          var idx;
          if (!frame) {
            console.warn(TEXTURE_MISSING_ERROR, this.key, name);
            idx = this.frames["__BASE"].sourceIndex;
          } else {
            idx = frame.sourceIndex;
          }
          return this.dataSource[idx].image;
        },
        setDataSource: function(data) {
          if (!Array.isArray(data)) {
            data = [data];
          }
          for (var i = 0; i < data.length; i++) {
            var source = this.source[i];
            this.dataSource.push(new TextureSource(this, data[i], source.width, source.height));
          }
        },
        setFilter: function(filterMode) {
          var i;
          for (i = 0; i < this.source.length; i++) {
            this.source[i].setFilter(filterMode);
          }
          for (i = 0; i < this.dataSource.length; i++) {
            this.dataSource[i].setFilter(filterMode);
          }
        },
        destroy: function() {
          var i;
          var source = this.source;
          var dataSource = this.dataSource;
          for (i = 0; i < source.length; i++) {
            if (source[i]) {
              source[i].destroy();
            }
          }
          for (i = 0; i < dataSource.length; i++) {
            if (dataSource[i]) {
              dataSource[i].destroy();
            }
          }
          for (var frameName in this.frames) {
            var frame = this.frames[frameName];
            if (frame) {
              frame.destroy();
            }
          }
          this.source = [];
          this.dataSource = [];
          this.frames = {};
          this.manager.removeKey(this.key);
          this.manager = null;
        }
      });
      module.exports = Texture;
    }
  });

  // ../../node_modules/phaser/src/textures/CanvasTexture.js
  var require_CanvasTexture = __commonJS({
    "../../node_modules/phaser/src/textures/CanvasTexture.js": function(exports, module) {
      var Class = require_Class();
      var Clamp = require_Clamp();
      var Color = require_Color();
      var CONST = require_const();
      var IsSizePowerOfTwo = require_IsSizePowerOfTwo();
      var Texture = require_Texture2();
      var CanvasTexture = new Class({
        Extends: Texture,
        initialize: function CanvasTexture2(manager, key, source, width, height) {
          Texture.call(this, manager, key, source, width, height);
          this.add("__BASE", 0, 0, 0, width, height);
          this._source = this.frames["__BASE"].source;
          this.canvas = this._source.image;
          this.context = this.canvas.getContext("2d", { willReadFrequently: true });
          this.width = width;
          this.height = height;
          this.imageData = this.context.getImageData(0, 0, width, height);
          this.data = null;
          if (this.imageData) {
            this.data = this.imageData.data;
          }
          this.pixels = null;
          this.buffer;
          if (this.data) {
            if (this.imageData.data.buffer) {
              this.buffer = this.imageData.data.buffer;
              this.pixels = new Uint32Array(this.buffer);
            } else if (window.ArrayBuffer) {
              this.buffer = new ArrayBuffer(this.imageData.data.length);
              this.pixels = new Uint32Array(this.buffer);
            } else {
              this.pixels = this.imageData.data;
            }
          }
        },
        update: function() {
          this.imageData = this.context.getImageData(0, 0, this.width, this.height);
          this.data = this.imageData.data;
          if (this.imageData.data.buffer) {
            this.buffer = this.imageData.data.buffer;
            this.pixels = new Uint32Array(this.buffer);
          } else if (window.ArrayBuffer) {
            this.buffer = new ArrayBuffer(this.imageData.data.length);
            this.pixels = new Uint32Array(this.buffer);
          } else {
            this.pixels = this.imageData.data;
          }
          if (this.manager.game.config.renderType === CONST.WEBGL) {
            this.refresh();
          }
          return this;
        },
        draw: function(x, y, source, update) {
          if (update === void 0) {
            update = true;
          }
          this.context.drawImage(source, x, y);
          if (update) {
            this.update();
          }
          return this;
        },
        drawFrame: function(key, frame, x, y, update) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (update === void 0) {
            update = true;
          }
          var textureFrame = this.manager.getFrame(key, frame);
          if (textureFrame) {
            var cd = textureFrame.canvasData;
            var width = textureFrame.cutWidth;
            var height = textureFrame.cutHeight;
            var res = textureFrame.source.resolution;
            this.context.drawImage(textureFrame.source.image, cd.x, cd.y, width, height, x, y, width / res, height / res);
            if (update) {
              this.update();
            }
          }
          return this;
        },
        setPixel: function(x, y, red, green, blue, alpha) {
          if (alpha === void 0) {
            alpha = 255;
          }
          x = Math.abs(Math.floor(x));
          y = Math.abs(Math.floor(y));
          var index = this.getIndex(x, y);
          if (index > -1) {
            var imageData = this.context.getImageData(x, y, 1, 1);
            imageData.data[0] = red;
            imageData.data[1] = green;
            imageData.data[2] = blue;
            imageData.data[3] = alpha;
            this.context.putImageData(imageData, x, y);
          }
          return this;
        },
        putData: function(imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
          if (dirtyX === void 0) {
            dirtyX = 0;
          }
          if (dirtyY === void 0) {
            dirtyY = 0;
          }
          if (dirtyWidth === void 0) {
            dirtyWidth = imageData.width;
          }
          if (dirtyHeight === void 0) {
            dirtyHeight = imageData.height;
          }
          this.context.putImageData(imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
          return this;
        },
        getData: function(x, y, width, height) {
          x = Clamp(Math.floor(x), 0, this.width - 1);
          y = Clamp(Math.floor(y), 0, this.height - 1);
          width = Clamp(width, 1, this.width - x);
          height = Clamp(height, 1, this.height - y);
          var imageData = this.context.getImageData(x, y, width, height);
          return imageData;
        },
        getPixel: function(x, y, out) {
          if (!out) {
            out = new Color();
          }
          var index = this.getIndex(x, y);
          if (index > -1) {
            var data = this.data;
            var r = data[index + 0];
            var g = data[index + 1];
            var b = data[index + 2];
            var a = data[index + 3];
            out.setTo(r, g, b, a);
          }
          return out;
        },
        getPixels: function(x, y, width, height) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (width === void 0) {
            width = this.width;
          }
          if (height === void 0) {
            height = width;
          }
          x = Math.abs(Math.round(x));
          y = Math.abs(Math.round(y));
          var left = Clamp(x, 0, this.width);
          var right = Clamp(x + width, 0, this.width);
          var top = Clamp(y, 0, this.height);
          var bottom = Clamp(y + height, 0, this.height);
          var pixel = new Color();
          var out = [];
          for (var py = top; py < bottom; py++) {
            var row = [];
            for (var px = left; px < right; px++) {
              pixel = this.getPixel(px, py, pixel);
              row.push({ x: px, y: py, color: pixel.color, alpha: pixel.alphaGL });
            }
            out.push(row);
          }
          return out;
        },
        getIndex: function(x, y) {
          x = Math.abs(Math.round(x));
          y = Math.abs(Math.round(y));
          if (x < this.width && y < this.height) {
            return (x + y * this.width) * 4;
          } else {
            return -1;
          }
        },
        refresh: function() {
          this._source.update();
          return this;
        },
        getCanvas: function() {
          return this.canvas;
        },
        getContext: function() {
          return this.context;
        },
        clear: function(x, y, width, height, update) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (width === void 0) {
            width = this.width;
          }
          if (height === void 0) {
            height = this.height;
          }
          if (update === void 0) {
            update = true;
          }
          this.context.clearRect(x, y, width, height);
          if (update) {
            this.update();
          }
          return this;
        },
        setSize: function(width, height) {
          if (height === void 0) {
            height = width;
          }
          if (width !== this.width || height !== this.height) {
            this.canvas.width = width;
            this.canvas.height = height;
            this._source.width = width;
            this._source.height = height;
            this._source.isPowerOf2 = IsSizePowerOfTwo(width, height);
            this.frames["__BASE"].setSize(width, height, 0, 0);
            this.width = width;
            this.height = height;
            this.refresh();
          }
          return this;
        },
        destroy: function() {
          Texture.prototype.destroy.call(this);
          this._source = null;
          this.canvas = null;
          this.context = null;
          this.imageData = null;
          this.data = null;
          this.pixels = null;
          this.buffer = null;
        }
      });
      module.exports = CanvasTexture;
    }
  });

  // ../../node_modules/phaser/src/textures/DynamicTexture.js
  var require_DynamicTexture = __commonJS({
    "../../node_modules/phaser/src/textures/DynamicTexture.js": function(exports, module) {
      var BlendModes = require_BlendModes();
      var Camera = require_BaseCamera();
      var CanvasPool = require_CanvasPool();
      var Class = require_Class();
      var CONST = require_const();
      var Frame = require_Frame();
      var GetFastValue = require_GetFastValue();
      var PIPELINES = require_const6();
      var RenderTarget = require_RenderTarget();
      var Texture = require_Texture2();
      var Utils = require_Utils();
      var DynamicTexture = new Class({
        Extends: Texture,
        initialize: function DynamicTexture2(manager, key, width, height) {
          if (width === void 0) {
            width = 256;
          }
          if (height === void 0) {
            height = 256;
          }
          this.type = "DynamicTexture";
          var renderer = manager.game.renderer;
          var isCanvas = renderer && renderer.type === CONST.CANVAS;
          var source = isCanvas ? CanvasPool.create2D(this, width, height) : [this];
          Texture.call(this, manager, key, source, width, height);
          this.add("__BASE", 0, 0, 0, width, height);
          this.renderer = renderer;
          this.isDrawing = false;
          this.canvas = isCanvas ? source : null;
          this.context = isCanvas ? source.getContext("2d") : null;
          this.dirty = false;
          this.isSpriteTexture = true;
          this._eraseMode = false;
          this.camera = new Camera(0, 0, width, height).setScene(manager.game.scene.systemScene, false);
          this.renderTarget = !isCanvas ? new RenderTarget(renderer, width, height, 1, 0, false) : null;
          this.pipeline = !isCanvas ? renderer.pipelines.get(PIPELINES.SINGLE_PIPELINE) : null;
          this.setSize(width, height);
        },
        setSize: function(width, height) {
          if (height === void 0) {
            height = width;
          }
          var frame = this.get();
          var source = frame.source;
          if (width !== this.width || height !== this.height) {
            if (this.canvas) {
              this.canvas.width = width;
              this.canvas.height = height;
            }
            var renderTarget = this.renderTarget;
            if (renderTarget) {
              renderTarget.resize(width, height);
              frame.glTexture = renderTarget.texture;
              source.isRenderTexture = true;
              source.isGLTexture = true;
              source.glTexture = renderTarget.texture;
              source.glTexture.flipY = true;
            }
            this.camera.setSize(width, height);
            source.width = width;
            source.height = height;
            frame.setSize(width, height);
            this.width = width;
            this.height = height;
          } else {
            var baseFrame = this.getSourceImage();
            if (frame.cutX + width > baseFrame.width) {
              width = baseFrame.width - frame.cutX;
            }
            if (frame.cutY + height > baseFrame.height) {
              height = baseFrame.height - frame.cutY;
            }
            frame.setSize(width, height, frame.cutX, frame.cutY);
          }
          return this;
        },
        setIsSpriteTexture: function(value) {
          this.isSpriteTexture = value;
          return this;
        },
        fill: function(rgb, alpha, x, y, width, height) {
          var camera = this.camera;
          var renderer = this.renderer;
          if (alpha === void 0) {
            alpha = 1;
          }
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (width === void 0) {
            width = this.width;
          }
          if (height === void 0) {
            height = this.height;
          }
          var r = rgb >> 16 & 255;
          var g = rgb >> 8 & 255;
          var b = rgb & 255;
          var renderTarget = this.renderTarget;
          camera.preRender();
          if (renderTarget) {
            renderTarget.bind(true);
            var pipeline = this.pipeline.manager.set(this.pipeline);
            var sx = renderer.width / renderTarget.width;
            var sy = renderer.height / renderTarget.height;
            pipeline.drawFillRect(x * sx, y * sy, width * sx, height * sy, Utils.getTintFromFloats(b / 255, g / 255, r / 255, 1), alpha);
            renderTarget.unbind(true);
          } else {
            var ctx = this.context;
            renderer.setContext(ctx);
            ctx.globalCompositeOperation = "source-over";
            ctx.fillStyle = "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
            ctx.fillRect(x, y, width, height);
            renderer.setContext();
          }
          this.dirty = true;
          return this;
        },
        clear: function() {
          if (this.dirty) {
            var ctx = this.context;
            var renderTarget = this.renderTarget;
            if (renderTarget) {
              renderTarget.clear();
            } else if (ctx) {
              ctx.save();
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              ctx.clearRect(0, 0, this.width, this.height);
              ctx.restore();
            }
            this.dirty = false;
          }
          return this;
        },
        stamp: function(key, frame, x, y, config) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          var alpha = GetFastValue(config, "alpha", 1);
          var tint = GetFastValue(config, "tint", 16777215);
          var angle = GetFastValue(config, "angle", 0);
          var rotation = GetFastValue(config, "rotation", 0);
          var scale = GetFastValue(config, "scale", 1);
          var scaleX = GetFastValue(config, "scaleX", scale);
          var scaleY = GetFastValue(config, "scaleY", scale);
          var originX = GetFastValue(config, "originX", 0.5);
          var originY = GetFastValue(config, "originY", 0.5);
          var blendMode = GetFastValue(config, "blendMode", 0);
          var erase = GetFastValue(config, "erase", false);
          var stamp = this.manager.resetStamp(alpha, tint);
          stamp.setAngle(0);
          if (angle !== 0) {
            stamp.setAngle(angle);
          } else if (rotation !== 0) {
            stamp.setRotation(rotation);
          }
          stamp.setScale(scaleX, scaleY);
          stamp.setTexture(key, frame);
          stamp.setOrigin(originX, originY);
          stamp.setBlendMode(blendMode);
          if (erase) {
            this._eraseMode = true;
          }
          this.draw(stamp, x, y);
          if (erase) {
            this._eraseMode = false;
          }
          return this;
        },
        erase: function(entries, x, y) {
          this._eraseMode = true;
          this.draw(entries, x, y);
          this._eraseMode = false;
          return this;
        },
        draw: function(entries, x, y, alpha, tint) {
          this.beginDraw();
          this.batchDraw(entries, x, y, alpha, tint);
          this.endDraw();
          return this;
        },
        drawFrame: function(key, frame, x, y, alpha, tint) {
          this.beginDraw();
          this.batchDrawFrame(key, frame, x, y, alpha, tint);
          this.endDraw();
          return this;
        },
        repeat: function(key, frame, x, y, width, height, alpha, tint, skipBatch) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (width === void 0) {
            width = this.width;
          }
          if (height === void 0) {
            height = this.height;
          }
          if (alpha === void 0) {
            alpha = 1;
          }
          if (tint === void 0) {
            tint = 16777215;
          }
          if (skipBatch === void 0) {
            skipBatch = false;
          }
          if (key instanceof Frame) {
            frame = key;
          } else {
            frame = this.manager.getFrame(key, frame);
          }
          if (!frame) {
            return this;
          }
          var stamp = this.manager.resetStamp(alpha, tint);
          stamp.setFrame(frame);
          stamp.setOrigin(0);
          var frameWidth = frame.width;
          var frameHeight = frame.height;
          width = Math.floor(width);
          height = Math.floor(height);
          var hmax = Math.ceil(width / frameWidth);
          var vmax = Math.ceil(height / frameHeight);
          var hdiff = hmax * frameWidth - width;
          var vdiff = vmax * frameHeight - height;
          if (hdiff > 0) {
            hdiff = frameWidth - hdiff;
          }
          if (vdiff > 0) {
            vdiff = frameHeight - vdiff;
          }
          if (x < 0) {
            hmax += Math.ceil(Math.abs(x) / frameWidth);
          }
          if (y < 0) {
            vmax += Math.ceil(Math.abs(y) / frameHeight);
          }
          var dx = x;
          var dy = y;
          var useCrop = false;
          var cropRect = this.manager.stampCrop.setTo(0, 0, frameWidth, frameHeight);
          if (!skipBatch) {
            this.beginDraw();
          }
          for (var ty = 0; ty < vmax; ty++) {
            if (dy + frameHeight < 0) {
              dy += frameHeight;
              continue;
            }
            for (var tx = 0; tx < hmax; tx++) {
              useCrop = false;
              if (dx + frameWidth < 0) {
                dx += frameWidth;
                continue;
              } else if (dx < 0) {
                useCrop = true;
                cropRect.width = frameWidth + dx;
                cropRect.x = frameWidth - cropRect.width;
              }
              if (dy < 0) {
                useCrop = true;
                cropRect.height = frameHeight + dy;
                cropRect.y = frameHeight - cropRect.height;
              }
              if (hdiff > 0 && tx === hmax - 1) {
                useCrop = true;
                cropRect.width = hdiff;
              }
              if (vdiff > 0 && ty === vmax - 1) {
                useCrop = true;
                cropRect.height = vdiff;
              }
              if (useCrop) {
                stamp.setCrop(cropRect);
              }
              this.batchGameObject(stamp, dx, dy);
              stamp.isCropped = false;
              cropRect.setTo(0, 0, frameWidth, frameHeight);
              dx += frameWidth;
            }
            dx = x;
            dy += frameHeight;
          }
          if (!skipBatch) {
            this.endDraw();
          }
          return this;
        },
        beginDraw: function() {
          if (!this.isDrawing) {
            var camera = this.camera;
            var renderer = this.renderer;
            var renderTarget = this.renderTarget;
            camera.preRender();
            if (renderTarget) {
              renderer.beginCapture(renderTarget.width, renderTarget.height);
            } else {
              renderer.setContext(this.context);
            }
            this.isDrawing = true;
          }
          return this;
        },
        batchDraw: function(entries, x, y, alpha, tint) {
          if (!Array.isArray(entries)) {
            entries = [entries];
          }
          this.batchList(entries, x, y, alpha, tint);
          return this;
        },
        batchDrawFrame: function(key, frame, x, y, alpha, tint) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (alpha === void 0) {
            alpha = 1;
          }
          if (tint === void 0) {
            tint = 16777215;
          }
          var textureFrame = this.manager.getFrame(key, frame);
          if (textureFrame) {
            if (this.renderTarget) {
              this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null);
            } else {
              this.batchTextureFrame(textureFrame, x, y, alpha, tint);
            }
          }
          return this;
        },
        endDraw: function(erase) {
          if (erase === void 0) {
            erase = this._eraseMode;
          }
          if (this.isDrawing) {
            var renderer = this.renderer;
            var renderTarget = this.renderTarget;
            if (renderTarget) {
              var canvasTarget = renderer.endCapture();
              var util = renderer.pipelines.setUtility();
              util.blitFrame(canvasTarget, renderTarget, 1, false, false, erase, this.isSpriteTexture);
              renderer.resetScissor();
              renderer.resetViewport();
            } else {
              renderer.setContext();
            }
            this.dirty = true;
            this.isDrawing = false;
          }
          return this;
        },
        batchList: function(children, x, y, alpha, tint) {
          var len = children.length;
          if (len === 0) {
            return;
          }
          for (var i = 0; i < len; i++) {
            var entry = children[i];
            if (!entry || entry === this) {
              continue;
            }
            if (entry.renderWebGL || entry.renderCanvas) {
              this.batchGameObject(entry, x, y);
            } else if (entry.isParent || entry.list) {
              this.batchGroup(entry.getChildren(), x, y);
            } else if (typeof entry === "string") {
              this.batchTextureFrameKey(entry, null, x, y, alpha, tint);
            } else if (entry instanceof Frame) {
              this.batchTextureFrame(entry, x, y, alpha, tint);
            } else if (Array.isArray(entry)) {
              this.batchList(entry, x, y, alpha, tint);
            }
          }
        },
        batchGroup: function(children, x, y) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          for (var i = 0; i < children.length; i++) {
            var entry = children[i];
            if (entry.willRender(this.camera)) {
              this.batchGameObject(entry, entry.x + x, entry.y + y);
            }
          }
        },
        batchGameObject: function(gameObject, x, y) {
          if (x === void 0) {
            x = gameObject.x;
          }
          if (y === void 0) {
            y = gameObject.y;
          }
          var prevX = gameObject.x;
          var prevY = gameObject.y;
          var camera = this.camera;
          var renderer = this.renderer;
          var eraseMode = this._eraseMode;
          var mask = gameObject.mask;
          gameObject.setPosition(x, y);
          if (this.canvas) {
            if (eraseMode) {
              var blendMode = gameObject.blendMode;
              gameObject.blendMode = BlendModes.ERASE;
            }
            if (mask) {
              mask.preRenderCanvas(renderer, gameObject, camera);
            }
            gameObject.renderCanvas(renderer, gameObject, camera, null);
            if (mask) {
              mask.postRenderCanvas(renderer, gameObject, camera);
            }
            if (eraseMode) {
              gameObject.blendMode = blendMode;
            }
          } else if (renderer) {
            if (mask) {
              mask.preRenderWebGL(renderer, gameObject, camera);
            }
            if (!eraseMode) {
              renderer.setBlendMode(gameObject.blendMode);
            }
            gameObject.renderWebGL(renderer, gameObject, camera);
            if (mask) {
              mask.postRenderWebGL(renderer, camera, this.renderTarget);
            }
          }
          gameObject.setPosition(prevX, prevY);
        },
        batchTextureFrameKey: function(key, frame, x, y, alpha, tint) {
          var textureFrame = this.manager.getFrame(key, frame);
          if (textureFrame) {
            this.batchTextureFrame(textureFrame, x, y, alpha, tint);
          }
        },
        batchTextureFrame: function(textureFrame, x, y, alpha, tint) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (alpha === void 0) {
            alpha = 1;
          }
          if (tint === void 0) {
            tint = 16777215;
          }
          var matrix = this.camera.matrix;
          var renderTarget = this.renderTarget;
          if (renderTarget) {
            this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, matrix, null);
          } else {
            var ctx = this.context;
            var cd = textureFrame.canvasData;
            var source = textureFrame.source.image;
            ctx.save();
            ctx.globalCompositeOperation = this._eraseMode ? "destination-out" : "source-over";
            ctx.globalAlpha = alpha;
            matrix.setToContext(ctx);
            if (cd.width > 0 && cd.height > 0) {
              ctx.drawImage(source, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);
            }
            ctx.restore();
          }
        },
        snapshotArea: function(x, y, width, height, callback, type, encoderOptions) {
          if (this.renderTarget) {
            this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, false, x, y, width, height, type, encoderOptions);
          } else {
            this.renderer.snapshotCanvas(this.canvas, callback, false, x, y, width, height, type, encoderOptions);
          }
          return this;
        },
        snapshot: function(callback, type, encoderOptions) {
          return this.snapshotArea(0, 0, this.width, this.height, callback, type, encoderOptions);
        },
        snapshotPixel: function(x, y, callback) {
          return this.snapshotArea(x, y, 1, 1, callback, "pixel");
        },
        renderWebGL: function(renderer, src, camera, parentMatrix) {
          var stamp = this.manager.resetStamp();
          stamp.setTexture(this);
          stamp.setOrigin(0);
          stamp.renderWebGL(renderer, stamp, camera, parentMatrix);
        },
        renderCanvas: function() {
        },
        preDestroy: function() {
          CanvasPool.remove(this.canvas);
          if (this.renderTarget) {
            this.renderTarget.destroy();
          }
          this.camera.destroy();
          this.stamp.destroy();
          this.canvas = null;
          this.context = null;
          this.renderer = null;
          this.scene = null;
        }
      });
      module.exports = DynamicTexture;
    }
  });

  // ../../node_modules/phaser/src/create/palettes/Arne16.js
  var require_Arne16 = __commonJS({
    "../../node_modules/phaser/src/create/palettes/Arne16.js": function(exports, module) {
      module.exports = {
        0: "#000",
        1: "#9D9D9D",
        2: "#FFF",
        3: "#BE2633",
        4: "#E06F8B",
        5: "#493C2B",
        6: "#A46422",
        7: "#EB8931",
        8: "#F7E26B",
        9: "#2F484E",
        A: "#44891A",
        B: "#A3CE27",
        C: "#1B2632",
        D: "#005784",
        E: "#31A2F2",
        F: "#B2DCEF"
      };
    }
  });

  // ../../node_modules/phaser/src/create/GenerateTexture.js
  var require_GenerateTexture = __commonJS({
    "../../node_modules/phaser/src/create/GenerateTexture.js": function(exports, module) {
      var Arne16 = require_Arne16();
      var CanvasPool = require_CanvasPool();
      var GetValue = require_GetValue();
      var GenerateTexture = function(config) {
        var data = GetValue(config, "data", []);
        var canvas = GetValue(config, "canvas", null);
        var palette = GetValue(config, "palette", Arne16);
        var pixelWidth = GetValue(config, "pixelWidth", 1);
        var pixelHeight = GetValue(config, "pixelHeight", pixelWidth);
        var resizeCanvas = GetValue(config, "resizeCanvas", true);
        var clearCanvas = GetValue(config, "clearCanvas", true);
        var preRender = GetValue(config, "preRender", null);
        var postRender = GetValue(config, "postRender", null);
        var width = Math.floor(Math.abs(data[0].length * pixelWidth));
        var height = Math.floor(Math.abs(data.length * pixelHeight));
        if (!canvas) {
          canvas = CanvasPool.create2D(this, width, height);
          resizeCanvas = false;
          clearCanvas = false;
        }
        if (resizeCanvas) {
          canvas.width = width;
          canvas.height = height;
        }
        var ctx = canvas.getContext("2d");
        if (clearCanvas) {
          ctx.clearRect(0, 0, width, height);
        }
        if (preRender) {
          preRender(canvas, ctx);
        }
        for (var y = 0; y < data.length; y++) {
          var row = data[y];
          for (var x = 0; x < row.length; x++) {
            var d = row[x];
            if (d !== "." && d !== " ") {
              ctx.fillStyle = palette[d];
              ctx.fillRect(x * pixelWidth, y * pixelHeight, pixelWidth, pixelHeight);
            }
          }
        }
        if (postRender) {
          postRender(canvas, ctx);
        }
        return canvas;
      };
      module.exports = GenerateTexture;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/image/ImageWebGLRenderer.js
  var require_ImageWebGLRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/image/ImageWebGLRenderer.js": function(exports, module) {
      var ImageWebGLRenderer = function(renderer, src, camera, parentMatrix) {
        camera.addToRenderList(src);
        this.pipeline.batchSprite(src, camera, parentMatrix);
      };
      module.exports = ImageWebGLRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/image/ImageCanvasRenderer.js
  var require_ImageCanvasRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/image/ImageCanvasRenderer.js": function(exports, module) {
      var ImageCanvasRenderer = function(renderer, src, camera, parentMatrix) {
        camera.addToRenderList(src);
        renderer.batchSprite(src, src.frame, camera, parentMatrix);
      };
      module.exports = ImageCanvasRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/image/ImageRender.js
  var require_ImageRender = __commonJS({
    "../../node_modules/phaser/src/gameobjects/image/ImageRender.js": function(exports, module) {
      var NOOP = require_NOOP();
      var renderWebGL = NOOP;
      var renderCanvas = NOOP;
      if (true) {
        renderWebGL = require_ImageWebGLRenderer();
      }
      if (true) {
        renderCanvas = require_ImageCanvasRenderer();
      }
      module.exports = {
        renderWebGL: renderWebGL,
        renderCanvas: renderCanvas
      };
    }
  });

  // ../../node_modules/phaser/src/gameobjects/image/Image.js
  var require_Image = __commonJS({
    "../../node_modules/phaser/src/gameobjects/image/Image.js": function(exports, module) {
      var Class = require_Class();
      var Components = require_components();
      var GameObject = require_GameObject();
      var ImageRender = require_ImageRender();
      var Image2 = new Class({
        Extends: GameObject,
        Mixins: [
          Components.Alpha,
          Components.BlendMode,
          Components.Depth,
          Components.Flip,
          Components.FX,
          Components.GetBounds,
          Components.Mask,
          Components.Origin,
          Components.Pipeline,
          Components.PostPipeline,
          Components.ScrollFactor,
          Components.Size,
          Components.TextureCrop,
          Components.Tint,
          Components.Transform,
          Components.Visible,
          ImageRender
        ],
        initialize: function Image3(scene, x, y, texture, frame) {
          GameObject.call(this, scene, "Image");
          this._crop = this.resetCropObject();
          this.setTexture(texture, frame);
          this.setPosition(x, y);
          this.setSizeToFrame();
          this.setOriginFromFrame();
          this.initPipeline();
          this.initPostPipeline();
        }
      });
      module.exports = Image2;
    }
  });

  // ../../node_modules/phaser/src/textures/parsers/AtlasXML.js
  var require_AtlasXML = __commonJS({
    "../../node_modules/phaser/src/textures/parsers/AtlasXML.js": function(exports, module) {
      var AtlasXML = function(texture, sourceIndex, xml) {
        if (!xml.getElementsByTagName("TextureAtlas")) {
          console.warn("Invalid Texture Atlas XML given");
          return;
        }
        var source = texture.source[sourceIndex];
        texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
        var frames = xml.getElementsByTagName("SubTexture");
        var newFrame;
        for (var i = 0; i < frames.length; i++) {
          var frame = frames[i].attributes;
          var name = frame.name.value;
          var x = parseInt(frame.x.value, 10);
          var y = parseInt(frame.y.value, 10);
          var width = parseInt(frame.width.value, 10);
          var height = parseInt(frame.height.value, 10);
          newFrame = texture.add(name, sourceIndex, x, y, width, height);
          if (frame.frameX) {
            var frameX = Math.abs(parseInt(frame.frameX.value, 10));
            var frameY = Math.abs(parseInt(frame.frameY.value, 10));
            var frameWidth = parseInt(frame.frameWidth.value, 10);
            var frameHeight = parseInt(frame.frameHeight.value, 10);
            newFrame.setTrim(width, height, frameX, frameY, frameWidth, frameHeight);
          }
        }
        return texture;
      };
      module.exports = AtlasXML;
    }
  });

  // ../../node_modules/phaser/src/textures/parsers/Canvas.js
  var require_Canvas = __commonJS({
    "../../node_modules/phaser/src/textures/parsers/Canvas.js": function(exports, module) {
      var Canvas = function(texture, sourceIndex) {
        var source = texture.source[sourceIndex];
        texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
        return texture;
      };
      module.exports = Canvas;
    }
  });

  // ../../node_modules/phaser/src/textures/parsers/Image.js
  var require_Image2 = __commonJS({
    "../../node_modules/phaser/src/textures/parsers/Image.js": function(exports, module) {
      var Image2 = function(texture, sourceIndex) {
        var source = texture.source[sourceIndex];
        texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
        return texture;
      };
      module.exports = Image2;
    }
  });

  // ../../node_modules/phaser/src/textures/parsers/JSONArray.js
  var require_JSONArray = __commonJS({
    "../../node_modules/phaser/src/textures/parsers/JSONArray.js": function(exports, module) {
      var Clone = require_Clone();
      var JSONArray = function(texture, sourceIndex, json) {
        if (!json["frames"] && !json["textures"]) {
          console.warn("Invalid Texture Atlas JSON Array");
          return;
        }
        var source = texture.source[sourceIndex];
        texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
        var frames = Array.isArray(json.textures) ? json.textures[sourceIndex].frames : json.frames;
        var newFrame;
        for (var i = 0; i < frames.length; i++) {
          var src = frames[i];
          newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);
          if (!newFrame) {
            console.warn("Invalid atlas json, frame already exists: " + src.filename);
            continue;
          }
          if (src.trimmed) {
            newFrame.setTrim(src.sourceSize.w, src.sourceSize.h, src.spriteSourceSize.x, src.spriteSourceSize.y, src.spriteSourceSize.w, src.spriteSourceSize.h);
          }
          if (src.rotated) {
            newFrame.rotated = true;
            newFrame.updateUVsInverted();
          }
          var pivot = src.anchor || src.pivot;
          if (pivot) {
            newFrame.customPivot = true;
            newFrame.pivotX = pivot.x;
            newFrame.pivotY = pivot.y;
          }
          newFrame.customData = Clone(src);
        }
        for (var dataKey in json) {
          if (dataKey === "frames") {
            continue;
          }
          if (Array.isArray(json[dataKey])) {
            texture.customData[dataKey] = json[dataKey].slice(0);
          } else {
            texture.customData[dataKey] = json[dataKey];
          }
        }
        return texture;
      };
      module.exports = JSONArray;
    }
  });

  // ../../node_modules/phaser/src/textures/parsers/JSONHash.js
  var require_JSONHash = __commonJS({
    "../../node_modules/phaser/src/textures/parsers/JSONHash.js": function(exports, module) {
      var Clone = require_Clone();
      var JSONHash = function(texture, sourceIndex, json) {
        if (!json["frames"]) {
          console.warn("Invalid Texture Atlas JSON Hash given, missing 'frames' Object");
          return;
        }
        var source = texture.source[sourceIndex];
        texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
        var frames = json.frames;
        var newFrame;
        for (var key in frames) {
          if (!frames.hasOwnProperty(key)) {
            continue;
          }
          var src = frames[key];
          newFrame = texture.add(key, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);
          if (!newFrame) {
            console.warn("Invalid atlas json, frame already exists: " + key);
            continue;
          }
          if (src.trimmed) {
            newFrame.setTrim(src.sourceSize.w, src.sourceSize.h, src.spriteSourceSize.x, src.spriteSourceSize.y, src.spriteSourceSize.w, src.spriteSourceSize.h);
          }
          if (src.rotated) {
            newFrame.rotated = true;
            newFrame.updateUVsInverted();
          }
          var pivot = src.anchor || src.pivot;
          if (pivot) {
            newFrame.customPivot = true;
            newFrame.pivotX = pivot.x;
            newFrame.pivotY = pivot.y;
          }
          newFrame.customData = Clone(src);
        }
        for (var dataKey in json) {
          if (dataKey === "frames") {
            continue;
          }
          if (Array.isArray(json[dataKey])) {
            texture.customData[dataKey] = json[dataKey].slice(0);
          } else {
            texture.customData[dataKey] = json[dataKey];
          }
        }
        return texture;
      };
      module.exports = JSONHash;
    }
  });

  // ../../node_modules/phaser/src/textures/parsers/KTXParser.js
  var require_KTXParser = __commonJS({
    "../../node_modules/phaser/src/textures/parsers/KTXParser.js": function(exports, module) {
      var KTXParser = function(data) {
        var idCheck = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
        var i;
        var id = new Uint8Array(data, 0, 12);
        for (i = 0; i < id.length; i++) {
          if (id[i] !== idCheck[i]) {
            console.warn("KTXParser - Invalid file format");
            return;
          }
        }
        var size = Uint32Array.BYTES_PER_ELEMENT;
        var head = new DataView(data, 12, 13 * size);
        var littleEndian = head.getUint32(0, true) === 67305985;
        var glType = head.getUint32(1 * size, littleEndian);
        if (glType !== 0) {
          console.warn("KTXParser - Only compressed formats supported");
          return;
        }
        var internalFormat = head.getUint32(4 * size, littleEndian);
        var width = head.getUint32(6 * size, littleEndian);
        var height = head.getUint32(7 * size, littleEndian);
        var mipmapLevels = Math.max(1, head.getUint32(11 * size, littleEndian));
        var bytesOfKeyValueData = head.getUint32(12 * size, littleEndian);
        var mipmaps = new Array(mipmapLevels);
        var offset = 12 + 13 * 4 + bytesOfKeyValueData;
        var levelWidth = width;
        var levelHeight = height;
        for (i = 0; i < mipmapLevels; i++) {
          var levelSize = new Int32Array(data, offset, 1)[0];
          offset += 4;
          mipmaps[i] = {
            data: new Uint8Array(data, offset, levelSize),
            width: levelWidth,
            height: levelHeight
          };
          levelWidth = Math.max(1, levelWidth >> 1);
          levelHeight = Math.max(1, levelHeight >> 1);
          offset += levelSize;
        }
        return {
          mipmaps: mipmaps,
          width: width,
          height: height,
          internalFormat: internalFormat,
          compressed: true,
          generateMipmap: false
        };
      };
      module.exports = KTXParser;
    }
  });

  // ../../node_modules/phaser/src/textures/parsers/PVRParser.js
  var require_PVRParser = __commonJS({
    "../../node_modules/phaser/src/textures/parsers/PVRParser.js": function(exports, module) {
      function GetSize(width, height, x, y, dx, dy, mult) {
        if (mult === void 0) {
          mult = 16;
        }
        return Math.floor((width + x) / dx) * Math.floor((height + y) / dy) * mult;
      }
      function PVRTC2bppSize(width, height) {
        width = Math.max(width, 16);
        height = Math.max(height, 8);
        return width * height / 4;
      }
      function PVRTC4bppSize(width, height) {
        width = Math.max(width, 8);
        height = Math.max(height, 8);
        return width * height / 2;
      }
      function DXTEtcSmallSize(width, height) {
        return GetSize(width, height, 3, 3, 4, 4, 8);
      }
      function DXTEtcAstcBigSize(width, height) {
        return GetSize(width, height, 3, 3, 4, 4);
      }
      function ATC5x4Size(width, height) {
        return GetSize(width, height, 4, 3, 5, 4);
      }
      function ATC5x5Size(width, height) {
        return GetSize(width, height, 4, 4, 5, 5);
      }
      function ATC6x5Size(width, height) {
        return GetSize(width, height, 5, 4, 6, 5);
      }
      function ATC6x6Size(width, height) {
        return GetSize(width, height, 5, 5, 6, 6);
      }
      function ATC8x5Size(width, height) {
        return GetSize(width, height, 7, 4, 8, 5);
      }
      function ATC8x6Size(width, height) {
        return GetSize(width, height, 7, 5, 8, 6);
      }
      function ATC8x8Size(width, height) {
        return GetSize(width, height, 7, 7, 8, 8);
      }
      function ATC10x5Size(width, height) {
        return GetSize(width, height, 9, 4, 10, 5);
      }
      function ATC10x6Size(width, height) {
        return GetSize(width, height, 9, 5, 10, 6);
      }
      function ATC10x8Size(width, height) {
        return GetSize(width, height, 9, 7, 10, 8);
      }
      function ATC10x10Size(width, height) {
        return GetSize(width, height, 9, 9, 10, 10);
      }
      function ATC12x10Size(width, height) {
        return GetSize(width, height, 11, 9, 12, 10);
      }
      function ATC12x12Size(width, height) {
        return GetSize(width, height, 11, 11, 12, 12);
      }
      var FORMATS = {
        0: { sizeFunc: PVRTC2bppSize, glFormat: 35841 },
        1: { sizeFunc: PVRTC2bppSize, glFormat: 35843 },
        2: { sizeFunc: PVRTC4bppSize, glFormat: 35840 },
        3: { sizeFunc: PVRTC4bppSize, glFormat: 35842 },
        6: { sizeFunc: DXTEtcSmallSize, glFormat: 36196 },
        7: { sizeFunc: DXTEtcSmallSize, glFormat: 33776 },
        8: { sizeFunc: DXTEtcAstcBigSize, glFormat: 33777 },
        9: { sizeFunc: DXTEtcAstcBigSize, glFormat: 33778 },
        11: { sizeFunc: DXTEtcAstcBigSize, glFormat: 33779 },
        22: { sizeFunc: DXTEtcSmallSize, glFormat: 37492 },
        23: { sizeFunc: DXTEtcAstcBigSize, glFormat: 37496 },
        24: { sizeFunc: DXTEtcSmallSize, glFormat: 37494 },
        25: { sizeFunc: DXTEtcSmallSize, glFormat: 37488 },
        26: { sizeFunc: DXTEtcAstcBigSize, glFormat: 37490 },
        27: { sizeFunc: DXTEtcAstcBigSize, glFormat: 37808 },
        28: { sizeFunc: ATC5x4Size, glFormat: 37809 },
        29: { sizeFunc: ATC5x5Size, glFormat: 37810 },
        30: { sizeFunc: ATC6x5Size, glFormat: 37811 },
        31: { sizeFunc: ATC6x6Size, glFormat: 37812 },
        32: { sizeFunc: ATC8x5Size, glFormat: 37813 },
        33: { sizeFunc: ATC8x6Size, glFormat: 37814 },
        34: { sizeFunc: ATC8x8Size, glFormat: 37815 },
        35: { sizeFunc: ATC10x5Size, glFormat: 37816 },
        36: { sizeFunc: ATC10x6Size, glFormat: 37817 },
        37: { sizeFunc: ATC10x8Size, glFormat: 37818 },
        38: { sizeFunc: ATC10x10Size, glFormat: 37819 },
        39: { sizeFunc: ATC12x10Size, glFormat: 37820 },
        40: { sizeFunc: ATC12x12Size, glFormat: 37821 }
      };
      var PVRParser = function(data) {
        var header = new Uint32Array(data, 0, 13);
        var pvrFormat = header[2];
        var internalFormat = FORMATS[pvrFormat].glFormat;
        var sizeFunction = FORMATS[pvrFormat].sizeFunc;
        var mipmapLevels = header[11];
        var width = header[7];
        var height = header[6];
        var dataOffset = 52 + header[12];
        var image = new Uint8Array(data, dataOffset);
        var mipmaps = new Array(mipmapLevels);
        var offset = 0;
        var levelWidth = width;
        var levelHeight = height;
        for (var i = 0; i < mipmapLevels; i++) {
          var levelSize = sizeFunction(levelWidth, levelHeight);
          mipmaps[i] = {
            data: new Uint8Array(image.buffer, image.byteOffset + offset, levelSize),
            width: levelWidth,
            height: levelHeight
          };
          levelWidth = Math.max(1, levelWidth >> 1);
          levelHeight = Math.max(1, levelHeight >> 1);
          offset += levelSize;
        }
        return {
          mipmaps: mipmaps,
          width: width,
          height: height,
          internalFormat: internalFormat,
          compressed: true,
          generateMipmap: false
        };
      };
      module.exports = PVRParser;
    }
  });

  // ../../node_modules/phaser/src/textures/parsers/SpriteSheet.js
  var require_SpriteSheet = __commonJS({
    "../../node_modules/phaser/src/textures/parsers/SpriteSheet.js": function(exports, module) {
      var GetFastValue = require_GetFastValue();
      var SpriteSheet = function(texture, sourceIndex, x, y, width, height, config) {
        var frameWidth = GetFastValue(config, "frameWidth", null);
        var frameHeight = GetFastValue(config, "frameHeight", frameWidth);
        if (frameWidth === null) {
          throw new Error("TextureManager.SpriteSheet: Invalid frameWidth given.");
        }
        var source = texture.source[sourceIndex];
        texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
        var startFrame = GetFastValue(config, "startFrame", 0);
        var endFrame = GetFastValue(config, "endFrame", -1);
        var margin = GetFastValue(config, "margin", 0);
        var spacing = GetFastValue(config, "spacing", 0);
        var row = Math.floor((width - margin + spacing) / (frameWidth + spacing));
        var column = Math.floor((height - margin + spacing) / (frameHeight + spacing));
        var total = row * column;
        if (total === 0) {
          console.warn("SpriteSheet frame dimensions will result in zero frames for texture:", texture.key);
        }
        if (startFrame > total || startFrame < -total) {
          startFrame = 0;
        }
        if (startFrame < 0) {
          startFrame = total + startFrame;
        }
        if (endFrame === -1 || endFrame > total || endFrame < startFrame) {
          endFrame = total;
        }
        var fx = margin;
        var fy = margin;
        var ax = 0;
        var ay = 0;
        var c = 0;
        for (var i = 0; i < total; i++) {
          ax = 0;
          ay = 0;
          var w = fx + frameWidth;
          var h = fy + frameHeight;
          if (w > width) {
            ax = w - width;
          }
          if (h > height) {
            ay = h - height;
          }
          if (i >= startFrame && i <= endFrame) {
            texture.add(c, sourceIndex, x + fx, y + fy, frameWidth - ax, frameHeight - ay);
            c++;
          }
          fx += frameWidth + spacing;
          if (fx + frameWidth > width) {
            fx = margin;
            fy += frameHeight + spacing;
          }
        }
        return texture;
      };
      module.exports = SpriteSheet;
    }
  });

  // ../../node_modules/phaser/src/textures/parsers/SpriteSheetFromAtlas.js
  var require_SpriteSheetFromAtlas = __commonJS({
    "../../node_modules/phaser/src/textures/parsers/SpriteSheetFromAtlas.js": function(exports, module) {
      var GetFastValue = require_GetFastValue();
      var SpriteSheetFromAtlas = function(texture, frame, config) {
        var frameWidth = GetFastValue(config, "frameWidth", null);
        var frameHeight = GetFastValue(config, "frameHeight", frameWidth);
        if (!frameWidth) {
          throw new Error("TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.");
        }
        var source = texture.source[0];
        texture.add("__BASE", 0, 0, 0, source.width, source.height);
        var startFrame = GetFastValue(config, "startFrame", 0);
        var endFrame = GetFastValue(config, "endFrame", -1);
        var margin = GetFastValue(config, "margin", 0);
        var spacing = GetFastValue(config, "spacing", 0);
        var x = frame.cutX;
        var y = frame.cutY;
        var cutWidth = frame.cutWidth;
        var cutHeight = frame.cutHeight;
        var sheetWidth = frame.realWidth;
        var sheetHeight = frame.realHeight;
        var row = Math.floor((sheetWidth - margin + spacing) / (frameWidth + spacing));
        var column = Math.floor((sheetHeight - margin + spacing) / (frameHeight + spacing));
        var total = row * column;
        var leftPad = frame.x;
        var leftWidth = frameWidth - leftPad;
        var rightWidth = frameWidth - (sheetWidth - cutWidth - leftPad);
        var topPad = frame.y;
        var topHeight = frameHeight - topPad;
        var bottomHeight = frameHeight - (sheetHeight - cutHeight - topPad);
        if (startFrame > total || startFrame < -total) {
          startFrame = 0;
        }
        if (startFrame < 0) {
          startFrame = total + startFrame;
        }
        if (endFrame !== -1) {
          total = startFrame + (endFrame + 1);
        }
        var sheetFrame;
        var frameX = margin;
        var frameY = margin;
        var frameIndex = 0;
        var sourceIndex = 0;
        for (var sheetY = 0; sheetY < column; sheetY++) {
          var topRow = sheetY === 0;
          var bottomRow = sheetY === column - 1;
          for (var sheetX = 0; sheetX < row; sheetX++) {
            var leftRow = sheetX === 0;
            var rightRow = sheetX === row - 1;
            sheetFrame = texture.add(frameIndex, sourceIndex, x + frameX, y + frameY, frameWidth, frameHeight);
            if (leftRow || topRow || rightRow || bottomRow) {
              var destX = leftRow ? leftPad : 0;
              var destY = topRow ? topPad : 0;
              var trimWidth = 0;
              var trimHeight = 0;
              if (leftRow) {
                trimWidth += frameWidth - leftWidth;
              }
              if (rightRow) {
                trimWidth += frameWidth - rightWidth;
              }
              if (topRow) {
                trimHeight += frameHeight - topHeight;
              }
              if (bottomRow) {
                trimHeight += frameHeight - bottomHeight;
              }
              var destWidth = frameWidth - trimWidth;
              var destHeight = frameHeight - trimHeight;
              sheetFrame.cutWidth = destWidth;
              sheetFrame.cutHeight = destHeight;
              sheetFrame.setTrim(frameWidth, frameHeight, destX, destY, destWidth, destHeight);
            }
            frameX += spacing;
            if (leftRow) {
              frameX += leftWidth;
            } else if (rightRow) {
              frameX += rightWidth;
            } else {
              frameX += frameWidth;
            }
            frameIndex++;
          }
          frameX = margin;
          frameY += spacing;
          if (topRow) {
            frameY += topHeight;
          } else if (bottomRow) {
            frameY += bottomHeight;
          } else {
            frameY += frameHeight;
          }
        }
        return texture;
      };
      module.exports = SpriteSheetFromAtlas;
    }
  });

  // ../../node_modules/phaser/src/textures/parsers/UnityYAML.js
  var require_UnityYAML = __commonJS({
    "../../node_modules/phaser/src/textures/parsers/UnityYAML.js": function(exports, module) {
      var imageHeight = 0;
      var addFrame = function(texture, sourceIndex, name, frame) {
        var y = imageHeight - frame.y - frame.height;
        texture.add(name, sourceIndex, frame.x, y, frame.width, frame.height);
      };
      var UnityYAML = function(texture, sourceIndex, yaml) {
        var source = texture.source[sourceIndex];
        texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
        imageHeight = source.height;
        var data = yaml.split("\n");
        var lineRegExp = /^[ ]*(- )*(\w+)+[: ]+(.*)/;
        var prevSprite = "";
        var currentSprite = "";
        var rect = { x: 0, y: 0, width: 0, height: 0 };
        for (var i = 0; i < data.length; i++) {
          var results = data[i].match(lineRegExp);
          if (!results) {
            continue;
          }
          var isList = results[1] === "- ";
          var key = results[2];
          var value = results[3];
          if (isList) {
            if (currentSprite !== prevSprite) {
              addFrame(texture, sourceIndex, currentSprite, rect);
              prevSprite = currentSprite;
            }
            rect = { x: 0, y: 0, width: 0, height: 0 };
          }
          if (key === "name") {
            currentSprite = value;
            continue;
          }
          switch (key) {
            case "x":
            case "y":
            case "width":
            case "height":
              rect[key] = parseInt(value, 10);
              break;
          }
        }
        if (currentSprite !== prevSprite) {
          addFrame(texture, sourceIndex, currentSprite, rect);
        }
        return texture;
      };
      module.exports = UnityYAML;
    }
  });

  // ../../node_modules/phaser/src/textures/parsers/index.js
  var require_parsers = __commonJS({
    "../../node_modules/phaser/src/textures/parsers/index.js": function(exports, module) {
      module.exports = {
        AtlasXML: require_AtlasXML(),
        Canvas: require_Canvas(),
        Image: require_Image2(),
        JSONArray: require_JSONArray(),
        JSONHash: require_JSONHash(),
        KTXParser: require_KTXParser(),
        PVRParser: require_PVRParser(),
        SpriteSheet: require_SpriteSheet(),
        SpriteSheetFromAtlas: require_SpriteSheetFromAtlas(),
        UnityYAML: require_UnityYAML()
      };
    }
  });

  // ../../node_modules/phaser/src/textures/TextureManager.js
  var require_TextureManager = __commonJS({
    "../../node_modules/phaser/src/textures/TextureManager.js": function(exports, module) {
      var CanvasPool = require_CanvasPool();
      var CanvasTexture = require_CanvasTexture();
      var Class = require_Class();
      var Color = require_Color();
      var CONST = require_const();
      var DynamicTexture = require_DynamicTexture();
      var EventEmitter = require_eventemitter3();
      var Events = require_events9();
      var Frame = require_Frame();
      var GameEvents = require_events5();
      var GenerateTexture = require_GenerateTexture();
      var GetValue = require_GetValue();
      var ImageGameObject = require_Image();
      var IsPlainObject = require_IsPlainObject();
      var Parser = require_parsers();
      var Rectangle = require_Rectangle();
      var Texture = require_Texture2();
      var TextureManager = new Class({
        Extends: EventEmitter,
        initialize: function TextureManager2(game) {
          EventEmitter.call(this);
          this.game = game;
          this.name = "TextureManager";
          this.list = {};
          this._tempCanvas = CanvasPool.create2D(this);
          this._tempContext = this._tempCanvas.getContext("2d", { willReadFrequently: true });
          this._pending = 0;
          this.stamp;
          this.stampCrop = new Rectangle();
          this.silentWarnings = false;
          game.events.once(GameEvents.BOOT, this.boot, this);
        },
        boot: function() {
          this._pending = 3;
          this.on(Events.LOAD, this.updatePending, this);
          this.on(Events.ERROR, this.updatePending, this);
          var config = this.game.config;
          this.addBase64("__DEFAULT", config.defaultImage);
          this.addBase64("__MISSING", config.missingImage);
          this.addBase64("__WHITE", config.whiteImage);
          this.game.events.once(GameEvents.DESTROY, this.destroy, this);
        },
        updatePending: function() {
          this._pending--;
          if (this._pending === 0) {
            this.off(Events.LOAD);
            this.off(Events.ERROR);
            this.emit(Events.READY);
            this.stamp = new ImageGameObject(this.game.scene.systemScene).setOrigin(0);
          }
        },
        checkKey: function(key) {
          if (this.exists(key)) {
            if (!this.silentWarnings) {
              console.error("Texture key already in use: " + key);
            }
            return false;
          }
          return true;
        },
        remove: function(key) {
          if (typeof key === "string") {
            if (this.exists(key)) {
              key = this.get(key);
            } else {
              if (!this.silentWarnings) {
                console.warn("No texture found matching key: " + key);
              }
              return this;
            }
          }
          if (this.list.hasOwnProperty(key.key)) {
            key.destroy();
            this.emit(Events.REMOVE, key.key);
            this.emit(Events.REMOVE_KEY + key.key);
          }
          return this;
        },
        removeKey: function(key) {
          if (this.list.hasOwnProperty(key)) {
            delete this.list[key];
          }
          return this;
        },
        addBase64: function(key, data) {
          if (this.checkKey(key)) {
            var _this = this;
            var image = new Image();
            image.onerror = function() {
              _this.emit(Events.ERROR, key);
            };
            image.onload = function() {
              var texture = _this.create(key, image);
              Parser.Image(texture, 0);
              _this.emit(Events.ADD, key, texture);
              _this.emit(Events.ADD_KEY + key, texture);
              _this.emit(Events.LOAD, key, texture);
            };
            image.src = data;
          }
          return this;
        },
        getBase64: function(key, frame, type, encoderOptions) {
          if (type === void 0) {
            type = "image/png";
          }
          if (encoderOptions === void 0) {
            encoderOptions = 0.92;
          }
          var data = "";
          var textureFrame = this.getFrame(key, frame);
          if (textureFrame && (textureFrame.source.isRenderTexture || textureFrame.source.isGLTexture)) {
            if (!this.silentWarnings) {
              console.warn("Cannot getBase64 from WebGL Texture");
            }
          } else if (textureFrame) {
            var cd = textureFrame.canvasData;
            var canvas = CanvasPool.create2D(this, cd.width, cd.height);
            var ctx = canvas.getContext("2d");
            if (cd.width > 0 && cd.height > 0) {
              ctx.drawImage(textureFrame.source.image, cd.x, cd.y, cd.width, cd.height, 0, 0, cd.width, cd.height);
            }
            data = canvas.toDataURL(type, encoderOptions);
            CanvasPool.remove(canvas);
          }
          return data;
        },
        addImage: function(key, source, dataSource) {
          var texture = null;
          if (this.checkKey(key)) {
            texture = this.create(key, source);
            Parser.Image(texture, 0);
            if (dataSource) {
              texture.setDataSource(dataSource);
            }
            this.emit(Events.ADD, key, texture);
            this.emit(Events.ADD_KEY + key, texture);
          }
          return texture;
        },
        addGLTexture: function(key, glTexture, width, height) {
          var texture = null;
          if (this.checkKey(key)) {
            if (width === void 0) {
              width = glTexture.width;
            }
            if (height === void 0) {
              height = glTexture.height;
            }
            texture = this.create(key, glTexture, width, height);
            texture.add("__BASE", 0, 0, 0, width, height);
            this.emit(Events.ADD, key, texture);
            this.emit(Events.ADD_KEY + key, texture);
          }
          return texture;
        },
        addCompressedTexture: function(key, textureData, atlasData) {
          var texture = null;
          if (this.checkKey(key)) {
            texture = this.create(key, textureData);
            texture.add("__BASE", 0, 0, 0, textureData.width, textureData.height);
            if (atlasData) {
              if (Array.isArray(atlasData)) {
                for (var i = 0; i < atlasData.length; i++) {
                  Parser.JSONHash(texture, i, atlasData[i]);
                }
              } else {
                Parser.JSONHash(texture, 0, atlasData);
              }
            }
            this.emit(Events.ADD, key, texture);
            this.emit(Events.ADD_KEY + key, texture);
          }
          return texture;
        },
        addRenderTexture: function(key, renderTexture) {
          var texture = null;
          if (this.checkKey(key)) {
            texture = this.create(key, renderTexture);
            texture.add("__BASE", 0, 0, 0, renderTexture.width, renderTexture.height);
            this.emit(Events.ADD, key, texture);
            this.emit(Events.ADD_KEY + key, texture);
          }
          return texture;
        },
        generate: function(key, config) {
          if (this.checkKey(key)) {
            var canvas = CanvasPool.create(this, 1, 1);
            config.canvas = canvas;
            GenerateTexture(config);
            return this.addCanvas(key, canvas);
          } else {
            return null;
          }
        },
        createCanvas: function(key, width, height) {
          if (width === void 0) {
            width = 256;
          }
          if (height === void 0) {
            height = 256;
          }
          if (this.checkKey(key)) {
            var canvas = CanvasPool.create(this, width, height, CONST.CANVAS, true);
            return this.addCanvas(key, canvas);
          }
          return null;
        },
        addCanvas: function(key, source, skipCache) {
          if (skipCache === void 0) {
            skipCache = false;
          }
          var texture = null;
          if (skipCache) {
            texture = new CanvasTexture(this, key, source, source.width, source.height);
          } else if (this.checkKey(key)) {
            texture = new CanvasTexture(this, key, source, source.width, source.height);
            this.list[key] = texture;
            this.emit(Events.ADD, key, texture);
            this.emit(Events.ADD_KEY + key, texture);
          }
          return texture;
        },
        addDynamicTexture: function(key, width, height) {
          var texture = null;
          if (typeof key === "string" && !this.exists(key)) {
            texture = new DynamicTexture(this, key, width, height);
          } else {
            texture = key;
            key = texture.key;
          }
          if (this.checkKey(key)) {
            this.list[key] = texture;
            this.emit(Events.ADD, key, texture);
            this.emit(Events.ADD_KEY + key, texture);
          } else {
            texture = null;
          }
          return texture;
        },
        addAtlas: function(key, source, data, dataSource) {
          if (Array.isArray(data.textures) || Array.isArray(data.frames)) {
            return this.addAtlasJSONArray(key, source, data, dataSource);
          } else {
            return this.addAtlasJSONHash(key, source, data, dataSource);
          }
        },
        addAtlasJSONArray: function(key, source, data, dataSource) {
          var texture = null;
          if (source instanceof Texture) {
            key = texture.key;
            texture = source;
          } else if (this.checkKey(key)) {
            texture = this.create(key, source);
          }
          if (texture) {
            if (Array.isArray(data)) {
              var singleAtlasFile = data.length === 1;
              for (var i = 0; i < texture.source.length; i++) {
                var atlasData = singleAtlasFile ? data[0] : data[i];
                Parser.JSONArray(texture, i, atlasData);
              }
            } else {
              Parser.JSONArray(texture, 0, data);
            }
            if (dataSource) {
              texture.setDataSource(dataSource);
            }
            this.emit(Events.ADD, key, texture);
            this.emit(Events.ADD_KEY + key, texture);
          }
          return texture;
        },
        addAtlasJSONHash: function(key, source, data, dataSource) {
          var texture = null;
          if (source instanceof Texture) {
            key = texture.key;
            texture = source;
          } else if (this.checkKey(key)) {
            texture = this.create(key, source);
          }
          if (texture) {
            if (Array.isArray(data)) {
              for (var i = 0; i < data.length; i++) {
                Parser.JSONHash(texture, i, data[i]);
              }
            } else {
              Parser.JSONHash(texture, 0, data);
            }
            if (dataSource) {
              texture.setDataSource(dataSource);
            }
            this.emit(Events.ADD, key, texture);
            this.emit(Events.ADD_KEY + key, texture);
          }
          return texture;
        },
        addAtlasXML: function(key, source, data, dataSource) {
          var texture = null;
          if (source instanceof Texture) {
            key = texture.key;
            texture = source;
          } else if (this.checkKey(key)) {
            texture = this.create(key, source);
          }
          if (texture) {
            Parser.AtlasXML(texture, 0, data);
            if (dataSource) {
              texture.setDataSource(dataSource);
            }
            this.emit(Events.ADD, key, texture);
            this.emit(Events.ADD_KEY + key, texture);
          }
          return texture;
        },
        addUnityAtlas: function(key, source, data, dataSource) {
          var texture = null;
          if (source instanceof Texture) {
            key = texture.key;
            texture = source;
          } else if (this.checkKey(key)) {
            texture = this.create(key, source);
          }
          if (texture) {
            Parser.UnityYAML(texture, 0, data);
            if (dataSource) {
              texture.setDataSource(dataSource);
            }
            this.emit(Events.ADD, key, texture);
            this.emit(Events.ADD_KEY + key, texture);
          }
          return texture;
        },
        addSpriteSheet: function(key, source, config) {
          var texture = null;
          if (source instanceof Texture) {
            key = texture.key;
            texture = source;
          } else if (this.checkKey(key)) {
            texture = this.create(key, source);
          }
          if (texture) {
            var width = texture.source[0].width;
            var height = texture.source[0].height;
            Parser.SpriteSheet(texture, 0, 0, 0, width, height, config);
            this.emit(Events.ADD, key, texture);
            this.emit(Events.ADD_KEY + key, texture);
          }
          return texture;
        },
        addSpriteSheetFromAtlas: function(key, config) {
          if (!this.checkKey(key)) {
            return null;
          }
          var atlasKey = GetValue(config, "atlas", null);
          var atlasFrame = GetValue(config, "frame", null);
          if (!atlasKey || !atlasFrame) {
            return;
          }
          var atlas = this.get(atlasKey);
          var sheet = atlas.get(atlasFrame);
          if (sheet) {
            var texture = this.create(key, sheet.source.image);
            if (sheet.trimmed) {
              Parser.SpriteSheetFromAtlas(texture, sheet, config);
            } else {
              Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, config);
            }
            this.emit(Events.ADD, key, texture);
            this.emit(Events.ADD_KEY + key, texture);
            return texture;
          }
        },
        create: function(key, source, width, height) {
          var texture = null;
          if (this.checkKey(key)) {
            texture = new Texture(this, key, source, width, height);
            this.list[key] = texture;
          }
          return texture;
        },
        exists: function(key) {
          return this.list.hasOwnProperty(key);
        },
        get: function(key) {
          if (key === void 0) {
            key = "__DEFAULT";
          }
          if (this.list[key]) {
            return this.list[key];
          } else if (key instanceof Texture) {
            return key;
          } else if (key instanceof Frame) {
            return key.texture;
          } else {
            return this.list["__MISSING"];
          }
        },
        cloneFrame: function(key, frame) {
          if (this.list[key]) {
            return this.list[key].get(frame).clone();
          }
        },
        getFrame: function(key, frame) {
          if (this.list[key]) {
            return this.list[key].get(frame);
          }
        },
        parseFrame: function(key) {
          if (!key) {
            return void 0;
          } else if (typeof key === "string") {
            return this.getFrame(key);
          } else if (Array.isArray(key) && key.length === 2) {
            return this.getFrame(key[0], key[1]);
          } else if (IsPlainObject(key)) {
            return this.getFrame(key.key, key.frame);
          } else if (key instanceof Texture) {
            return key.get();
          } else if (key instanceof Frame) {
            return key;
          }
        },
        getTextureKeys: function() {
          var output = [];
          for (var key in this.list) {
            if (key !== "__DEFAULT" && key !== "__MISSING" && key !== "__WHITE") {
              output.push(key);
            }
          }
          return output;
        },
        getPixel: function(x, y, key, frame) {
          var textureFrame = this.getFrame(key, frame);
          if (textureFrame) {
            x -= textureFrame.x;
            y -= textureFrame.y;
            var data = textureFrame.data.cut;
            x += data.x;
            y += data.y;
            if (x >= data.x && x < data.r && y >= data.y && y < data.b) {
              var ctx = this._tempContext;
              ctx.clearRect(0, 0, 1, 1);
              ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);
              var rgb = ctx.getImageData(0, 0, 1, 1);
              return new Color(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);
            }
          }
          return null;
        },
        getPixelAlpha: function(x, y, key, frame) {
          var textureFrame = this.getFrame(key, frame);
          if (textureFrame) {
            x -= textureFrame.x;
            y -= textureFrame.y;
            var data = textureFrame.data.cut;
            x += data.x;
            y += data.y;
            if (x >= data.x && x < data.r && y >= data.y && y < data.b) {
              var ctx = this._tempContext;
              ctx.clearRect(0, 0, 1, 1);
              ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);
              var rgb = ctx.getImageData(0, 0, 1, 1);
              return rgb.data[3];
            }
          }
          return null;
        },
        setTexture: function(gameObject, key, frame) {
          if (this.list[key]) {
            gameObject.texture = this.list[key];
            gameObject.frame = gameObject.texture.get(frame);
          }
          return gameObject;
        },
        renameTexture: function(currentKey, newKey) {
          var texture = this.get(currentKey);
          if (texture && currentKey !== newKey) {
            texture.key = newKey;
            this.list[newKey] = texture;
            delete this.list[currentKey];
            return true;
          }
          return false;
        },
        each: function(callback, scope) {
          var args = [null];
          for (var i = 1; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          for (var texture in this.list) {
            args[0] = this.list[texture];
            callback.apply(scope, args);
          }
        },
        resetStamp: function(alpha, tint) {
          if (alpha === void 0) {
            alpha = 1;
          }
          if (tint === void 0) {
            tint = 16777215;
          }
          var stamp = this.stamp;
          stamp.setCrop();
          stamp.setPosition(0);
          stamp.setAngle(0);
          stamp.setScale(1);
          stamp.setAlpha(alpha);
          stamp.setTint(tint);
          return stamp;
        },
        destroy: function() {
          for (var texture in this.list) {
            this.list[texture].destroy();
          }
          this.list = {};
          this.stamp.destroy();
          this.game = null;
          this.stamp = null;
          CanvasPool.remove(this._tempCanvas);
        }
      });
      module.exports = TextureManager;
    }
  });

  // ../../node_modules/phaser/src/sound/events/COMPLETE_EVENT.js
  var require_COMPLETE_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/sound/events/COMPLETE_EVENT.js": function(exports, module) {
      module.exports = "complete";
    }
  });

  // ../../node_modules/phaser/src/sound/events/DECODED_EVENT.js
  var require_DECODED_EVENT = __commonJS({
    "../../node_modules/phaser/src/sound/events/DECODED_EVENT.js": function(exports, module) {
      module.exports = "decoded";
    }
  });

  // ../../node_modules/phaser/src/sound/events/DECODED_ALL_EVENT.js
  var require_DECODED_ALL_EVENT = __commonJS({
    "../../node_modules/phaser/src/sound/events/DECODED_ALL_EVENT.js": function(exports, module) {
      module.exports = "decodedall";
    }
  });

  // ../../node_modules/phaser/src/sound/events/DESTROY_EVENT.js
  var require_DESTROY_EVENT8 = __commonJS({
    "../../node_modules/phaser/src/sound/events/DESTROY_EVENT.js": function(exports, module) {
      module.exports = "destroy";
    }
  });

  // ../../node_modules/phaser/src/sound/events/DETUNE_EVENT.js
  var require_DETUNE_EVENT = __commonJS({
    "../../node_modules/phaser/src/sound/events/DETUNE_EVENT.js": function(exports, module) {
      module.exports = "detune";
    }
  });

  // ../../node_modules/phaser/src/sound/events/GLOBAL_DETUNE_EVENT.js
  var require_GLOBAL_DETUNE_EVENT = __commonJS({
    "../../node_modules/phaser/src/sound/events/GLOBAL_DETUNE_EVENT.js": function(exports, module) {
      module.exports = "detune";
    }
  });

  // ../../node_modules/phaser/src/sound/events/GLOBAL_MUTE_EVENT.js
  var require_GLOBAL_MUTE_EVENT = __commonJS({
    "../../node_modules/phaser/src/sound/events/GLOBAL_MUTE_EVENT.js": function(exports, module) {
      module.exports = "mute";
    }
  });

  // ../../node_modules/phaser/src/sound/events/GLOBAL_RATE_EVENT.js
  var require_GLOBAL_RATE_EVENT = __commonJS({
    "../../node_modules/phaser/src/sound/events/GLOBAL_RATE_EVENT.js": function(exports, module) {
      module.exports = "rate";
    }
  });

  // ../../node_modules/phaser/src/sound/events/GLOBAL_VOLUME_EVENT.js
  var require_GLOBAL_VOLUME_EVENT = __commonJS({
    "../../node_modules/phaser/src/sound/events/GLOBAL_VOLUME_EVENT.js": function(exports, module) {
      module.exports = "volume";
    }
  });

  // ../../node_modules/phaser/src/sound/events/LOOP_EVENT.js
  var require_LOOP_EVENT = __commonJS({
    "../../node_modules/phaser/src/sound/events/LOOP_EVENT.js": function(exports, module) {
      module.exports = "loop";
    }
  });

  // ../../node_modules/phaser/src/sound/events/LOOPED_EVENT.js
  var require_LOOPED_EVENT = __commonJS({
    "../../node_modules/phaser/src/sound/events/LOOPED_EVENT.js": function(exports, module) {
      module.exports = "looped";
    }
  });

  // ../../node_modules/phaser/src/sound/events/MUTE_EVENT.js
  var require_MUTE_EVENT = __commonJS({
    "../../node_modules/phaser/src/sound/events/MUTE_EVENT.js": function(exports, module) {
      module.exports = "mute";
    }
  });

  // ../../node_modules/phaser/src/sound/events/PAN_EVENT.js
  var require_PAN_EVENT = __commonJS({
    "../../node_modules/phaser/src/sound/events/PAN_EVENT.js": function(exports, module) {
      module.exports = "pan";
    }
  });

  // ../../node_modules/phaser/src/sound/events/PAUSE_ALL_EVENT.js
  var require_PAUSE_ALL_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/sound/events/PAUSE_ALL_EVENT.js": function(exports, module) {
      module.exports = "pauseall";
    }
  });

  // ../../node_modules/phaser/src/sound/events/PAUSE_EVENT.js
  var require_PAUSE_EVENT3 = __commonJS({
    "../../node_modules/phaser/src/sound/events/PAUSE_EVENT.js": function(exports, module) {
      module.exports = "pause";
    }
  });

  // ../../node_modules/phaser/src/sound/events/PLAY_EVENT.js
  var require_PLAY_EVENT = __commonJS({
    "../../node_modules/phaser/src/sound/events/PLAY_EVENT.js": function(exports, module) {
      module.exports = "play";
    }
  });

  // ../../node_modules/phaser/src/sound/events/RATE_EVENT.js
  var require_RATE_EVENT = __commonJS({
    "../../node_modules/phaser/src/sound/events/RATE_EVENT.js": function(exports, module) {
      module.exports = "rate";
    }
  });

  // ../../node_modules/phaser/src/sound/events/RESUME_ALL_EVENT.js
  var require_RESUME_ALL_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/sound/events/RESUME_ALL_EVENT.js": function(exports, module) {
      module.exports = "resumeall";
    }
  });

  // ../../node_modules/phaser/src/sound/events/RESUME_EVENT.js
  var require_RESUME_EVENT3 = __commonJS({
    "../../node_modules/phaser/src/sound/events/RESUME_EVENT.js": function(exports, module) {
      module.exports = "resume";
    }
  });

  // ../../node_modules/phaser/src/sound/events/SEEK_EVENT.js
  var require_SEEK_EVENT = __commonJS({
    "../../node_modules/phaser/src/sound/events/SEEK_EVENT.js": function(exports, module) {
      module.exports = "seek";
    }
  });

  // ../../node_modules/phaser/src/sound/events/STOP_ALL_EVENT.js
  var require_STOP_ALL_EVENT = __commonJS({
    "../../node_modules/phaser/src/sound/events/STOP_ALL_EVENT.js": function(exports, module) {
      module.exports = "stopall";
    }
  });

  // ../../node_modules/phaser/src/sound/events/STOP_EVENT.js
  var require_STOP_EVENT = __commonJS({
    "../../node_modules/phaser/src/sound/events/STOP_EVENT.js": function(exports, module) {
      module.exports = "stop";
    }
  });

  // ../../node_modules/phaser/src/sound/events/UNLOCKED_EVENT.js
  var require_UNLOCKED_EVENT = __commonJS({
    "../../node_modules/phaser/src/sound/events/UNLOCKED_EVENT.js": function(exports, module) {
      module.exports = "unlocked";
    }
  });

  // ../../node_modules/phaser/src/sound/events/VOLUME_EVENT.js
  var require_VOLUME_EVENT = __commonJS({
    "../../node_modules/phaser/src/sound/events/VOLUME_EVENT.js": function(exports, module) {
      module.exports = "volume";
    }
  });

  // ../../node_modules/phaser/src/sound/events/index.js
  var require_events15 = __commonJS({
    "../../node_modules/phaser/src/sound/events/index.js": function(exports, module) {
      module.exports = {
        COMPLETE: require_COMPLETE_EVENT2(),
        DECODED: require_DECODED_EVENT(),
        DECODED_ALL: require_DECODED_ALL_EVENT(),
        DESTROY: require_DESTROY_EVENT8(),
        DETUNE: require_DETUNE_EVENT(),
        GLOBAL_DETUNE: require_GLOBAL_DETUNE_EVENT(),
        GLOBAL_MUTE: require_GLOBAL_MUTE_EVENT(),
        GLOBAL_RATE: require_GLOBAL_RATE_EVENT(),
        GLOBAL_VOLUME: require_GLOBAL_VOLUME_EVENT(),
        LOOP: require_LOOP_EVENT(),
        LOOPED: require_LOOPED_EVENT(),
        MUTE: require_MUTE_EVENT(),
        PAN: require_PAN_EVENT(),
        PAUSE_ALL: require_PAUSE_ALL_EVENT2(),
        PAUSE: require_PAUSE_EVENT3(),
        PLAY: require_PLAY_EVENT(),
        RATE: require_RATE_EVENT(),
        RESUME_ALL: require_RESUME_ALL_EVENT2(),
        RESUME: require_RESUME_EVENT3(),
        SEEK: require_SEEK_EVENT(),
        STOP_ALL: require_STOP_ALL_EVENT(),
        STOP: require_STOP_EVENT(),
        UNLOCKED: require_UNLOCKED_EVENT(),
        VOLUME: require_VOLUME_EVENT()
      };
    }
  });

  // ../../node_modules/phaser/src/utils/array/SafeRange.js
  var require_SafeRange = __commonJS({
    "../../node_modules/phaser/src/utils/array/SafeRange.js": function(exports, module) {
      var SafeRange = function(array, startIndex, endIndex, throwError) {
        var len = array.length;
        if (startIndex < 0 || startIndex > len || startIndex >= endIndex || endIndex > len) {
          if (throwError) {
            throw new Error("Range Error: Values outside acceptable range");
          }
          return false;
        } else {
          return true;
        }
      };
      module.exports = SafeRange;
    }
  });

  // ../../node_modules/phaser/src/utils/array/GetAll.js
  var require_GetAll = __commonJS({
    "../../node_modules/phaser/src/utils/array/GetAll.js": function(exports, module) {
      var SafeRange = require_SafeRange();
      var GetAll = function(array, property, value, startIndex, endIndex) {
        if (startIndex === void 0) {
          startIndex = 0;
        }
        if (endIndex === void 0) {
          endIndex = array.length;
        }
        var output = [];
        if (SafeRange(array, startIndex, endIndex)) {
          for (var i = startIndex; i < endIndex; i++) {
            var child = array[i];
            if (!property || property && value === void 0 && child.hasOwnProperty(property) || property && value !== void 0 && child[property] === value) {
              output.push(child);
            }
          }
        }
        return output;
      };
      module.exports = GetAll;
    }
  });

  // ../../node_modules/phaser/src/utils/array/GetFirst.js
  var require_GetFirst = __commonJS({
    "../../node_modules/phaser/src/utils/array/GetFirst.js": function(exports, module) {
      var SafeRange = require_SafeRange();
      var GetFirst = function(array, property, value, startIndex, endIndex) {
        if (startIndex === void 0) {
          startIndex = 0;
        }
        if (endIndex === void 0) {
          endIndex = array.length;
        }
        if (SafeRange(array, startIndex, endIndex)) {
          for (var i = startIndex; i < endIndex; i++) {
            var child = array[i];
            if (!property || property && value === void 0 && child.hasOwnProperty(property) || property && value !== void 0 && child[property] === value) {
              return child;
            }
          }
        }
        return null;
      };
      module.exports = GetFirst;
    }
  });

  // ../../node_modules/phaser/src/sound/BaseSoundManager.js
  var require_BaseSoundManager = __commonJS({
    "../../node_modules/phaser/src/sound/BaseSoundManager.js": function(exports, module) {
      var Class = require_Class();
      var Clone = require_Clone();
      var EventEmitter = require_eventemitter3();
      var Events = require_events15();
      var GameEvents = require_events5();
      var GetAll = require_GetAll();
      var GetFirst = require_GetFirst();
      var NOOP = require_NOOP();
      var Vector2 = require_Vector2();
      var BaseSoundManager = new Class({
        Extends: EventEmitter,
        initialize: function BaseSoundManager2(game) {
          EventEmitter.call(this);
          this.game = game;
          this.jsonCache = game.cache.json;
          this.sounds = [];
          this.mute = false;
          this.volume = 1;
          this.pauseOnBlur = true;
          this._rate = 1;
          this._detune = 0;
          this.locked = this.locked || false;
          this.unlocked = false;
          this.listenerPosition = new Vector2();
          game.events.on(GameEvents.BLUR, this.onGameBlur, this);
          game.events.on(GameEvents.FOCUS, this.onGameFocus, this);
          game.events.on(GameEvents.PRE_STEP, this.update, this);
          game.events.once(GameEvents.DESTROY, this.destroy, this);
        },
        add: NOOP,
        addAudioSprite: function(key, config) {
          if (config === void 0) {
            config = {};
          }
          var sound = this.add(key, config);
          sound.spritemap = this.jsonCache.get(key).spritemap;
          for (var markerName in sound.spritemap) {
            if (!sound.spritemap.hasOwnProperty(markerName)) {
              continue;
            }
            var markerConfig = Clone(config);
            var marker = sound.spritemap[markerName];
            markerConfig.loop = marker.hasOwnProperty("loop") ? marker.loop : false;
            sound.addMarker({
              name: markerName,
              start: marker.start,
              duration: marker.end - marker.start,
              config: markerConfig
            });
          }
          return sound;
        },
        get: function(key) {
          return GetFirst(this.sounds, "key", key);
        },
        getAll: function(key) {
          if (key) {
            return GetAll(this.sounds, "key", key);
          } else {
            return GetAll(this.sounds);
          }
        },
        getAllPlaying: function() {
          return GetAll(this.sounds, "isPlaying", true);
        },
        play: function(key, extra) {
          var sound = this.add(key);
          sound.once(Events.COMPLETE, sound.destroy, sound);
          if (extra) {
            if (extra.name) {
              sound.addMarker(extra);
              return sound.play(extra.name);
            } else {
              return sound.play(extra);
            }
          } else {
            return sound.play();
          }
        },
        playAudioSprite: function(key, spriteName, config) {
          var sound = this.addAudioSprite(key);
          sound.once(Events.COMPLETE, sound.destroy, sound);
          return sound.play(spriteName, config);
        },
        remove: function(sound) {
          var index = this.sounds.indexOf(sound);
          if (index !== -1) {
            sound.destroy();
            this.sounds.splice(index, 1);
            return true;
          }
          return false;
        },
        removeAll: function() {
          this.sounds.forEach(function(sound) {
            sound.destroy();
          });
          this.sounds.length = 0;
        },
        removeByKey: function(key) {
          var removed = 0;
          for (var i = this.sounds.length - 1; i >= 0; i--) {
            var sound = this.sounds[i];
            if (sound.key === key) {
              sound.destroy();
              this.sounds.splice(i, 1);
              removed++;
            }
          }
          return removed;
        },
        pauseAll: function() {
          this.forEachActiveSound(function(sound) {
            sound.pause();
          });
          this.emit(Events.PAUSE_ALL, this);
        },
        resumeAll: function() {
          this.forEachActiveSound(function(sound) {
            sound.resume();
          });
          this.emit(Events.RESUME_ALL, this);
        },
        setListenerPosition: NOOP,
        stopAll: function() {
          this.forEachActiveSound(function(sound) {
            sound.stop();
          });
          this.emit(Events.STOP_ALL, this);
        },
        stopByKey: function(key) {
          var stopped = 0;
          this.getAll(key).forEach(function(sound) {
            if (sound.stop()) {
              stopped++;
            }
          });
          return stopped;
        },
        unlock: NOOP,
        onBlur: NOOP,
        onFocus: NOOP,
        onGameBlur: function() {
          if (this.pauseOnBlur) {
            this.onBlur();
          }
        },
        onGameFocus: function() {
          if (this.pauseOnBlur) {
            this.onFocus();
          }
        },
        update: function(time, delta) {
          if (this.unlocked) {
            this.unlocked = false;
            this.locked = false;
            this.emit(Events.UNLOCKED, this);
          }
          for (var i = this.sounds.length - 1; i >= 0; i--) {
            if (this.sounds[i].pendingRemove) {
              this.sounds.splice(i, 1);
            }
          }
          this.sounds.forEach(function(sound) {
            sound.update(time, delta);
          });
        },
        destroy: function() {
          this.game.events.off(GameEvents.BLUR, this.onGameBlur, this);
          this.game.events.off(GameEvents.FOCUS, this.onGameFocus, this);
          this.game.events.off(GameEvents.PRE_STEP, this.update, this);
          this.removeAllListeners();
          this.removeAll();
          this.sounds.length = 0;
          this.sounds = null;
          this.listenerPosition = null;
          this.game = null;
        },
        forEachActiveSound: function(callback, scope) {
          var _this = this;
          this.sounds.forEach(function(sound, index) {
            if (sound && !sound.pendingRemove) {
              callback.call(scope || _this, sound, index, _this.sounds);
            }
          });
        },
        setRate: function(value) {
          this.rate = value;
          return this;
        },
        rate: {
          get: function() {
            return this._rate;
          },
          set: function(value) {
            this._rate = value;
            this.forEachActiveSound(function(sound) {
              sound.calculateRate();
            });
            this.emit(Events.GLOBAL_RATE, this, value);
          }
        },
        setDetune: function(value) {
          this.detune = value;
          return this;
        },
        detune: {
          get: function() {
            return this._detune;
          },
          set: function(value) {
            this._detune = value;
            this.forEachActiveSound(function(sound) {
              sound.calculateRate();
            });
            this.emit(Events.GLOBAL_DETUNE, this, value);
          }
        }
      });
      module.exports = BaseSoundManager;
    }
  });

  // ../../node_modules/phaser/src/sound/BaseSound.js
  var require_BaseSound = __commonJS({
    "../../node_modules/phaser/src/sound/BaseSound.js": function(exports, module) {
      var Class = require_Class();
      var EventEmitter = require_eventemitter3();
      var Events = require_events15();
      var Extend = require_Extend();
      var NOOP = require_NOOP();
      var BaseSound = new Class({
        Extends: EventEmitter,
        initialize: function BaseSound2(manager, key, config) {
          EventEmitter.call(this);
          this.manager = manager;
          this.key = key;
          this.isPlaying = false;
          this.isPaused = false;
          this.totalRate = 1;
          this.duration = this.duration || 0;
          this.totalDuration = this.totalDuration || 0;
          this.config = {
            mute: false,
            volume: 1,
            rate: 1,
            detune: 0,
            seek: 0,
            loop: false,
            delay: 0,
            pan: 0
          };
          this.currentConfig = this.config;
          this.config = Extend(this.config, config);
          this.markers = {};
          this.currentMarker = null;
          this.pendingRemove = false;
        },
        addMarker: function(marker) {
          if (!marker || !marker.name || typeof marker.name !== "string") {
            return false;
          }
          if (this.markers[marker.name]) {
            console.error("addMarker " + marker.name + " already exists in Sound");
            return false;
          }
          marker = Extend(true, {
            name: "",
            start: 0,
            duration: this.totalDuration - (marker.start || 0),
            config: {
              mute: false,
              volume: 1,
              rate: 1,
              detune: 0,
              seek: 0,
              loop: false,
              delay: 0,
              pan: 0
            }
          }, marker);
          this.markers[marker.name] = marker;
          return true;
        },
        updateMarker: function(marker) {
          if (!marker || !marker.name || typeof marker.name !== "string") {
            return false;
          }
          if (!this.markers[marker.name]) {
            console.warn("Audio Marker: " + marker.name + " missing in Sound: " + this.key);
            return false;
          }
          this.markers[marker.name] = Extend(true, this.markers[marker.name], marker);
          return true;
        },
        removeMarker: function(markerName) {
          var marker = this.markers[markerName];
          if (!marker) {
            return null;
          }
          this.markers[markerName] = null;
          return marker;
        },
        play: function(markerName, config) {
          if (markerName === void 0) {
            markerName = "";
          }
          if (typeof markerName === "object") {
            config = markerName;
            markerName = "";
          }
          if (typeof markerName !== "string") {
            return false;
          }
          if (!markerName) {
            this.currentMarker = null;
            this.currentConfig = this.config;
            this.duration = this.totalDuration;
          } else {
            if (!this.markers[markerName]) {
              console.warn("Marker: " + markerName + " missing in Sound: " + this.key);
              return false;
            }
            this.currentMarker = this.markers[markerName];
            this.currentConfig = this.currentMarker.config;
            this.duration = this.currentMarker.duration;
          }
          this.resetConfig();
          this.currentConfig = Extend(this.currentConfig, config);
          this.isPlaying = true;
          this.isPaused = false;
          return true;
        },
        pause: function() {
          if (this.isPaused || !this.isPlaying) {
            return false;
          }
          this.isPlaying = false;
          this.isPaused = true;
          return true;
        },
        resume: function() {
          if (!this.isPaused || this.isPlaying) {
            return false;
          }
          this.isPlaying = true;
          this.isPaused = false;
          return true;
        },
        stop: function() {
          if (!this.isPaused && !this.isPlaying) {
            return false;
          }
          this.isPlaying = false;
          this.isPaused = false;
          this.resetConfig();
          return true;
        },
        applyConfig: function() {
          this.mute = this.currentConfig.mute;
          this.volume = this.currentConfig.volume;
          this.rate = this.currentConfig.rate;
          this.detune = this.currentConfig.detune;
          this.loop = this.currentConfig.loop;
          this.pan = this.currentConfig.pan;
        },
        resetConfig: function() {
          this.currentConfig.seek = 0;
          this.currentConfig.delay = 0;
        },
        update: NOOP,
        calculateRate: function() {
          var cent = 1.0005777895065548;
          var totalDetune = this.currentConfig.detune + this.manager.detune;
          var detuneRate = Math.pow(cent, totalDetune);
          this.totalRate = this.currentConfig.rate * this.manager.rate * detuneRate;
        },
        destroy: function() {
          if (this.pendingRemove) {
            return;
          }
          this.emit(Events.DESTROY, this);
          this.removeAllListeners();
          this.pendingRemove = true;
          this.manager = null;
          this.config = null;
          this.currentConfig = null;
          this.markers = null;
          this.currentMarker = null;
        }
      });
      module.exports = BaseSound;
    }
  });

  // ../../node_modules/phaser/src/sound/html5/HTML5AudioSound.js
  var require_HTML5AudioSound = __commonJS({
    "../../node_modules/phaser/src/sound/html5/HTML5AudioSound.js": function(exports, module) {
      var BaseSound = require_BaseSound();
      var Class = require_Class();
      var Events = require_events15();
      var Clamp = require_Clamp();
      var HTML5AudioSound = new Class({
        Extends: BaseSound,
        initialize: function HTML5AudioSound2(manager, key, config) {
          if (config === void 0) {
            config = {};
          }
          this.tags = manager.game.cache.audio.get(key);
          if (!this.tags) {
            throw new Error('No cached audio asset with key "' + key);
          }
          this.audio = null;
          this.startTime = 0;
          this.previousTime = 0;
          this.duration = this.tags[0].duration;
          this.totalDuration = this.tags[0].duration;
          BaseSound.call(this, manager, key, config);
        },
        play: function(markerName, config) {
          if (this.manager.isLocked(this, "play", [markerName, config])) {
            return false;
          }
          if (!BaseSound.prototype.play.call(this, markerName, config)) {
            return false;
          }
          if (!this.pickAndPlayAudioTag()) {
            return false;
          }
          this.emit(Events.PLAY, this);
          return true;
        },
        pause: function() {
          if (this.manager.isLocked(this, "pause")) {
            return false;
          }
          if (this.startTime > 0) {
            return false;
          }
          if (!BaseSound.prototype.pause.call(this)) {
            return false;
          }
          this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
          this.stopAndReleaseAudioTag();
          this.emit(Events.PAUSE, this);
          return true;
        },
        resume: function() {
          if (this.manager.isLocked(this, "resume")) {
            return false;
          }
          if (this.startTime > 0) {
            return false;
          }
          if (!BaseSound.prototype.resume.call(this)) {
            return false;
          }
          if (!this.pickAndPlayAudioTag()) {
            return false;
          }
          this.emit(Events.RESUME, this);
          return true;
        },
        stop: function() {
          if (this.manager.isLocked(this, "stop")) {
            return false;
          }
          if (!BaseSound.prototype.stop.call(this)) {
            return false;
          }
          this.stopAndReleaseAudioTag();
          this.emit(Events.STOP, this);
          return true;
        },
        pickAndPlayAudioTag: function() {
          if (!this.pickAudioTag()) {
            this.reset();
            return false;
          }
          var seek = this.currentConfig.seek;
          var delay = this.currentConfig.delay;
          var offset = (this.currentMarker ? this.currentMarker.start : 0) + seek;
          this.previousTime = offset;
          this.audio.currentTime = offset;
          this.applyConfig();
          if (delay === 0) {
            this.startTime = 0;
            if (this.audio.paused) {
              this.playCatchPromise();
            }
          } else {
            this.startTime = window.performance.now() + delay * 1e3;
            if (!this.audio.paused) {
              this.audio.pause();
            }
          }
          this.resetConfig();
          return true;
        },
        pickAudioTag: function() {
          if (this.audio) {
            return true;
          }
          for (var i = 0; i < this.tags.length; i++) {
            var audio = this.tags[i];
            if (audio.dataset.used === "false") {
              audio.dataset.used = "true";
              this.audio = audio;
              return true;
            }
          }
          if (!this.manager.override) {
            return false;
          }
          var otherSounds = [];
          this.manager.forEachActiveSound(function(sound) {
            if (sound.key === this.key && sound.audio) {
              otherSounds.push(sound);
            }
          }, this);
          otherSounds.sort(function(a1, a2) {
            if (a1.loop === a2.loop) {
              return a2.seek / a2.duration - a1.seek / a1.duration;
            }
            return a1.loop ? 1 : -1;
          });
          var selectedSound = otherSounds[0];
          this.audio = selectedSound.audio;
          selectedSound.reset();
          selectedSound.audio = null;
          selectedSound.startTime = 0;
          selectedSound.previousTime = 0;
          return true;
        },
        playCatchPromise: function() {
          var playPromise = this.audio.play();
          if (playPromise) {
            playPromise.catch(function(reason) {
              console.warn(reason);
            });
          }
        },
        stopAndReleaseAudioTag: function() {
          this.startTime = 0;
          this.previousTime = 0;
          if (this.audio) {
            this.audio.pause();
            this.audio.dataset.used = "false";
            this.audio = null;
          }
        },
        reset: function() {
          BaseSound.prototype.stop.call(this);
        },
        onBlur: function() {
          this.isPlaying = false;
          this.isPaused = true;
          this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
          this.currentConfig.delay = Math.max(0, (this.startTime - window.performance.now()) / 1e3);
          this.stopAndReleaseAudioTag();
        },
        onFocus: function() {
          this.isPlaying = true;
          this.isPaused = false;
          this.pickAndPlayAudioTag();
        },
        update: function(time) {
          if (!this.isPlaying) {
            return;
          }
          if (this.startTime > 0) {
            if (this.startTime < time - this.manager.audioPlayDelay) {
              this.audio.currentTime += Math.max(0, time - this.startTime) / 1e3;
              this.startTime = 0;
              this.previousTime = this.audio.currentTime;
              this.playCatchPromise();
            }
            return;
          }
          var startTime = this.currentMarker ? this.currentMarker.start : 0;
          var endTime = startTime + this.duration;
          var currentTime = this.audio.currentTime;
          if (this.currentConfig.loop) {
            if (currentTime >= endTime - this.manager.loopEndOffset) {
              this.audio.currentTime = startTime + Math.max(0, currentTime - endTime);
              currentTime = this.audio.currentTime;
            } else if (currentTime < startTime) {
              this.audio.currentTime += startTime;
              currentTime = this.audio.currentTime;
            }
            if (currentTime < this.previousTime) {
              this.emit(Events.LOOPED, this);
            }
          } else if (currentTime >= endTime) {
            this.reset();
            this.stopAndReleaseAudioTag();
            this.emit(Events.COMPLETE, this);
            return;
          }
          this.previousTime = currentTime;
        },
        destroy: function() {
          BaseSound.prototype.destroy.call(this);
          this.tags = null;
          if (this.audio) {
            this.stopAndReleaseAudioTag();
          }
        },
        updateMute: function() {
          if (this.audio) {
            this.audio.muted = this.currentConfig.mute || this.manager.mute;
          }
        },
        updateVolume: function() {
          if (this.audio) {
            this.audio.volume = Clamp(this.currentConfig.volume * this.manager.volume, 0, 1);
          }
        },
        calculateRate: function() {
          BaseSound.prototype.calculateRate.call(this);
          if (this.audio) {
            this.audio.playbackRate = this.totalRate;
          }
        },
        mute: {
          get: function() {
            return this.currentConfig.mute;
          },
          set: function(value) {
            this.currentConfig.mute = value;
            if (this.manager.isLocked(this, "mute", value)) {
              return;
            }
            this.updateMute();
            this.emit(Events.MUTE, this, value);
          }
        },
        setMute: function(value) {
          this.mute = value;
          return this;
        },
        volume: {
          get: function() {
            return this.currentConfig.volume;
          },
          set: function(value) {
            this.currentConfig.volume = value;
            if (this.manager.isLocked(this, "volume", value)) {
              return;
            }
            this.updateVolume();
            this.emit(Events.VOLUME, this, value);
          }
        },
        setVolume: function(value) {
          this.volume = value;
          return this;
        },
        rate: {
          get: function() {
            return this.currentConfig.rate;
          },
          set: function(value) {
            this.currentConfig.rate = value;
            if (this.manager.isLocked(this, Events.RATE, value)) {
              return;
            } else {
              this.calculateRate();
              this.emit(Events.RATE, this, value);
            }
          }
        },
        setRate: function(value) {
          this.rate = value;
          return this;
        },
        detune: {
          get: function() {
            return this.currentConfig.detune;
          },
          set: function(value) {
            this.currentConfig.detune = value;
            if (this.manager.isLocked(this, Events.DETUNE, value)) {
              return;
            } else {
              this.calculateRate();
              this.emit(Events.DETUNE, this, value);
            }
          }
        },
        setDetune: function(value) {
          this.detune = value;
          return this;
        },
        seek: {
          get: function() {
            if (this.isPlaying) {
              return this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
            } else if (this.isPaused) {
              return this.currentConfig.seek;
            } else {
              return 0;
            }
          },
          set: function(value) {
            if (this.manager.isLocked(this, "seek", value)) {
              return;
            }
            if (this.startTime > 0) {
              return;
            }
            if (this.isPlaying || this.isPaused) {
              value = Math.min(Math.max(0, value), this.duration);
              if (this.isPlaying) {
                this.previousTime = value;
                this.audio.currentTime = value;
              } else if (this.isPaused) {
                this.currentConfig.seek = value;
              }
              this.emit(Events.SEEK, this, value);
            }
          }
        },
        setSeek: function(value) {
          this.seek = value;
          return this;
        },
        loop: {
          get: function() {
            return this.currentConfig.loop;
          },
          set: function(value) {
            this.currentConfig.loop = value;
            if (this.manager.isLocked(this, "loop", value)) {
              return;
            }
            if (this.audio) {
              this.audio.loop = value;
            }
            this.emit(Events.LOOP, this, value);
          }
        },
        setLoop: function(value) {
          this.loop = value;
          return this;
        },
        pan: {
          get: function() {
            return this.currentConfig.pan;
          },
          set: function(value) {
            this.currentConfig.pan = value;
            this.emit(Events.PAN, this, value);
          }
        },
        setPan: function(value) {
          this.pan = value;
          return this;
        }
      });
      module.exports = HTML5AudioSound;
    }
  });

  // ../../node_modules/phaser/src/sound/html5/HTML5AudioSoundManager.js
  var require_HTML5AudioSoundManager = __commonJS({
    "../../node_modules/phaser/src/sound/html5/HTML5AudioSoundManager.js": function(exports, module) {
      var BaseSoundManager = require_BaseSoundManager();
      var Class = require_Class();
      var Events = require_events15();
      var HTML5AudioSound = require_HTML5AudioSound();
      var HTML5AudioSoundManager = new Class({
        Extends: BaseSoundManager,
        initialize: function HTML5AudioSoundManager2(game) {
          this.override = true;
          this.audioPlayDelay = 0.1;
          this.loopEndOffset = 0.05;
          this.onBlurPausedSounds = [];
          this.locked = "ontouchstart" in window;
          this.lockedActionsQueue = this.locked ? [] : null;
          this._mute = false;
          this._volume = 1;
          BaseSoundManager.call(this, game);
        },
        add: function(key, config) {
          var sound = new HTML5AudioSound(this, key, config);
          this.sounds.push(sound);
          return sound;
        },
        unlock: function() {
          this.locked = false;
          var _this = this;
          this.game.cache.audio.entries.each(function(key, tags) {
            for (var i = 0; i < tags.length; i++) {
              if (tags[i].dataset.locked === "true") {
                _this.locked = true;
                return false;
              }
            }
            return true;
          });
          if (!this.locked) {
            return;
          }
          var moved = false;
          var detectMove = function() {
            moved = true;
          };
          var unlock = function() {
            if (moved) {
              moved = false;
              return;
            }
            document.body.removeEventListener("touchmove", detectMove);
            document.body.removeEventListener("touchend", unlock);
            var lockedTags = [];
            _this.game.cache.audio.entries.each(function(key, tags) {
              for (var i = 0; i < tags.length; i++) {
                var tag = tags[i];
                if (tag.dataset.locked === "true") {
                  lockedTags.push(tag);
                }
              }
              return true;
            });
            if (lockedTags.length === 0) {
              return;
            }
            var lastTag = lockedTags[lockedTags.length - 1];
            lastTag.oncanplaythrough = function() {
              lastTag.oncanplaythrough = null;
              lockedTags.forEach(function(tag) {
                tag.dataset.locked = "false";
              });
              _this.unlocked = true;
            };
            lockedTags.forEach(function(tag) {
              tag.load();
            });
          };
          this.once(Events.UNLOCKED, function() {
            this.forEachActiveSound(function(sound) {
              if (sound.currentMarker === null && sound.duration === 0) {
                sound.duration = sound.tags[0].duration;
              }
              sound.totalDuration = sound.tags[0].duration;
            });
            while (this.lockedActionsQueue.length) {
              var lockedAction = this.lockedActionsQueue.shift();
              if (lockedAction.sound[lockedAction.prop].apply) {
                lockedAction.sound[lockedAction.prop].apply(lockedAction.sound, lockedAction.value || []);
              } else {
                lockedAction.sound[lockedAction.prop] = lockedAction.value;
              }
            }
          }, this);
          document.body.addEventListener("touchmove", detectMove, false);
          document.body.addEventListener("touchend", unlock, false);
        },
        onBlur: function() {
          this.forEachActiveSound(function(sound) {
            if (sound.isPlaying) {
              this.onBlurPausedSounds.push(sound);
              sound.onBlur();
            }
          });
        },
        onFocus: function() {
          this.onBlurPausedSounds.forEach(function(sound) {
            sound.onFocus();
          });
          this.onBlurPausedSounds.length = 0;
        },
        destroy: function() {
          BaseSoundManager.prototype.destroy.call(this);
          this.onBlurPausedSounds.length = 0;
          this.onBlurPausedSounds = null;
        },
        isLocked: function(sound, prop, value) {
          if (sound.tags[0].dataset.locked === "true") {
            this.lockedActionsQueue.push({
              sound: sound,
              prop: prop,
              value: value
            });
            return true;
          }
          return false;
        },
        setMute: function(value) {
          this.mute = value;
          return this;
        },
        mute: {
          get: function() {
            return this._mute;
          },
          set: function(value) {
            this._mute = value;
            this.forEachActiveSound(function(sound) {
              sound.updateMute();
            });
            this.emit(Events.GLOBAL_MUTE, this, value);
          }
        },
        setVolume: function(value) {
          this.volume = value;
          return this;
        },
        volume: {
          get: function() {
            return this._volume;
          },
          set: function(value) {
            this._volume = value;
            this.forEachActiveSound(function(sound) {
              sound.updateVolume();
            });
            this.emit(Events.GLOBAL_VOLUME, this, value);
          }
        }
      });
      module.exports = HTML5AudioSoundManager;
    }
  });

  // ../../node_modules/phaser/src/sound/noaudio/NoAudioSound.js
  var require_NoAudioSound = __commonJS({
    "../../node_modules/phaser/src/sound/noaudio/NoAudioSound.js": function(exports, module) {
      var BaseSound = require_BaseSound();
      var Class = require_Class();
      var EventEmitter = require_eventemitter3();
      var Extend = require_Extend();
      var NOOP = require_NOOP();
      var returnFalse = function() {
        return false;
      };
      var returnNull = function() {
        return null;
      };
      var returnThis = function() {
        return this;
      };
      var NoAudioSound = new Class({
        Extends: EventEmitter,
        initialize: function NoAudioSound2(manager, key, config) {
          if (config === void 0) {
            config = {};
          }
          EventEmitter.call(this);
          this.manager = manager;
          this.key = key;
          this.isPlaying = false;
          this.isPaused = false;
          this.totalRate = 1;
          this.duration = 0;
          this.totalDuration = 0;
          this.config = Extend({
            mute: false,
            volume: 1,
            rate: 1,
            detune: 0,
            seek: 0,
            loop: false,
            delay: 0,
            pan: 0
          }, config);
          this.currentConfig = this.config;
          this.mute = false;
          this.volume = 1;
          this.rate = 1;
          this.detune = 0;
          this.seek = 0;
          this.loop = false;
          this.pan = 0;
          this.markers = {};
          this.currentMarker = null;
          this.pendingRemove = false;
        },
        addMarker: returnFalse,
        updateMarker: returnFalse,
        removeMarker: returnNull,
        play: returnFalse,
        pause: returnFalse,
        resume: returnFalse,
        stop: returnFalse,
        setMute: returnThis,
        setVolume: returnThis,
        setRate: returnThis,
        setDetune: returnThis,
        setSeek: returnThis,
        setLoop: returnThis,
        setPan: returnThis,
        applyConfig: returnNull,
        resetConfig: returnNull,
        update: NOOP,
        calculateRate: returnNull,
        destroy: function() {
          BaseSound.prototype.destroy.call(this);
        }
      });
      module.exports = NoAudioSound;
    }
  });

  // ../../node_modules/phaser/src/sound/noaudio/NoAudioSoundManager.js
  var require_NoAudioSoundManager = __commonJS({
    "../../node_modules/phaser/src/sound/noaudio/NoAudioSoundManager.js": function(exports, module) {
      var BaseSoundManager = require_BaseSoundManager();
      var Class = require_Class();
      var EventEmitter = require_eventemitter3();
      var NoAudioSound = require_NoAudioSound();
      var NOOP = require_NOOP();
      var NoAudioSoundManager = new Class({
        Extends: EventEmitter,
        initialize: function NoAudioSoundManager2(game) {
          EventEmitter.call(this);
          this.game = game;
          this.sounds = [];
          this.mute = false;
          this.volume = 1;
          this.rate = 1;
          this.detune = 0;
          this.pauseOnBlur = true;
          this.locked = false;
        },
        add: function(key, config) {
          var sound = new NoAudioSound(this, key, config);
          this.sounds.push(sound);
          return sound;
        },
        addAudioSprite: function(key, config) {
          var sound = this.add(key, config);
          sound.spritemap = {};
          return sound;
        },
        get: function(key) {
          return BaseSoundManager.prototype.get.call(this, key);
        },
        getAll: function(key) {
          return BaseSoundManager.prototype.getAll.call(this, key);
        },
        play: function(key, extra) {
          return false;
        },
        playAudioSprite: function(key, spriteName, config) {
          return false;
        },
        remove: function(sound) {
          return BaseSoundManager.prototype.remove.call(this, sound);
        },
        removeAll: function() {
          return BaseSoundManager.prototype.removeAll.call(this);
        },
        removeByKey: function(key) {
          return BaseSoundManager.prototype.removeByKey.call(this, key);
        },
        stopByKey: function(key) {
          return BaseSoundManager.prototype.stopByKey.call(this, key);
        },
        onBlur: NOOP,
        onFocus: NOOP,
        onGameBlur: NOOP,
        onGameFocus: NOOP,
        pauseAll: NOOP,
        resumeAll: NOOP,
        stopAll: NOOP,
        update: NOOP,
        setRate: NOOP,
        setDetune: NOOP,
        setMute: NOOP,
        setVolume: NOOP,
        unlock: NOOP,
        forEachActiveSound: function(callbackfn, scope) {
          BaseSoundManager.prototype.forEachActiveSound.call(this, callbackfn, scope);
        },
        destroy: function() {
          BaseSoundManager.prototype.destroy.call(this);
        }
      });
      module.exports = NoAudioSoundManager;
    }
  });

  // ../../node_modules/phaser/src/utils/base64/Base64ToArrayBuffer.js
  var require_Base64ToArrayBuffer = __commonJS({
    "../../node_modules/phaser/src/utils/base64/Base64ToArrayBuffer.js": function(exports, module) {
      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup = new Uint8Array(256);
      for (i = 0; i < chars.length; i++) {
        lookup[chars.charCodeAt(i)] = i;
      }
      var i;
      var Base64ToArrayBuffer = function(base64) {
        base64 = base64.substr(base64.indexOf(",") + 1);
        var len = base64.length;
        var bufferLength = len * 0.75;
        var p = 0;
        var encoded1;
        var encoded2;
        var encoded3;
        var encoded4;
        if (base64[len - 1] === "=") {
          bufferLength--;
          if (base64[len - 2] === "=") {
            bufferLength--;
          }
        }
        var arrayBuffer = new ArrayBuffer(bufferLength);
        var bytes = new Uint8Array(arrayBuffer);
        for (var i2 = 0; i2 < len; i2 += 4) {
          encoded1 = lookup[base64.charCodeAt(i2)];
          encoded2 = lookup[base64.charCodeAt(i2 + 1)];
          encoded3 = lookup[base64.charCodeAt(i2 + 2)];
          encoded4 = lookup[base64.charCodeAt(i2 + 3)];
          bytes[p++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return arrayBuffer;
      };
      module.exports = Base64ToArrayBuffer;
    }
  });

  // ../../node_modules/phaser/src/sound/webaudio/WebAudioSound.js
  var require_WebAudioSound = __commonJS({
    "../../node_modules/phaser/src/sound/webaudio/WebAudioSound.js": function(exports, module) {
      var BaseSound = require_BaseSound();
      var Class = require_Class();
      var Events = require_events15();
      var GetFastValue = require_GetFastValue();
      var WebAudioSound = new Class({
        Extends: BaseSound,
        initialize: function WebAudioSound2(manager, key, config) {
          if (config === void 0) {
            config = {};
          }
          this.audioBuffer = manager.game.cache.audio.get(key);
          if (!this.audioBuffer) {
            throw new Error('Audio key "' + key + '" missing from cache');
          }
          this.source = null;
          this.loopSource = null;
          this.muteNode = manager.context.createGain();
          this.volumeNode = manager.context.createGain();
          this.pannerNode = null;
          this.spatialNode = null;
          this.spatialSource = null;
          this.playTime = 0;
          this.startTime = 0;
          this.loopTime = 0;
          this.rateUpdates = [];
          this.hasEnded = false;
          this.hasLooped = false;
          this.muteNode.connect(this.volumeNode);
          if (manager.context.createPanner) {
            this.spatialNode = manager.context.createPanner();
            this.volumeNode.connect(this.spatialNode);
          }
          if (manager.context.createStereoPanner) {
            this.pannerNode = manager.context.createStereoPanner();
            if (manager.context.createPanner) {
              this.spatialNode.connect(this.pannerNode);
            } else {
              this.volumeNode.connect(this.pannerNode);
            }
            this.pannerNode.connect(manager.destination);
          } else if (manager.context.createPanner) {
            this.spatialNode.connect(manager.destination);
          } else {
            this.volumeNode.connect(manager.destination);
          }
          this.duration = this.audioBuffer.duration;
          this.totalDuration = this.audioBuffer.duration;
          BaseSound.call(this, manager, key, config);
        },
        play: function(markerName, config) {
          if (!BaseSound.prototype.play.call(this, markerName, config)) {
            return false;
          }
          this.stopAndRemoveBufferSource();
          this.createAndStartBufferSource();
          this.emit(Events.PLAY, this);
          return true;
        },
        pause: function() {
          if (this.manager.context.currentTime < this.startTime) {
            return false;
          }
          if (!BaseSound.prototype.pause.call(this)) {
            return false;
          }
          this.currentConfig.seek = this.getCurrentTime();
          this.stopAndRemoveBufferSource();
          this.emit(Events.PAUSE, this);
          return true;
        },
        resume: function() {
          if (this.manager.context.currentTime < this.startTime) {
            return false;
          }
          if (!BaseSound.prototype.resume.call(this)) {
            return false;
          }
          this.createAndStartBufferSource();
          this.emit(Events.RESUME, this);
          return true;
        },
        stop: function() {
          if (!BaseSound.prototype.stop.call(this)) {
            return false;
          }
          this.stopAndRemoveBufferSource();
          this.emit(Events.STOP, this);
          return true;
        },
        createAndStartBufferSource: function() {
          var seek = this.currentConfig.seek;
          var delay = this.currentConfig.delay;
          var when = this.manager.context.currentTime + delay;
          var offset = (this.currentMarker ? this.currentMarker.start : 0) + seek;
          var duration = this.duration - seek;
          this.playTime = when - seek;
          this.startTime = when;
          this.source = this.createBufferSource();
          this.applyConfig();
          this.source.start(Math.max(0, when), Math.max(0, offset), Math.max(0, duration));
          this.resetConfig();
        },
        createAndStartLoopBufferSource: function() {
          var when = this.getLoopTime();
          var offset = this.currentMarker ? this.currentMarker.start : 0;
          var duration = this.duration;
          this.loopTime = when;
          this.loopSource = this.createBufferSource();
          this.loopSource.playbackRate.setValueAtTime(this.totalRate, 0);
          this.loopSource.start(Math.max(0, when), Math.max(0, offset), Math.max(0, duration));
        },
        createBufferSource: function() {
          var _this = this;
          var source = this.manager.context.createBufferSource();
          source.buffer = this.audioBuffer;
          source.connect(this.muteNode);
          source.onended = function(ev) {
            if (ev.target === _this.source) {
              if (_this.currentConfig.loop) {
                _this.hasLooped = true;
              } else {
                _this.hasEnded = true;
              }
            }
          };
          return source;
        },
        stopAndRemoveBufferSource: function() {
          if (this.source) {
            this.source.stop();
            this.source.disconnect();
            this.source = null;
          }
          this.playTime = 0;
          this.startTime = 0;
          this.stopAndRemoveLoopBufferSource();
        },
        stopAndRemoveLoopBufferSource: function() {
          if (this.loopSource) {
            this.loopSource.stop();
            this.loopSource.disconnect();
            this.loopSource = null;
          }
          this.loopTime = 0;
        },
        applyConfig: function() {
          this.rateUpdates.length = 0;
          this.rateUpdates.push({
            time: 0,
            rate: 1
          });
          var source = this.currentConfig.source;
          if (source && this.manager.context.createPanner) {
            var node = this.spatialNode;
            node.panningModel = GetFastValue(source, "panningModel", "equalpower");
            node.distanceModel = GetFastValue(source, "distanceModel", "inverse");
            node.positionX.value = GetFastValue(source, "x", 0);
            node.positionY.value = GetFastValue(source, "y", 0);
            node.positionZ.value = GetFastValue(source, "z", 0);
            node.orientationX.value = GetFastValue(source, "orientationX", 0);
            node.orientationY.value = GetFastValue(source, "orientationY", 0);
            node.orientationZ.value = GetFastValue(source, "orientationZ", -1);
            node.refDistance = GetFastValue(source, "refDistance", 1);
            node.maxDistance = GetFastValue(source, "maxDistance", 1e4);
            node.rolloffFactor = GetFastValue(source, "rolloffFactor", 1);
            node.coneInnerAngle = GetFastValue(source, "coneInnerAngle", 360);
            node.coneOuterAngle = GetFastValue(source, "coneOuterAngle", 0);
            node.coneOuterGain = GetFastValue(source, "coneOuterGain", 0);
            this.spatialSource = GetFastValue(source, "follow", null);
          }
          BaseSound.prototype.applyConfig.call(this);
        },
        x: {
          get: function() {
            if (this.spatialNode) {
              return this.spatialNode.positionX;
            } else {
              return 0;
            }
          },
          set: function(value) {
            if (this.spatialNode) {
              this.spatialNode.positionX.value = value;
            }
          }
        },
        y: {
          get: function() {
            if (this.spatialNode) {
              return this.spatialNode.positionY;
            } else {
              return 0;
            }
          },
          set: function(value) {
            if (this.spatialNode) {
              this.spatialNode.positionY.value = value;
            }
          }
        },
        update: function() {
          if (this.isPlaying && this.spatialSource) {
            this.x = this.spatialSource.x;
            this.y = this.spatialSource.y;
          }
          if (this.hasEnded) {
            this.hasEnded = false;
            BaseSound.prototype.stop.call(this);
            this.stopAndRemoveBufferSource();
            this.emit(Events.COMPLETE, this);
          } else if (this.hasLooped) {
            this.hasLooped = false;
            this.source = this.loopSource;
            this.loopSource = null;
            this.playTime = this.startTime = this.loopTime;
            this.rateUpdates.length = 0;
            this.rateUpdates.push({
              time: 0,
              rate: this.totalRate
            });
            this.createAndStartLoopBufferSource();
            this.emit(Events.LOOPED, this);
          }
        },
        destroy: function() {
          if (this.pendingRemove) {
            return;
          }
          BaseSound.prototype.destroy.call(this);
          this.audioBuffer = null;
          this.stopAndRemoveBufferSource();
          this.muteNode.disconnect();
          this.muteNode = null;
          this.volumeNode.disconnect();
          this.volumeNode = null;
          if (this.pannerNode) {
            this.pannerNode.disconnect();
            this.pannerNode = null;
          }
          if (this.spatialNode) {
            this.spatialNode.disconnect();
            this.spatialNode = null;
            this.spatialSource = null;
          }
          this.rateUpdates.length = 0;
          this.rateUpdates = null;
        },
        calculateRate: function() {
          BaseSound.prototype.calculateRate.call(this);
          var now = this.manager.context.currentTime;
          if (this.source && typeof this.totalRate === "number") {
            this.source.playbackRate.setValueAtTime(this.totalRate, now);
          }
          if (this.isPlaying) {
            this.rateUpdates.push({
              time: Math.max(this.startTime, now) - this.playTime,
              rate: this.totalRate
            });
            if (this.loopSource) {
              this.stopAndRemoveLoopBufferSource();
              this.createAndStartLoopBufferSource();
            }
          }
        },
        getCurrentTime: function() {
          var currentTime = 0;
          for (var i = 0; i < this.rateUpdates.length; i++) {
            var nextTime = 0;
            if (i < this.rateUpdates.length - 1) {
              nextTime = this.rateUpdates[i + 1].time;
            } else {
              nextTime = this.manager.context.currentTime - this.playTime;
            }
            currentTime += (nextTime - this.rateUpdates[i].time) * this.rateUpdates[i].rate;
          }
          return currentTime;
        },
        getLoopTime: function() {
          var lastRateUpdateCurrentTime = 0;
          for (var i = 0; i < this.rateUpdates.length - 1; i++) {
            lastRateUpdateCurrentTime += (this.rateUpdates[i + 1].time - this.rateUpdates[i].time) * this.rateUpdates[i].rate;
          }
          var lastRateUpdate = this.rateUpdates[this.rateUpdates.length - 1];
          return this.playTime + lastRateUpdate.time + (this.duration - lastRateUpdateCurrentTime) / lastRateUpdate.rate;
        },
        rate: {
          get: function() {
            return this.currentConfig.rate;
          },
          set: function(value) {
            this.currentConfig.rate = value;
            this.calculateRate();
            this.emit(Events.RATE, this, value);
          }
        },
        setRate: function(value) {
          this.rate = value;
          return this;
        },
        detune: {
          get: function() {
            return this.currentConfig.detune;
          },
          set: function(value) {
            this.currentConfig.detune = value;
            this.calculateRate();
            this.emit(Events.DETUNE, this, value);
          }
        },
        setDetune: function(value) {
          this.detune = value;
          return this;
        },
        mute: {
          get: function() {
            return this.muteNode.gain.value === 0;
          },
          set: function(value) {
            this.currentConfig.mute = value;
            this.muteNode.gain.setValueAtTime(value ? 0 : 1, 0);
            this.emit(Events.MUTE, this, value);
          }
        },
        setMute: function(value) {
          this.mute = value;
          return this;
        },
        volume: {
          get: function() {
            return this.volumeNode.gain.value;
          },
          set: function(value) {
            this.currentConfig.volume = value;
            this.volumeNode.gain.setValueAtTime(value, 0);
            this.emit(Events.VOLUME, this, value);
          }
        },
        setVolume: function(value) {
          this.volume = value;
          return this;
        },
        seek: {
          get: function() {
            if (this.isPlaying) {
              if (this.manager.context.currentTime < this.startTime) {
                return this.startTime - this.playTime;
              }
              return this.getCurrentTime();
            } else if (this.isPaused) {
              return this.currentConfig.seek;
            } else {
              return 0;
            }
          },
          set: function(value) {
            if (this.manager.context.currentTime < this.startTime) {
              return;
            }
            if (this.isPlaying || this.isPaused) {
              value = Math.min(Math.max(0, value), this.duration);
              this.currentConfig.seek = value;
              if (this.isPlaying) {
                this.stopAndRemoveBufferSource();
                this.createAndStartBufferSource();
              }
              this.emit(Events.SEEK, this, value);
            }
          }
        },
        setSeek: function(value) {
          this.seek = value;
          return this;
        },
        loop: {
          get: function() {
            return this.currentConfig.loop;
          },
          set: function(value) {
            this.currentConfig.loop = value;
            if (this.isPlaying) {
              this.stopAndRemoveLoopBufferSource();
              if (value) {
                this.createAndStartLoopBufferSource();
              }
            }
            this.emit(Events.LOOP, this, value);
          }
        },
        setLoop: function(value) {
          this.loop = value;
          return this;
        },
        pan: {
          get: function() {
            if (this.pannerNode) {
              return this.pannerNode.pan.value;
            } else {
              return 0;
            }
          },
          set: function(value) {
            this.currentConfig.pan = value;
            if (this.pannerNode) {
              this.pannerNode.pan.setValueAtTime(value, this.manager.context.currentTime);
            }
            this.emit(Events.PAN, this, value);
          }
        },
        setPan: function(value) {
          this.pan = value;
          return this;
        }
      });
      module.exports = WebAudioSound;
    }
  });

  // ../../node_modules/phaser/src/sound/webaudio/WebAudioSoundManager.js
  var require_WebAudioSoundManager = __commonJS({
    "../../node_modules/phaser/src/sound/webaudio/WebAudioSoundManager.js": function(exports, module) {
      var Base64ToArrayBuffer = require_Base64ToArrayBuffer();
      var BaseSoundManager = require_BaseSoundManager();
      var Class = require_Class();
      var Events = require_events15();
      var GameEvents = require_events5();
      var WebAudioSound = require_WebAudioSound();
      var WebAudioSoundManager = new Class({
        Extends: BaseSoundManager,
        initialize: function WebAudioSoundManager2(game) {
          this.context = this.createAudioContext(game);
          this.masterMuteNode = this.context.createGain();
          this.masterVolumeNode = this.context.createGain();
          this.masterMuteNode.connect(this.masterVolumeNode);
          this.masterVolumeNode.connect(this.context.destination);
          this.destination = this.masterMuteNode;
          this.locked = this.context.state === "suspended" && ("ontouchstart" in window || "onclick" in window);
          BaseSoundManager.call(this, game);
          if (this.locked && game.isBooted) {
            this.unlock();
          } else {
            game.events.once(GameEvents.BOOT, this.unlock, this);
          }
        },
        createAudioContext: function(game) {
          var audioConfig = game.config.audio;
          if (audioConfig.context) {
            audioConfig.context.resume();
            return audioConfig.context;
          }
          if (window.hasOwnProperty("AudioContext")) {
            return new AudioContext();
          } else if (window.hasOwnProperty("webkitAudioContext")) {
            return new window.webkitAudioContext();
          }
        },
        setAudioContext: function(context) {
          if (this.context) {
            this.context.close();
          }
          if (this.masterMuteNode) {
            this.masterMuteNode.disconnect();
          }
          if (this.masterVolumeNode) {
            this.masterVolumeNode.disconnect();
          }
          this.context = context;
          this.masterMuteNode = context.createGain();
          this.masterVolumeNode = context.createGain();
          this.masterMuteNode.connect(this.masterVolumeNode);
          this.masterVolumeNode.connect(context.destination);
          this.destination = this.masterMuteNode;
          return this;
        },
        add: function(key, config) {
          var sound = new WebAudioSound(this, key, config);
          this.sounds.push(sound);
          return sound;
        },
        decodeAudio: function(audioKey, audioData) {
          var audioFiles;
          if (!Array.isArray(audioKey)) {
            audioFiles = [{ key: audioKey, data: audioData }];
          } else {
            audioFiles = audioKey;
          }
          var cache = this.game.cache.audio;
          var remaining = audioFiles.length;
          for (var i = 0; i < audioFiles.length; i++) {
            var entry = audioFiles[i];
            var key = entry.key;
            var data = entry.data;
            if (typeof data === "string") {
              data = Base64ToArrayBuffer(data);
            }
            var success = function(key2, audioBuffer) {
              cache.add(key2, audioBuffer);
              this.emit(Events.DECODED, key2);
              remaining--;
              if (remaining === 0) {
                this.emit(Events.DECODED_ALL);
              }
            }.bind(this, key);
            var failure = function(key2, error) {
              console.error("Error decoding audio: " + key2 + " - ", error ? error.message : "");
              remaining--;
              if (remaining === 0) {
                this.emit(Events.DECODED_ALL);
              }
            }.bind(this, key);
            this.context.decodeAudioData(data, success, failure);
          }
        },
        setListenerPosition: function(x, y) {
          if (x === void 0) {
            x = this.game.scale.width / 2;
          }
          if (y === void 0) {
            y = this.game.scale.height / 2;
          }
          this.listenerPosition.set(x, y);
          return this;
        },
        unlock: function() {
          var _this = this;
          var body = document.body;
          var unlockHandler = function unlockHandler2() {
            if (_this.context && body) {
              var bodyRemove = body.removeEventListener;
              _this.context.resume().then(function() {
                bodyRemove("touchstart", unlockHandler2);
                bodyRemove("touchend", unlockHandler2);
                bodyRemove("click", unlockHandler2);
                bodyRemove("keydown", unlockHandler2);
                _this.unlocked = true;
              }, function() {
                bodyRemove("touchstart", unlockHandler2);
                bodyRemove("touchend", unlockHandler2);
                bodyRemove("click", unlockHandler2);
                bodyRemove("keydown", unlockHandler2);
              });
            }
          };
          if (body) {
            body.addEventListener("touchstart", unlockHandler, false);
            body.addEventListener("touchend", unlockHandler, false);
            body.addEventListener("click", unlockHandler, false);
            body.addEventListener("keydown", unlockHandler, false);
          }
        },
        onBlur: function() {
          if (!this.locked) {
            this.context.suspend();
          }
        },
        onFocus: function() {
          var context = this.context;
          if (context && !this.locked && (context.state === "suspended" || context.state === "interrupted")) {
            context.resume();
          }
        },
        update: function(time, delta) {
          var listener = this.context.listener;
          if (this.listenerPosition && listener) {
            listener.positionX.value = this.listenerPosition.x;
            listener.positionY.value = this.listenerPosition.y;
          }
          BaseSoundManager.prototype.update.call(this, time, delta);
          this.onFocus();
        },
        destroy: function() {
          this.destination = null;
          this.masterVolumeNode.disconnect();
          this.masterVolumeNode = null;
          this.masterMuteNode.disconnect();
          this.masterMuteNode = null;
          if (this.game.config.audio.context) {
            this.context.suspend();
          } else {
            var _this = this;
            this.context.close().then(function() {
              _this.context = null;
            });
          }
          BaseSoundManager.prototype.destroy.call(this);
        },
        setMute: function(value) {
          this.mute = value;
          return this;
        },
        mute: {
          get: function() {
            return this.masterMuteNode.gain.value === 0;
          },
          set: function(value) {
            this.masterMuteNode.gain.setValueAtTime(value ? 0 : 1, 0);
            this.emit(Events.GLOBAL_MUTE, this, value);
          }
        },
        setVolume: function(value) {
          this.volume = value;
          return this;
        },
        volume: {
          get: function() {
            return this.masterVolumeNode.gain.value;
          },
          set: function(value) {
            this.masterVolumeNode.gain.setValueAtTime(value, 0);
            this.emit(Events.GLOBAL_VOLUME, this, value);
          }
        }
      });
      module.exports = WebAudioSoundManager;
    }
  });

  // ../../node_modules/phaser/src/sound/SoundManagerCreator.js
  var require_SoundManagerCreator = __commonJS({
    "../../node_modules/phaser/src/sound/SoundManagerCreator.js": function(exports, module) {
      var HTML5AudioSoundManager = require_HTML5AudioSoundManager();
      var NoAudioSoundManager = require_NoAudioSoundManager();
      var WebAudioSoundManager = require_WebAudioSoundManager();
      var SoundManagerCreator = {
        create: function(game) {
          var audioConfig = game.config.audio;
          var deviceAudio = game.device.audio;
          if (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
            return new NoAudioSoundManager(game);
          }
          if (deviceAudio.webAudio && !audioConfig.disableWebAudio) {
            return new WebAudioSoundManager(game);
          }
          return new HTML5AudioSoundManager(game);
        }
      };
      module.exports = SoundManagerCreator;
    }
  });

  // ../../node_modules/phaser/plugins/fbinstant/src/AdInstance.js
  var require_AdInstance = __commonJS({
    "../../node_modules/phaser/plugins/fbinstant/src/AdInstance.js": function(exports, module) {
      var AdInstance = function(placementID, instance, video) {
        return {
          instance: instance,
          placementID: placementID,
          shown: false,
          video: video
        };
      };
      module.exports = AdInstance;
    }
  });

  // ../../node_modules/phaser/plugins/fbinstant/src/LeaderboardScore.js
  var require_LeaderboardScore = __commonJS({
    "../../node_modules/phaser/plugins/fbinstant/src/LeaderboardScore.js": function(exports, module) {
      var LeaderboardScore = function(entry) {
        return {
          score: entry.getScore(),
          scoreFormatted: entry.getFormattedScore(),
          timestamp: entry.getTimestamp(),
          rank: entry.getRank(),
          data: entry.getExtraData(),
          playerName: entry.getPlayer().getName(),
          playerPhotoURL: entry.getPlayer().getPhoto(),
          playerID: entry.getPlayer().getID()
        };
      };
      module.exports = LeaderboardScore;
    }
  });

  // ../../node_modules/phaser/plugins/fbinstant/src/Leaderboard.js
  var require_Leaderboard = __commonJS({
    "../../node_modules/phaser/plugins/fbinstant/src/Leaderboard.js": function(exports, module) {
      var Class = require_Class();
      var EventEmitter = require_eventemitter3();
      var LeaderboardScore = require_LeaderboardScore();
      var Leaderboard = new Class({
        Extends: EventEmitter,
        initialize: function Leaderboard2(plugin, data) {
          EventEmitter.call(this);
          this.plugin = plugin;
          this.ref = data;
          this.name = data.getName();
          this.contextID = data.getContextID();
          this.entryCount = 0;
          this.playerScore = null;
          this.scores = [];
          this.getEntryCount();
        },
        getEntryCount: function() {
          var _this = this;
          this.ref.getEntryCountAsync().then(function(count) {
            _this.entryCount = count;
            _this.emit("getentrycount", count, _this.name);
          }).catch(function(e) {
            console.warn(e);
          });
          return this;
        },
        setScore: function(score, data) {
          if (data === void 0) {
            data = "";
          }
          if (typeof data === "object") {
            data = JSON.stringify(data);
          }
          var _this = this;
          this.ref.setScoreAsync(score, data).then(function(entry) {
            if (entry) {
              var score2 = LeaderboardScore(entry);
              _this.playerScore = score2;
              _this.emit("setscore", score2, _this.name);
            } else {
              _this.emit("setscore", null, _this.name);
            }
          }).catch(function(e) {
            console.warn(e);
          });
          return this;
        },
        getPlayerScore: function() {
          var _this = this;
          this.ref.getPlayerEntryAsync().then(function(entry) {
            if (entry) {
              var score = LeaderboardScore(entry);
              _this.playerScore = score;
              _this.emit("getplayerscore", score, _this.name);
            } else {
              _this.emit("getplayerscore", null, _this.name);
            }
          }).catch(function(e) {
            console.warn(e);
          });
          return this;
        },
        getScores: function(count, offset) {
          if (count === void 0) {
            count = 10;
          }
          if (offset === void 0) {
            offset = 0;
          }
          var _this = this;
          this.ref.getEntriesAsync(count, offset).then(function(entries) {
            _this.scores = [];
            entries.forEach(function(entry) {
              _this.scores.push(LeaderboardScore(entry));
            });
            _this.emit("getscores", _this.scores, _this.name);
          }).catch(function(e) {
            console.warn(e);
          });
          return this;
        },
        getConnectedScores: function() {
          var _this = this;
          this.ref.getConnectedPlayerEntriesAsync().then(function(entries) {
            _this.scores = [];
            entries.forEach(function(entry) {
              _this.scores.push(LeaderboardScore(entry));
            });
            _this.emit("getconnectedscores", _this.scores, _this.name);
          }).catch(function(e) {
            console.warn(e);
          });
          return this;
        }
      });
      module.exports = Leaderboard;
    }
  });

  // ../../node_modules/phaser/plugins/fbinstant/src/Product.js
  var require_Product = __commonJS({
    "../../node_modules/phaser/plugins/fbinstant/src/Product.js": function(exports, module) {
      var GetFastValue = require_GetFastValue();
      var Product = function(data) {
        return {
          title: GetFastValue(data, "title", ""),
          productID: GetFastValue(data, "productID", ""),
          description: GetFastValue(data, "description", ""),
          imageURI: GetFastValue(data, "imageURI", ""),
          price: GetFastValue(data, "price", ""),
          priceCurrencyCode: GetFastValue(data, "priceCurrencyCode", "")
        };
      };
      module.exports = Product;
    }
  });

  // ../../node_modules/phaser/plugins/fbinstant/src/Purchase.js
  var require_Purchase = __commonJS({
    "../../node_modules/phaser/plugins/fbinstant/src/Purchase.js": function(exports, module) {
      var GetFastValue = require_GetFastValue();
      var Purchase = function(data) {
        return {
          developerPayload: GetFastValue(data, "developerPayload", ""),
          paymentID: GetFastValue(data, "paymentID", ""),
          productID: GetFastValue(data, "productID", ""),
          purchaseTime: GetFastValue(data, "purchaseTime", ""),
          purchaseToken: GetFastValue(data, "purchaseToken", ""),
          signedRequest: GetFastValue(data, "signedRequest", "")
        };
      };
      module.exports = Purchase;
    }
  });

  // ../../node_modules/phaser/plugins/fbinstant/src/FacebookInstantGamesPlugin.js
  var require_FacebookInstantGamesPlugin = __commonJS({
    "../../node_modules/phaser/plugins/fbinstant/src/FacebookInstantGamesPlugin.js": function(exports, module) {
      var AdInstance = require_AdInstance();
      var Class = require_Class();
      var DataManager = require_DataManager();
      var EventEmitter = require_eventemitter3();
      var Leaderboard = require_Leaderboard();
      var Product = require_Product();
      var Purchase = require_Purchase();
      var FacebookInstantGamesPlugin = new Class({
        Extends: EventEmitter,
        initialize: function FacebookInstantGamesPlugin2(game) {
          EventEmitter.call(this);
          this.game = game;
          this.data = new DataManager(this);
          this.on("setdata", this.setDataHandler, this);
          this.on("changedata", this.changeDataHandler, this);
          this.hasLoaded = false;
          this.dataLocked = false;
          this.supportedAPIs = [];
          this.entryPoint = "";
          this.entryPointData = null;
          this.contextID = null;
          this.contextType = null;
          this.locale = null;
          this.platform = null;
          this.version = null;
          this.playerID = null;
          this.playerName = null;
          this.playerPhotoURL = null;
          this.playerCanSubscribeBot = false;
          this.paymentsReady = false;
          this.catalog = [];
          this.purchases = [];
          this.leaderboards = {};
          this.ads = [];
        },
        setDataHandler: function(parent, key, value) {
          if (this.dataLocked) {
            return;
          }
          var data = {};
          data[key] = value;
          var _this = this;
          FBInstant.player.setDataAsync(data).then(function() {
            _this.emit("savedata", data);
          });
        },
        changeDataHandler: function(parent, key, value) {
          if (this.dataLocked) {
            return;
          }
          var data = {};
          data[key] = value;
          var _this = this;
          FBInstant.player.setDataAsync(data).then(function() {
            _this.emit("savedata", data);
          });
        },
        showLoadProgress: function(scene) {
          scene.load.on("progress", function(value) {
            if (!this.hasLoaded) {
              FBInstant.setLoadingProgress(value * 100);
            }
          }, this);
          scene.load.on("complete", function() {
            if (!this.hasLoaded) {
              this.hasLoaded = true;
              FBInstant.startGameAsync().then(this.gameStartedHandler.bind(this));
            }
          }, this);
          return this;
        },
        gameStarted: function() {
          if (!this.hasLoaded) {
            this.hasLoaded = true;
            FBInstant.startGameAsync().then(this.gameStartedHandler.bind(this));
          } else {
            this.gameStartedHandler();
          }
        },
        gameStartedHandler: function() {
          var APIs = FBInstant.getSupportedAPIs();
          var supported = {};
          var dotToUpper = function(match) {
            return match[1].toUpperCase();
          };
          APIs.forEach(function(api) {
            api = api.replace(/\../g, dotToUpper);
            supported[api] = true;
          });
          this.supportedAPIs = supported;
          this.getID();
          this.getType();
          this.getLocale();
          this.getPlatform();
          this.getSDKVersion();
          this.getPlayerID();
          this.getPlayerName();
          this.getPlayerPhotoURL();
          var _this = this;
          FBInstant.onPause(function() {
            _this.emit("pause");
          });
          FBInstant.getEntryPointAsync().then(function(entrypoint) {
            _this.entryPoint = entrypoint;
            _this.entryPointData = FBInstant.getEntryPointData();
            _this.emit("startgame");
          }).catch(function(e) {
            console.warn(e);
          });
          if (this.supportedAPIs.paymentsPurchaseAsync) {
            FBInstant.payments.onReady(function() {
              _this.paymentsReady = true;
            }).catch(function(e) {
              console.warn(e);
            });
          }
        },
        checkAPI: function(api) {
          if (!this.supportedAPIs[api]) {
            return false;
          } else {
            return true;
          }
        },
        getID: function() {
          if (!this.contextID && this.supportedAPIs.contextGetID) {
            this.contextID = FBInstant.context.getID();
          }
          return this.contextID;
        },
        getType: function() {
          if (!this.contextType && this.supportedAPIs.contextGetType) {
            this.contextType = FBInstant.context.getType();
          }
          return this.contextType;
        },
        getLocale: function() {
          if (!this.locale && this.supportedAPIs.getLocale) {
            this.locale = FBInstant.getLocale();
          }
          return this.locale;
        },
        getPlatform: function() {
          if (!this.platform && this.supportedAPIs.getPlatform) {
            this.platform = FBInstant.getPlatform();
          }
          return this.platform;
        },
        getSDKVersion: function() {
          if (!this.version && this.supportedAPIs.getSDKVersion) {
            this.version = FBInstant.getSDKVersion();
          }
          return this.version;
        },
        getPlayerID: function() {
          if (!this.playerID && this.supportedAPIs.playerGetID) {
            this.playerID = FBInstant.player.getID();
          }
          return this.playerID;
        },
        getPlayerName: function() {
          if (!this.playerName && this.supportedAPIs.playerGetName) {
            this.playerName = FBInstant.player.getName();
          }
          return this.playerName;
        },
        getPlayerPhotoURL: function() {
          if (!this.playerPhotoURL && this.supportedAPIs.playerGetPhoto) {
            this.playerPhotoURL = FBInstant.player.getPhoto();
          }
          return this.playerPhotoURL;
        },
        loadPlayerPhoto: function(scene, key) {
          if (this.playerPhotoURL) {
            scene.load.setCORS("anonymous");
            scene.load.image(key, this.playerPhotoURL);
            scene.load.once("filecomplete-image-" + key, function() {
              this.emit("photocomplete", key);
            }, this);
            scene.load.start();
          }
          return this;
        },
        canSubscribeBot: function() {
          if (this.supportedAPIs.playerCanSubscribeBotAsync) {
            var _this = this;
            FBInstant.player.canSubscribeBotAsync().then(function() {
              _this.playerCanSubscribeBot = true;
              _this.emit("cansubscribebot");
            }).catch(function(e) {
              _this.emit("cansubscribebotfail", e);
            });
          } else {
            this.emit("cansubscribebotfail");
          }
          return this;
        },
        subscribeBot: function() {
          if (this.playerCanSubscribeBot) {
            var _this = this;
            FBInstant.player.subscribeBotAsync().then(function() {
              _this.emit("subscribebot");
            }).catch(function(e) {
              _this.emit("subscribebotfail", e);
            });
          } else {
            this.emit("subscribebotfail");
          }
          return this;
        },
        getData: function(keys) {
          if (!this.checkAPI("playerGetDataAsync")) {
            return this;
          }
          if (!Array.isArray(keys)) {
            keys = [keys];
          }
          var _this = this;
          FBInstant.player.getDataAsync(keys).then(function(data) {
            _this.dataLocked = true;
            for (var key in data) {
              _this.data.set(key, data[key]);
            }
            _this.dataLocked = false;
            _this.emit("getdata", data);
          });
          return this;
        },
        saveData: function(data) {
          if (!this.checkAPI("playerSetDataAsync")) {
            return this;
          }
          var _this = this;
          FBInstant.player.setDataAsync(data).then(function() {
            _this.emit("savedata", data);
          }).catch(function(e) {
            _this.emit("savedatafail", e);
          });
          return this;
        },
        flushData: function() {
          if (!this.checkAPI("playerFlushDataAsync")) {
            return this;
          }
          var _this = this;
          FBInstant.player.flushDataAsync().then(function() {
            _this.emit("flushdata");
          }).catch(function(e) {
            _this.emit("flushdatafail", e);
          });
          return this;
        },
        getStats: function(keys) {
          if (!this.checkAPI("playerGetStatsAsync")) {
            return this;
          }
          var _this = this;
          FBInstant.player.getStatsAsync(keys).then(function(data) {
            _this.emit("getstats", data);
          }).catch(function(e) {
            _this.emit("getstatsfail", e);
          });
          return this;
        },
        saveStats: function(data) {
          if (!this.checkAPI("playerSetStatsAsync")) {
            return this;
          }
          var output = {};
          for (var key in data) {
            if (typeof data[key] === "number") {
              output[key] = data[key];
            }
          }
          var _this = this;
          FBInstant.player.setStatsAsync(output).then(function() {
            _this.emit("savestats", output);
          }).catch(function(e) {
            _this.emit("savestatsfail", e);
          });
          return this;
        },
        incStats: function(data) {
          if (!this.checkAPI("playerIncrementStatsAsync")) {
            return this;
          }
          var output = {};
          for (var key in data) {
            if (typeof data[key] === "number") {
              output[key] = data[key];
            }
          }
          var _this = this;
          FBInstant.player.incrementStatsAsync(output).then(function(stats) {
            _this.emit("incstats", stats);
          }).catch(function(e) {
            _this.emit("incstatsfail", e);
          });
          return this;
        },
        saveSession: function(data) {
          if (!this.checkAPI("setSessionData")) {
            return this;
          }
          var test = JSON.stringify(data);
          if (test.length <= 1e3) {
            FBInstant.setSessionData(data);
          } else {
            console.warn("Session data too long. Max 1000 chars.");
          }
          return this;
        },
        openShare: function(text, key, frame, sessionData) {
          return this._share("SHARE", text, key, frame, sessionData);
        },
        openInvite: function(text, key, frame, sessionData) {
          return this._share("INVITE", text, key, frame, sessionData);
        },
        openRequest: function(text, key, frame, sessionData) {
          return this._share("REQUEST", text, key, frame, sessionData);
        },
        openChallenge: function(text, key, frame, sessionData) {
          return this._share("CHALLENGE", text, key, frame, sessionData);
        },
        _share: function(intent, text, key, frame, sessionData) {
          if (!this.checkAPI("shareAsync")) {
            return this;
          }
          if (sessionData === void 0) {
            sessionData = {};
          }
          if (key) {
            var imageData = this.game.textures.getBase64(key, frame);
          }
          var payload = {
            intent: intent,
            image: imageData,
            text: text,
            data: sessionData
          };
          var _this = this;
          FBInstant.shareAsync(payload).then(function() {
            _this.emit("resume");
          });
          return this;
        },
        isSizeBetween: function(min, max) {
          if (!this.checkAPI("contextIsSizeBetween")) {
            return this;
          }
          return FBInstant.context.isSizeBetween(min, max);
        },
        switchContext: function(contextID) {
          if (!this.checkAPI("contextSwitchAsync")) {
            return this;
          }
          if (contextID !== this.contextID) {
            var _this = this;
            FBInstant.context.switchAsync(contextID).then(function() {
              _this.contextID = FBInstant.context.getID();
              _this.emit("switch", _this.contextID);
            }).catch(function(e) {
              _this.emit("switchfail", e);
            });
          }
          return this;
        },
        chooseContext: function(options) {
          if (!this.checkAPI("contextChooseAsync")) {
            return this;
          }
          var _this = this;
          FBInstant.context.chooseAsync(options).then(function() {
            _this.contextID = FBInstant.context.getID();
            _this.emit("choose", _this.contextID);
          }).catch(function(e) {
            _this.emit("choosefail", e);
          });
          return this;
        },
        createContext: function(playerID) {
          if (!this.checkAPI("contextCreateAsync")) {
            return this;
          }
          var _this = this;
          FBInstant.context.createAsync(playerID).then(function() {
            _this.contextID = FBInstant.context.getID();
            _this.emit("create", _this.contextID);
          }).catch(function(e) {
            _this.emit("createfail", e);
          });
          return this;
        },
        getPlayers: function() {
          if (!this.checkAPI("playerGetConnectedPlayersAsync")) {
            return this;
          }
          var _this = this;
          FBInstant.player.getConnectedPlayersAsync().then(function(players) {
            _this.emit("players", players);
          }).catch(function(e) {
            _this.emit("playersfail", e);
          });
          return this;
        },
        getCatalog: function() {
          if (!this.paymentsReady) {
            return this;
          }
          var _this = this;
          var catalog = this.catalog;
          FBInstant.payments.getCatalogAsync().then(function(data) {
            catalog = [];
            data.forEach(function(item) {
              catalog.push(Product(item));
            });
            _this.emit("getcatalog", catalog);
          }).catch(function(e) {
            _this.emit("getcatalogfail", e);
          });
          return this;
        },
        getProduct: function(productID) {
          for (var i = 0; i < this.catalog.length; i++) {
            if (this.catalog[i].productID === productID) {
              return this.catalog[i];
            }
          }
          return null;
        },
        purchase: function(productID, developerPayload) {
          if (!this.paymentsReady) {
            return this;
          }
          var config = { productID: productID };
          if (developerPayload) {
            config.developerPayload = developerPayload;
          }
          var _this = this;
          FBInstant.payments.purchaseAsync(config).then(function(data) {
            var purchase = Purchase(data);
            _this.emit("purchase", purchase);
          }).catch(function(e) {
            _this.emit("purchasefail", e);
          });
          return this;
        },
        getPurchases: function() {
          if (!this.paymentsReady) {
            return this;
          }
          var _this = this;
          var purchases = this.purchases;
          FBInstant.payments.getPurchasesAsync().then(function(data) {
            purchases = [];
            data.forEach(function(item) {
              purchases.push(Purchase(item));
            });
            _this.emit("getpurchases", purchases);
          }).catch(function(e) {
            _this.emit("getpurchasesfail", e);
          });
          return this;
        },
        consumePurchase: function(purchaseToken) {
          if (!this.paymentsReady) {
            return this;
          }
          var _this = this;
          FBInstant.payments.consumePurchaseAsync(purchaseToken).then(function() {
            _this.emit("consumepurchase", purchaseToken);
          }).catch(function(e) {
            _this.emit("consumepurchasefail", e);
          });
          return this;
        },
        update: function(cta, text, key, frame, template, updateData) {
          return this._update("CUSTOM", cta, text, key, frame, template, updateData);
        },
        updateLeaderboard: function(cta, text, key, frame, template, updateData) {
          return this._update("LEADERBOARD", cta, text, key, frame, template, updateData);
        },
        _update: function(action, cta, text, key, frame, template, updateData) {
          if (!this.checkAPI("shareAsync")) {
            return this;
          }
          if (cta === void 0) {
            cta = "";
          }
          if (typeof text === "string") {
            text = { default: text };
          }
          if (updateData === void 0) {
            updateData = {};
          }
          if (key) {
            var imageData = this.game.textures.getBase64(key, frame);
          }
          var payload = {
            action: action,
            cta: cta,
            image: imageData,
            text: text,
            template: template,
            data: updateData,
            strategy: "IMMEDIATE",
            notification: "NO_PUSH"
          };
          var _this = this;
          FBInstant.updateAsync(payload).then(function() {
            _this.emit("update");
          }).catch(function(e) {
            _this.emit("updatefail", e);
          });
          return this;
        },
        switchGame: function(appID, data) {
          if (!this.checkAPI("switchGameAsync")) {
            return this;
          }
          if (data) {
            var test = JSON.stringify(data);
            if (test.length > 1e3) {
              console.warn("Switch Game data too long. Max 1000 chars.");
              return this;
            }
          }
          var _this = this;
          FBInstant.switchGameAsync(appID, data).then(function() {
            _this.emit("switchgame", appID);
          }).catch(function(e) {
            _this.emit("switchgamefail", e);
          });
          return this;
        },
        createShortcut: function() {
          var _this = this;
          FBInstant.canCreateShortcutAsync().then(function(canCreateShortcut) {
            if (canCreateShortcut) {
              FBInstant.createShortcutAsync().then(function() {
                _this.emit("shortcutcreated");
              }).catch(function(e) {
                _this.emit("shortcutfailed", e);
              });
            }
          });
          return this;
        },
        quit: function() {
          FBInstant.quit();
        },
        log: function(name, value, params) {
          if (!this.checkAPI("logEvent")) {
            return this;
          }
          if (params === void 0) {
            params = {};
          }
          if (name.length >= 2 && name.length <= 40) {
            FBInstant.logEvent(name, parseFloat(value), params);
          }
          return this;
        },
        preloadAds: function(placementID) {
          if (!this.checkAPI("getInterstitialAdAsync")) {
            return this;
          }
          if (!Array.isArray(placementID)) {
            placementID = [placementID];
          }
          var i;
          var _this = this;
          var total = 0;
          for (i = 0; i < this.ads.length; i++) {
            if (!this.ads[i].shown) {
              total++;
            }
          }
          if (total + placementID.length >= 3) {
            console.warn("Too many AdInstances. Show an ad before loading more");
            return this;
          }
          for (i = 0; i < placementID.length; i++) {
            var id = placementID[i];
            var data;
            FBInstant.getInterstitialAdAsync(id).then(function(interstitial) {
              data = interstitial;
              return interstitial.loadAsync();
            }).then(function() {
              var ad = AdInstance(id, data, false);
              _this.ads.push(ad);
              _this.emit("adloaded", ad);
            }).catch(function(e) {
              if (e.code === "ADS_NO_FILL") {
                _this.emit("adsnofill", id);
              } else if (e.code === "ADS_FREQUENT_LOAD") {
                _this.emit("adsfrequentload", id);
              } else {
                console.warn(e);
              }
            });
          }
          return this;
        },
        preloadVideoAds: function(placementID) {
          if (!this.checkAPI("getRewardedVideoAsync")) {
            return this;
          }
          if (!Array.isArray(placementID)) {
            placementID = [placementID];
          }
          var i;
          var _this = this;
          var total = 0;
          for (i = 0; i < this.ads.length; i++) {
            if (!this.ads[i].shown) {
              total++;
            }
          }
          if (total + placementID.length >= 3) {
            console.warn("Too many AdInstances. Show an ad before loading more");
            return this;
          }
          for (i = 0; i < placementID.length; i++) {
            var id = placementID[i];
            var data;
            FBInstant.getRewardedVideoAsync(id).then(function(reward) {
              data = reward;
              return reward.loadAsync();
            }).then(function() {
              var ad = AdInstance(id, data, true);
              _this.ads.push(ad);
              _this.emit("adloaded", ad);
            }).catch(function(e) {
              if (e.code === "ADS_NO_FILL") {
                _this.emit("adsnofill", id);
              } else if (e.code === "ADS_FREQUENT_LOAD") {
                _this.emit("adsfrequentload", id);
              } else {
                console.warn(e);
              }
            });
          }
          return this;
        },
        showAd: function(placementID) {
          var _this = this;
          for (var i = 0; i < this.ads.length; i++) {
            var ad = this.ads[i];
            if (ad.placementID === placementID && !ad.shown) {
              ad.instance.showAsync().then(function() {
                ad.shown = true;
                _this.emit("adfinished", ad);
              }).catch(function(e) {
                if (e.code === "ADS_NOT_LOADED") {
                  _this.emit("adsnotloaded", ad);
                } else if (e.code === "RATE_LIMITED") {
                  _this.emit("adratelimited", ad);
                }
                _this.emit("adshowerror", e, ad);
              });
              break;
            }
          }
          return this;
        },
        showVideo: function(placementID) {
          var _this = this;
          for (var i = 0; i < this.ads.length; i++) {
            var ad = this.ads[i];
            if (ad.placementID === placementID && ad.video && !ad.shown) {
              ad.instance.showAsync().then(function() {
                ad.shown = true;
                _this.emit("adfinished", ad);
              }).catch(function(e) {
                if (e.code === "ADS_NOT_LOADED") {
                  _this.emit("adsnotloaded", ad);
                } else if (e.code === "RATE_LIMITED") {
                  _this.emit("adratelimited", ad);
                }
                _this.emit("adshowerror", e, ad);
              });
              break;
            }
          }
          return this;
        },
        matchPlayer: function(matchTag, switchImmediately) {
          if (matchTag === void 0) {
            matchTag = null;
          }
          if (switchImmediately === void 0) {
            switchImmediately = false;
          }
          if (!this.checkAPI("matchPlayerAsync")) {
            return this;
          }
          var _this = this;
          FBInstant.matchPlayerAsync(matchTag, switchImmediately).then(function() {
            _this.getID();
            _this.getType();
            _this.emit("matchplayer", _this.contextID, _this.contextType);
          });
          return this;
        },
        getLeaderboard: function(name) {
          if (!this.checkAPI("getLeaderboardAsync")) {
            return this;
          }
          var _this = this;
          FBInstant.getLeaderboardAsync(name).then(function(data) {
            var leaderboard = new Leaderboard(_this, data);
            _this.leaderboards[name] = leaderboard;
            _this.emit("getleaderboard", leaderboard);
          }).catch(function(e) {
            console.warn(e);
          });
          return this;
        },
        destroy: function() {
          FBInstant.quit();
          this.data.destroy();
          this.removeAllListeners();
          this.catalog = [];
          this.purchases = [];
          this.leaderboards = [];
          this.ads = [];
          this.game = null;
        }
      });
      module.exports = FacebookInstantGamesPlugin;
    }
  });

  // ../../node_modules/phaser/src/core/Game.js
  var require_Game = __commonJS({
    "../../node_modules/phaser/src/core/Game.js": function(exports, module) {
      var AddToDOM = require_AddToDOM();
      var AnimationManager = require_AnimationManager();
      var CacheManager = require_CacheManager();
      var CanvasPool = require_CanvasPool();
      var Class = require_Class();
      var Config = require_Config();
      var CreateDOMContainer = require_CreateDOMContainer();
      var CreateRenderer = require_CreateRenderer();
      var DataManager = require_DataManager();
      var DebugHeader = require_DebugHeader();
      var Device = require_device();
      var DOMContentLoaded = require_DOMContentLoaded();
      var EventEmitter = require_eventemitter3();
      var Events = require_events5();
      var InputManager = require_InputManager();
      var PluginCache = require_PluginCache();
      var PluginManager = require_PluginManager();
      var ScaleManager = require_ScaleManager();
      var SceneManager = require_SceneManager();
      var TextureEvents = require_events9();
      var TextureManager = require_TextureManager();
      var TimeStep = require_TimeStep();
      var VisibilityHandler = require_VisibilityHandler();
      if (false) {
        SoundManagerCreator = require_SoundManagerCreator();
      }
      var SoundManagerCreator;
      if (false) {
        FacebookInstantGamesPlugin = require_FacebookInstantGamesPlugin();
      }
      var FacebookInstantGamesPlugin;
      var Game = new Class({
        initialize: function Game2(config) {
          this.config = new Config(config);
          this.renderer = null;
          this.domContainer = null;
          this.canvas = null;
          this.context = null;
          this.isBooted = false;
          this.isRunning = false;
          this.events = new EventEmitter();
          this.anims = new AnimationManager(this);
          this.textures = new TextureManager(this);
          this.cache = new CacheManager(this);
          this.registry = new DataManager(this, new EventEmitter());
          this.input = new InputManager(this, this.config);
          this.scene = new SceneManager(this, this.config.sceneConfig);
          this.device = Device;
          this.scale = new ScaleManager(this, this.config);
          this.sound = null;
          if (false) {
            this.sound = SoundManagerCreator.create(this);
          }
          this.loop = new TimeStep(this, this.config.fps);
          this.plugins = new PluginManager(this, this.config);
          if (false) {
            this.facebook = new FacebookInstantGamesPlugin(this);
          }
          this.pendingDestroy = false;
          this.removeCanvas = false;
          this.noReturn = false;
          this.hasFocus = false;
          this.isPaused = false;
          DOMContentLoaded(this.boot.bind(this));
        },
        boot: function() {
          if (!PluginCache.hasCore("EventEmitter")) {
            console.warn("Aborting. Core Plugins missing.");
            return;
          }
          this.isBooted = true;
          this.config.preBoot(this);
          this.scale.preBoot();
          CreateRenderer(this);
          CreateDOMContainer(this);
          DebugHeader(this);
          AddToDOM(this.canvas, this.config.parent);
          this.textures.once(TextureEvents.READY, this.texturesReady, this);
          this.events.emit(Events.BOOT);
          if (false && window) {
            window.PHASER_GAME = this;
          }
        },
        texturesReady: function() {
          this.events.emit(Events.READY);
          this.start();
        },
        start: function() {
          this.isRunning = true;
          this.config.postBoot(this);
          if (this.renderer) {
            this.loop.start(this.step.bind(this));
          } else {
            this.loop.start(this.headlessStep.bind(this));
          }
          VisibilityHandler(this);
          var eventEmitter = this.events;
          eventEmitter.on(Events.HIDDEN, this.onHidden, this);
          eventEmitter.on(Events.VISIBLE, this.onVisible, this);
          eventEmitter.on(Events.BLUR, this.onBlur, this);
          eventEmitter.on(Events.FOCUS, this.onFocus, this);
        },
        step: function(time, delta) {
          if (this.pendingDestroy) {
            return this.runDestroy();
          }
          if (this.isPaused) {
            return;
          }
          var eventEmitter = this.events;
          eventEmitter.emit(Events.PRE_STEP, time, delta);
          eventEmitter.emit(Events.STEP, time, delta);
          this.scene.update(time, delta);
          eventEmitter.emit(Events.POST_STEP, time, delta);
          var renderer = this.renderer;
          renderer.preRender();
          eventEmitter.emit(Events.PRE_RENDER, renderer, time, delta);
          this.scene.render(renderer);
          renderer.postRender();
          eventEmitter.emit(Events.POST_RENDER, renderer, time, delta);
        },
        headlessStep: function(time, delta) {
          if (this.pendingDestroy) {
            return this.runDestroy();
          }
          if (this.isPaused) {
            return;
          }
          var eventEmitter = this.events;
          eventEmitter.emit(Events.PRE_STEP, time, delta);
          eventEmitter.emit(Events.STEP, time, delta);
          this.scene.update(time, delta);
          eventEmitter.emit(Events.POST_STEP, time, delta);
          this.scene.isProcessing = false;
          eventEmitter.emit(Events.PRE_RENDER, null, time, delta);
          eventEmitter.emit(Events.POST_RENDER, null, time, delta);
        },
        onHidden: function() {
          this.loop.pause();
          this.events.emit(Events.PAUSE);
        },
        pause: function() {
          var wasPaused = this.isPaused;
          this.isPaused = true;
          if (!wasPaused) {
            this.events.emit(Events.PAUSE);
          }
        },
        onVisible: function() {
          this.loop.resume();
          this.events.emit(Events.RESUME);
        },
        resume: function() {
          var wasPaused = this.isPaused;
          this.isPaused = false;
          if (wasPaused) {
            this.events.emit(Events.RESUME);
          }
        },
        onBlur: function() {
          this.hasFocus = false;
          this.loop.blur();
        },
        onFocus: function() {
          this.hasFocus = true;
          this.loop.focus();
        },
        getFrame: function() {
          return this.loop.frame;
        },
        getTime: function() {
          return this.loop.now;
        },
        destroy: function(removeCanvas, noReturn) {
          if (noReturn === void 0) {
            noReturn = false;
          }
          this.pendingDestroy = true;
          this.removeCanvas = removeCanvas;
          this.noReturn = noReturn;
        },
        runDestroy: function() {
          this.scene.destroy();
          this.events.emit(Events.DESTROY);
          this.events.removeAllListeners();
          if (this.renderer) {
            this.renderer.destroy();
          }
          if (this.removeCanvas && this.canvas) {
            CanvasPool.remove(this.canvas);
            if (this.canvas.parentNode) {
              this.canvas.parentNode.removeChild(this.canvas);
            }
          }
          if (this.domContainer) {
            this.domContainer.parentNode.removeChild(this.domContainer);
          }
          this.loop.destroy();
          this.pendingDestroy = false;
        }
      });
      module.exports = Game;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/rendertexture/RenderTexture.js
  var require_RenderTexture = __commonJS({
    "../../node_modules/phaser/src/gameobjects/rendertexture/RenderTexture.js": function(exports, module) {
      var Class = require_Class();
      var DynamicTexture = require_DynamicTexture();
      var Image2 = require_Image();
      var RenderTexture = new Class({
        Extends: Image2,
        initialize: function RenderTexture2(scene, x, y, width, height) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (width === void 0) {
            width = 32;
          }
          if (height === void 0) {
            height = 32;
          }
          var dynamicTexture = new DynamicTexture(scene.sys.textures, "", width, height);
          Image2.call(this, scene, x, y, dynamicTexture);
          this.type = "RenderTexture";
          this.camera = this.texture.camera;
          this._saved = false;
        },
        setSize: function(width, height) {
          this.width = width;
          this.height = height;
          this.texture.setSize(width, height);
          this.updateDisplayOrigin();
          var input = this.input;
          if (input && !input.customHitArea) {
            input.hitArea.width = width;
            input.hitArea.height = height;
          }
          return this;
        },
        resize: function(width, height) {
          this.setSize(width, height);
          return this;
        },
        saveTexture: function(key) {
          var texture = this.texture;
          texture.key = key;
          if (texture.manager.addDynamicTexture(texture)) {
            this._saved = true;
          }
          return texture;
        },
        fill: function(rgb, alpha, x, y, width, height) {
          this.texture.fill(rgb, alpha, x, y, width, height);
          return this;
        },
        clear: function() {
          this.texture.clear();
          return this;
        },
        stamp: function(key, frame, x, y, config) {
          this.texture.stamp(key, frame, x, y, config);
          return this;
        },
        erase: function(entries, x, y) {
          this.texture.erase(entries, x, y);
          return this;
        },
        draw: function(entries, x, y, alpha, tint) {
          this.texture.draw(entries, x, y, alpha, tint);
          return this;
        },
        drawFrame: function(key, frame, x, y, alpha, tint) {
          this.texture.drawFrame(key, frame, x, y, alpha, tint);
          return this;
        },
        repeat: function(key, frame, x, y, width, height, alpha, tint, skipBatch) {
          this.texture.repeat(key, frame, x, y, width, height, alpha, tint, skipBatch);
          return this;
        },
        beginDraw: function() {
          this.texture.beginDraw();
          return this;
        },
        batchDraw: function(entries, x, y, alpha, tint) {
          this.texture.batchDraw(entries, x, y, alpha, tint);
          return this;
        },
        batchDrawFrame: function(key, frame, x, y, alpha, tint) {
          this.texture.batchDrawFrame(key, frame, x, y, alpha, tint);
          return this;
        },
        endDraw: function(erase) {
          this.texture.endDraw(erase);
          return this;
        },
        snapshotArea: function(x, y, width, height, callback, type, encoderOptions) {
          this.texture.snapshotArea(x, y, width, height, callback, type, encoderOptions);
          return this;
        },
        snapshot: function(callback, type, encoderOptions) {
          return this.snapshotArea(0, 0, this.width, this.height, callback, type, encoderOptions);
        },
        snapshotPixel: function(x, y, callback) {
          return this.snapshotArea(x, y, 1, 1, callback, "pixel");
        },
        preDestroy: function() {
          if (!this._saved) {
            this.texture.destroy();
          }
        }
      });
      module.exports = RenderTexture;
    }
  });

  // ../../node_modules/phaser/src/utils/array/matrix/CheckMatrix.js
  var require_CheckMatrix = __commonJS({
    "../../node_modules/phaser/src/utils/array/matrix/CheckMatrix.js": function(exports, module) {
      var CheckMatrix = function(matrix) {
        if (!Array.isArray(matrix) || !Array.isArray(matrix[0])) {
          return false;
        }
        var size = matrix[0].length;
        for (var i = 1; i < matrix.length; i++) {
          if (matrix[i].length !== size) {
            return false;
          }
        }
        return true;
      };
      module.exports = CheckMatrix;
    }
  });

  // ../../node_modules/phaser/src/utils/array/matrix/MatrixToString.js
  var require_MatrixToString = __commonJS({
    "../../node_modules/phaser/src/utils/array/matrix/MatrixToString.js": function(exports, module) {
      var Pad = require_Pad();
      var CheckMatrix = require_CheckMatrix();
      var MatrixToString = function(matrix) {
        var str = "";
        if (!CheckMatrix(matrix)) {
          return str;
        }
        for (var r = 0; r < matrix.length; r++) {
          for (var c = 0; c < matrix[r].length; c++) {
            var cell = matrix[r][c].toString();
            if (cell !== "undefined") {
              str += Pad(cell, 2);
            } else {
              str += "?";
            }
            if (c < matrix[r].length - 1) {
              str += " |";
            }
          }
          if (r < matrix.length - 1) {
            str += "\n";
            for (var i = 0; i < matrix[r].length; i++) {
              str += "---";
              if (i < matrix[r].length - 1) {
                str += "+";
              }
            }
            str += "\n";
          }
        }
        return str;
      };
      module.exports = MatrixToString;
    }
  });

  // ../../node_modules/phaser/src/utils/array/matrix/ReverseColumns.js
  var require_ReverseColumns = __commonJS({
    "../../node_modules/phaser/src/utils/array/matrix/ReverseColumns.js": function(exports, module) {
      var ReverseColumns = function(matrix) {
        return matrix.reverse();
      };
      module.exports = ReverseColumns;
    }
  });

  // ../../node_modules/phaser/src/utils/array/matrix/ReverseRows.js
  var require_ReverseRows = __commonJS({
    "../../node_modules/phaser/src/utils/array/matrix/ReverseRows.js": function(exports, module) {
      var ReverseRows = function(matrix) {
        for (var i = 0; i < matrix.length; i++) {
          matrix[i].reverse();
        }
        return matrix;
      };
      module.exports = ReverseRows;
    }
  });

  // ../../node_modules/phaser/src/utils/array/matrix/TransposeMatrix.js
  var require_TransposeMatrix = __commonJS({
    "../../node_modules/phaser/src/utils/array/matrix/TransposeMatrix.js": function(exports, module) {
      var TransposeMatrix = function(array) {
        var sourceRowCount = array.length;
        var sourceColCount = array[0].length;
        var result = new Array(sourceColCount);
        for (var i = 0; i < sourceColCount; i++) {
          result[i] = new Array(sourceRowCount);
          for (var j = sourceRowCount - 1; j > -1; j--) {
            result[i][j] = array[j][i];
          }
        }
        return result;
      };
      module.exports = TransposeMatrix;
    }
  });

  // ../../node_modules/phaser/src/utils/array/matrix/RotateMatrix.js
  var require_RotateMatrix = __commonJS({
    "../../node_modules/phaser/src/utils/array/matrix/RotateMatrix.js": function(exports, module) {
      var CheckMatrix = require_CheckMatrix();
      var TransposeMatrix = require_TransposeMatrix();
      var RotateMatrix = function(matrix, direction) {
        if (direction === void 0) {
          direction = 90;
        }
        if (!CheckMatrix(matrix)) {
          return null;
        }
        if (typeof direction !== "string") {
          direction = (direction % 360 + 360) % 360;
        }
        if (direction === 90 || direction === -270 || direction === "rotateLeft") {
          matrix = TransposeMatrix(matrix);
          matrix.reverse();
        } else if (direction === -90 || direction === 270 || direction === "rotateRight") {
          matrix.reverse();
          matrix = TransposeMatrix(matrix);
        } else if (Math.abs(direction) === 180 || direction === "rotate180") {
          for (var i = 0; i < matrix.length; i++) {
            matrix[i].reverse();
          }
          matrix.reverse();
        }
        return matrix;
      };
      module.exports = RotateMatrix;
    }
  });

  // ../../node_modules/phaser/src/utils/array/matrix/Rotate180.js
  var require_Rotate180 = __commonJS({
    "../../node_modules/phaser/src/utils/array/matrix/Rotate180.js": function(exports, module) {
      var RotateMatrix = require_RotateMatrix();
      var Rotate180 = function(matrix) {
        return RotateMatrix(matrix, 180);
      };
      module.exports = Rotate180;
    }
  });

  // ../../node_modules/phaser/src/utils/array/matrix/RotateLeft.js
  var require_RotateLeft = __commonJS({
    "../../node_modules/phaser/src/utils/array/matrix/RotateLeft.js": function(exports, module) {
      var RotateMatrix = require_RotateMatrix();
      var RotateLeft = function(matrix) {
        return RotateMatrix(matrix, 90);
      };
      module.exports = RotateLeft;
    }
  });

  // ../../node_modules/phaser/src/utils/array/matrix/RotateRight.js
  var require_RotateRight = __commonJS({
    "../../node_modules/phaser/src/utils/array/matrix/RotateRight.js": function(exports, module) {
      var RotateMatrix = require_RotateMatrix();
      var RotateRight = function(matrix) {
        return RotateMatrix(matrix, -90);
      };
      module.exports = RotateRight;
    }
  });

  // ../../node_modules/phaser/src/utils/array/RotateLeft.js
  var require_RotateLeft2 = __commonJS({
    "../../node_modules/phaser/src/utils/array/RotateLeft.js": function(exports, module) {
      var RotateLeft = function(array, total) {
        if (total === void 0) {
          total = 1;
        }
        var element = null;
        for (var i = 0; i < total; i++) {
          element = array.shift();
          array.push(element);
        }
        return element;
      };
      module.exports = RotateLeft;
    }
  });

  // ../../node_modules/phaser/src/utils/array/RotateRight.js
  var require_RotateRight2 = __commonJS({
    "../../node_modules/phaser/src/utils/array/RotateRight.js": function(exports, module) {
      var RotateRight = function(array, total) {
        if (total === void 0) {
          total = 1;
        }
        var element = null;
        for (var i = 0; i < total; i++) {
          element = array.pop();
          array.unshift(element);
        }
        return element;
      };
      module.exports = RotateRight;
    }
  });

  // ../../node_modules/phaser/src/utils/array/matrix/TranslateMatrix.js
  var require_TranslateMatrix = __commonJS({
    "../../node_modules/phaser/src/utils/array/matrix/TranslateMatrix.js": function(exports, module) {
      var RotateLeft = require_RotateLeft2();
      var RotateRight = require_RotateRight2();
      var TranslateMatrix = function(matrix, x, y) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (y !== 0) {
          if (y < 0) {
            RotateLeft(matrix, Math.abs(y));
          } else {
            RotateRight(matrix, y);
          }
        }
        if (x !== 0) {
          for (var i = 0; i < matrix.length; i++) {
            var row = matrix[i];
            if (x < 0) {
              RotateLeft(row, Math.abs(x));
            } else {
              RotateRight(row, x);
            }
          }
        }
        return matrix;
      };
      module.exports = TranslateMatrix;
    }
  });

  // ../../node_modules/phaser/src/utils/array/matrix/index.js
  var require_matrix = __commonJS({
    "../../node_modules/phaser/src/utils/array/matrix/index.js": function(exports, module) {
      module.exports = {
        CheckMatrix: require_CheckMatrix(),
        MatrixToString: require_MatrixToString(),
        ReverseColumns: require_ReverseColumns(),
        ReverseRows: require_ReverseRows(),
        Rotate180: require_Rotate180(),
        RotateLeft: require_RotateLeft(),
        RotateMatrix: require_RotateMatrix(),
        RotateRight: require_RotateRight(),
        Translate: require_TranslateMatrix(),
        TransposeMatrix: require_TransposeMatrix()
      };
    }
  });

  // ../../node_modules/phaser/src/utils/array/Add.js
  var require_Add = __commonJS({
    "../../node_modules/phaser/src/utils/array/Add.js": function(exports, module) {
      var Add = function(array, item, limit, callback, context) {
        if (context === void 0) {
          context = array;
        }
        if (limit > 0) {
          var remaining = limit - array.length;
          if (remaining <= 0) {
            return null;
          }
        }
        if (!Array.isArray(item)) {
          if (array.indexOf(item) === -1) {
            array.push(item);
            if (callback) {
              callback.call(context, item);
            }
            return item;
          } else {
            return null;
          }
        }
        var itemLength = item.length - 1;
        while (itemLength >= 0) {
          if (array.indexOf(item[itemLength]) !== -1) {
            item.splice(itemLength, 1);
          }
          itemLength--;
        }
        itemLength = item.length;
        if (itemLength === 0) {
          return null;
        }
        if (limit > 0 && itemLength > remaining) {
          item.splice(remaining);
          itemLength = remaining;
        }
        for (var i = 0; i < itemLength; i++) {
          var entry = item[i];
          array.push(entry);
          if (callback) {
            callback.call(context, entry);
          }
        }
        return item;
      };
      module.exports = Add;
    }
  });

  // ../../node_modules/phaser/src/utils/array/AddAt.js
  var require_AddAt = __commonJS({
    "../../node_modules/phaser/src/utils/array/AddAt.js": function(exports, module) {
      var AddAt = function(array, item, index, limit, callback, context) {
        if (index === void 0) {
          index = 0;
        }
        if (context === void 0) {
          context = array;
        }
        if (limit > 0) {
          var remaining = limit - array.length;
          if (remaining <= 0) {
            return null;
          }
        }
        if (!Array.isArray(item)) {
          if (array.indexOf(item) === -1) {
            array.splice(index, 0, item);
            if (callback) {
              callback.call(context, item);
            }
            return item;
          } else {
            return null;
          }
        }
        var itemLength = item.length - 1;
        while (itemLength >= 0) {
          if (array.indexOf(item[itemLength]) !== -1) {
            item.pop();
          }
          itemLength--;
        }
        itemLength = item.length;
        if (itemLength === 0) {
          return null;
        }
        if (limit > 0 && itemLength > remaining) {
          item.splice(remaining);
          itemLength = remaining;
        }
        for (var i = itemLength - 1; i >= 0; i--) {
          var entry = item[i];
          array.splice(index, 0, entry);
          if (callback) {
            callback.call(context, entry);
          }
        }
        return item;
      };
      module.exports = AddAt;
    }
  });

  // ../../node_modules/phaser/src/utils/array/BringToTop.js
  var require_BringToTop = __commonJS({
    "../../node_modules/phaser/src/utils/array/BringToTop.js": function(exports, module) {
      var BringToTop = function(array, item) {
        var currentIndex = array.indexOf(item);
        if (currentIndex !== -1 && currentIndex < array.length) {
          array.splice(currentIndex, 1);
          array.push(item);
        }
        return item;
      };
      module.exports = BringToTop;
    }
  });

  // ../../node_modules/phaser/src/utils/array/CountAllMatching.js
  var require_CountAllMatching = __commonJS({
    "../../node_modules/phaser/src/utils/array/CountAllMatching.js": function(exports, module) {
      var SafeRange = require_SafeRange();
      var CountAllMatching = function(array, property, value, startIndex, endIndex) {
        if (startIndex === void 0) {
          startIndex = 0;
        }
        if (endIndex === void 0) {
          endIndex = array.length;
        }
        var total = 0;
        if (SafeRange(array, startIndex, endIndex)) {
          for (var i = startIndex; i < endIndex; i++) {
            var child = array[i];
            if (child[property] === value) {
              total++;
            }
          }
        }
        return total;
      };
      module.exports = CountAllMatching;
    }
  });

  // ../../node_modules/phaser/src/utils/array/Each.js
  var require_Each = __commonJS({
    "../../node_modules/phaser/src/utils/array/Each.js": function(exports, module) {
      var Each = function(array, callback, context) {
        var i;
        var args = [null];
        for (i = 3; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        for (i = 0; i < array.length; i++) {
          args[0] = array[i];
          callback.apply(context, args);
        }
        return array;
      };
      module.exports = Each;
    }
  });

  // ../../node_modules/phaser/src/utils/array/EachInRange.js
  var require_EachInRange = __commonJS({
    "../../node_modules/phaser/src/utils/array/EachInRange.js": function(exports, module) {
      var SafeRange = require_SafeRange();
      var EachInRange = function(array, callback, context, startIndex, endIndex) {
        if (startIndex === void 0) {
          startIndex = 0;
        }
        if (endIndex === void 0) {
          endIndex = array.length;
        }
        if (SafeRange(array, startIndex, endIndex)) {
          var i;
          var args = [null];
          for (i = 5; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          for (i = startIndex; i < endIndex; i++) {
            args[0] = array[i];
            callback.apply(context, args);
          }
        }
        return array;
      };
      module.exports = EachInRange;
    }
  });

  // ../../node_modules/phaser/src/utils/array/Flatten.js
  var require_Flatten = __commonJS({
    "../../node_modules/phaser/src/utils/array/Flatten.js": function(exports, module) {
      var Flatten = function(array, output) {
        if (output === void 0) {
          output = [];
        }
        for (var i = 0; i < array.length; i++) {
          if (Array.isArray(array[i])) {
            Flatten(array[i], output);
          } else {
            output.push(array[i]);
          }
        }
        return output;
      };
      module.exports = Flatten;
    }
  });

  // ../../node_modules/phaser/src/utils/array/GetRandom.js
  var require_GetRandom = __commonJS({
    "../../node_modules/phaser/src/utils/array/GetRandom.js": function(exports, module) {
      var GetRandom = function(array, startIndex, length) {
        if (startIndex === void 0) {
          startIndex = 0;
        }
        if (length === void 0) {
          length = array.length;
        }
        var randomIndex = startIndex + Math.floor(Math.random() * length);
        return array[randomIndex] === void 0 ? null : array[randomIndex];
      };
      module.exports = GetRandom;
    }
  });

  // ../../node_modules/phaser/src/utils/array/MoveDown.js
  var require_MoveDown = __commonJS({
    "../../node_modules/phaser/src/utils/array/MoveDown.js": function(exports, module) {
      var MoveDown = function(array, item) {
        var currentIndex = array.indexOf(item);
        if (currentIndex > 0) {
          var item2 = array[currentIndex - 1];
          var index2 = array.indexOf(item2);
          array[currentIndex] = item2;
          array[index2] = item;
        }
        return array;
      };
      module.exports = MoveDown;
    }
  });

  // ../../node_modules/phaser/src/utils/array/MoveTo.js
  var require_MoveTo = __commonJS({
    "../../node_modules/phaser/src/utils/array/MoveTo.js": function(exports, module) {
      var MoveTo = function(array, item, index) {
        var currentIndex = array.indexOf(item);
        if (currentIndex === -1 || index < 0 || index >= array.length) {
          throw new Error("Supplied index out of bounds");
        }
        if (currentIndex !== index) {
          array.splice(currentIndex, 1);
          array.splice(index, 0, item);
        }
        return item;
      };
      module.exports = MoveTo;
    }
  });

  // ../../node_modules/phaser/src/utils/array/MoveUp.js
  var require_MoveUp = __commonJS({
    "../../node_modules/phaser/src/utils/array/MoveUp.js": function(exports, module) {
      var MoveUp = function(array, item) {
        var currentIndex = array.indexOf(item);
        if (currentIndex !== -1 && currentIndex < array.length - 1) {
          var item2 = array[currentIndex + 1];
          var index2 = array.indexOf(item2);
          array[currentIndex] = item2;
          array[index2] = item;
        }
        return array;
      };
      module.exports = MoveUp;
    }
  });

  // ../../node_modules/phaser/src/utils/array/MoveAbove.js
  var require_MoveAbove = __commonJS({
    "../../node_modules/phaser/src/utils/array/MoveAbove.js": function(exports, module) {
      var MoveAbove = function(array, item1, item2) {
        if (item1 === item2) {
          return array;
        }
        var currentIndex = array.indexOf(item1);
        var baseIndex = array.indexOf(item2);
        if (currentIndex < 0 || baseIndex < 0) {
          throw new Error("Supplied items must be elements of the same array");
        }
        if (currentIndex > baseIndex) {
          return array;
        }
        array.splice(currentIndex, 1);
        if (baseIndex === array.length - 1) {
          array.push(item1);
        } else {
          array.splice(baseIndex, 0, item1);
        }
        return array;
      };
      module.exports = MoveAbove;
    }
  });

  // ../../node_modules/phaser/src/utils/array/MoveBelow.js
  var require_MoveBelow = __commonJS({
    "../../node_modules/phaser/src/utils/array/MoveBelow.js": function(exports, module) {
      var MoveBelow = function(array, item1, item2) {
        if (item1 === item2) {
          return array;
        }
        var currentIndex = array.indexOf(item1);
        var baseIndex = array.indexOf(item2);
        if (currentIndex < 0 || baseIndex < 0) {
          throw new Error("Supplied items must be elements of the same array");
        }
        if (currentIndex < baseIndex) {
          return array;
        }
        array.splice(currentIndex, 1);
        if (baseIndex === 0) {
          array.unshift(item1);
        } else {
          array.splice(baseIndex, 0, item1);
        }
        return array;
      };
      module.exports = MoveBelow;
    }
  });

  // ../../node_modules/phaser/src/utils/array/NumberArrayStep.js
  var require_NumberArrayStep = __commonJS({
    "../../node_modules/phaser/src/utils/array/NumberArrayStep.js": function(exports, module) {
      var RoundAwayFromZero = require_RoundAwayFromZero();
      var NumberArrayStep = function(start, end, step) {
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = null;
        }
        if (step === void 0) {
          step = 1;
        }
        if (end === null) {
          end = start;
          start = 0;
        }
        var result = [];
        var total = Math.max(RoundAwayFromZero((end - start) / (step || 1)), 0);
        for (var i = 0; i < total; i++) {
          result.push(start);
          start += step;
        }
        return result;
      };
      module.exports = NumberArrayStep;
    }
  });

  // ../../node_modules/phaser/src/utils/array/QuickSelect.js
  var require_QuickSelect = __commonJS({
    "../../node_modules/phaser/src/utils/array/QuickSelect.js": function(exports, module) {
      function swap(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }
      function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      var QuickSelect = function(arr, k, left, right, compare) {
        if (left === void 0) {
          left = 0;
        }
        if (right === void 0) {
          right = arr.length - 1;
        }
        if (compare === void 0) {
          compare = defaultCompare;
        }
        while (right > left) {
          if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            QuickSelect(arr, k, newLeft, newRight, compare);
          }
          var t = arr[k];
          var i = left;
          var j = right;
          swap(arr, left, k);
          if (compare(arr[right], t) > 0) {
            swap(arr, left, right);
          }
          while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) {
              i++;
            }
            while (compare(arr[j], t) > 0) {
              j--;
            }
          }
          if (compare(arr[left], t) === 0) {
            swap(arr, left, j);
          } else {
            j++;
            swap(arr, j, right);
          }
          if (j <= k) {
            left = j + 1;
          }
          if (k <= j) {
            right = j - 1;
          }
        }
      };
      module.exports = QuickSelect;
    }
  });

  // ../../node_modules/phaser/src/utils/array/Shuffle.js
  var require_Shuffle = __commonJS({
    "../../node_modules/phaser/src/utils/array/Shuffle.js": function(exports, module) {
      var Shuffle = function(array) {
        for (var i = array.length - 1; i > 0; i--) {
          var j = Math.floor(Math.random() * (i + 1));
          var temp = array[i];
          array[i] = array[j];
          array[j] = temp;
        }
        return array;
      };
      module.exports = Shuffle;
    }
  });

  // ../../node_modules/phaser/src/utils/array/Range.js
  var require_Range = __commonJS({
    "../../node_modules/phaser/src/utils/array/Range.js": function(exports, module) {
      var GetValue = require_GetValue();
      var Shuffle = require_Shuffle();
      var BuildChunk = function(a, b, qty) {
        var out = [];
        for (var aIndex = 0; aIndex < a.length; aIndex++) {
          for (var bIndex = 0; bIndex < b.length; bIndex++) {
            for (var i = 0; i < qty; i++) {
              out.push({ a: a[aIndex], b: b[bIndex] });
            }
          }
        }
        return out;
      };
      var Range = function(a, b, options) {
        var max = GetValue(options, "max", 0);
        var qty = GetValue(options, "qty", 1);
        var random = GetValue(options, "random", false);
        var randomB = GetValue(options, "randomB", false);
        var repeat = GetValue(options, "repeat", 0);
        var yoyo = GetValue(options, "yoyo", false);
        var out = [];
        if (randomB) {
          Shuffle(b);
        }
        if (repeat === -1) {
          if (max === 0) {
            repeat = 0;
          } else {
            var total = a.length * b.length * qty;
            if (yoyo) {
              total *= 2;
            }
            repeat = Math.ceil(max / total);
          }
        }
        for (var i = 0; i <= repeat; i++) {
          var chunk = BuildChunk(a, b, qty);
          if (random) {
            Shuffle(chunk);
          }
          out = out.concat(chunk);
          if (yoyo) {
            chunk.reverse();
            out = out.concat(chunk);
          }
        }
        if (max) {
          out.splice(max);
        }
        return out;
      };
      module.exports = Range;
    }
  });

  // ../../node_modules/phaser/src/utils/array/RemoveAt.js
  var require_RemoveAt = __commonJS({
    "../../node_modules/phaser/src/utils/array/RemoveAt.js": function(exports, module) {
      var SpliceOne = require_SpliceOne();
      var RemoveAt = function(array, index, callback, context) {
        if (context === void 0) {
          context = array;
        }
        if (index < 0 || index > array.length - 1) {
          throw new Error("Index out of bounds");
        }
        var item = SpliceOne(array, index);
        if (callback) {
          callback.call(context, item);
        }
        return item;
      };
      module.exports = RemoveAt;
    }
  });

  // ../../node_modules/phaser/src/utils/array/RemoveBetween.js
  var require_RemoveBetween = __commonJS({
    "../../node_modules/phaser/src/utils/array/RemoveBetween.js": function(exports, module) {
      var SafeRange = require_SafeRange();
      var RemoveBetween = function(array, startIndex, endIndex, callback, context) {
        if (startIndex === void 0) {
          startIndex = 0;
        }
        if (endIndex === void 0) {
          endIndex = array.length;
        }
        if (context === void 0) {
          context = array;
        }
        if (SafeRange(array, startIndex, endIndex)) {
          var size = endIndex - startIndex;
          var removed = array.splice(startIndex, size);
          if (callback) {
            for (var i = 0; i < removed.length; i++) {
              var entry = removed[i];
              callback.call(context, entry);
            }
          }
          return removed;
        } else {
          return [];
        }
      };
      module.exports = RemoveBetween;
    }
  });

  // ../../node_modules/phaser/src/utils/array/RemoveRandomElement.js
  var require_RemoveRandomElement = __commonJS({
    "../../node_modules/phaser/src/utils/array/RemoveRandomElement.js": function(exports, module) {
      var SpliceOne = require_SpliceOne();
      var RemoveRandomElement = function(array, start, length) {
        if (start === void 0) {
          start = 0;
        }
        if (length === void 0) {
          length = array.length;
        }
        var randomIndex = start + Math.floor(Math.random() * length);
        return SpliceOne(array, randomIndex);
      };
      module.exports = RemoveRandomElement;
    }
  });

  // ../../node_modules/phaser/src/utils/array/Replace.js
  var require_Replace = __commonJS({
    "../../node_modules/phaser/src/utils/array/Replace.js": function(exports, module) {
      var Replace = function(array, oldChild, newChild) {
        var index1 = array.indexOf(oldChild);
        var index2 = array.indexOf(newChild);
        if (index1 !== -1 && index2 === -1) {
          array[index1] = newChild;
          return true;
        } else {
          return false;
        }
      };
      module.exports = Replace;
    }
  });

  // ../../node_modules/phaser/src/utils/array/SendToBack.js
  var require_SendToBack = __commonJS({
    "../../node_modules/phaser/src/utils/array/SendToBack.js": function(exports, module) {
      var SendToBack = function(array, item) {
        var currentIndex = array.indexOf(item);
        if (currentIndex !== -1 && currentIndex > 0) {
          array.splice(currentIndex, 1);
          array.unshift(item);
        }
        return item;
      };
      module.exports = SendToBack;
    }
  });

  // ../../node_modules/phaser/src/utils/array/SetAll.js
  var require_SetAll = __commonJS({
    "../../node_modules/phaser/src/utils/array/SetAll.js": function(exports, module) {
      var SafeRange = require_SafeRange();
      var SetAll = function(array, property, value, startIndex, endIndex) {
        if (startIndex === void 0) {
          startIndex = 0;
        }
        if (endIndex === void 0) {
          endIndex = array.length;
        }
        if (SafeRange(array, startIndex, endIndex)) {
          for (var i = startIndex; i < endIndex; i++) {
            var entry = array[i];
            if (entry.hasOwnProperty(property)) {
              entry[property] = value;
            }
          }
        }
        return array;
      };
      module.exports = SetAll;
    }
  });

  // ../../node_modules/phaser/src/utils/array/StableSort.js
  var require_StableSort = __commonJS({
    "../../node_modules/phaser/src/utils/array/StableSort.js": function(exports, module) {
      var Device = require_device();
      function Compare(a, b) {
        return String(a).localeCompare(b);
      }
      function Process(array, compare) {
        var len = array.length;
        if (len <= 1) {
          return array;
        }
        var buffer = new Array(len);
        for (var chk = 1; chk < len; chk *= 2) {
          RunPass(array, compare, chk, buffer);
          var tmp = array;
          array = buffer;
          buffer = tmp;
        }
        return array;
      }
      function RunPass(arr, comp, chk, result) {
        var len = arr.length;
        var i = 0;
        var dbl = chk * 2;
        var l, r, e;
        var li, ri;
        for (l = 0; l < len; l += dbl) {
          r = l + chk;
          e = r + chk;
          if (r > len) {
            r = len;
          }
          if (e > len) {
            e = len;
          }
          li = l;
          ri = r;
          while (true) {
            if (li < r && ri < e) {
              if (comp(arr[li], arr[ri]) <= 0) {
                result[i++] = arr[li++];
              } else {
                result[i++] = arr[ri++];
              }
            } else if (li < r) {
              result[i++] = arr[li++];
            } else if (ri < e) {
              result[i++] = arr[ri++];
            } else {
              break;
            }
          }
        }
      }
      var StableSort = function(array, compare) {
        if (compare === void 0) {
          compare = Compare;
        }
        if (!array || array.length < 2) {
          return array;
        }
        if (Device.features.stableSort) {
          return array.sort(compare);
        }
        var result = Process(array, compare);
        if (result !== array) {
          RunPass(result, null, array.length, array);
        }
        return array;
      };
      module.exports = StableSort;
    }
  });

  // ../../node_modules/phaser/src/utils/array/Swap.js
  var require_Swap = __commonJS({
    "../../node_modules/phaser/src/utils/array/Swap.js": function(exports, module) {
      var Swap = function(array, item1, item2) {
        if (item1 === item2) {
          return array;
        }
        var index1 = array.indexOf(item1);
        var index2 = array.indexOf(item2);
        if (index1 < 0 || index2 < 0) {
          throw new Error("Supplied items must be elements of the same array");
        }
        array[index1] = item2;
        array[index2] = item1;
        return array;
      };
      module.exports = Swap;
    }
  });

  // ../../node_modules/phaser/src/utils/array/index.js
  var require_array = __commonJS({
    "../../node_modules/phaser/src/utils/array/index.js": function(exports, module) {
      module.exports = {
        Matrix: require_matrix(),
        Add: require_Add(),
        AddAt: require_AddAt(),
        BringToTop: require_BringToTop(),
        CountAllMatching: require_CountAllMatching(),
        Each: require_Each(),
        EachInRange: require_EachInRange(),
        FindClosestInSorted: require_FindClosestInSorted(),
        Flatten: require_Flatten(),
        GetAll: require_GetAll(),
        GetFirst: require_GetFirst(),
        GetRandom: require_GetRandom(),
        MoveDown: require_MoveDown(),
        MoveTo: require_MoveTo(),
        MoveUp: require_MoveUp(),
        MoveAbove: require_MoveAbove(),
        MoveBelow: require_MoveBelow(),
        NumberArray: require_NumberArray(),
        NumberArrayStep: require_NumberArrayStep(),
        QuickSelect: require_QuickSelect(),
        Range: require_Range(),
        Remove: require_Remove(),
        RemoveAt: require_RemoveAt(),
        RemoveBetween: require_RemoveBetween(),
        RemoveRandomElement: require_RemoveRandomElement(),
        Replace: require_Replace(),
        RotateLeft: require_RotateLeft2(),
        RotateRight: require_RotateRight2(),
        SafeRange: require_SafeRange(),
        SendToBack: require_SendToBack(),
        SetAll: require_SetAll(),
        Shuffle: require_Shuffle(),
        SortByDigits: require_SortByDigits(),
        SpliceOne: require_SpliceOne(),
        StableSort: require_StableSort(),
        Swap: require_Swap()
      };
    }
  });

  // ../../node_modules/phaser/src/gameobjects/container/ContainerWebGLRenderer.js
  var require_ContainerWebGLRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/container/ContainerWebGLRenderer.js": function(exports, module) {
      var ContainerWebGLRenderer = function(renderer, container, camera, parentMatrix) {
        camera.addToRenderList(container);
        var children = container.list;
        var childCount = children.length;
        if (childCount === 0) {
          return;
        }
        var transformMatrix = container.localTransform;
        if (parentMatrix) {
          transformMatrix.loadIdentity();
          transformMatrix.multiply(parentMatrix);
          transformMatrix.translate(container.x, container.y);
          transformMatrix.rotate(container.rotation);
          transformMatrix.scale(container.scaleX, container.scaleY);
        } else {
          transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);
        }
        renderer.pipelines.preBatch(container);
        var containerHasBlendMode = container.blendMode !== -1;
        if (!containerHasBlendMode) {
          renderer.setBlendMode(0);
        }
        var alpha = container.alpha;
        var scrollFactorX = container.scrollFactorX;
        var scrollFactorY = container.scrollFactorY;
        for (var i = 0; i < childCount; i++) {
          var child = children[i];
          if (!child.willRender(camera)) {
            continue;
          }
          var childAlphaTopLeft;
          var childAlphaTopRight;
          var childAlphaBottomLeft;
          var childAlphaBottomRight;
          if (child.alphaTopLeft !== void 0) {
            childAlphaTopLeft = child.alphaTopLeft;
            childAlphaTopRight = child.alphaTopRight;
            childAlphaBottomLeft = child.alphaBottomLeft;
            childAlphaBottomRight = child.alphaBottomRight;
          } else {
            var childAlpha = child.alpha;
            childAlphaTopLeft = childAlpha;
            childAlphaTopRight = childAlpha;
            childAlphaBottomLeft = childAlpha;
            childAlphaBottomRight = childAlpha;
          }
          var childScrollFactorX = child.scrollFactorX;
          var childScrollFactorY = child.scrollFactorY;
          if (!containerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
            renderer.setBlendMode(child.blendMode);
          }
          var mask = child.mask;
          if (mask) {
            mask.preRenderWebGL(renderer, child, camera);
          }
          var type = child.type;
          if (type !== renderer.currentType) {
            renderer.newType = true;
            renderer.currentType = type;
          }
          renderer.nextTypeMatch = i < childCount - 1 ? children[i + 1].type === renderer.currentType : false;
          child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY);
          child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha);
          child.renderWebGL(renderer, child, camera, transformMatrix, container);
          child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight);
          child.setScrollFactor(childScrollFactorX, childScrollFactorY);
          if (mask) {
            mask.postRenderWebGL(renderer, camera);
          }
          renderer.newType = false;
        }
        renderer.pipelines.postBatch(container);
      };
      module.exports = ContainerWebGLRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/container/ContainerCanvasRenderer.js
  var require_ContainerCanvasRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/container/ContainerCanvasRenderer.js": function(exports, module) {
      var ContainerCanvasRenderer = function(renderer, container, camera, parentMatrix) {
        camera.addToRenderList(container);
        var children = container.list;
        if (children.length === 0) {
          return;
        }
        var transformMatrix = container.localTransform;
        if (parentMatrix) {
          transformMatrix.loadIdentity();
          transformMatrix.multiply(parentMatrix);
          transformMatrix.translate(container.x, container.y);
          transformMatrix.rotate(container.rotation);
          transformMatrix.scale(container.scaleX, container.scaleY);
        } else {
          transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);
        }
        var containerHasBlendMode = container.blendMode !== -1;
        if (!containerHasBlendMode) {
          renderer.setBlendMode(0);
        }
        var alpha = container._alpha;
        var scrollFactorX = container.scrollFactorX;
        var scrollFactorY = container.scrollFactorY;
        if (container.mask) {
          container.mask.preRenderCanvas(renderer, null, camera);
        }
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          if (!child.willRender(camera)) {
            continue;
          }
          var childAlpha = child.alpha;
          var childScrollFactorX = child.scrollFactorX;
          var childScrollFactorY = child.scrollFactorY;
          if (!containerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
            renderer.setBlendMode(child.blendMode);
          }
          child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY);
          child.setAlpha(childAlpha * alpha);
          child.renderCanvas(renderer, child, camera, transformMatrix);
          child.setAlpha(childAlpha);
          child.setScrollFactor(childScrollFactorX, childScrollFactorY);
        }
        if (container.mask) {
          container.mask.postRenderCanvas(renderer);
        }
      };
      module.exports = ContainerCanvasRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/container/ContainerRender.js
  var require_ContainerRender = __commonJS({
    "../../node_modules/phaser/src/gameobjects/container/ContainerRender.js": function(exports, module) {
      var NOOP = require_NOOP();
      var renderWebGL = NOOP;
      var renderCanvas = NOOP;
      if (true) {
        renderWebGL = require_ContainerWebGLRenderer();
      }
      if (true) {
        renderCanvas = require_ContainerCanvasRenderer();
      }
      module.exports = {
        renderWebGL: renderWebGL,
        renderCanvas: renderCanvas
      };
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/Union.js
  var require_Union = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/Union.js": function(exports, module) {
      var Rectangle = require_Rectangle();
      var Union = function(rectA, rectB, out) {
        if (out === void 0) {
          out = new Rectangle();
        }
        var x = Math.min(rectA.x, rectB.x);
        var y = Math.min(rectA.y, rectB.y);
        var w = Math.max(rectA.right, rectB.right) - x;
        var h = Math.max(rectA.bottom, rectB.bottom) - y;
        return out.setTo(x, y, w, h);
      };
      module.exports = Union;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/container/Container.js
  var require_Container = __commonJS({
    "../../node_modules/phaser/src/gameobjects/container/Container.js": function(exports, module) {
      var ArrayUtils = require_array();
      var BlendModes = require_BlendModes();
      var Class = require_Class();
      var Components = require_components();
      var Events = require_events3();
      var GameObject = require_GameObject();
      var Rectangle = require_Rectangle();
      var Render = require_ContainerRender();
      var Union = require_Union();
      var Vector2 = require_Vector2();
      var Container = new Class({
        Extends: GameObject,
        Mixins: [
          Components.AlphaSingle,
          Components.BlendMode,
          Components.ComputedSize,
          Components.Depth,
          Components.Mask,
          Components.PostPipeline,
          Components.Transform,
          Components.Visible,
          Render
        ],
        initialize: function Container2(scene, x, y, children) {
          GameObject.call(this, scene, "Container");
          this.list = [];
          this.exclusive = true;
          this.maxSize = -1;
          this.position = 0;
          this.localTransform = new Components.TransformMatrix();
          this.tempTransformMatrix = new Components.TransformMatrix();
          this._sortKey = "";
          this._sysEvents = scene.sys.events;
          this.scrollFactorX = 1;
          this.scrollFactorY = 1;
          this.initPostPipeline();
          this.setPosition(x, y);
          this.clearAlpha();
          this.setBlendMode(BlendModes.SKIP_CHECK);
          if (children) {
            this.add(children);
          }
        },
        originX: {
          get: function() {
            return 0.5;
          }
        },
        originY: {
          get: function() {
            return 0.5;
          }
        },
        displayOriginX: {
          get: function() {
            return this.width * 0.5;
          }
        },
        displayOriginY: {
          get: function() {
            return this.height * 0.5;
          }
        },
        setExclusive: function(value) {
          if (value === void 0) {
            value = true;
          }
          this.exclusive = value;
          return this;
        },
        getBounds: function(output) {
          if (output === void 0) {
            output = new Rectangle();
          }
          output.setTo(this.x, this.y, 0, 0);
          if (this.parentContainer) {
            var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
            var transformedPosition = parentMatrix.transformPoint(this.x, this.y);
            output.setTo(transformedPosition.x, transformedPosition.y, 0, 0);
          }
          if (this.list.length > 0) {
            var children = this.list;
            var tempRect = new Rectangle();
            var hasSetFirst = false;
            output.setEmpty();
            for (var i = 0; i < children.length; i++) {
              var entry = children[i];
              if (entry.getBounds) {
                entry.getBounds(tempRect);
                if (!hasSetFirst) {
                  output.setTo(tempRect.x, tempRect.y, tempRect.width, tempRect.height);
                  hasSetFirst = true;
                } else {
                  Union(tempRect, output, output);
                }
              }
            }
          }
          return output;
        },
        addHandler: function(gameObject) {
          gameObject.once(Events.DESTROY, this.remove, this);
          if (this.exclusive) {
            if (gameObject.parentContainer) {
              gameObject.parentContainer.remove(gameObject);
            }
            gameObject.parentContainer = this;
            gameObject.removeFromDisplayList();
            gameObject.addedToScene();
          }
        },
        removeHandler: function(gameObject) {
          gameObject.off(Events.DESTROY, this.remove, this);
          if (this.exclusive) {
            gameObject.parentContainer = null;
            gameObject.removedFromScene();
            gameObject.addToDisplayList();
          }
        },
        pointToContainer: function(source, output) {
          if (output === void 0) {
            output = new Vector2();
          }
          if (this.parentContainer) {
            this.parentContainer.pointToContainer(source, output);
          } else {
            output.x = source.x;
            output.y = source.y;
          }
          var tempMatrix = this.tempTransformMatrix;
          tempMatrix.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY);
          tempMatrix.invert();
          tempMatrix.transformPoint(source.x, source.y, output);
          return output;
        },
        getBoundsTransformMatrix: function() {
          return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform);
        },
        add: function(child) {
          ArrayUtils.Add(this.list, child, this.maxSize, this.addHandler, this);
          return this;
        },
        addAt: function(child, index) {
          ArrayUtils.AddAt(this.list, child, index, this.maxSize, this.addHandler, this);
          return this;
        },
        getAt: function(index) {
          return this.list[index];
        },
        getIndex: function(child) {
          return this.list.indexOf(child);
        },
        sort: function(property, handler) {
          if (!property) {
            return this;
          }
          if (handler === void 0) {
            handler = function(childA, childB) {
              return childA[property] - childB[property];
            };
          }
          ArrayUtils.StableSort(this.list, handler);
          return this;
        },
        getByName: function(name) {
          return ArrayUtils.GetFirst(this.list, "name", name);
        },
        getRandom: function(startIndex, length) {
          return ArrayUtils.GetRandom(this.list, startIndex, length);
        },
        getFirst: function(property, value, startIndex, endIndex) {
          return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);
        },
        getAll: function(property, value, startIndex, endIndex) {
          return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);
        },
        count: function(property, value, startIndex, endIndex) {
          return ArrayUtils.CountAllMatching(this.list, property, value, startIndex, endIndex);
        },
        swap: function(child1, child2) {
          ArrayUtils.Swap(this.list, child1, child2);
          return this;
        },
        moveTo: function(child, index) {
          ArrayUtils.MoveTo(this.list, child, index);
          return this;
        },
        moveAbove: function(child1, child2) {
          ArrayUtils.MoveAbove(this.list, child1, child2);
          return this;
        },
        moveBelow: function(child1, child2) {
          ArrayUtils.MoveBelow(this.list, child1, child2);
          return this;
        },
        remove: function(child, destroyChild) {
          var removed = ArrayUtils.Remove(this.list, child, this.removeHandler, this);
          if (destroyChild && removed) {
            if (!Array.isArray(removed)) {
              removed = [removed];
            }
            for (var i = 0; i < removed.length; i++) {
              removed[i].destroy();
            }
          }
          return this;
        },
        removeAt: function(index, destroyChild) {
          var removed = ArrayUtils.RemoveAt(this.list, index, this.removeHandler, this);
          if (destroyChild && removed) {
            removed.destroy();
          }
          return this;
        },
        removeBetween: function(startIndex, endIndex, destroyChild) {
          var removed = ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeHandler, this);
          if (destroyChild) {
            for (var i = 0; i < removed.length; i++) {
              removed[i].destroy();
            }
          }
          return this;
        },
        removeAll: function(destroyChild) {
          var list = this.list;
          if (destroyChild) {
            for (var i = 0; i < list.length; i++) {
              if (list[i] && list[i].scene) {
                list[i].off(Events.DESTROY, this.remove, this);
                list[i].destroy();
              }
            }
            this.list = [];
          } else {
            ArrayUtils.RemoveBetween(list, 0, list.length, this.removeHandler, this);
          }
          return this;
        },
        bringToTop: function(child) {
          ArrayUtils.BringToTop(this.list, child);
          return this;
        },
        sendToBack: function(child) {
          ArrayUtils.SendToBack(this.list, child);
          return this;
        },
        moveUp: function(child) {
          ArrayUtils.MoveUp(this.list, child);
          return this;
        },
        moveDown: function(child) {
          ArrayUtils.MoveDown(this.list, child);
          return this;
        },
        reverse: function() {
          this.list.reverse();
          return this;
        },
        shuffle: function() {
          ArrayUtils.Shuffle(this.list);
          return this;
        },
        replace: function(oldChild, newChild, destroyChild) {
          var moved = ArrayUtils.Replace(this.list, oldChild, newChild);
          if (moved) {
            this.addHandler(newChild);
            this.removeHandler(oldChild);
            if (destroyChild) {
              oldChild.destroy();
            }
          }
          return this;
        },
        exists: function(child) {
          return this.list.indexOf(child) > -1;
        },
        setAll: function(property, value, startIndex, endIndex) {
          ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);
          return this;
        },
        each: function(callback, context) {
          var args = [null];
          var i;
          var temp = this.list.slice();
          var len = temp.length;
          for (i = 2; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          for (i = 0; i < len; i++) {
            args[0] = temp[i];
            callback.apply(context, args);
          }
          return this;
        },
        iterate: function(callback, context) {
          var args = [null];
          var i;
          for (i = 2; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          for (i = 0; i < this.list.length; i++) {
            args[0] = this.list[i];
            callback.apply(context, args);
          }
          return this;
        },
        setScrollFactor: function(x, y, updateChildren) {
          if (y === void 0) {
            y = x;
          }
          if (updateChildren === void 0) {
            updateChildren = false;
          }
          this.scrollFactorX = x;
          this.scrollFactorY = y;
          if (updateChildren) {
            ArrayUtils.SetAll(this.list, "scrollFactorX", x);
            ArrayUtils.SetAll(this.list, "scrollFactorY", y);
          }
          return this;
        },
        length: {
          get: function() {
            return this.list.length;
          }
        },
        first: {
          get: function() {
            this.position = 0;
            if (this.list.length > 0) {
              return this.list[0];
            } else {
              return null;
            }
          }
        },
        last: {
          get: function() {
            if (this.list.length > 0) {
              this.position = this.list.length - 1;
              return this.list[this.position];
            } else {
              return null;
            }
          }
        },
        next: {
          get: function() {
            if (this.position < this.list.length) {
              this.position++;
              return this.list[this.position];
            } else {
              return null;
            }
          }
        },
        previous: {
          get: function() {
            if (this.position > 0) {
              this.position--;
              return this.list[this.position];
            } else {
              return null;
            }
          }
        },
        preDestroy: function() {
          this.removeAll(!!this.exclusive);
          this.localTransform.destroy();
          this.tempTransformMatrix.destroy();
          this.list = [];
        }
      });
      module.exports = Container;
    }
  });

  // ../../node_modules/phaser/src/structs/List.js
  var require_List = __commonJS({
    "../../node_modules/phaser/src/structs/List.js": function(exports, module) {
      var ArrayUtils = require_array();
      var Class = require_Class();
      var NOOP = require_NOOP();
      var StableSort = require_StableSort();
      var List = new Class({
        initialize: function List2(parent) {
          this.parent = parent;
          this.list = [];
          this.position = 0;
          this.addCallback = NOOP;
          this.removeCallback = NOOP;
          this._sortKey = "";
        },
        add: function(child, skipCallback) {
          if (skipCallback) {
            return ArrayUtils.Add(this.list, child);
          } else {
            return ArrayUtils.Add(this.list, child, 0, this.addCallback, this);
          }
        },
        addAt: function(child, index, skipCallback) {
          if (skipCallback) {
            return ArrayUtils.AddAt(this.list, child, index);
          } else {
            return ArrayUtils.AddAt(this.list, child, index, 0, this.addCallback, this);
          }
        },
        getAt: function(index) {
          return this.list[index];
        },
        getIndex: function(child) {
          return this.list.indexOf(child);
        },
        sort: function(property, handler) {
          if (!property) {
            return this;
          }
          if (handler === void 0) {
            handler = function(childA, childB) {
              return childA[property] - childB[property];
            };
          }
          StableSort(this.list, handler);
          return this;
        },
        getByName: function(name) {
          return ArrayUtils.GetFirst(this.list, "name", name);
        },
        getRandom: function(startIndex, length) {
          return ArrayUtils.GetRandom(this.list, startIndex, length);
        },
        getFirst: function(property, value, startIndex, endIndex) {
          return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);
        },
        getAll: function(property, value, startIndex, endIndex) {
          return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);
        },
        count: function(property, value) {
          return ArrayUtils.CountAllMatching(this.list, property, value);
        },
        swap: function(child1, child2) {
          ArrayUtils.Swap(this.list, child1, child2);
        },
        moveTo: function(child, index) {
          return ArrayUtils.MoveTo(this.list, child, index);
        },
        moveAbove: function(child1, child2) {
          return ArrayUtils.MoveAbove(this.list, child1, child2);
        },
        moveBelow: function(child1, child2) {
          return ArrayUtils.MoveBelow(this.list, child1, child2);
        },
        remove: function(child, skipCallback) {
          if (skipCallback) {
            return ArrayUtils.Remove(this.list, child);
          } else {
            return ArrayUtils.Remove(this.list, child, this.removeCallback, this);
          }
        },
        removeAt: function(index, skipCallback) {
          if (skipCallback) {
            return ArrayUtils.RemoveAt(this.list, index);
          } else {
            return ArrayUtils.RemoveAt(this.list, index, this.removeCallback, this);
          }
        },
        removeBetween: function(startIndex, endIndex, skipCallback) {
          if (skipCallback) {
            return ArrayUtils.RemoveBetween(this.list, startIndex, endIndex);
          } else {
            return ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeCallback, this);
          }
        },
        removeAll: function(skipCallback) {
          var i = this.list.length;
          while (i--) {
            this.remove(this.list[i], skipCallback);
          }
          return this;
        },
        bringToTop: function(child) {
          return ArrayUtils.BringToTop(this.list, child);
        },
        sendToBack: function(child) {
          return ArrayUtils.SendToBack(this.list, child);
        },
        moveUp: function(child) {
          ArrayUtils.MoveUp(this.list, child);
          return child;
        },
        moveDown: function(child) {
          ArrayUtils.MoveDown(this.list, child);
          return child;
        },
        reverse: function() {
          this.list.reverse();
          return this;
        },
        shuffle: function() {
          ArrayUtils.Shuffle(this.list);
          return this;
        },
        replace: function(oldChild, newChild) {
          return ArrayUtils.Replace(this.list, oldChild, newChild);
        },
        exists: function(child) {
          return this.list.indexOf(child) > -1;
        },
        setAll: function(property, value, startIndex, endIndex) {
          ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);
          return this;
        },
        each: function(callback, context) {
          var args = [null];
          for (var i = 2; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          for (i = 0; i < this.list.length; i++) {
            args[0] = this.list[i];
            callback.apply(context, args);
          }
        },
        shutdown: function() {
          this.removeAll();
          this.list = [];
        },
        destroy: function() {
          this.removeAll();
          this.parent = null;
          this.addCallback = null;
          this.removeCallback = null;
        },
        length: {
          get: function() {
            return this.list.length;
          }
        },
        first: {
          get: function() {
            this.position = 0;
            if (this.list.length > 0) {
              return this.list[0];
            } else {
              return null;
            }
          }
        },
        last: {
          get: function() {
            if (this.list.length > 0) {
              this.position = this.list.length - 1;
              return this.list[this.position];
            } else {
              return null;
            }
          }
        },
        next: {
          get: function() {
            if (this.position < this.list.length) {
              this.position++;
              return this.list[this.position];
            } else {
              return null;
            }
          }
        },
        previous: {
          get: function() {
            if (this.position > 0) {
              this.position--;
              return this.list[this.position];
            } else {
              return null;
            }
          }
        }
      });
      module.exports = List;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/DisplayList.js
  var require_DisplayList = __commonJS({
    "../../node_modules/phaser/src/gameobjects/DisplayList.js": function(exports, module) {
      var Class = require_Class();
      var List = require_List();
      var PluginCache = require_PluginCache();
      var GameObjectEvents = require_events3();
      var SceneEvents = require_events();
      var StableSort = require_StableSort();
      var DisplayList = new Class({
        Extends: List,
        initialize: function DisplayList2(scene) {
          List.call(this, scene);
          this.sortChildrenFlag = false;
          this.scene = scene;
          this.systems = scene.sys;
          this.events = scene.sys.events;
          this.addCallback = this.addChildCallback;
          this.removeCallback = this.removeChildCallback;
          this.events.once(SceneEvents.BOOT, this.boot, this);
          this.events.on(SceneEvents.START, this.start, this);
        },
        boot: function() {
          this.events.once(SceneEvents.DESTROY, this.destroy, this);
        },
        addChildCallback: function(gameObject) {
          if (gameObject.displayList && gameObject.displayList !== this) {
            gameObject.removeFromDisplayList();
          }
          if (gameObject.parentContainer) {
            gameObject.parentContainer.remove(gameObject);
          }
          if (!gameObject.displayList) {
            this.queueDepthSort();
            gameObject.displayList = this;
            gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene);
            this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene);
          }
        },
        removeChildCallback: function(gameObject) {
          this.queueDepthSort();
          gameObject.displayList = null;
          gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
          this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
        },
        start: function() {
          this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        queueDepthSort: function() {
          this.sortChildrenFlag = true;
        },
        depthSort: function() {
          if (this.sortChildrenFlag) {
            StableSort(this.list, this.sortByDepth);
            this.sortChildrenFlag = false;
          }
        },
        sortByDepth: function(childA, childB) {
          return childA._depth - childB._depth;
        },
        getChildren: function() {
          return this.list;
        },
        shutdown: function() {
          var list = this.list;
          while (list.length) {
            list[0].destroy(true);
          }
          this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        destroy: function() {
          this.shutdown();
          this.events.off(SceneEvents.START, this.start, this);
          this.scene = null;
          this.systems = null;
          this.events = null;
        }
      });
      PluginCache.register("DisplayList", DisplayList, "displayList");
      module.exports = DisplayList;
    }
  });

  // ../../node_modules/phaser/src/structs/events/PROCESS_QUEUE_ADD_EVENT.js
  var require_PROCESS_QUEUE_ADD_EVENT = __commonJS({
    "../../node_modules/phaser/src/structs/events/PROCESS_QUEUE_ADD_EVENT.js": function(exports, module) {
      module.exports = "add";
    }
  });

  // ../../node_modules/phaser/src/structs/events/PROCESS_QUEUE_REMOVE_EVENT.js
  var require_PROCESS_QUEUE_REMOVE_EVENT = __commonJS({
    "../../node_modules/phaser/src/structs/events/PROCESS_QUEUE_REMOVE_EVENT.js": function(exports, module) {
      module.exports = "remove";
    }
  });

  // ../../node_modules/phaser/src/structs/events/index.js
  var require_events16 = __commonJS({
    "../../node_modules/phaser/src/structs/events/index.js": function(exports, module) {
      module.exports = {
        PROCESS_QUEUE_ADD: require_PROCESS_QUEUE_ADD_EVENT(),
        PROCESS_QUEUE_REMOVE: require_PROCESS_QUEUE_REMOVE_EVENT()
      };
    }
  });

  // ../../node_modules/phaser/src/structs/ProcessQueue.js
  var require_ProcessQueue = __commonJS({
    "../../node_modules/phaser/src/structs/ProcessQueue.js": function(exports, module) {
      var Class = require_Class();
      var EventEmitter = require_eventemitter3();
      var Events = require_events16();
      var ProcessQueue = new Class({
        Extends: EventEmitter,
        initialize: function ProcessQueue2() {
          EventEmitter.call(this);
          this._pending = [];
          this._active = [];
          this._destroy = [];
          this._toProcess = 0;
          this.checkQueue = false;
        },
        isActive: function(item) {
          return this._active.indexOf(item) > -1;
        },
        isPending: function(item) {
          return this._toProcess > 0 && this._pending.indexOf(item) > -1;
        },
        isDestroying: function(item) {
          return this._destroy.indexOf(item) > -1;
        },
        add: function(item) {
          if (this.checkQueue && (this.isActive() && !this.isDestroying()) || this.isPending()) {
            return item;
          }
          this._pending.push(item);
          this._toProcess++;
          return item;
        },
        remove: function(item) {
          if (this.isPending(item)) {
            var pending = this._pending;
            var idx = pending.indexOf(item);
            if (idx !== -1) {
              pending.splice(idx, 1);
            }
          } else if (this.isActive(item)) {
            this._destroy.push(item);
            this._toProcess++;
          }
          return item;
        },
        removeAll: function() {
          var list = this._active;
          var destroy = this._destroy;
          var i = list.length;
          while (i--) {
            destroy.push(list[i]);
            this._toProcess++;
          }
          return this;
        },
        update: function() {
          if (this._toProcess === 0) {
            return this._active;
          }
          var list = this._destroy;
          var active = this._active;
          var i;
          var item;
          for (i = 0; i < list.length; i++) {
            item = list[i];
            var idx = active.indexOf(item);
            if (idx !== -1) {
              active.splice(idx, 1);
              this.emit(Events.PROCESS_QUEUE_REMOVE, item);
            }
          }
          list.length = 0;
          list = this._pending;
          for (i = 0; i < list.length; i++) {
            item = list[i];
            if (!this.checkQueue || this.checkQueue && active.indexOf(item) === -1) {
              active.push(item);
              this.emit(Events.PROCESS_QUEUE_ADD, item);
            }
          }
          list.length = 0;
          this._toProcess = 0;
          return active;
        },
        getActive: function() {
          return this._active;
        },
        length: {
          get: function() {
            return this._active.length;
          }
        },
        destroy: function() {
          this._toProcess = 0;
          this._pending = [];
          this._active = [];
          this._destroy = [];
        }
      });
      module.exports = ProcessQueue;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/UpdateList.js
  var require_UpdateList = __commonJS({
    "../../node_modules/phaser/src/gameobjects/UpdateList.js": function(exports, module) {
      var Class = require_Class();
      var ProcessQueue = require_ProcessQueue();
      var PluginCache = require_PluginCache();
      var SceneEvents = require_events();
      var UpdateList = new Class({
        Extends: ProcessQueue,
        initialize: function UpdateList2(scene) {
          ProcessQueue.call(this);
          this.checkQueue = true;
          this.scene = scene;
          this.systems = scene.sys;
          scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
          scene.sys.events.on(SceneEvents.START, this.start, this);
        },
        boot: function() {
          this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
        },
        start: function() {
          var eventEmitter = this.systems.events;
          eventEmitter.on(SceneEvents.PRE_UPDATE, this.update, this);
          eventEmitter.on(SceneEvents.UPDATE, this.sceneUpdate, this);
          eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        sceneUpdate: function(time, delta) {
          var list = this._active;
          var length = list.length;
          for (var i = 0; i < length; i++) {
            var gameObject = list[i];
            if (gameObject.active) {
              gameObject.preUpdate.call(gameObject, time, delta);
            }
          }
        },
        shutdown: function() {
          var i = this._active.length;
          while (i--) {
            this._active[i].destroy(true);
          }
          i = this._pending.length;
          while (i--) {
            this._pending[i].destroy(true);
          }
          i = this._destroy.length;
          while (i--) {
            this._destroy[i].destroy(true);
          }
          this._toProcess = 0;
          this._pending = [];
          this._active = [];
          this._destroy = [];
          this.removeAllListeners();
          var eventEmitter = this.systems.events;
          eventEmitter.off(SceneEvents.PRE_UPDATE, this.update, this);
          eventEmitter.off(SceneEvents.UPDATE, this.sceneUpdate, this);
          eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        destroy: function() {
          this.shutdown();
          this.systems.events.off(SceneEvents.START, this.start, this);
          this.scene = null;
          this.systems = null;
        }
      });
      PluginCache.register("UpdateList", UpdateList, "updateList");
      module.exports = UpdateList;
    }
  });

  // ../../node_modules/phaser/src/utils/object/GetAdvancedValue.js
  var require_GetAdvancedValue = __commonJS({
    "../../node_modules/phaser/src/utils/object/GetAdvancedValue.js": function(exports, module) {
      var MATH = require_math();
      var GetValue = require_GetValue();
      var GetAdvancedValue = function(source, key, defaultValue) {
        var value = GetValue(source, key, null);
        if (value === null) {
          return defaultValue;
        } else if (Array.isArray(value)) {
          return MATH.RND.pick(value);
        } else if (typeof value === "object") {
          if (value.hasOwnProperty("randInt")) {
            return MATH.RND.integerInRange(value.randInt[0], value.randInt[1]);
          } else if (value.hasOwnProperty("randFloat")) {
            return MATH.RND.realInRange(value.randFloat[0], value.randFloat[1]);
          }
        } else if (typeof value === "function") {
          return value(key);
        }
        return value;
      };
      module.exports = GetAdvancedValue;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/BuildGameObject.js
  var require_BuildGameObject = __commonJS({
    "../../node_modules/phaser/src/gameobjects/BuildGameObject.js": function(exports, module) {
      var BlendModes = require_BlendModes();
      var GetAdvancedValue = require_GetAdvancedValue();
      var BuildGameObject = function(scene, gameObject, config) {
        gameObject.x = GetAdvancedValue(config, "x", 0);
        gameObject.y = GetAdvancedValue(config, "y", 0);
        gameObject.depth = GetAdvancedValue(config, "depth", 0);
        gameObject.flipX = GetAdvancedValue(config, "flipX", false);
        gameObject.flipY = GetAdvancedValue(config, "flipY", false);
        var scale = GetAdvancedValue(config, "scale", null);
        if (typeof scale === "number") {
          gameObject.setScale(scale);
        } else if (scale !== null) {
          gameObject.scaleX = GetAdvancedValue(scale, "x", 1);
          gameObject.scaleY = GetAdvancedValue(scale, "y", 1);
        }
        var scrollFactor = GetAdvancedValue(config, "scrollFactor", null);
        if (typeof scrollFactor === "number") {
          gameObject.setScrollFactor(scrollFactor);
        } else if (scrollFactor !== null) {
          gameObject.scrollFactorX = GetAdvancedValue(scrollFactor, "x", 1);
          gameObject.scrollFactorY = GetAdvancedValue(scrollFactor, "y", 1);
        }
        gameObject.rotation = GetAdvancedValue(config, "rotation", 0);
        var angle = GetAdvancedValue(config, "angle", null);
        if (angle !== null) {
          gameObject.angle = angle;
        }
        gameObject.alpha = GetAdvancedValue(config, "alpha", 1);
        var origin = GetAdvancedValue(config, "origin", null);
        if (typeof origin === "number") {
          gameObject.setOrigin(origin);
        } else if (origin !== null) {
          var ox = GetAdvancedValue(origin, "x", 0.5);
          var oy = GetAdvancedValue(origin, "y", 0.5);
          gameObject.setOrigin(ox, oy);
        }
        gameObject.blendMode = GetAdvancedValue(config, "blendMode", BlendModes.NORMAL);
        gameObject.visible = GetAdvancedValue(config, "visible", true);
        var add = GetAdvancedValue(config, "add", true);
        if (add) {
          scene.sys.displayList.add(gameObject);
        }
        if (gameObject.preUpdate) {
          scene.sys.updateList.add(gameObject);
        }
        return gameObject;
      };
      module.exports = BuildGameObject;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/BuildGameObjectAnimation.js
  var require_BuildGameObjectAnimation = __commonJS({
    "../../node_modules/phaser/src/gameobjects/BuildGameObjectAnimation.js": function(exports, module) {
      var GetAdvancedValue = require_GetAdvancedValue();
      var BuildGameObjectAnimation = function(sprite, config) {
        var animConfig = GetAdvancedValue(config, "anims", null);
        if (animConfig === null) {
          return sprite;
        }
        if (typeof animConfig === "string") {
          sprite.anims.play(animConfig);
        } else if (typeof animConfig === "object") {
          var anims = sprite.anims;
          var key = GetAdvancedValue(animConfig, "key", void 0);
          if (key) {
            var startFrame = GetAdvancedValue(animConfig, "startFrame", void 0);
            var delay = GetAdvancedValue(animConfig, "delay", 0);
            var repeat = GetAdvancedValue(animConfig, "repeat", 0);
            var repeatDelay = GetAdvancedValue(animConfig, "repeatDelay", 0);
            var yoyo = GetAdvancedValue(animConfig, "yoyo", false);
            var play = GetAdvancedValue(animConfig, "play", false);
            var delayedPlay = GetAdvancedValue(animConfig, "delayedPlay", 0);
            var playConfig = {
              key: key,
              delay: delay,
              repeat: repeat,
              repeatDelay: repeatDelay,
              yoyo: yoyo,
              startFrame: startFrame
            };
            if (play) {
              anims.play(playConfig);
            } else if (delayedPlay > 0) {
              anims.playAfterDelay(playConfig, delayedPlay);
            } else {
              anims.load(playConfig);
            }
          }
        }
        return sprite;
      };
      module.exports = BuildGameObjectAnimation;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/graphics/Commands.js
  var require_Commands = __commonJS({
    "../../node_modules/phaser/src/gameobjects/graphics/Commands.js": function(exports, module) {
      module.exports = {
        ARC: 0,
        BEGIN_PATH: 1,
        CLOSE_PATH: 2,
        FILL_RECT: 3,
        LINE_TO: 4,
        MOVE_TO: 5,
        LINE_STYLE: 6,
        FILL_STYLE: 7,
        FILL_PATH: 8,
        STROKE_PATH: 9,
        FILL_TRIANGLE: 10,
        STROKE_TRIANGLE: 11,
        SAVE: 14,
        RESTORE: 15,
        TRANSLATE: 16,
        SCALE: 17,
        ROTATE: 18,
        GRADIENT_FILL_STYLE: 21,
        GRADIENT_LINE_STYLE: 22
      };
    }
  });

  // ../../node_modules/phaser/src/geom/ellipse/Contains.js
  var require_Contains3 = __commonJS({
    "../../node_modules/phaser/src/geom/ellipse/Contains.js": function(exports, module) {
      var Contains = function(ellipse, x, y) {
        if (ellipse.width <= 0 || ellipse.height <= 0) {
          return false;
        }
        var normx = (x - ellipse.x) / ellipse.width;
        var normy = (y - ellipse.y) / ellipse.height;
        normx *= normx;
        normy *= normy;
        return normx + normy < 0.25;
      };
      module.exports = Contains;
    }
  });

  // ../../node_modules/phaser/src/geom/ellipse/CircumferencePoint.js
  var require_CircumferencePoint2 = __commonJS({
    "../../node_modules/phaser/src/geom/ellipse/CircumferencePoint.js": function(exports, module) {
      var Point = require_Point();
      var CircumferencePoint = function(ellipse, angle, out) {
        if (out === void 0) {
          out = new Point();
        }
        var halfWidth = ellipse.width / 2;
        var halfHeight = ellipse.height / 2;
        out.x = ellipse.x + halfWidth * Math.cos(angle);
        out.y = ellipse.y + halfHeight * Math.sin(angle);
        return out;
      };
      module.exports = CircumferencePoint;
    }
  });

  // ../../node_modules/phaser/src/geom/ellipse/GetPoint.js
  var require_GetPoint4 = __commonJS({
    "../../node_modules/phaser/src/geom/ellipse/GetPoint.js": function(exports, module) {
      var CircumferencePoint = require_CircumferencePoint2();
      var FromPercent = require_FromPercent();
      var MATH_CONST = require_const4();
      var Point = require_Point();
      var GetPoint = function(ellipse, position, out) {
        if (out === void 0) {
          out = new Point();
        }
        var angle = FromPercent(position, 0, MATH_CONST.PI2);
        return CircumferencePoint(ellipse, angle, out);
      };
      module.exports = GetPoint;
    }
  });

  // ../../node_modules/phaser/src/geom/ellipse/Circumference.js
  var require_Circumference2 = __commonJS({
    "../../node_modules/phaser/src/geom/ellipse/Circumference.js": function(exports, module) {
      var Circumference = function(ellipse) {
        var rx = ellipse.width / 2;
        var ry = ellipse.height / 2;
        var h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);
        return Math.PI * (rx + ry) * (1 + 3 * h / (10 + Math.sqrt(4 - 3 * h)));
      };
      module.exports = Circumference;
    }
  });

  // ../../node_modules/phaser/src/geom/ellipse/GetPoints.js
  var require_GetPoints4 = __commonJS({
    "../../node_modules/phaser/src/geom/ellipse/GetPoints.js": function(exports, module) {
      var Circumference = require_Circumference2();
      var CircumferencePoint = require_CircumferencePoint2();
      var FromPercent = require_FromPercent();
      var MATH_CONST = require_const4();
      var GetPoints = function(ellipse, quantity, stepRate, out) {
        if (out === void 0) {
          out = [];
        }
        if (!quantity && stepRate > 0) {
          quantity = Circumference(ellipse) / stepRate;
        }
        for (var i = 0; i < quantity; i++) {
          var angle = FromPercent(i / quantity, 0, MATH_CONST.PI2);
          out.push(CircumferencePoint(ellipse, angle));
        }
        return out;
      };
      module.exports = GetPoints;
    }
  });

  // ../../node_modules/phaser/src/geom/ellipse/Random.js
  var require_Random5 = __commonJS({
    "../../node_modules/phaser/src/geom/ellipse/Random.js": function(exports, module) {
      var Point = require_Point();
      var Random = function(ellipse, out) {
        if (out === void 0) {
          out = new Point();
        }
        var p = Math.random() * Math.PI * 2;
        var s = Math.sqrt(Math.random());
        out.x = ellipse.x + s * Math.cos(p) * ellipse.width / 2;
        out.y = ellipse.y + s * Math.sin(p) * ellipse.height / 2;
        return out;
      };
      module.exports = Random;
    }
  });

  // ../../node_modules/phaser/src/geom/ellipse/Ellipse.js
  var require_Ellipse = __commonJS({
    "../../node_modules/phaser/src/geom/ellipse/Ellipse.js": function(exports, module) {
      var Class = require_Class();
      var Contains = require_Contains3();
      var GetPoint = require_GetPoint4();
      var GetPoints = require_GetPoints4();
      var GEOM_CONST = require_const3();
      var Random = require_Random5();
      var Ellipse = new Class({
        initialize: function Ellipse2(x, y, width, height) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (width === void 0) {
            width = 0;
          }
          if (height === void 0) {
            height = 0;
          }
          this.type = GEOM_CONST.ELLIPSE;
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
        },
        contains: function(x, y) {
          return Contains(this, x, y);
        },
        getPoint: function(position, point) {
          return GetPoint(this, position, point);
        },
        getPoints: function(quantity, stepRate, output) {
          return GetPoints(this, quantity, stepRate, output);
        },
        getRandomPoint: function(point) {
          return Random(this, point);
        },
        setTo: function(x, y, width, height) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
          return this;
        },
        setEmpty: function() {
          this.width = 0;
          this.height = 0;
          return this;
        },
        setPosition: function(x, y) {
          if (y === void 0) {
            y = x;
          }
          this.x = x;
          this.y = y;
          return this;
        },
        setSize: function(width, height) {
          if (height === void 0) {
            height = width;
          }
          this.width = width;
          this.height = height;
          return this;
        },
        isEmpty: function() {
          return this.width <= 0 || this.height <= 0;
        },
        getMinorRadius: function() {
          return Math.min(this.width, this.height) / 2;
        },
        getMajorRadius: function() {
          return Math.max(this.width, this.height) / 2;
        },
        left: {
          get: function() {
            return this.x - this.width / 2;
          },
          set: function(value) {
            this.x = value + this.width / 2;
          }
        },
        right: {
          get: function() {
            return this.x + this.width / 2;
          },
          set: function(value) {
            this.x = value - this.width / 2;
          }
        },
        top: {
          get: function() {
            return this.y - this.height / 2;
          },
          set: function(value) {
            this.y = value + this.height / 2;
          }
        },
        bottom: {
          get: function() {
            return this.y + this.height / 2;
          },
          set: function(value) {
            this.y = value - this.height / 2;
          }
        }
      });
      module.exports = Ellipse;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/GetCalcMatrix.js
  var require_GetCalcMatrix = __commonJS({
    "../../node_modules/phaser/src/gameobjects/GetCalcMatrix.js": function(exports, module) {
      var TransformMatrix = require_TransformMatrix();
      var tempMatrix1 = new TransformMatrix();
      var tempMatrix2 = new TransformMatrix();
      var tempMatrix3 = new TransformMatrix();
      var result = { camera: tempMatrix1, sprite: tempMatrix2, calc: tempMatrix3 };
      var GetCalcMatrix = function(src, camera, parentMatrix) {
        var camMatrix = tempMatrix1;
        var spriteMatrix = tempMatrix2;
        var calcMatrix = tempMatrix3;
        spriteMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);
        camMatrix.copyFrom(camera.matrix);
        if (parentMatrix) {
          camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);
          spriteMatrix.e = src.x;
          spriteMatrix.f = src.y;
        } else {
          spriteMatrix.e -= camera.scrollX * src.scrollFactorX;
          spriteMatrix.f -= camera.scrollY * src.scrollFactorY;
        }
        camMatrix.multiply(spriteMatrix, calcMatrix);
        return result;
      };
      module.exports = GetCalcMatrix;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/graphics/GraphicsWebGLRenderer.js
  var require_GraphicsWebGLRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/graphics/GraphicsWebGLRenderer.js": function(exports, module) {
      var Commands = require_Commands();
      var GetCalcMatrix = require_GetCalcMatrix();
      var TransformMatrix = require_TransformMatrix();
      var Utils = require_Utils();
      var Point = function(x, y, width) {
        this.x = x;
        this.y = y;
        this.width = width;
      };
      var Path = function(x, y, width) {
        this.points = [];
        this.pointsLength = 1;
        this.points[0] = new Point(x, y, width);
      };
      var matrixStack = [];
      var tempMatrix = new TransformMatrix();
      var GraphicsWebGLRenderer = function(renderer, src, camera, parentMatrix) {
        if (src.commandBuffer.length === 0) {
          return;
        }
        camera.addToRenderList(src);
        var pipeline = renderer.pipelines.set(src.pipeline, src);
        renderer.pipelines.preBatch(src);
        var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
        var currentMatrix = tempMatrix.loadIdentity();
        var commands = src.commandBuffer;
        var alpha = camera.alpha * src.alpha;
        var lineWidth = 1;
        var fillTint = pipeline.fillTint;
        var strokeTint = pipeline.strokeTint;
        var tx = 0;
        var ty = 0;
        var ta = 0;
        var iterStep = 0.01;
        var PI2 = Math.PI * 2;
        var cmd;
        var path = [];
        var pathIndex = 0;
        var pathOpen = true;
        var lastPath = null;
        var getTint = Utils.getTintAppendFloatAlpha;
        for (var cmdIndex = 0; cmdIndex < commands.length; cmdIndex++) {
          cmd = commands[cmdIndex];
          switch (cmd) {
            case Commands.BEGIN_PATH: {
              path.length = 0;
              lastPath = null;
              pathOpen = true;
              break;
            }
            case Commands.CLOSE_PATH: {
              pathOpen = false;
              if (lastPath && lastPath.points.length) {
                lastPath.points.push(lastPath.points[0]);
              }
              break;
            }
            case Commands.FILL_PATH: {
              for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
                pipeline.batchFillPath(path[pathIndex].points, currentMatrix, calcMatrix);
              }
              break;
            }
            case Commands.STROKE_PATH: {
              for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
                pipeline.batchStrokePath(path[pathIndex].points, lineWidth, pathOpen, currentMatrix, calcMatrix);
              }
              break;
            }
            case Commands.LINE_STYLE: {
              lineWidth = commands[++cmdIndex];
              var strokeColor = commands[++cmdIndex];
              var strokeAlpha = commands[++cmdIndex] * alpha;
              var strokeTintColor = getTint(strokeColor, strokeAlpha);
              strokeTint.TL = strokeTintColor;
              strokeTint.TR = strokeTintColor;
              strokeTint.BL = strokeTintColor;
              strokeTint.BR = strokeTintColor;
              break;
            }
            case Commands.FILL_STYLE: {
              var fillColor = commands[++cmdIndex];
              var fillAlpha = commands[++cmdIndex] * alpha;
              var fillTintColor = getTint(fillColor, fillAlpha);
              fillTint.TL = fillTintColor;
              fillTint.TR = fillTintColor;
              fillTint.BL = fillTintColor;
              fillTint.BR = fillTintColor;
              break;
            }
            case Commands.GRADIENT_FILL_STYLE: {
              var alphaTL = commands[++cmdIndex] * alpha;
              var alphaTR = commands[++cmdIndex] * alpha;
              var alphaBL = commands[++cmdIndex] * alpha;
              var alphaBR = commands[++cmdIndex] * alpha;
              fillTint.TL = getTint(commands[++cmdIndex], alphaTL);
              fillTint.TR = getTint(commands[++cmdIndex], alphaTR);
              fillTint.BL = getTint(commands[++cmdIndex], alphaBL);
              fillTint.BR = getTint(commands[++cmdIndex], alphaBR);
              break;
            }
            case Commands.GRADIENT_LINE_STYLE: {
              lineWidth = commands[++cmdIndex];
              var gradientLineAlpha = commands[++cmdIndex] * alpha;
              strokeTint.TL = getTint(commands[++cmdIndex], gradientLineAlpha);
              strokeTint.TR = getTint(commands[++cmdIndex], gradientLineAlpha);
              strokeTint.BL = getTint(commands[++cmdIndex], gradientLineAlpha);
              strokeTint.BR = getTint(commands[++cmdIndex], gradientLineAlpha);
              break;
            }
            case Commands.ARC: {
              var iteration = 0;
              var x = commands[++cmdIndex];
              var y = commands[++cmdIndex];
              var radius = commands[++cmdIndex];
              var startAngle = commands[++cmdIndex];
              var endAngle = commands[++cmdIndex];
              var anticlockwise = commands[++cmdIndex];
              var overshoot = commands[++cmdIndex];
              endAngle -= startAngle;
              if (anticlockwise) {
                if (endAngle < -PI2) {
                  endAngle = -PI2;
                } else if (endAngle > 0) {
                  endAngle = -PI2 + endAngle % PI2;
                }
              } else if (endAngle > PI2) {
                endAngle = PI2;
              } else if (endAngle < 0) {
                endAngle = PI2 + endAngle % PI2;
              }
              if (lastPath === null) {
                lastPath = new Path(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius, lineWidth);
                path.push(lastPath);
                iteration += iterStep;
              }
              while (iteration < 1 + overshoot) {
                ta = endAngle * iteration + startAngle;
                tx = x + Math.cos(ta) * radius;
                ty = y + Math.sin(ta) * radius;
                lastPath.points.push(new Point(tx, ty, lineWidth));
                iteration += iterStep;
              }
              ta = endAngle + startAngle;
              tx = x + Math.cos(ta) * radius;
              ty = y + Math.sin(ta) * radius;
              lastPath.points.push(new Point(tx, ty, lineWidth));
              break;
            }
            case Commands.FILL_RECT: {
              pipeline.batchFillRect(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], currentMatrix, calcMatrix);
              break;
            }
            case Commands.FILL_TRIANGLE: {
              pipeline.batchFillTriangle(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], currentMatrix, calcMatrix);
              break;
            }
            case Commands.STROKE_TRIANGLE: {
              pipeline.batchStrokeTriangle(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], lineWidth, currentMatrix, calcMatrix);
              break;
            }
            case Commands.LINE_TO: {
              if (lastPath !== null) {
                lastPath.points.push(new Point(commands[++cmdIndex], commands[++cmdIndex], lineWidth));
              } else {
                lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);
                path.push(lastPath);
              }
              break;
            }
            case Commands.MOVE_TO: {
              lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);
              path.push(lastPath);
              break;
            }
            case Commands.SAVE: {
              matrixStack.push(currentMatrix.copyToArray());
              break;
            }
            case Commands.RESTORE: {
              currentMatrix.copyFromArray(matrixStack.pop());
              break;
            }
            case Commands.TRANSLATE: {
              x = commands[++cmdIndex];
              y = commands[++cmdIndex];
              currentMatrix.translate(x, y);
              break;
            }
            case Commands.SCALE: {
              x = commands[++cmdIndex];
              y = commands[++cmdIndex];
              currentMatrix.scale(x, y);
              break;
            }
            case Commands.ROTATE: {
              currentMatrix.rotate(commands[++cmdIndex]);
              break;
            }
          }
        }
        renderer.pipelines.postBatch(src);
      };
      module.exports = GraphicsWebGLRenderer;
    }
  });

  // ../../node_modules/phaser/src/renderer/canvas/utils/SetTransform.js
  var require_SetTransform = __commonJS({
    "../../node_modules/phaser/src/renderer/canvas/utils/SetTransform.js": function(exports, module) {
      var GetCalcMatrix = require_GetCalcMatrix();
      var SetTransform = function(renderer, ctx, src, camera, parentMatrix) {
        var alpha = camera.alpha * src.alpha;
        if (alpha <= 0) {
          return false;
        }
        var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
        ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
        ctx.globalAlpha = alpha;
        ctx.save();
        calcMatrix.setToContext(ctx);
        ctx.imageSmoothingEnabled = src.frame ? !src.frame.source.scaleMode : renderer.antialias;
        return true;
      };
      module.exports = SetTransform;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/graphics/GraphicsCanvasRenderer.js
  var require_GraphicsCanvasRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/graphics/GraphicsCanvasRenderer.js": function(exports, module) {
      var Commands = require_Commands();
      var SetTransform = require_SetTransform();
      var GraphicsCanvasRenderer = function(renderer, src, camera, parentMatrix, renderTargetCtx, allowClip) {
        var commandBuffer = src.commandBuffer;
        var commandBufferLength = commandBuffer.length;
        var ctx = renderTargetCtx || renderer.currentContext;
        if (commandBufferLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {
          return;
        }
        camera.addToRenderList(src);
        var lineAlpha = 1;
        var fillAlpha = 1;
        var lineColor = 0;
        var fillColor = 0;
        var lineWidth = 1;
        var red = 0;
        var green = 0;
        var blue = 0;
        ctx.beginPath();
        for (var index = 0; index < commandBufferLength; ++index) {
          var commandID = commandBuffer[index];
          switch (commandID) {
            case Commands.ARC:
              ctx.arc(commandBuffer[index + 1], commandBuffer[index + 2], commandBuffer[index + 3], commandBuffer[index + 4], commandBuffer[index + 5], commandBuffer[index + 6]);
              index += 7;
              break;
            case Commands.LINE_STYLE:
              lineWidth = commandBuffer[index + 1];
              lineColor = commandBuffer[index + 2];
              lineAlpha = commandBuffer[index + 3];
              red = (lineColor & 16711680) >>> 16;
              green = (lineColor & 65280) >>> 8;
              blue = lineColor & 255;
              ctx.strokeStyle = "rgba(" + red + "," + green + "," + blue + "," + lineAlpha + ")";
              ctx.lineWidth = lineWidth;
              index += 3;
              break;
            case Commands.FILL_STYLE:
              fillColor = commandBuffer[index + 1];
              fillAlpha = commandBuffer[index + 2];
              red = (fillColor & 16711680) >>> 16;
              green = (fillColor & 65280) >>> 8;
              blue = fillColor & 255;
              ctx.fillStyle = "rgba(" + red + "," + green + "," + blue + "," + fillAlpha + ")";
              index += 2;
              break;
            case Commands.BEGIN_PATH:
              ctx.beginPath();
              break;
            case Commands.CLOSE_PATH:
              ctx.closePath();
              break;
            case Commands.FILL_PATH:
              if (!allowClip) {
                ctx.fill();
              }
              break;
            case Commands.STROKE_PATH:
              if (!allowClip) {
                ctx.stroke();
              }
              break;
            case Commands.FILL_RECT:
              if (!allowClip) {
                ctx.fillRect(commandBuffer[index + 1], commandBuffer[index + 2], commandBuffer[index + 3], commandBuffer[index + 4]);
              } else {
                ctx.rect(commandBuffer[index + 1], commandBuffer[index + 2], commandBuffer[index + 3], commandBuffer[index + 4]);
              }
              index += 4;
              break;
            case Commands.FILL_TRIANGLE:
              ctx.beginPath();
              ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
              ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
              ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
              ctx.closePath();
              if (!allowClip) {
                ctx.fill();
              }
              index += 6;
              break;
            case Commands.STROKE_TRIANGLE:
              ctx.beginPath();
              ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
              ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
              ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
              ctx.closePath();
              if (!allowClip) {
                ctx.stroke();
              }
              index += 6;
              break;
            case Commands.LINE_TO:
              ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]);
              index += 2;
              break;
            case Commands.MOVE_TO:
              ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
              index += 2;
              break;
            case Commands.LINE_FX_TO:
              ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]);
              index += 5;
              break;
            case Commands.MOVE_FX_TO:
              ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
              index += 5;
              break;
            case Commands.SAVE:
              ctx.save();
              break;
            case Commands.RESTORE:
              ctx.restore();
              break;
            case Commands.TRANSLATE:
              ctx.translate(commandBuffer[index + 1], commandBuffer[index + 2]);
              index += 2;
              break;
            case Commands.SCALE:
              ctx.scale(commandBuffer[index + 1], commandBuffer[index + 2]);
              index += 2;
              break;
            case Commands.ROTATE:
              ctx.rotate(commandBuffer[index + 1]);
              index += 1;
              break;
            case Commands.GRADIENT_FILL_STYLE:
              index += 5;
              break;
            case Commands.GRADIENT_LINE_STYLE:
              index += 6;
              break;
          }
        }
        ctx.restore();
      };
      module.exports = GraphicsCanvasRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/graphics/GraphicsRender.js
  var require_GraphicsRender = __commonJS({
    "../../node_modules/phaser/src/gameobjects/graphics/GraphicsRender.js": function(exports, module) {
      var NOOP = require_NOOP();
      var renderWebGL = NOOP;
      var renderCanvas = NOOP;
      if (true) {
        renderWebGL = require_GraphicsWebGLRenderer();
        renderCanvas = require_GraphicsCanvasRenderer();
      }
      if (true) {
        renderCanvas = require_GraphicsCanvasRenderer();
      }
      module.exports = {
        renderWebGL: renderWebGL,
        renderCanvas: renderCanvas
      };
    }
  });

  // ../../node_modules/phaser/src/gameobjects/graphics/Graphics.js
  var require_Graphics = __commonJS({
    "../../node_modules/phaser/src/gameobjects/graphics/Graphics.js": function(exports, module) {
      var BaseCamera = require_BaseCamera();
      var Class = require_Class();
      var Commands = require_Commands();
      var Components = require_components();
      var Ellipse = require_Ellipse();
      var GameObject = require_GameObject();
      var GetFastValue = require_GetFastValue();
      var GetValue = require_GetValue();
      var MATH_CONST = require_const4();
      var Render = require_GraphicsRender();
      var Graphics = new Class({
        Extends: GameObject,
        Mixins: [
          Components.Alpha,
          Components.BlendMode,
          Components.Depth,
          Components.Mask,
          Components.Pipeline,
          Components.PostPipeline,
          Components.Transform,
          Components.Visible,
          Components.ScrollFactor,
          Render
        ],
        initialize: function Graphics2(scene, options) {
          var x = GetValue(options, "x", 0);
          var y = GetValue(options, "y", 0);
          GameObject.call(this, scene, "Graphics");
          this.setPosition(x, y);
          this.initPipeline();
          this.initPostPipeline();
          this.displayOriginX = 0;
          this.displayOriginY = 0;
          this.commandBuffer = [];
          this.defaultFillColor = -1;
          this.defaultFillAlpha = 1;
          this.defaultStrokeWidth = 1;
          this.defaultStrokeColor = -1;
          this.defaultStrokeAlpha = 1;
          this._lineWidth = 1;
          this.setDefaultStyles(options);
        },
        setDefaultStyles: function(options) {
          if (GetValue(options, "lineStyle", null)) {
            this.defaultStrokeWidth = GetValue(options, "lineStyle.width", 1);
            this.defaultStrokeColor = GetValue(options, "lineStyle.color", 16777215);
            this.defaultStrokeAlpha = GetValue(options, "lineStyle.alpha", 1);
            this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
          }
          if (GetValue(options, "fillStyle", null)) {
            this.defaultFillColor = GetValue(options, "fillStyle.color", 16777215);
            this.defaultFillAlpha = GetValue(options, "fillStyle.alpha", 1);
            this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
          }
          return this;
        },
        lineStyle: function(lineWidth, color, alpha) {
          if (alpha === void 0) {
            alpha = 1;
          }
          this.commandBuffer.push(Commands.LINE_STYLE, lineWidth, color, alpha);
          this._lineWidth = lineWidth;
          return this;
        },
        fillStyle: function(color, alpha) {
          if (alpha === void 0) {
            alpha = 1;
          }
          this.commandBuffer.push(Commands.FILL_STYLE, color, alpha);
          return this;
        },
        fillGradientStyle: function(topLeft, topRight, bottomLeft, bottomRight, alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight) {
          if (alphaTopLeft === void 0) {
            alphaTopLeft = 1;
          }
          if (alphaTopRight === void 0) {
            alphaTopRight = alphaTopLeft;
          }
          if (alphaBottomLeft === void 0) {
            alphaBottomLeft = alphaTopLeft;
          }
          if (alphaBottomRight === void 0) {
            alphaBottomRight = alphaTopLeft;
          }
          this.commandBuffer.push(Commands.GRADIENT_FILL_STYLE, alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight, topLeft, topRight, bottomLeft, bottomRight);
          return this;
        },
        lineGradientStyle: function(lineWidth, topLeft, topRight, bottomLeft, bottomRight, alpha) {
          if (alpha === void 0) {
            alpha = 1;
          }
          this.commandBuffer.push(Commands.GRADIENT_LINE_STYLE, lineWidth, alpha, topLeft, topRight, bottomLeft, bottomRight);
          return this;
        },
        beginPath: function() {
          this.commandBuffer.push(Commands.BEGIN_PATH);
          return this;
        },
        closePath: function() {
          this.commandBuffer.push(Commands.CLOSE_PATH);
          return this;
        },
        fillPath: function() {
          this.commandBuffer.push(Commands.FILL_PATH);
          return this;
        },
        fill: function() {
          this.commandBuffer.push(Commands.FILL_PATH);
          return this;
        },
        strokePath: function() {
          this.commandBuffer.push(Commands.STROKE_PATH);
          return this;
        },
        stroke: function() {
          this.commandBuffer.push(Commands.STROKE_PATH);
          return this;
        },
        fillCircleShape: function(circle) {
          return this.fillCircle(circle.x, circle.y, circle.radius);
        },
        strokeCircleShape: function(circle) {
          return this.strokeCircle(circle.x, circle.y, circle.radius);
        },
        fillCircle: function(x, y, radius) {
          this.beginPath();
          this.arc(x, y, radius, 0, MATH_CONST.PI2);
          this.fillPath();
          return this;
        },
        strokeCircle: function(x, y, radius) {
          this.beginPath();
          this.arc(x, y, radius, 0, MATH_CONST.PI2);
          this.strokePath();
          return this;
        },
        fillRectShape: function(rect) {
          return this.fillRect(rect.x, rect.y, rect.width, rect.height);
        },
        strokeRectShape: function(rect) {
          return this.strokeRect(rect.x, rect.y, rect.width, rect.height);
        },
        fillRect: function(x, y, width, height) {
          this.commandBuffer.push(Commands.FILL_RECT, x, y, width, height);
          return this;
        },
        strokeRect: function(x, y, width, height) {
          var lineWidthHalf = this._lineWidth / 2;
          var minx = x - lineWidthHalf;
          var maxx = x + lineWidthHalf;
          this.beginPath();
          this.moveTo(x, y);
          this.lineTo(x, y + height);
          this.strokePath();
          this.beginPath();
          this.moveTo(x + width, y);
          this.lineTo(x + width, y + height);
          this.strokePath();
          this.beginPath();
          this.moveTo(minx, y);
          this.lineTo(maxx + width, y);
          this.strokePath();
          this.beginPath();
          this.moveTo(minx, y + height);
          this.lineTo(maxx + width, y + height);
          this.strokePath();
          return this;
        },
        fillRoundedRect: function(x, y, width, height, radius) {
          if (radius === void 0) {
            radius = 20;
          }
          var tl = radius;
          var tr = radius;
          var bl = radius;
          var br = radius;
          if (typeof radius !== "number") {
            tl = GetFastValue(radius, "tl", 20);
            tr = GetFastValue(radius, "tr", 20);
            bl = GetFastValue(radius, "bl", 20);
            br = GetFastValue(radius, "br", 20);
          }
          var convexTL = tl >= 0;
          var convexTR = tr >= 0;
          var convexBL = bl >= 0;
          var convexBR = br >= 0;
          tl = Math.abs(tl);
          tr = Math.abs(tr);
          bl = Math.abs(bl);
          br = Math.abs(br);
          this.beginPath();
          this.moveTo(x + tl, y);
          this.lineTo(x + width - tr, y);
          if (convexTR) {
            this.arc(x + width - tr, y + tr, tr, -MATH_CONST.TAU, 0);
          } else {
            this.arc(x + width, y, tr, Math.PI, MATH_CONST.TAU, true);
          }
          this.lineTo(x + width, y + height - br);
          if (convexBR) {
            this.arc(x + width - br, y + height - br, br, 0, MATH_CONST.TAU);
          } else {
            this.arc(x + width, y + height, br, -MATH_CONST.TAU, Math.PI, true);
          }
          this.lineTo(x + bl, y + height);
          if (convexBL) {
            this.arc(x + bl, y + height - bl, bl, MATH_CONST.TAU, Math.PI);
          } else {
            this.arc(x, y + height, bl, 0, -MATH_CONST.TAU, true);
          }
          this.lineTo(x, y + tl);
          if (convexTL) {
            this.arc(x + tl, y + tl, tl, -Math.PI, -MATH_CONST.TAU);
          } else {
            this.arc(x, y, tl, MATH_CONST.TAU, 0, true);
          }
          this.fillPath();
          return this;
        },
        strokeRoundedRect: function(x, y, width, height, radius) {
          if (radius === void 0) {
            radius = 20;
          }
          var tl = radius;
          var tr = radius;
          var bl = radius;
          var br = radius;
          var maxRadius = Math.min(width, height) / 2;
          if (typeof radius !== "number") {
            tl = GetFastValue(radius, "tl", 20);
            tr = GetFastValue(radius, "tr", 20);
            bl = GetFastValue(radius, "bl", 20);
            br = GetFastValue(radius, "br", 20);
          }
          var convexTL = tl >= 0;
          var convexTR = tr >= 0;
          var convexBL = bl >= 0;
          var convexBR = br >= 0;
          tl = Math.min(Math.abs(tl), maxRadius);
          tr = Math.min(Math.abs(tr), maxRadius);
          bl = Math.min(Math.abs(bl), maxRadius);
          br = Math.min(Math.abs(br), maxRadius);
          this.beginPath();
          this.moveTo(x + tl, y);
          this.lineTo(x + width - tr, y);
          this.moveTo(x + width - tr, y);
          if (convexTR) {
            this.arc(x + width - tr, y + tr, tr, -MATH_CONST.TAU, 0);
          } else {
            this.arc(x + width, y, tr, Math.PI, MATH_CONST.TAU, true);
          }
          this.lineTo(x + width, y + height - br);
          this.moveTo(x + width, y + height - br);
          if (convexBR) {
            this.arc(x + width - br, y + height - br, br, 0, MATH_CONST.TAU);
          } else {
            this.arc(x + width, y + height, br, -MATH_CONST.TAU, Math.PI, true);
          }
          this.lineTo(x + bl, y + height);
          this.moveTo(x + bl, y + height);
          if (convexBL) {
            this.arc(x + bl, y + height - bl, bl, MATH_CONST.TAU, Math.PI);
          } else {
            this.arc(x, y + height, bl, 0, -MATH_CONST.TAU, true);
          }
          this.lineTo(x, y + tl);
          this.moveTo(x, y + tl);
          if (convexTL) {
            this.arc(x + tl, y + tl, tl, -Math.PI, -MATH_CONST.TAU);
          } else {
            this.arc(x, y, tl, MATH_CONST.TAU, 0, true);
          }
          this.strokePath();
          return this;
        },
        fillPointShape: function(point, size) {
          return this.fillPoint(point.x, point.y, size);
        },
        fillPoint: function(x, y, size) {
          if (!size || size < 1) {
            size = 1;
          } else {
            x -= size / 2;
            y -= size / 2;
          }
          this.commandBuffer.push(Commands.FILL_RECT, x, y, size, size);
          return this;
        },
        fillTriangleShape: function(triangle) {
          return this.fillTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
        },
        strokeTriangleShape: function(triangle) {
          return this.strokeTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
        },
        fillTriangle: function(x0, y0, x1, y1, x2, y2) {
          this.commandBuffer.push(Commands.FILL_TRIANGLE, x0, y0, x1, y1, x2, y2);
          return this;
        },
        strokeTriangle: function(x0, y0, x1, y1, x2, y2) {
          this.commandBuffer.push(Commands.STROKE_TRIANGLE, x0, y0, x1, y1, x2, y2);
          return this;
        },
        strokeLineShape: function(line) {
          return this.lineBetween(line.x1, line.y1, line.x2, line.y2);
        },
        lineBetween: function(x1, y1, x2, y2) {
          this.beginPath();
          this.moveTo(x1, y1);
          this.lineTo(x2, y2);
          this.strokePath();
          return this;
        },
        lineTo: function(x, y) {
          this.commandBuffer.push(Commands.LINE_TO, x, y);
          return this;
        },
        moveTo: function(x, y) {
          this.commandBuffer.push(Commands.MOVE_TO, x, y);
          return this;
        },
        strokePoints: function(points, closeShape, closePath, endIndex) {
          if (closeShape === void 0) {
            closeShape = false;
          }
          if (closePath === void 0) {
            closePath = false;
          }
          if (endIndex === void 0) {
            endIndex = points.length;
          }
          this.beginPath();
          this.moveTo(points[0].x, points[0].y);
          for (var i = 1; i < endIndex; i++) {
            this.lineTo(points[i].x, points[i].y);
          }
          if (closeShape) {
            this.lineTo(points[0].x, points[0].y);
          }
          if (closePath) {
            this.closePath();
          }
          this.strokePath();
          return this;
        },
        fillPoints: function(points, closeShape, closePath, endIndex) {
          if (closeShape === void 0) {
            closeShape = false;
          }
          if (closePath === void 0) {
            closePath = false;
          }
          if (endIndex === void 0) {
            endIndex = points.length;
          }
          this.beginPath();
          this.moveTo(points[0].x, points[0].y);
          for (var i = 1; i < endIndex; i++) {
            this.lineTo(points[i].x, points[i].y);
          }
          if (closeShape) {
            this.lineTo(points[0].x, points[0].y);
          }
          if (closePath) {
            this.closePath();
          }
          this.fillPath();
          return this;
        },
        strokeEllipseShape: function(ellipse, smoothness) {
          if (smoothness === void 0) {
            smoothness = 32;
          }
          var points = ellipse.getPoints(smoothness);
          return this.strokePoints(points, true);
        },
        strokeEllipse: function(x, y, width, height, smoothness) {
          if (smoothness === void 0) {
            smoothness = 32;
          }
          var ellipse = new Ellipse(x, y, width, height);
          var points = ellipse.getPoints(smoothness);
          return this.strokePoints(points, true);
        },
        fillEllipseShape: function(ellipse, smoothness) {
          if (smoothness === void 0) {
            smoothness = 32;
          }
          var points = ellipse.getPoints(smoothness);
          return this.fillPoints(points, true);
        },
        fillEllipse: function(x, y, width, height, smoothness) {
          if (smoothness === void 0) {
            smoothness = 32;
          }
          var ellipse = new Ellipse(x, y, width, height);
          var points = ellipse.getPoints(smoothness);
          return this.fillPoints(points, true);
        },
        arc: function(x, y, radius, startAngle, endAngle, anticlockwise, overshoot) {
          if (anticlockwise === void 0) {
            anticlockwise = false;
          }
          if (overshoot === void 0) {
            overshoot = 0;
          }
          this.commandBuffer.push(Commands.ARC, x, y, radius, startAngle, endAngle, anticlockwise, overshoot);
          return this;
        },
        slice: function(x, y, radius, startAngle, endAngle, anticlockwise, overshoot) {
          if (anticlockwise === void 0) {
            anticlockwise = false;
          }
          if (overshoot === void 0) {
            overshoot = 0;
          }
          this.commandBuffer.push(Commands.BEGIN_PATH);
          this.commandBuffer.push(Commands.MOVE_TO, x, y);
          this.commandBuffer.push(Commands.ARC, x, y, radius, startAngle, endAngle, anticlockwise, overshoot);
          this.commandBuffer.push(Commands.CLOSE_PATH);
          return this;
        },
        save: function() {
          this.commandBuffer.push(Commands.SAVE);
          return this;
        },
        restore: function() {
          this.commandBuffer.push(Commands.RESTORE);
          return this;
        },
        translateCanvas: function(x, y) {
          this.commandBuffer.push(Commands.TRANSLATE, x, y);
          return this;
        },
        scaleCanvas: function(x, y) {
          this.commandBuffer.push(Commands.SCALE, x, y);
          return this;
        },
        rotateCanvas: function(radians) {
          this.commandBuffer.push(Commands.ROTATE, radians);
          return this;
        },
        clear: function() {
          this.commandBuffer.length = 0;
          if (this.defaultFillColor > -1) {
            this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
          }
          if (this.defaultStrokeColor > -1) {
            this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
          }
          return this;
        },
        generateTexture: function(key, width, height) {
          var sys = this.scene.sys;
          var renderer = sys.game.renderer;
          if (width === void 0) {
            width = sys.scale.width;
          }
          if (height === void 0) {
            height = sys.scale.height;
          }
          Graphics.TargetCamera.setScene(this.scene);
          Graphics.TargetCamera.setViewport(0, 0, width, height);
          Graphics.TargetCamera.scrollX = this.x;
          Graphics.TargetCamera.scrollY = this.y;
          var texture;
          var ctx;
          if (typeof key === "string") {
            if (sys.textures.exists(key)) {
              texture = sys.textures.get(key);
              var src = texture.getSourceImage();
              if (src instanceof HTMLCanvasElement) {
                ctx = src.getContext("2d");
              }
            } else {
              texture = sys.textures.createCanvas(key, width, height);
              ctx = texture.getSourceImage().getContext("2d");
            }
          } else if (key instanceof HTMLCanvasElement) {
            ctx = key.getContext("2d");
          }
          if (ctx) {
            this.renderCanvas(renderer, this, Graphics.TargetCamera, null, ctx, false);
            if (texture) {
              texture.refresh();
            }
          }
          return this;
        },
        preDestroy: function() {
          this.commandBuffer = [];
        }
      });
      Graphics.TargetCamera = new BaseCamera();
      module.exports = Graphics;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/Shape.js
  var require_Shape = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/Shape.js": function(exports, module) {
      var Class = require_Class();
      var Components = require_components();
      var GameObject = require_GameObject();
      var Line = require_Line();
      var Shape = new Class({
        Extends: GameObject,
        Mixins: [
          Components.AlphaSingle,
          Components.BlendMode,
          Components.Depth,
          Components.GetBounds,
          Components.FX,
          Components.Mask,
          Components.Origin,
          Components.Pipeline,
          Components.PostPipeline,
          Components.ScrollFactor,
          Components.Transform,
          Components.Visible
        ],
        initialize: function Shape2(scene, type, data) {
          if (type === void 0) {
            type = "Shape";
          }
          GameObject.call(this, scene, type);
          this.geom = data;
          this.pathData = [];
          this.pathIndexes = [];
          this.fillColor = 16777215;
          this.fillAlpha = 1;
          this.strokeColor = 16777215;
          this.strokeAlpha = 1;
          this.lineWidth = 1;
          this.isFilled = false;
          this.isStroked = false;
          this.closePath = true;
          this._tempLine = new Line();
          this.width = 0;
          this.height = 0;
          this.initPipeline();
          this.initPostPipeline();
        },
        setFillStyle: function(color, alpha) {
          if (alpha === void 0) {
            alpha = 1;
          }
          if (color === void 0) {
            this.isFilled = false;
          } else {
            this.fillColor = color;
            this.fillAlpha = alpha;
            this.isFilled = true;
          }
          return this;
        },
        setStrokeStyle: function(lineWidth, color, alpha) {
          if (alpha === void 0) {
            alpha = 1;
          }
          if (lineWidth === void 0) {
            this.isStroked = false;
          } else {
            this.lineWidth = lineWidth;
            this.strokeColor = color;
            this.strokeAlpha = alpha;
            this.isStroked = true;
          }
          return this;
        },
        setClosePath: function(value) {
          this.closePath = value;
          return this;
        },
        setSize: function(width, height) {
          this.width = width;
          this.height = height;
          return this;
        },
        setDisplaySize: function(width, height) {
          this.displayWidth = width;
          this.displayHeight = height;
          return this;
        },
        preDestroy: function() {
          this.geom = null;
          this._tempLine = null;
          this.pathData = [];
          this.pathIndexes = [];
        },
        displayWidth: {
          get: function() {
            return this.scaleX * this.width;
          },
          set: function(value) {
            this.scaleX = value / this.width;
          }
        },
        displayHeight: {
          get: function() {
            return this.scaleY * this.height;
          },
          set: function(value) {
            this.scaleY = value / this.height;
          }
        }
      });
      module.exports = Shape;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/FillPathWebGL.js
  var require_FillPathWebGL = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/FillPathWebGL.js": function(exports, module) {
      var Utils = require_Utils();
      var FillPathWebGL = function(pipeline, calcMatrix, src, alpha, dx, dy) {
        var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
        var path = src.pathData;
        var pathIndexes = src.pathIndexes;
        for (var i = 0; i < pathIndexes.length; i += 3) {
          var p0 = pathIndexes[i] * 2;
          var p1 = pathIndexes[i + 1] * 2;
          var p2 = pathIndexes[i + 2] * 2;
          var x0 = path[p0 + 0] - dx;
          var y0 = path[p0 + 1] - dy;
          var x1 = path[p1 + 0] - dx;
          var y1 = path[p1 + 1] - dy;
          var x2 = path[p2 + 0] - dx;
          var y2 = path[p2 + 1] - dy;
          var tx0 = calcMatrix.getX(x0, y0);
          var ty0 = calcMatrix.getY(x0, y0);
          var tx1 = calcMatrix.getX(x1, y1);
          var ty1 = calcMatrix.getY(x1, y1);
          var tx2 = calcMatrix.getX(x2, y2);
          var ty2 = calcMatrix.getY(x2, y2);
          pipeline.batchTri(src, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, fillTintColor, fillTintColor, fillTintColor, 2);
        }
      };
      module.exports = FillPathWebGL;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/StrokePathWebGL.js
  var require_StrokePathWebGL = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/StrokePathWebGL.js": function(exports, module) {
      var Utils = require_Utils();
      var StrokePathWebGL = function(pipeline, src, alpha, dx, dy) {
        var strokeTint = pipeline.strokeTint;
        var strokeTintColor = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);
        strokeTint.TL = strokeTintColor;
        strokeTint.TR = strokeTintColor;
        strokeTint.BL = strokeTintColor;
        strokeTint.BR = strokeTintColor;
        var path = src.pathData;
        var pathLength = path.length - 1;
        var lineWidth = src.lineWidth;
        var halfLineWidth = lineWidth / 2;
        var px1 = path[0] - dx;
        var py1 = path[1] - dy;
        if (!src.closePath) {
          pathLength -= 2;
        }
        for (var i = 2; i < pathLength; i += 2) {
          var px2 = path[i] - dx;
          var py2 = path[i + 1] - dy;
          pipeline.batchLine(px1, py1, px2, py2, halfLineWidth, halfLineWidth, lineWidth, i - 2, src.closePath ? i === pathLength - 1 : false);
          px1 = px2;
          py1 = py2;
        }
      };
      module.exports = StrokePathWebGL;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/ellipse/EllipseWebGLRenderer.js
  var require_EllipseWebGLRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/ellipse/EllipseWebGLRenderer.js": function(exports, module) {
      var FillPathWebGL = require_FillPathWebGL();
      var GetCalcMatrix = require_GetCalcMatrix();
      var StrokePathWebGL = require_StrokePathWebGL();
      var EllipseWebGLRenderer = function(renderer, src, camera, parentMatrix) {
        camera.addToRenderList(src);
        var pipeline = renderer.pipelines.set(src.pipeline);
        var result = GetCalcMatrix(src, camera, parentMatrix);
        var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
        var dx = src._displayOriginX;
        var dy = src._displayOriginY;
        var alpha = camera.alpha * src.alpha;
        renderer.pipelines.preBatch(src);
        if (src.isFilled) {
          FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
        }
        if (src.isStroked) {
          StrokePathWebGL(pipeline, src, alpha, dx, dy);
        }
        renderer.pipelines.postBatch(src);
      };
      module.exports = EllipseWebGLRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/FillStyleCanvas.js
  var require_FillStyleCanvas = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/FillStyleCanvas.js": function(exports, module) {
      var FillStyleCanvas = function(ctx, src, altColor, altAlpha) {
        var fillColor = altColor ? altColor : src.fillColor;
        var fillAlpha = altAlpha ? altAlpha : src.fillAlpha;
        var red = (fillColor & 16711680) >>> 16;
        var green = (fillColor & 65280) >>> 8;
        var blue = fillColor & 255;
        ctx.fillStyle = "rgba(" + red + "," + green + "," + blue + "," + fillAlpha + ")";
      };
      module.exports = FillStyleCanvas;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/LineStyleCanvas.js
  var require_LineStyleCanvas = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/LineStyleCanvas.js": function(exports, module) {
      var LineStyleCanvas = function(ctx, src, altColor, altAlpha) {
        var strokeColor = altColor ? altColor : src.strokeColor;
        var strokeAlpha = altAlpha ? altAlpha : src.strokeAlpha;
        var red = (strokeColor & 16711680) >>> 16;
        var green = (strokeColor & 65280) >>> 8;
        var blue = strokeColor & 255;
        ctx.strokeStyle = "rgba(" + red + "," + green + "," + blue + "," + strokeAlpha + ")";
        ctx.lineWidth = src.lineWidth;
      };
      module.exports = LineStyleCanvas;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/ellipse/EllipseCanvasRenderer.js
  var require_EllipseCanvasRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/ellipse/EllipseCanvasRenderer.js": function(exports, module) {
      var FillStyleCanvas = require_FillStyleCanvas();
      var LineStyleCanvas = require_LineStyleCanvas();
      var SetTransform = require_SetTransform();
      var EllipseCanvasRenderer = function(renderer, src, camera, parentMatrix) {
        camera.addToRenderList(src);
        var ctx = renderer.currentContext;
        if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
          var dx = src._displayOriginX;
          var dy = src._displayOriginY;
          var path = src.pathData;
          var pathLength = path.length - 1;
          var px1 = path[0] - dx;
          var py1 = path[1] - dy;
          ctx.beginPath();
          ctx.moveTo(px1, py1);
          if (!src.closePath) {
            pathLength -= 2;
          }
          for (var i = 2; i < pathLength; i += 2) {
            var px2 = path[i] - dx;
            var py2 = path[i + 1] - dy;
            ctx.lineTo(px2, py2);
          }
          ctx.closePath();
          if (src.isFilled) {
            FillStyleCanvas(ctx, src);
            ctx.fill();
          }
          if (src.isStroked) {
            LineStyleCanvas(ctx, src);
            ctx.stroke();
          }
          ctx.restore();
        }
      };
      module.exports = EllipseCanvasRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/ellipse/EllipseRender.js
  var require_EllipseRender = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/ellipse/EllipseRender.js": function(exports, module) {
      var NOOP = require_NOOP();
      var renderWebGL = NOOP;
      var renderCanvas = NOOP;
      if (true) {
        renderWebGL = require_EllipseWebGLRenderer();
      }
      if (true) {
        renderCanvas = require_EllipseCanvasRenderer();
      }
      module.exports = {
        renderWebGL: renderWebGL,
        renderCanvas: renderCanvas
      };
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/ellipse/Ellipse.js
  var require_Ellipse2 = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/ellipse/Ellipse.js": function(exports, module) {
      var Class = require_Class();
      var Earcut = require_Earcut();
      var EllipseRender = require_EllipseRender();
      var GeomEllipse = require_Ellipse();
      var Shape = require_Shape();
      var Ellipse = new Class({
        Extends: Shape,
        Mixins: [
          EllipseRender
        ],
        initialize: function Ellipse2(scene, x, y, width, height, fillColor, fillAlpha) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (width === void 0) {
            width = 128;
          }
          if (height === void 0) {
            height = 128;
          }
          Shape.call(this, scene, "Ellipse", new GeomEllipse(width / 2, height / 2, width, height));
          this._smoothness = 64;
          this.setPosition(x, y);
          this.width = width;
          this.height = height;
          if (fillColor !== void 0) {
            this.setFillStyle(fillColor, fillAlpha);
          }
          this.updateDisplayOrigin();
          this.updateData();
        },
        smoothness: {
          get: function() {
            return this._smoothness;
          },
          set: function(value) {
            this._smoothness = value;
            this.updateData();
          }
        },
        setSize: function(width, height) {
          this.width = width;
          this.height = height;
          this.geom.setPosition(width / 2, height / 2);
          this.geom.setSize(width, height);
          return this.updateData();
        },
        setSmoothness: function(value) {
          this._smoothness = value;
          return this.updateData();
        },
        updateData: function() {
          var path = [];
          var points = this.geom.getPoints(this._smoothness);
          for (var i = 0; i < points.length; i++) {
            path.push(points[i].x, points[i].y);
          }
          path.push(points[0].x, points[0].y);
          this.pathIndexes = Earcut(path);
          this.pathData = path;
          return this;
        }
      });
      module.exports = Ellipse;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/line/LineWebGLRenderer.js
  var require_LineWebGLRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/line/LineWebGLRenderer.js": function(exports, module) {
      var GetCalcMatrix = require_GetCalcMatrix();
      var Utils = require_Utils();
      var LineWebGLRenderer = function(renderer, src, camera, parentMatrix) {
        camera.addToRenderList(src);
        var pipeline = renderer.pipelines.set(src.pipeline);
        var result = GetCalcMatrix(src, camera, parentMatrix);
        pipeline.calcMatrix.copyFrom(result.calc);
        var dx = src._displayOriginX;
        var dy = src._displayOriginY;
        var alpha = camera.alpha * src.alpha;
        renderer.pipelines.preBatch(src);
        if (src.isStroked) {
          var strokeTint = pipeline.strokeTint;
          var color = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);
          strokeTint.TL = color;
          strokeTint.TR = color;
          strokeTint.BL = color;
          strokeTint.BR = color;
          var startWidth = src._startWidth;
          var endWidth = src._endWidth;
          pipeline.batchLine(src.geom.x1 - dx, src.geom.y1 - dy, src.geom.x2 - dx, src.geom.y2 - dy, startWidth, endWidth, 1, 0, false, result.sprite, result.camera);
        }
        renderer.pipelines.postBatch(src);
      };
      module.exports = LineWebGLRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/line/LineCanvasRenderer.js
  var require_LineCanvasRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/line/LineCanvasRenderer.js": function(exports, module) {
      var LineStyleCanvas = require_LineStyleCanvas();
      var SetTransform = require_SetTransform();
      var LineCanvasRenderer = function(renderer, src, camera, parentMatrix) {
        camera.addToRenderList(src);
        var ctx = renderer.currentContext;
        if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
          var dx = src._displayOriginX;
          var dy = src._displayOriginY;
          if (src.isStroked) {
            LineStyleCanvas(ctx, src);
            ctx.beginPath();
            ctx.moveTo(src.geom.x1 - dx, src.geom.y1 - dy);
            ctx.lineTo(src.geom.x2 - dx, src.geom.y2 - dy);
            ctx.stroke();
          }
          ctx.restore();
        }
      };
      module.exports = LineCanvasRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/line/LineRender.js
  var require_LineRender = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/line/LineRender.js": function(exports, module) {
      var NOOP = require_NOOP();
      var renderWebGL = NOOP;
      var renderCanvas = NOOP;
      if (true) {
        renderWebGL = require_LineWebGLRenderer();
      }
      if (true) {
        renderCanvas = require_LineCanvasRenderer();
      }
      module.exports = {
        renderWebGL: renderWebGL,
        renderCanvas: renderCanvas
      };
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/line/Line.js
  var require_Line2 = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/line/Line.js": function(exports, module) {
      var Class = require_Class();
      var Shape = require_Shape();
      var GeomLine = require_Line();
      var LineRender = require_LineRender();
      var Line = new Class({
        Extends: Shape,
        Mixins: [
          LineRender
        ],
        initialize: function Line2(scene, x, y, x1, y1, x2, y2, strokeColor, strokeAlpha) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (x1 === void 0) {
            x1 = 0;
          }
          if (y1 === void 0) {
            y1 = 0;
          }
          if (x2 === void 0) {
            x2 = 128;
          }
          if (y2 === void 0) {
            y2 = 0;
          }
          Shape.call(this, scene, "Line", new GeomLine(x1, y1, x2, y2));
          var width = Math.max(1, this.geom.right - this.geom.left);
          var height = Math.max(1, this.geom.bottom - this.geom.top);
          this.lineWidth = 1;
          this._startWidth = 1;
          this._endWidth = 1;
          this.setPosition(x, y);
          this.setSize(width, height);
          if (strokeColor !== void 0) {
            this.setStrokeStyle(1, strokeColor, strokeAlpha);
          }
          this.updateDisplayOrigin();
        },
        setLineWidth: function(startWidth, endWidth) {
          if (endWidth === void 0) {
            endWidth = startWidth;
          }
          this._startWidth = startWidth;
          this._endWidth = endWidth;
          this.lineWidth = startWidth;
          return this;
        },
        setTo: function(x1, y1, x2, y2) {
          this.geom.setTo(x1, y1, x2, y2);
          return this;
        }
      });
      module.exports = Line;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/rectangle/RectangleWebGLRenderer.js
  var require_RectangleWebGLRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/rectangle/RectangleWebGLRenderer.js": function(exports, module) {
      var GetCalcMatrix = require_GetCalcMatrix();
      var StrokePathWebGL = require_StrokePathWebGL();
      var Utils = require_Utils();
      var RectangleWebGLRenderer = function(renderer, src, camera, parentMatrix) {
        camera.addToRenderList(src);
        var pipeline = renderer.pipelines.set(src.pipeline);
        var result = GetCalcMatrix(src, camera, parentMatrix);
        pipeline.calcMatrix.copyFrom(result.calc);
        var dx = src._displayOriginX;
        var dy = src._displayOriginY;
        var alpha = camera.alpha * src.alpha;
        renderer.pipelines.preBatch(src);
        if (src.isFilled) {
          var fillTint = pipeline.fillTint;
          var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
          fillTint.TL = fillTintColor;
          fillTint.TR = fillTintColor;
          fillTint.BL = fillTintColor;
          fillTint.BR = fillTintColor;
          pipeline.batchFillRect(-dx, -dy, src.width, src.height);
        }
        if (src.isStroked) {
          StrokePathWebGL(pipeline, src, alpha, dx, dy);
        }
        renderer.pipelines.postBatch(src);
      };
      module.exports = RectangleWebGLRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/rectangle/RectangleCanvasRenderer.js
  var require_RectangleCanvasRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/rectangle/RectangleCanvasRenderer.js": function(exports, module) {
      var FillStyleCanvas = require_FillStyleCanvas();
      var LineStyleCanvas = require_LineStyleCanvas();
      var SetTransform = require_SetTransform();
      var RectangleCanvasRenderer = function(renderer, src, camera, parentMatrix) {
        camera.addToRenderList(src);
        var ctx = renderer.currentContext;
        if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
          var dx = src._displayOriginX;
          var dy = src._displayOriginY;
          if (src.isFilled) {
            FillStyleCanvas(ctx, src);
            ctx.fillRect(-dx, -dy, src.width, src.height);
          }
          if (src.isStroked) {
            LineStyleCanvas(ctx, src);
            ctx.beginPath();
            ctx.rect(-dx, -dy, src.width, src.height);
            ctx.stroke();
          }
          ctx.restore();
        }
      };
      module.exports = RectangleCanvasRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/rectangle/RectangleRender.js
  var require_RectangleRender = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/rectangle/RectangleRender.js": function(exports, module) {
      var NOOP = require_NOOP();
      var renderWebGL = NOOP;
      var renderCanvas = NOOP;
      if (true) {
        renderWebGL = require_RectangleWebGLRenderer();
      }
      if (true) {
        renderCanvas = require_RectangleCanvasRenderer();
      }
      module.exports = {
        renderWebGL: renderWebGL,
        renderCanvas: renderCanvas
      };
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/rectangle/Rectangle.js
  var require_Rectangle2 = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/rectangle/Rectangle.js": function(exports, module) {
      var Class = require_Class();
      var GeomRectangle = require_Rectangle();
      var Shape = require_Shape();
      var RectangleRender = require_RectangleRender();
      var Rectangle = new Class({
        Extends: Shape,
        Mixins: [
          RectangleRender
        ],
        initialize: function Rectangle2(scene, x, y, width, height, fillColor, fillAlpha) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (width === void 0) {
            width = 128;
          }
          if (height === void 0) {
            height = 128;
          }
          Shape.call(this, scene, "Rectangle", new GeomRectangle(0, 0, width, height));
          this.setPosition(x, y);
          this.setSize(width, height);
          if (fillColor !== void 0) {
            this.setFillStyle(fillColor, fillAlpha);
          }
          this.updateDisplayOrigin();
          this.updateData();
        },
        setSize: function(width, height) {
          this.width = width;
          this.height = height;
          this.geom.setSize(width, height);
          this.updateData();
          this.updateDisplayOrigin();
          var input = this.input;
          if (input && !input.customHitArea) {
            input.hitArea.width = width;
            input.hitArea.height = height;
          }
          return this;
        },
        updateData: function() {
          var path = [];
          var rect = this.geom;
          var line = this._tempLine;
          rect.getLineA(line);
          path.push(line.x1, line.y1, line.x2, line.y2);
          rect.getLineB(line);
          path.push(line.x2, line.y2);
          rect.getLineC(line);
          path.push(line.x2, line.y2);
          rect.getLineD(line);
          path.push(line.x2, line.y2);
          this.pathData = path;
          return this;
        }
      });
      module.exports = Rectangle;
    }
  });

  // ../../node_modules/phaser/src/actions/AlignTo.js
  var require_AlignTo = __commonJS({
    "../../node_modules/phaser/src/actions/AlignTo.js": function(exports, module) {
      var QuickSet = require_QuickSet2();
      var AlignTo = function(items, position, offsetX, offsetY) {
        var target = items[0];
        for (var i = 1; i < items.length; i++) {
          var item = items[i];
          QuickSet(item, target, position, offsetX, offsetY);
          target = item;
        }
        return items;
      };
      module.exports = AlignTo;
    }
  });

  // ../../node_modules/phaser/src/actions/PropertyValueInc.js
  var require_PropertyValueInc = __commonJS({
    "../../node_modules/phaser/src/actions/PropertyValueInc.js": function(exports, module) {
      var PropertyValueInc = function(items, key, value, step, index, direction) {
        if (step === void 0) {
          step = 0;
        }
        if (index === void 0) {
          index = 0;
        }
        if (direction === void 0) {
          direction = 1;
        }
        var i;
        var t = 0;
        var end = items.length;
        if (direction === 1) {
          for (i = index; i < end; i++) {
            items[i][key] += value + t * step;
            t++;
          }
        } else {
          for (i = index; i >= 0; i--) {
            items[i][key] += value + t * step;
            t++;
          }
        }
        return items;
      };
      module.exports = PropertyValueInc;
    }
  });

  // ../../node_modules/phaser/src/actions/Angle.js
  var require_Angle = __commonJS({
    "../../node_modules/phaser/src/actions/Angle.js": function(exports, module) {
      var PropertyValueInc = require_PropertyValueInc();
      var Angle = function(items, value, step, index, direction) {
        return PropertyValueInc(items, "angle", value, step, index, direction);
      };
      module.exports = Angle;
    }
  });

  // ../../node_modules/phaser/src/actions/Call.js
  var require_Call = __commonJS({
    "../../node_modules/phaser/src/actions/Call.js": function(exports, module) {
      var Call = function(items, callback, context) {
        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          callback.call(context, item);
        }
        return items;
      };
      module.exports = Call;
    }
  });

  // ../../node_modules/phaser/src/actions/GetFirst.js
  var require_GetFirst2 = __commonJS({
    "../../node_modules/phaser/src/actions/GetFirst.js": function(exports, module) {
      var GetFirst = function(items, compare, index) {
        if (index === void 0) {
          index = 0;
        }
        for (var i = index; i < items.length; i++) {
          var item = items[i];
          var match = true;
          for (var property in compare) {
            if (item[property] !== compare[property]) {
              match = false;
            }
          }
          if (match) {
            return item;
          }
        }
        return null;
      };
      module.exports = GetFirst;
    }
  });

  // ../../node_modules/phaser/src/actions/GetLast.js
  var require_GetLast = __commonJS({
    "../../node_modules/phaser/src/actions/GetLast.js": function(exports, module) {
      var GetLast = function(items, compare, index) {
        if (index === void 0) {
          index = 0;
        }
        for (var i = index; i < items.length; i++) {
          var item = items[i];
          var match = true;
          for (var property in compare) {
            if (item[property] !== compare[property]) {
              match = false;
            }
          }
          if (match) {
            return item;
          }
        }
        return null;
      };
      module.exports = GetLast;
    }
  });

  // ../../node_modules/phaser/src/actions/IncAlpha.js
  var require_IncAlpha = __commonJS({
    "../../node_modules/phaser/src/actions/IncAlpha.js": function(exports, module) {
      var PropertyValueInc = require_PropertyValueInc();
      var IncAlpha = function(items, value, step, index, direction) {
        return PropertyValueInc(items, "alpha", value, step, index, direction);
      };
      module.exports = IncAlpha;
    }
  });

  // ../../node_modules/phaser/src/actions/IncX.js
  var require_IncX = __commonJS({
    "../../node_modules/phaser/src/actions/IncX.js": function(exports, module) {
      var PropertyValueInc = require_PropertyValueInc();
      var IncX = function(items, value, step, index, direction) {
        return PropertyValueInc(items, "x", value, step, index, direction);
      };
      module.exports = IncX;
    }
  });

  // ../../node_modules/phaser/src/actions/IncXY.js
  var require_IncXY = __commonJS({
    "../../node_modules/phaser/src/actions/IncXY.js": function(exports, module) {
      var PropertyValueInc = require_PropertyValueInc();
      var IncXY = function(items, x, y, stepX, stepY, index, direction) {
        if (y === void 0 || y === null) {
          y = x;
        }
        PropertyValueInc(items, "x", x, stepX, index, direction);
        return PropertyValueInc(items, "y", y, stepY, index, direction);
      };
      module.exports = IncXY;
    }
  });

  // ../../node_modules/phaser/src/actions/IncY.js
  var require_IncY = __commonJS({
    "../../node_modules/phaser/src/actions/IncY.js": function(exports, module) {
      var PropertyValueInc = require_PropertyValueInc();
      var IncY = function(items, value, step, index, direction) {
        return PropertyValueInc(items, "y", value, step, index, direction);
      };
      module.exports = IncY;
    }
  });

  // ../../node_modules/phaser/src/actions/PlaceOnCircle.js
  var require_PlaceOnCircle = __commonJS({
    "../../node_modules/phaser/src/actions/PlaceOnCircle.js": function(exports, module) {
      var PlaceOnCircle = function(items, circle, startAngle, endAngle) {
        if (startAngle === void 0) {
          startAngle = 0;
        }
        if (endAngle === void 0) {
          endAngle = 6.28;
        }
        var angle = startAngle;
        var angleStep = (endAngle - startAngle) / items.length;
        var cx = circle.x;
        var cy = circle.y;
        var radius = circle.radius;
        for (var i = 0; i < items.length; i++) {
          items[i].x = cx + radius * Math.cos(angle);
          items[i].y = cy + radius * Math.sin(angle);
          angle += angleStep;
        }
        return items;
      };
      module.exports = PlaceOnCircle;
    }
  });

  // ../../node_modules/phaser/src/actions/PlaceOnEllipse.js
  var require_PlaceOnEllipse = __commonJS({
    "../../node_modules/phaser/src/actions/PlaceOnEllipse.js": function(exports, module) {
      var PlaceOnEllipse = function(items, ellipse, startAngle, endAngle) {
        if (startAngle === void 0) {
          startAngle = 0;
        }
        if (endAngle === void 0) {
          endAngle = 6.28;
        }
        var angle = startAngle;
        var angleStep = (endAngle - startAngle) / items.length;
        var a = ellipse.width / 2;
        var b = ellipse.height / 2;
        for (var i = 0; i < items.length; i++) {
          items[i].x = ellipse.x + a * Math.cos(angle);
          items[i].y = ellipse.y + b * Math.sin(angle);
          angle += angleStep;
        }
        return items;
      };
      module.exports = PlaceOnEllipse;
    }
  });

  // ../../node_modules/phaser/src/actions/PlaceOnLine.js
  var require_PlaceOnLine = __commonJS({
    "../../node_modules/phaser/src/actions/PlaceOnLine.js": function(exports, module) {
      var GetPoints = require_GetPoints3();
      var PlaceOnLine = function(items, line) {
        var points = GetPoints(line, items.length);
        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          var point = points[i];
          item.x = point.x;
          item.y = point.y;
        }
        return items;
      };
      module.exports = PlaceOnLine;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/MarchingAnts.js
  var require_MarchingAnts = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/MarchingAnts.js": function(exports, module) {
      var Perimeter = require_Perimeter();
      var Point = require_Point();
      var MarchingAnts = function(rect, step, quantity, out) {
        if (out === void 0) {
          out = [];
        }
        if (!step && !quantity) {
          return out;
        }
        if (!step) {
          step = Perimeter(rect) / quantity;
        } else {
          quantity = Math.round(Perimeter(rect) / step);
        }
        var x = rect.x;
        var y = rect.y;
        var face = 0;
        for (var i = 0; i < quantity; i++) {
          out.push(new Point(x, y));
          switch (face) {
            case 0:
              x += step;
              if (x >= rect.right) {
                face = 1;
                y += x - rect.right;
                x = rect.right;
              }
              break;
            case 1:
              y += step;
              if (y >= rect.bottom) {
                face = 2;
                x -= y - rect.bottom;
                y = rect.bottom;
              }
              break;
            case 2:
              x -= step;
              if (x <= rect.left) {
                face = 3;
                y -= rect.left - x;
                x = rect.left;
              }
              break;
            case 3:
              y -= step;
              if (y <= rect.top) {
                face = 0;
                y = rect.top;
              }
              break;
          }
        }
        return out;
      };
      module.exports = MarchingAnts;
    }
  });

  // ../../node_modules/phaser/src/actions/PlaceOnRectangle.js
  var require_PlaceOnRectangle = __commonJS({
    "../../node_modules/phaser/src/actions/PlaceOnRectangle.js": function(exports, module) {
      var MarchingAnts = require_MarchingAnts();
      var RotateLeft = require_RotateLeft2();
      var RotateRight = require_RotateRight2();
      var PlaceOnRectangle = function(items, rect, shift) {
        if (shift === void 0) {
          shift = 0;
        }
        var points = MarchingAnts(rect, false, items.length);
        if (shift > 0) {
          RotateLeft(points, shift);
        } else if (shift < 0) {
          RotateRight(points, Math.abs(shift));
        }
        for (var i = 0; i < items.length; i++) {
          items[i].x = points[i].x;
          items[i].y = points[i].y;
        }
        return items;
      };
      module.exports = PlaceOnRectangle;
    }
  });

  // ../../node_modules/phaser/src/geom/line/BresenhamPoints.js
  var require_BresenhamPoints = __commonJS({
    "../../node_modules/phaser/src/geom/line/BresenhamPoints.js": function(exports, module) {
      var BresenhamPoints = function(line, stepRate, results) {
        if (stepRate === void 0) {
          stepRate = 1;
        }
        if (results === void 0) {
          results = [];
        }
        var x1 = Math.round(line.x1);
        var y1 = Math.round(line.y1);
        var x2 = Math.round(line.x2);
        var y2 = Math.round(line.y2);
        var dx = Math.abs(x2 - x1);
        var dy = Math.abs(y2 - y1);
        var sx = x1 < x2 ? 1 : -1;
        var sy = y1 < y2 ? 1 : -1;
        var err = dx - dy;
        results.push({ x: x1, y: y1 });
        var i = 1;
        while (!(x1 === x2 && y1 === y2)) {
          var e2 = err << 1;
          if (e2 > -dy) {
            err -= dy;
            x1 += sx;
          }
          if (e2 < dx) {
            err += dx;
            y1 += sy;
          }
          if (i % stepRate === 0) {
            results.push({ x: x1, y: y1 });
          }
          i++;
        }
        return results;
      };
      module.exports = BresenhamPoints;
    }
  });

  // ../../node_modules/phaser/src/actions/PlaceOnTriangle.js
  var require_PlaceOnTriangle = __commonJS({
    "../../node_modules/phaser/src/actions/PlaceOnTriangle.js": function(exports, module) {
      var BresenhamPoints = require_BresenhamPoints();
      var PlaceOnTriangle = function(items, triangle, stepRate) {
        var p1 = BresenhamPoints({ x1: triangle.x1, y1: triangle.y1, x2: triangle.x2, y2: triangle.y2 }, stepRate);
        var p2 = BresenhamPoints({ x1: triangle.x2, y1: triangle.y2, x2: triangle.x3, y2: triangle.y3 }, stepRate);
        var p3 = BresenhamPoints({ x1: triangle.x3, y1: triangle.y3, x2: triangle.x1, y2: triangle.y1 }, stepRate);
        p1.pop();
        p2.pop();
        p3.pop();
        p1 = p1.concat(p2, p3);
        var step = p1.length / items.length;
        var p = 0;
        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          var point = p1[Math.floor(p)];
          item.x = point.x;
          item.y = point.y;
          p += step;
        }
        return items;
      };
      module.exports = PlaceOnTriangle;
    }
  });

  // ../../node_modules/phaser/src/actions/PlayAnimation.js
  var require_PlayAnimation = __commonJS({
    "../../node_modules/phaser/src/actions/PlayAnimation.js": function(exports, module) {
      var PlayAnimation = function(items, key, ignoreIfPlaying) {
        for (var i = 0; i < items.length; i++) {
          var gameObject = items[i];
          if (gameObject.anims) {
            gameObject.anims.play(key, ignoreIfPlaying);
          }
        }
        return items;
      };
      module.exports = PlayAnimation;
    }
  });

  // ../../node_modules/phaser/src/actions/PropertyValueSet.js
  var require_PropertyValueSet = __commonJS({
    "../../node_modules/phaser/src/actions/PropertyValueSet.js": function(exports, module) {
      var PropertyValueSet = function(items, key, value, step, index, direction) {
        if (step === void 0) {
          step = 0;
        }
        if (index === void 0) {
          index = 0;
        }
        if (direction === void 0) {
          direction = 1;
        }
        var i;
        var t = 0;
        var end = items.length;
        if (direction === 1) {
          for (i = index; i < end; i++) {
            items[i][key] = value + t * step;
            t++;
          }
        } else {
          for (i = index; i >= 0; i--) {
            items[i][key] = value + t * step;
            t++;
          }
        }
        return items;
      };
      module.exports = PropertyValueSet;
    }
  });

  // ../../node_modules/phaser/src/actions/RandomCircle.js
  var require_RandomCircle = __commonJS({
    "../../node_modules/phaser/src/actions/RandomCircle.js": function(exports, module) {
      var Random = require_Random();
      var RandomCircle = function(items, circle) {
        for (var i = 0; i < items.length; i++) {
          Random(circle, items[i]);
        }
        return items;
      };
      module.exports = RandomCircle;
    }
  });

  // ../../node_modules/phaser/src/actions/RandomEllipse.js
  var require_RandomEllipse = __commonJS({
    "../../node_modules/phaser/src/actions/RandomEllipse.js": function(exports, module) {
      var Random = require_Random5();
      var RandomEllipse = function(items, ellipse) {
        for (var i = 0; i < items.length; i++) {
          Random(ellipse, items[i]);
        }
        return items;
      };
      module.exports = RandomEllipse;
    }
  });

  // ../../node_modules/phaser/src/actions/RandomLine.js
  var require_RandomLine = __commonJS({
    "../../node_modules/phaser/src/actions/RandomLine.js": function(exports, module) {
      var Random = require_Random2();
      var RandomLine = function(items, line) {
        for (var i = 0; i < items.length; i++) {
          Random(line, items[i]);
        }
        return items;
      };
      module.exports = RandomLine;
    }
  });

  // ../../node_modules/phaser/src/actions/RandomRectangle.js
  var require_RandomRectangle = __commonJS({
    "../../node_modules/phaser/src/actions/RandomRectangle.js": function(exports, module) {
      var Random = require_Random3();
      var RandomRectangle = function(items, rect) {
        for (var i = 0; i < items.length; i++) {
          Random(rect, items[i]);
        }
        return items;
      };
      module.exports = RandomRectangle;
    }
  });

  // ../../node_modules/phaser/src/geom/triangle/Random.js
  var require_Random6 = __commonJS({
    "../../node_modules/phaser/src/geom/triangle/Random.js": function(exports, module) {
      var Point = require_Point();
      var Random = function(triangle, out) {
        if (out === void 0) {
          out = new Point();
        }
        var ux = triangle.x2 - triangle.x1;
        var uy = triangle.y2 - triangle.y1;
        var vx = triangle.x3 - triangle.x1;
        var vy = triangle.y3 - triangle.y1;
        var r = Math.random();
        var s = Math.random();
        if (r + s >= 1) {
          r = 1 - r;
          s = 1 - s;
        }
        out.x = triangle.x1 + (ux * r + vx * s);
        out.y = triangle.y1 + (uy * r + vy * s);
        return out;
      };
      module.exports = Random;
    }
  });

  // ../../node_modules/phaser/src/actions/RandomTriangle.js
  var require_RandomTriangle = __commonJS({
    "../../node_modules/phaser/src/actions/RandomTriangle.js": function(exports, module) {
      var Random = require_Random6();
      var RandomTriangle = function(items, triangle) {
        for (var i = 0; i < items.length; i++) {
          Random(triangle, items[i]);
        }
        return items;
      };
      module.exports = RandomTriangle;
    }
  });

  // ../../node_modules/phaser/src/actions/Rotate.js
  var require_Rotate2 = __commonJS({
    "../../node_modules/phaser/src/actions/Rotate.js": function(exports, module) {
      var PropertyValueInc = require_PropertyValueInc();
      var Rotate = function(items, value, step, index, direction) {
        return PropertyValueInc(items, "rotation", value, step, index, direction);
      };
      module.exports = Rotate;
    }
  });

  // ../../node_modules/phaser/src/actions/RotateAround.js
  var require_RotateAround2 = __commonJS({
    "../../node_modules/phaser/src/actions/RotateAround.js": function(exports, module) {
      var RotateAroundDistance = require_RotateAroundDistance();
      var DistanceBetween = require_DistanceBetween();
      var RotateAround = function(items, point, angle) {
        var x = point.x;
        var y = point.y;
        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          RotateAroundDistance(item, x, y, angle, Math.max(1, DistanceBetween(item.x, item.y, x, y)));
        }
        return items;
      };
      module.exports = RotateAround;
    }
  });

  // ../../node_modules/phaser/src/actions/RotateAroundDistance.js
  var require_RotateAroundDistance2 = __commonJS({
    "../../node_modules/phaser/src/actions/RotateAroundDistance.js": function(exports, module) {
      var MathRotateAroundDistance = require_RotateAroundDistance();
      var RotateAroundDistance = function(items, point, angle, distance) {
        var x = point.x;
        var y = point.y;
        if (distance === 0) {
          return items;
        }
        for (var i = 0; i < items.length; i++) {
          MathRotateAroundDistance(items[i], x, y, angle, distance);
        }
        return items;
      };
      module.exports = RotateAroundDistance;
    }
  });

  // ../../node_modules/phaser/src/actions/ScaleX.js
  var require_ScaleX = __commonJS({
    "../../node_modules/phaser/src/actions/ScaleX.js": function(exports, module) {
      var PropertyValueInc = require_PropertyValueInc();
      var ScaleX = function(items, value, step, index, direction) {
        return PropertyValueInc(items, "scaleX", value, step, index, direction);
      };
      module.exports = ScaleX;
    }
  });

  // ../../node_modules/phaser/src/actions/ScaleXY.js
  var require_ScaleXY = __commonJS({
    "../../node_modules/phaser/src/actions/ScaleXY.js": function(exports, module) {
      var PropertyValueInc = require_PropertyValueInc();
      var ScaleXY = function(items, scaleX, scaleY, stepX, stepY, index, direction) {
        if (scaleY === void 0 || scaleY === null) {
          scaleY = scaleX;
        }
        PropertyValueInc(items, "scaleX", scaleX, stepX, index, direction);
        return PropertyValueInc(items, "scaleY", scaleY, stepY, index, direction);
      };
      module.exports = ScaleXY;
    }
  });

  // ../../node_modules/phaser/src/actions/ScaleY.js
  var require_ScaleY = __commonJS({
    "../../node_modules/phaser/src/actions/ScaleY.js": function(exports, module) {
      var PropertyValueInc = require_PropertyValueInc();
      var ScaleY = function(items, value, step, index, direction) {
        return PropertyValueInc(items, "scaleY", value, step, index, direction);
      };
      module.exports = ScaleY;
    }
  });

  // ../../node_modules/phaser/src/actions/SetAlpha.js
  var require_SetAlpha = __commonJS({
    "../../node_modules/phaser/src/actions/SetAlpha.js": function(exports, module) {
      var PropertyValueSet = require_PropertyValueSet();
      var SetAlpha = function(items, value, step, index, direction) {
        return PropertyValueSet(items, "alpha", value, step, index, direction);
      };
      module.exports = SetAlpha;
    }
  });

  // ../../node_modules/phaser/src/actions/SetBlendMode.js
  var require_SetBlendMode = __commonJS({
    "../../node_modules/phaser/src/actions/SetBlendMode.js": function(exports, module) {
      var PropertyValueSet = require_PropertyValueSet();
      var SetBlendMode = function(items, value, index, direction) {
        return PropertyValueSet(items, "blendMode", value, 0, index, direction);
      };
      module.exports = SetBlendMode;
    }
  });

  // ../../node_modules/phaser/src/actions/SetDepth.js
  var require_SetDepth = __commonJS({
    "../../node_modules/phaser/src/actions/SetDepth.js": function(exports, module) {
      var PropertyValueSet = require_PropertyValueSet();
      var SetDepth = function(items, value, step, index, direction) {
        return PropertyValueSet(items, "depth", value, step, index, direction);
      };
      module.exports = SetDepth;
    }
  });

  // ../../node_modules/phaser/src/actions/SetHitArea.js
  var require_SetHitArea = __commonJS({
    "../../node_modules/phaser/src/actions/SetHitArea.js": function(exports, module) {
      var SetHitArea = function(items, hitArea, hitAreaCallback) {
        for (var i = 0; i < items.length; i++) {
          items[i].setInteractive(hitArea, hitAreaCallback);
        }
        return items;
      };
      module.exports = SetHitArea;
    }
  });

  // ../../node_modules/phaser/src/actions/SetOrigin.js
  var require_SetOrigin = __commonJS({
    "../../node_modules/phaser/src/actions/SetOrigin.js": function(exports, module) {
      var PropertyValueSet = require_PropertyValueSet();
      var SetOrigin = function(items, originX, originY, stepX, stepY, index, direction) {
        if (originY === void 0 || originY === null) {
          originY = originX;
        }
        PropertyValueSet(items, "originX", originX, stepX, index, direction);
        PropertyValueSet(items, "originY", originY, stepY, index, direction);
        items.forEach(function(item) {
          item.updateDisplayOrigin();
        });
        return items;
      };
      module.exports = SetOrigin;
    }
  });

  // ../../node_modules/phaser/src/actions/SetRotation.js
  var require_SetRotation = __commonJS({
    "../../node_modules/phaser/src/actions/SetRotation.js": function(exports, module) {
      var PropertyValueSet = require_PropertyValueSet();
      var SetRotation = function(items, value, step, index, direction) {
        return PropertyValueSet(items, "rotation", value, step, index, direction);
      };
      module.exports = SetRotation;
    }
  });

  // ../../node_modules/phaser/src/actions/SetScale.js
  var require_SetScale = __commonJS({
    "../../node_modules/phaser/src/actions/SetScale.js": function(exports, module) {
      var PropertyValueSet = require_PropertyValueSet();
      var SetScale = function(items, scaleX, scaleY, stepX, stepY, index, direction) {
        if (scaleY === void 0 || scaleY === null) {
          scaleY = scaleX;
        }
        PropertyValueSet(items, "scaleX", scaleX, stepX, index, direction);
        return PropertyValueSet(items, "scaleY", scaleY, stepY, index, direction);
      };
      module.exports = SetScale;
    }
  });

  // ../../node_modules/phaser/src/actions/SetScaleX.js
  var require_SetScaleX = __commonJS({
    "../../node_modules/phaser/src/actions/SetScaleX.js": function(exports, module) {
      var PropertyValueSet = require_PropertyValueSet();
      var SetScaleX = function(items, value, step, index, direction) {
        return PropertyValueSet(items, "scaleX", value, step, index, direction);
      };
      module.exports = SetScaleX;
    }
  });

  // ../../node_modules/phaser/src/actions/SetScaleY.js
  var require_SetScaleY = __commonJS({
    "../../node_modules/phaser/src/actions/SetScaleY.js": function(exports, module) {
      var PropertyValueSet = require_PropertyValueSet();
      var SetScaleY = function(items, value, step, index, direction) {
        return PropertyValueSet(items, "scaleY", value, step, index, direction);
      };
      module.exports = SetScaleY;
    }
  });

  // ../../node_modules/phaser/src/actions/SetScrollFactor.js
  var require_SetScrollFactor = __commonJS({
    "../../node_modules/phaser/src/actions/SetScrollFactor.js": function(exports, module) {
      var PropertyValueSet = require_PropertyValueSet();
      var SetScrollFactor = function(items, scrollFactorX, scrollFactorY, stepX, stepY, index, direction) {
        if (scrollFactorY === void 0 || scrollFactorY === null) {
          scrollFactorY = scrollFactorX;
        }
        PropertyValueSet(items, "scrollFactorX", scrollFactorX, stepX, index, direction);
        return PropertyValueSet(items, "scrollFactorY", scrollFactorY, stepY, index, direction);
      };
      module.exports = SetScrollFactor;
    }
  });

  // ../../node_modules/phaser/src/actions/SetScrollFactorX.js
  var require_SetScrollFactorX = __commonJS({
    "../../node_modules/phaser/src/actions/SetScrollFactorX.js": function(exports, module) {
      var PropertyValueSet = require_PropertyValueSet();
      var SetScrollFactorX = function(items, value, step, index, direction) {
        return PropertyValueSet(items, "scrollFactorX", value, step, index, direction);
      };
      module.exports = SetScrollFactorX;
    }
  });

  // ../../node_modules/phaser/src/actions/SetScrollFactorY.js
  var require_SetScrollFactorY = __commonJS({
    "../../node_modules/phaser/src/actions/SetScrollFactorY.js": function(exports, module) {
      var PropertyValueSet = require_PropertyValueSet();
      var SetScrollFactorY = function(items, value, step, index, direction) {
        return PropertyValueSet(items, "scrollFactorY", value, step, index, direction);
      };
      module.exports = SetScrollFactorY;
    }
  });

  // ../../node_modules/phaser/src/actions/SetTint.js
  var require_SetTint = __commonJS({
    "../../node_modules/phaser/src/actions/SetTint.js": function(exports, module) {
      var SetTint = function(items, topLeft, topRight, bottomLeft, bottomRight) {
        for (var i = 0; i < items.length; i++) {
          items[i].setTint(topLeft, topRight, bottomLeft, bottomRight);
        }
        return items;
      };
      module.exports = SetTint;
    }
  });

  // ../../node_modules/phaser/src/actions/SetVisible.js
  var require_SetVisible = __commonJS({
    "../../node_modules/phaser/src/actions/SetVisible.js": function(exports, module) {
      var PropertyValueSet = require_PropertyValueSet();
      var SetVisible = function(items, value, index, direction) {
        return PropertyValueSet(items, "visible", value, 0, index, direction);
      };
      module.exports = SetVisible;
    }
  });

  // ../../node_modules/phaser/src/actions/SetX.js
  var require_SetX = __commonJS({
    "../../node_modules/phaser/src/actions/SetX.js": function(exports, module) {
      var PropertyValueSet = require_PropertyValueSet();
      var SetX = function(items, value, step, index, direction) {
        return PropertyValueSet(items, "x", value, step, index, direction);
      };
      module.exports = SetX;
    }
  });

  // ../../node_modules/phaser/src/actions/SetXY.js
  var require_SetXY = __commonJS({
    "../../node_modules/phaser/src/actions/SetXY.js": function(exports, module) {
      var PropertyValueSet = require_PropertyValueSet();
      var SetXY = function(items, x, y, stepX, stepY, index, direction) {
        if (y === void 0 || y === null) {
          y = x;
        }
        PropertyValueSet(items, "x", x, stepX, index, direction);
        return PropertyValueSet(items, "y", y, stepY, index, direction);
      };
      module.exports = SetXY;
    }
  });

  // ../../node_modules/phaser/src/actions/SetY.js
  var require_SetY = __commonJS({
    "../../node_modules/phaser/src/actions/SetY.js": function(exports, module) {
      var PropertyValueSet = require_PropertyValueSet();
      var SetY = function(items, value, step, index, direction) {
        return PropertyValueSet(items, "y", value, step, index, direction);
      };
      module.exports = SetY;
    }
  });

  // ../../node_modules/phaser/src/actions/ShiftPosition.js
  var require_ShiftPosition = __commonJS({
    "../../node_modules/phaser/src/actions/ShiftPosition.js": function(exports, module) {
      var Vector2 = require_Vector2();
      var ShiftPosition = function(items, x, y, direction, output) {
        if (direction === void 0) {
          direction = 0;
        }
        if (output === void 0) {
          output = new Vector2();
        }
        var px;
        var py;
        var len = items.length;
        if (len === 1) {
          px = items[0].x;
          py = items[0].y;
          items[0].x = x;
          items[0].y = y;
        } else {
          var i = 1;
          var pos = 0;
          if (direction === 0) {
            pos = len - 1;
            i = len - 2;
          }
          px = items[pos].x;
          py = items[pos].y;
          items[pos].x = x;
          items[pos].y = y;
          for (var c = 0; c < len; c++) {
            if (i >= len || i === -1) {
              continue;
            }
            var cur = items[i];
            var cx = cur.x;
            var cy = cur.y;
            cur.x = px;
            cur.y = py;
            px = cx;
            py = cy;
            if (direction === 0) {
              i--;
            } else {
              i++;
            }
          }
        }
        output.x = px;
        output.y = py;
        return output;
      };
      module.exports = ShiftPosition;
    }
  });

  // ../../node_modules/phaser/src/actions/Shuffle.js
  var require_Shuffle2 = __commonJS({
    "../../node_modules/phaser/src/actions/Shuffle.js": function(exports, module) {
      var ArrayShuffle = require_Shuffle();
      var Shuffle = function(items) {
        return ArrayShuffle(items);
      };
      module.exports = Shuffle;
    }
  });

  // ../../node_modules/phaser/src/actions/SmootherStep.js
  var require_SmootherStep2 = __commonJS({
    "../../node_modules/phaser/src/actions/SmootherStep.js": function(exports, module) {
      var MathSmootherStep = require_SmootherStep();
      var SmootherStep = function(items, property, min, max, inc) {
        if (inc === void 0) {
          inc = false;
        }
        var step = Math.abs(max - min) / items.length;
        var i;
        if (inc) {
          for (i = 0; i < items.length; i++) {
            items[i][property] += MathSmootherStep(i * step, min, max);
          }
        } else {
          for (i = 0; i < items.length; i++) {
            items[i][property] = MathSmootherStep(i * step, min, max);
          }
        }
        return items;
      };
      module.exports = SmootherStep;
    }
  });

  // ../../node_modules/phaser/src/actions/SmoothStep.js
  var require_SmoothStep2 = __commonJS({
    "../../node_modules/phaser/src/actions/SmoothStep.js": function(exports, module) {
      var MathSmoothStep = require_SmoothStep();
      var SmoothStep = function(items, property, min, max, inc) {
        if (inc === void 0) {
          inc = false;
        }
        var step = Math.abs(max - min) / items.length;
        var i;
        if (inc) {
          for (i = 0; i < items.length; i++) {
            items[i][property] += MathSmoothStep(i * step, min, max);
          }
        } else {
          for (i = 0; i < items.length; i++) {
            items[i][property] = MathSmoothStep(i * step, min, max);
          }
        }
        return items;
      };
      module.exports = SmoothStep;
    }
  });

  // ../../node_modules/phaser/src/actions/Spread.js
  var require_Spread = __commonJS({
    "../../node_modules/phaser/src/actions/Spread.js": function(exports, module) {
      var Spread = function(items, property, min, max, inc) {
        if (inc === void 0) {
          inc = false;
        }
        if (items.length === 0) {
          return items;
        }
        if (items.length === 1) {
          if (inc) {
            items[0][property] += (max + min) / 2;
          } else {
            items[0][property] = (max + min) / 2;
          }
          return items;
        }
        var step = Math.abs(max - min) / (items.length - 1);
        var i;
        if (inc) {
          for (i = 0; i < items.length; i++) {
            items[i][property] += i * step + min;
          }
        } else {
          for (i = 0; i < items.length; i++) {
            items[i][property] = i * step + min;
          }
        }
        return items;
      };
      module.exports = Spread;
    }
  });

  // ../../node_modules/phaser/src/actions/ToggleVisible.js
  var require_ToggleVisible = __commonJS({
    "../../node_modules/phaser/src/actions/ToggleVisible.js": function(exports, module) {
      var ToggleVisible = function(items) {
        for (var i = 0; i < items.length; i++) {
          items[i].visible = !items[i].visible;
        }
        return items;
      };
      module.exports = ToggleVisible;
    }
  });

  // ../../node_modules/phaser/src/actions/WrapInRectangle.js
  var require_WrapInRectangle = __commonJS({
    "../../node_modules/phaser/src/actions/WrapInRectangle.js": function(exports, module) {
      var Wrap = require_Wrap();
      var WrapInRectangle = function(items, rect, padding) {
        if (padding === void 0) {
          padding = 0;
        }
        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          item.x = Wrap(item.x, rect.left - padding, rect.right + padding);
          item.y = Wrap(item.y, rect.top - padding, rect.bottom + padding);
        }
        return items;
      };
      module.exports = WrapInRectangle;
    }
  });

  // ../../node_modules/phaser/src/actions/index.js
  var require_actions = __commonJS({
    "../../node_modules/phaser/src/actions/index.js": function(exports, module) {
      module.exports = {
        AlignTo: require_AlignTo(),
        Angle: require_Angle(),
        Call: require_Call(),
        GetFirst: require_GetFirst2(),
        GetLast: require_GetLast(),
        GridAlign: require_GridAlign(),
        IncAlpha: require_IncAlpha(),
        IncX: require_IncX(),
        IncXY: require_IncXY(),
        IncY: require_IncY(),
        PlaceOnCircle: require_PlaceOnCircle(),
        PlaceOnEllipse: require_PlaceOnEllipse(),
        PlaceOnLine: require_PlaceOnLine(),
        PlaceOnRectangle: require_PlaceOnRectangle(),
        PlaceOnTriangle: require_PlaceOnTriangle(),
        PlayAnimation: require_PlayAnimation(),
        PropertyValueInc: require_PropertyValueInc(),
        PropertyValueSet: require_PropertyValueSet(),
        RandomCircle: require_RandomCircle(),
        RandomEllipse: require_RandomEllipse(),
        RandomLine: require_RandomLine(),
        RandomRectangle: require_RandomRectangle(),
        RandomTriangle: require_RandomTriangle(),
        Rotate: require_Rotate2(),
        RotateAround: require_RotateAround2(),
        RotateAroundDistance: require_RotateAroundDistance2(),
        ScaleX: require_ScaleX(),
        ScaleXY: require_ScaleXY(),
        ScaleY: require_ScaleY(),
        SetAlpha: require_SetAlpha(),
        SetBlendMode: require_SetBlendMode(),
        SetDepth: require_SetDepth(),
        SetHitArea: require_SetHitArea(),
        SetOrigin: require_SetOrigin(),
        SetRotation: require_SetRotation(),
        SetScale: require_SetScale(),
        SetScaleX: require_SetScaleX(),
        SetScaleY: require_SetScaleY(),
        SetScrollFactor: require_SetScrollFactor(),
        SetScrollFactorX: require_SetScrollFactorX(),
        SetScrollFactorY: require_SetScrollFactorY(),
        SetTint: require_SetTint(),
        SetVisible: require_SetVisible(),
        SetX: require_SetX(),
        SetXY: require_SetXY(),
        SetY: require_SetY(),
        ShiftPosition: require_ShiftPosition(),
        Shuffle: require_Shuffle2(),
        SmootherStep: require_SmootherStep2(),
        SmoothStep: require_SmoothStep2(),
        Spread: require_Spread(),
        ToggleVisible: require_ToggleVisible(),
        WrapInRectangle: require_WrapInRectangle()
      };
    }
  });

  // ../../node_modules/phaser/src/utils/object/HasValue.js
  var require_HasValue = __commonJS({
    "../../node_modules/phaser/src/utils/object/HasValue.js": function(exports, module) {
      var HasValue = function(source, key) {
        return source.hasOwnProperty(key);
      };
      module.exports = HasValue;
    }
  });

  // ../../node_modules/phaser/src/structs/Set.js
  var require_Set = __commonJS({
    "../../node_modules/phaser/src/structs/Set.js": function(exports, module) {
      var Class = require_Class();
      var Set = new Class({
        initialize: function Set2(elements) {
          this.entries = [];
          if (Array.isArray(elements)) {
            for (var i = 0; i < elements.length; i++) {
              this.set(elements[i]);
            }
          }
        },
        set: function(value) {
          if (this.entries.indexOf(value) === -1) {
            this.entries.push(value);
          }
          return this;
        },
        get: function(property, value) {
          for (var i = 0; i < this.entries.length; i++) {
            var entry = this.entries[i];
            if (entry[property] === value) {
              return entry;
            }
          }
        },
        getArray: function() {
          return this.entries.slice(0);
        },
        delete: function(value) {
          var index = this.entries.indexOf(value);
          if (index > -1) {
            this.entries.splice(index, 1);
          }
          return this;
        },
        dump: function() {
          console.group("Set");
          for (var i = 0; i < this.entries.length; i++) {
            var entry = this.entries[i];
            console.log(entry);
          }
          console.groupEnd();
        },
        each: function(callback, callbackScope) {
          var i;
          var temp = this.entries.slice();
          var len = temp.length;
          if (callbackScope) {
            for (i = 0; i < len; i++) {
              if (callback.call(callbackScope, temp[i], i) === false) {
                break;
              }
            }
          } else {
            for (i = 0; i < len; i++) {
              if (callback(temp[i], i) === false) {
                break;
              }
            }
          }
          return this;
        },
        iterate: function(callback, callbackScope) {
          var i;
          var len = this.entries.length;
          if (callbackScope) {
            for (i = 0; i < len; i++) {
              if (callback.call(callbackScope, this.entries[i], i) === false) {
                break;
              }
            }
          } else {
            for (i = 0; i < len; i++) {
              if (callback(this.entries[i], i) === false) {
                break;
              }
            }
          }
          return this;
        },
        iterateLocal: function(callbackKey) {
          var i;
          var args = [];
          for (i = 1; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          var len = this.entries.length;
          for (i = 0; i < len; i++) {
            var entry = this.entries[i];
            entry[callbackKey].apply(entry, args);
          }
          return this;
        },
        clear: function() {
          this.entries.length = 0;
          return this;
        },
        contains: function(value) {
          return this.entries.indexOf(value) > -1;
        },
        union: function(set) {
          var newSet = new Set();
          set.entries.forEach(function(value) {
            newSet.set(value);
          });
          this.entries.forEach(function(value) {
            newSet.set(value);
          });
          return newSet;
        },
        intersect: function(set) {
          var newSet = new Set();
          this.entries.forEach(function(value) {
            if (set.contains(value)) {
              newSet.set(value);
            }
          });
          return newSet;
        },
        difference: function(set) {
          var newSet = new Set();
          this.entries.forEach(function(value) {
            if (!set.contains(value)) {
              newSet.set(value);
            }
          });
          return newSet;
        },
        size: {
          get: function() {
            return this.entries.length;
          },
          set: function(value) {
            if (value < this.entries.length) {
              return this.entries.length = value;
            } else {
              return this.entries.length;
            }
          }
        }
      });
      module.exports = Set;
    }
  });

  // ../../node_modules/phaser/src/animations/AnimationState.js
  var require_AnimationState = __commonJS({
    "../../node_modules/phaser/src/animations/AnimationState.js": function(exports, module) {
      var Class = require_Class();
      var CustomMap = require_Map();
      var GetFastValue = require_GetFastValue();
      var Events = require_events12();
      var Animation = require_Animation();
      var AnimationState = new Class({
        initialize: function AnimationState2(parent) {
          this.parent = parent;
          this.animationManager = parent.scene.sys.anims;
          this.animationManager.on(Events.REMOVE_ANIMATION, this.globalRemove, this);
          this.textureManager = this.animationManager.textureManager;
          this.anims = null;
          this.isPlaying = false;
          this.hasStarted = false;
          this.currentAnim = null;
          this.currentFrame = null;
          this.nextAnim = null;
          this.nextAnimsQueue = [];
          this.timeScale = 1;
          this.frameRate = 0;
          this.duration = 0;
          this.msPerFrame = 0;
          this.skipMissedFrames = true;
          this.delay = 0;
          this.repeat = 0;
          this.repeatDelay = 0;
          this.yoyo = false;
          this.showBeforeDelay = false;
          this.showOnStart = false;
          this.hideOnComplete = false;
          this.forward = true;
          this.inReverse = false;
          this.accumulator = 0;
          this.nextTick = 0;
          this.delayCounter = 0;
          this.repeatCounter = 0;
          this.pendingRepeat = false;
          this._paused = false;
          this._wasPlaying = false;
          this._pendingStop = 0;
          this._pendingStopValue;
        },
        chain: function(key) {
          var parent = this.parent;
          if (key === void 0) {
            this.nextAnimsQueue.length = 0;
            this.nextAnim = null;
            return parent;
          }
          if (!Array.isArray(key)) {
            key = [key];
          }
          for (var i = 0; i < key.length; i++) {
            var anim = key[i];
            if (!this.nextAnim) {
              this.nextAnim = anim;
            } else {
              this.nextAnimsQueue.push(anim);
            }
          }
          return this.parent;
        },
        getName: function() {
          return this.currentAnim ? this.currentAnim.key : "";
        },
        getFrameName: function() {
          return this.currentFrame ? this.currentFrame.textureFrame : "";
        },
        load: function(key) {
          if (this.isPlaying) {
            this.stop();
          }
          var manager = this.animationManager;
          var animKey = typeof key === "string" ? key : GetFastValue(key, "key", null);
          var anim = this.exists(animKey) ? this.get(animKey) : manager.get(animKey);
          if (!anim) {
            console.warn("Missing animation: " + animKey);
          } else {
            this.currentAnim = anim;
            var totalFrames = anim.getTotalFrames();
            var frameRate = GetFastValue(key, "frameRate", anim.frameRate);
            var duration = GetFastValue(key, "duration", anim.duration);
            anim.calculateDuration(this, totalFrames, duration, frameRate);
            this.delay = GetFastValue(key, "delay", anim.delay);
            this.repeat = GetFastValue(key, "repeat", anim.repeat);
            this.repeatDelay = GetFastValue(key, "repeatDelay", anim.repeatDelay);
            this.yoyo = GetFastValue(key, "yoyo", anim.yoyo);
            this.showBeforeDelay = GetFastValue(key, "showBeforeDelay", anim.showBeforeDelay);
            this.showOnStart = GetFastValue(key, "showOnStart", anim.showOnStart);
            this.hideOnComplete = GetFastValue(key, "hideOnComplete", anim.hideOnComplete);
            this.skipMissedFrames = GetFastValue(key, "skipMissedFrames", anim.skipMissedFrames);
            this.timeScale = GetFastValue(key, "timeScale", this.timeScale);
            var startFrame = GetFastValue(key, "startFrame", 0);
            if (startFrame > anim.getTotalFrames()) {
              startFrame = 0;
            }
            var frame = anim.frames[startFrame];
            if (startFrame === 0 && !this.forward) {
              frame = anim.getLastFrame();
            }
            this.currentFrame = frame;
          }
          return this.parent;
        },
        pause: function(atFrame) {
          if (!this._paused) {
            this._paused = true;
            this._wasPlaying = this.isPlaying;
            this.isPlaying = false;
          }
          if (atFrame !== void 0) {
            this.setCurrentFrame(atFrame);
          }
          return this.parent;
        },
        resume: function(fromFrame) {
          if (this._paused) {
            this._paused = false;
            this.isPlaying = this._wasPlaying;
          }
          if (fromFrame !== void 0) {
            this.setCurrentFrame(fromFrame);
          }
          return this.parent;
        },
        playAfterDelay: function(key, delay) {
          if (!this.isPlaying) {
            this.delayCounter = delay;
            this.play(key, true);
          } else {
            var nextAnim = this.nextAnim;
            var queue = this.nextAnimsQueue;
            if (nextAnim) {
              queue.unshift(nextAnim);
            }
            this.nextAnim = key;
            this._pendingStop = 1;
            this._pendingStopValue = delay;
          }
          return this.parent;
        },
        playAfterRepeat: function(key, repeatCount) {
          if (repeatCount === void 0) {
            repeatCount = 1;
          }
          if (!this.isPlaying) {
            this.play(key);
          } else {
            var nextAnim = this.nextAnim;
            var queue = this.nextAnimsQueue;
            if (nextAnim) {
              queue.unshift(nextAnim);
            }
            if (this.repeatCounter !== -1 && repeatCount > this.repeatCounter) {
              repeatCount = this.repeatCounter;
            }
            this.nextAnim = key;
            this._pendingStop = 2;
            this._pendingStopValue = repeatCount;
          }
          return this.parent;
        },
        play: function(key, ignoreIfPlaying) {
          if (ignoreIfPlaying === void 0) {
            ignoreIfPlaying = false;
          }
          var currentAnim = this.currentAnim;
          var parent = this.parent;
          var animKey = typeof key === "string" ? key : key.key;
          if (ignoreIfPlaying && this.isPlaying && currentAnim.key === animKey) {
            return parent;
          }
          if (currentAnim && this.isPlaying) {
            var mix = this.animationManager.getMix(currentAnim.key, key);
            if (mix > 0) {
              return this.playAfterDelay(key, mix);
            }
          }
          this.forward = true;
          this.inReverse = false;
          this._paused = false;
          this._wasPlaying = true;
          return this.startAnimation(key);
        },
        playReverse: function(key, ignoreIfPlaying) {
          if (ignoreIfPlaying === void 0) {
            ignoreIfPlaying = false;
          }
          var animKey = typeof key === "string" ? key : key.key;
          if (ignoreIfPlaying && this.isPlaying && this.currentAnim.key === animKey) {
            return this.parent;
          }
          this.forward = false;
          this.inReverse = true;
          this._paused = false;
          this._wasPlaying = true;
          return this.startAnimation(key);
        },
        startAnimation: function(key) {
          this.load(key);
          var anim = this.currentAnim;
          var gameObject = this.parent;
          if (!anim) {
            return gameObject;
          }
          this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat;
          anim.getFirstTick(this);
          this.isPlaying = true;
          this.pendingRepeat = false;
          this.hasStarted = false;
          this._pendingStop = 0;
          this._pendingStopValue = 0;
          this._paused = false;
          this.delayCounter += this.delay;
          if (this.delayCounter === 0) {
            this.handleStart();
          } else if (this.showBeforeDelay) {
            this.setCurrentFrame(this.currentFrame);
          }
          return gameObject;
        },
        handleStart: function() {
          if (this.showOnStart) {
            this.parent.setVisible(true);
          }
          this.setCurrentFrame(this.currentFrame);
          this.hasStarted = true;
          this.emitEvents(Events.ANIMATION_START);
        },
        handleRepeat: function() {
          this.pendingRepeat = false;
          this.emitEvents(Events.ANIMATION_REPEAT);
        },
        handleStop: function() {
          this._pendingStop = 0;
          this.isPlaying = false;
          this.emitEvents(Events.ANIMATION_STOP);
        },
        handleComplete: function() {
          this._pendingStop = 0;
          this.isPlaying = false;
          if (this.hideOnComplete) {
            this.parent.setVisible(false);
          }
          this.emitEvents(Events.ANIMATION_COMPLETE, Events.ANIMATION_COMPLETE_KEY);
        },
        emitEvents: function(event, keyEvent) {
          var anim = this.currentAnim;
          if (anim) {
            var frame = this.currentFrame;
            var gameObject = this.parent;
            var frameKey = frame.textureFrame;
            gameObject.emit(event, anim, frame, gameObject, frameKey);
            if (keyEvent) {
              gameObject.emit(keyEvent + anim.key, anim, frame, gameObject, frameKey);
            }
          }
        },
        reverse: function() {
          if (this.isPlaying) {
            this.inReverse = !this.inReverse;
            this.forward = !this.forward;
          }
          return this.parent;
        },
        getProgress: function() {
          var frame = this.currentFrame;
          if (!frame) {
            return 0;
          }
          var p = frame.progress;
          if (this.inReverse) {
            p *= -1;
          }
          return p;
        },
        setProgress: function(value) {
          if (!this.forward) {
            value = 1 - value;
          }
          this.setCurrentFrame(this.currentAnim.getFrameByProgress(value));
          return this.parent;
        },
        setRepeat: function(value) {
          this.repeatCounter = value === -1 ? Number.MAX_VALUE : value;
          return this.parent;
        },
        globalRemove: function(key, animation) {
          if (animation === void 0) {
            animation = this.currentAnim;
          }
          if (this.isPlaying && animation.key === this.currentAnim.key) {
            this.stop();
            this.setCurrentFrame(this.currentAnim.frames[0]);
          }
        },
        restart: function(includeDelay, resetRepeats) {
          if (includeDelay === void 0) {
            includeDelay = false;
          }
          if (resetRepeats === void 0) {
            resetRepeats = false;
          }
          var anim = this.currentAnim;
          var gameObject = this.parent;
          if (!anim) {
            return gameObject;
          }
          if (resetRepeats) {
            this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat;
          }
          anim.getFirstTick(this);
          this.emitEvents(Events.ANIMATION_RESTART);
          this.isPlaying = true;
          this.pendingRepeat = false;
          this.hasStarted = !includeDelay;
          this._pendingStop = 0;
          this._pendingStopValue = 0;
          this._paused = false;
          this.setCurrentFrame(anim.frames[0]);
          return this.parent;
        },
        complete: function() {
          this._pendingStop = 0;
          this.isPlaying = false;
          if (this.currentAnim) {
            this.handleComplete();
          }
          if (this.nextAnim) {
            var key = this.nextAnim;
            this.nextAnim = this.nextAnimsQueue.length > 0 ? this.nextAnimsQueue.shift() : null;
            this.play(key);
          }
          return this.parent;
        },
        stop: function() {
          this._pendingStop = 0;
          this.isPlaying = false;
          this.delayCounter = 0;
          if (this.currentAnim) {
            this.handleStop();
          }
          if (this.nextAnim) {
            var key = this.nextAnim;
            this.nextAnim = this.nextAnimsQueue.shift();
            this.play(key);
          }
          return this.parent;
        },
        stopAfterDelay: function(delay) {
          this._pendingStop = 1;
          this._pendingStopValue = delay;
          return this.parent;
        },
        stopAfterRepeat: function(repeatCount) {
          if (repeatCount === void 0) {
            repeatCount = 1;
          }
          if (this.repeatCounter !== -1 && repeatCount > this.repeatCounter) {
            repeatCount = this.repeatCounter;
          }
          this._pendingStop = 2;
          this._pendingStopValue = repeatCount;
          return this.parent;
        },
        stopOnFrame: function(frame) {
          this._pendingStop = 3;
          this._pendingStopValue = frame;
          return this.parent;
        },
        getTotalFrames: function() {
          return this.currentAnim ? this.currentAnim.getTotalFrames() : 0;
        },
        update: function(time, delta) {
          var anim = this.currentAnim;
          if (!this.isPlaying || !anim || anim.paused) {
            return;
          }
          this.accumulator += delta * this.timeScale;
          if (this._pendingStop === 1) {
            this._pendingStopValue -= delta;
            if (this._pendingStopValue <= 0) {
              return this.stop();
            }
          }
          if (!this.hasStarted) {
            if (this.accumulator >= this.delayCounter) {
              this.accumulator -= this.delayCounter;
              this.handleStart();
            }
          } else if (this.accumulator >= this.nextTick) {
            if (this.forward) {
              anim.nextFrame(this);
            } else {
              anim.previousFrame(this);
            }
            if (this.isPlaying && this._pendingStop === 0 && this.skipMissedFrames && this.accumulator > this.nextTick) {
              var safetyNet = 0;
              do {
                if (this.forward) {
                  anim.nextFrame(this);
                } else {
                  anim.previousFrame(this);
                }
                safetyNet++;
              } while (this.isPlaying && this.accumulator > this.nextTick && safetyNet < 60);
            }
          }
        },
        setCurrentFrame: function(animationFrame) {
          var gameObject = this.parent;
          this.currentFrame = animationFrame;
          gameObject.texture = animationFrame.frame.texture;
          gameObject.frame = animationFrame.frame;
          if (gameObject.isCropped) {
            gameObject.frame.updateCropUVs(gameObject._crop, gameObject.flipX, gameObject.flipY);
          }
          if (animationFrame.setAlpha) {
            gameObject.alpha = animationFrame.alpha;
          }
          gameObject.setSizeToFrame();
          if (gameObject._originComponent) {
            if (animationFrame.frame.customPivot) {
              gameObject.setOrigin(animationFrame.frame.pivotX, animationFrame.frame.pivotY);
            } else {
              gameObject.updateDisplayOrigin();
            }
          }
          if (this.isPlaying && this.hasStarted) {
            this.emitEvents(Events.ANIMATION_UPDATE);
            if (this._pendingStop === 3 && this._pendingStopValue === animationFrame) {
              this.stop();
            }
          }
          return gameObject;
        },
        nextFrame: function() {
          if (this.currentAnim) {
            this.currentAnim.nextFrame(this);
          }
          return this.parent;
        },
        previousFrame: function() {
          if (this.currentAnim) {
            this.currentAnim.previousFrame(this);
          }
          return this.parent;
        },
        get: function(key) {
          return this.anims ? this.anims.get(key) : null;
        },
        exists: function(key) {
          return this.anims ? this.anims.has(key) : false;
        },
        create: function(config) {
          var key = config.key;
          var anim = false;
          if (key) {
            anim = this.get(key);
            if (!anim) {
              anim = new Animation(this, key, config);
              if (!this.anims) {
                this.anims = new CustomMap();
              }
              this.anims.set(key, anim);
            }
          }
          return anim;
        },
        createFromAseprite: function(key, tags) {
          return this.animationManager.createFromAseprite(key, tags, this.parent);
        },
        generateFrameNames: function(key, config) {
          return this.animationManager.generateFrameNames(key, config);
        },
        generateFrameNumbers: function(key, config) {
          return this.animationManager.generateFrameNumbers(key, config);
        },
        remove: function(key) {
          var anim = this.get(key);
          if (anim) {
            if (this.currentAnim === anim) {
              this.stop();
            }
            this.anims.delete(key);
          }
          return anim;
        },
        destroy: function() {
          this.animationManager.off(Events.REMOVE_ANIMATION, this.globalRemove, this);
          if (this.anims) {
            this.anims.clear();
          }
          this.animationManager = null;
          this.parent = null;
          this.nextAnim = null;
          this.nextAnimsQueue.length = 0;
          this.currentAnim = null;
          this.currentFrame = null;
        },
        isPaused: {
          get: function() {
            return this._paused;
          }
        }
      });
      module.exports = AnimationState;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/sprite/SpriteWebGLRenderer.js
  var require_SpriteWebGLRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/sprite/SpriteWebGLRenderer.js": function(exports, module) {
      var SpriteWebGLRenderer = function(renderer, src, camera, parentMatrix) {
        camera.addToRenderList(src);
        src.pipeline.batchSprite(src, camera, parentMatrix);
      };
      module.exports = SpriteWebGLRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/sprite/SpriteCanvasRenderer.js
  var require_SpriteCanvasRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/sprite/SpriteCanvasRenderer.js": function(exports, module) {
      var SpriteCanvasRenderer = function(renderer, src, camera, parentMatrix) {
        camera.addToRenderList(src);
        renderer.batchSprite(src, src.frame, camera, parentMatrix);
      };
      module.exports = SpriteCanvasRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/sprite/SpriteRender.js
  var require_SpriteRender = __commonJS({
    "../../node_modules/phaser/src/gameobjects/sprite/SpriteRender.js": function(exports, module) {
      var NOOP = require_NOOP();
      var renderWebGL = NOOP;
      var renderCanvas = NOOP;
      if (true) {
        renderWebGL = require_SpriteWebGLRenderer();
      }
      if (true) {
        renderCanvas = require_SpriteCanvasRenderer();
      }
      module.exports = {
        renderWebGL: renderWebGL,
        renderCanvas: renderCanvas
      };
    }
  });

  // ../../node_modules/phaser/src/gameobjects/sprite/Sprite.js
  var require_Sprite = __commonJS({
    "../../node_modules/phaser/src/gameobjects/sprite/Sprite.js": function(exports, module) {
      var AnimationState = require_AnimationState();
      var Class = require_Class();
      var Components = require_components();
      var GameObject = require_GameObject();
      var SpriteRender = require_SpriteRender();
      var Sprite = new Class({
        Extends: GameObject,
        Mixins: [
          Components.Alpha,
          Components.BlendMode,
          Components.Depth,
          Components.Flip,
          Components.FX,
          Components.GetBounds,
          Components.Mask,
          Components.Origin,
          Components.Pipeline,
          Components.PostPipeline,
          Components.ScrollFactor,
          Components.Size,
          Components.TextureCrop,
          Components.Tint,
          Components.Transform,
          Components.Visible,
          SpriteRender
        ],
        initialize: function Sprite2(scene, x, y, texture, frame) {
          GameObject.call(this, scene, "Sprite");
          this._crop = this.resetCropObject();
          this.anims = new AnimationState(this);
          this.setTexture(texture, frame);
          this.setPosition(x, y);
          this.setSizeToFrame();
          this.setOriginFromFrame();
          this.initPipeline();
          this.initPostPipeline();
        },
        addedToScene: function() {
          this.scene.sys.updateList.add(this);
        },
        removedFromScene: function() {
          this.scene.sys.updateList.remove(this);
        },
        preUpdate: function(time, delta) {
          this.anims.update(time, delta);
        },
        play: function(key, ignoreIfPlaying) {
          return this.anims.play(key, ignoreIfPlaying);
        },
        playReverse: function(key, ignoreIfPlaying) {
          return this.anims.playReverse(key, ignoreIfPlaying);
        },
        playAfterDelay: function(key, delay) {
          return this.anims.playAfterDelay(key, delay);
        },
        playAfterRepeat: function(key, repeatCount) {
          return this.anims.playAfterRepeat(key, repeatCount);
        },
        chain: function(key) {
          return this.anims.chain(key);
        },
        stop: function() {
          return this.anims.stop();
        },
        stopAfterDelay: function(delay) {
          return this.anims.stopAfterDelay(delay);
        },
        stopAfterRepeat: function(repeatCount) {
          return this.anims.stopAfterRepeat(repeatCount);
        },
        stopOnFrame: function(frame) {
          return this.anims.stopOnFrame(frame);
        },
        toJSON: function() {
          return Components.ToJSON(this);
        },
        preDestroy: function() {
          this.anims.destroy();
          this.anims = void 0;
        }
      });
      module.exports = Sprite;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/group/Group.js
  var require_Group = __commonJS({
    "../../node_modules/phaser/src/gameobjects/group/Group.js": function(exports, module) {
      var Actions = require_actions();
      var Class = require_Class();
      var Events = require_events3();
      var EventEmitter = require_eventemitter3();
      var GetAll = require_GetAll();
      var GetFastValue = require_GetFastValue();
      var GetValue = require_GetValue();
      var HasValue = require_HasValue();
      var IsPlainObject = require_IsPlainObject();
      var Range = require_Range();
      var Set = require_Set();
      var Sprite = require_Sprite();
      var Group = new Class({
        Extends: EventEmitter,
        initialize: function Group2(scene, children, config) {
          EventEmitter.call(this);
          if (config) {
            if (children && !Array.isArray(children)) {
              children = [children];
            }
          } else if (Array.isArray(children)) {
            if (IsPlainObject(children[0])) {
              config = children;
              children = null;
            }
          } else if (IsPlainObject(children)) {
            config = children;
            children = null;
          }
          this.scene = scene;
          this.children = new Set();
          this.isParent = true;
          this.type = "Group";
          this.classType = GetFastValue(config, "classType", Sprite);
          this.name = GetFastValue(config, "name", "");
          this.active = GetFastValue(config, "active", true);
          this.maxSize = GetFastValue(config, "maxSize", -1);
          this.defaultKey = GetFastValue(config, "defaultKey", null);
          this.defaultFrame = GetFastValue(config, "defaultFrame", null);
          this.runChildUpdate = GetFastValue(config, "runChildUpdate", false);
          this.createCallback = GetFastValue(config, "createCallback", null);
          this.removeCallback = GetFastValue(config, "removeCallback", null);
          this.createMultipleCallback = GetFastValue(config, "createMultipleCallback", null);
          this.internalCreateCallback = GetFastValue(config, "internalCreateCallback", null);
          this.internalRemoveCallback = GetFastValue(config, "internalRemoveCallback", null);
          if (children) {
            this.addMultiple(children);
          }
          if (config) {
            this.createMultiple(config);
          }
          this.on(Events.ADDED_TO_SCENE, this.addedToScene, this);
          this.on(Events.REMOVED_FROM_SCENE, this.removedFromScene, this);
        },
        addedToScene: function() {
          this.scene.sys.updateList.add(this);
        },
        removedFromScene: function() {
          this.scene.sys.updateList.remove(this);
        },
        create: function(x, y, key, frame, visible, active) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (key === void 0) {
            key = this.defaultKey;
          }
          if (frame === void 0) {
            frame = this.defaultFrame;
          }
          if (visible === void 0) {
            visible = true;
          }
          if (active === void 0) {
            active = true;
          }
          if (this.isFull()) {
            return null;
          }
          var child = new this.classType(this.scene, x, y, key, frame);
          child.addToDisplayList(this.scene.sys.displayList);
          child.addToUpdateList();
          child.visible = visible;
          child.setActive(active);
          this.add(child);
          return child;
        },
        createMultiple: function(config) {
          if (this.isFull()) {
            return [];
          }
          if (!Array.isArray(config)) {
            config = [config];
          }
          var output = [];
          if (config[0].key) {
            for (var i = 0; i < config.length; i++) {
              var entries = this.createFromConfig(config[i]);
              output = output.concat(entries);
            }
          }
          return output;
        },
        createFromConfig: function(options) {
          if (this.isFull()) {
            return [];
          }
          this.classType = GetFastValue(options, "classType", this.classType);
          var key = GetFastValue(options, "key", void 0);
          var frame = GetFastValue(options, "frame", null);
          var visible = GetFastValue(options, "visible", true);
          var active = GetFastValue(options, "active", true);
          var entries = [];
          if (key === void 0) {
            return entries;
          } else {
            if (!Array.isArray(key)) {
              key = [key];
            }
            if (!Array.isArray(frame)) {
              frame = [frame];
            }
          }
          var repeat = GetFastValue(options, "repeat", 0);
          var randomKey = GetFastValue(options, "randomKey", false);
          var randomFrame = GetFastValue(options, "randomFrame", false);
          var yoyo = GetFastValue(options, "yoyo", false);
          var quantity = GetFastValue(options, "quantity", false);
          var frameQuantity = GetFastValue(options, "frameQuantity", 1);
          var max = GetFastValue(options, "max", 0);
          var range = Range(key, frame, {
            max: max,
            qty: quantity ? quantity : frameQuantity,
            random: randomKey,
            randomB: randomFrame,
            repeat: repeat,
            yoyo: yoyo
          });
          if (options.createCallback) {
            this.createCallback = options.createCallback;
          }
          if (options.removeCallback) {
            this.removeCallback = options.removeCallback;
          }
          for (var c = 0; c < range.length; c++) {
            var created = this.create(0, 0, range[c].a, range[c].b, visible, active);
            if (!created) {
              break;
            }
            entries.push(created);
          }
          if (HasValue(options, "setXY")) {
            var x = GetValue(options, "setXY.x", 0);
            var y = GetValue(options, "setXY.y", 0);
            var stepX = GetValue(options, "setXY.stepX", 0);
            var stepY = GetValue(options, "setXY.stepY", 0);
            Actions.SetXY(entries, x, y, stepX, stepY);
          }
          if (HasValue(options, "setRotation")) {
            var rotation = GetValue(options, "setRotation.value", 0);
            var stepRotation = GetValue(options, "setRotation.step", 0);
            Actions.SetRotation(entries, rotation, stepRotation);
          }
          if (HasValue(options, "setScale")) {
            var scaleX = GetValue(options, "setScale.x", 1);
            var scaleY = GetValue(options, "setScale.y", scaleX);
            var stepScaleX = GetValue(options, "setScale.stepX", 0);
            var stepScaleY = GetValue(options, "setScale.stepY", 0);
            Actions.SetScale(entries, scaleX, scaleY, stepScaleX, stepScaleY);
          }
          if (HasValue(options, "setOrigin")) {
            var originX = GetValue(options, "setOrigin.x", 0.5);
            var originY = GetValue(options, "setOrigin.y", originX);
            var stepOriginX = GetValue(options, "setOrigin.stepX", 0);
            var stepOriginY = GetValue(options, "setOrigin.stepY", 0);
            Actions.SetOrigin(entries, originX, originY, stepOriginX, stepOriginY);
          }
          if (HasValue(options, "setAlpha")) {
            var alpha = GetValue(options, "setAlpha.value", 1);
            var stepAlpha = GetValue(options, "setAlpha.step", 0);
            Actions.SetAlpha(entries, alpha, stepAlpha);
          }
          if (HasValue(options, "setDepth")) {
            var depth = GetValue(options, "setDepth.value", 0);
            var stepDepth = GetValue(options, "setDepth.step", 0);
            Actions.SetDepth(entries, depth, stepDepth);
          }
          if (HasValue(options, "setScrollFactor")) {
            var scrollFactorX = GetValue(options, "setScrollFactor.x", 1);
            var scrollFactorY = GetValue(options, "setScrollFactor.y", scrollFactorX);
            var stepScrollFactorX = GetValue(options, "setScrollFactor.stepX", 0);
            var stepScrollFactorY = GetValue(options, "setScrollFactor.stepY", 0);
            Actions.SetScrollFactor(entries, scrollFactorX, scrollFactorY, stepScrollFactorX, stepScrollFactorY);
          }
          var hitArea = GetFastValue(options, "hitArea", null);
          var hitAreaCallback = GetFastValue(options, "hitAreaCallback", null);
          if (hitArea) {
            Actions.SetHitArea(entries, hitArea, hitAreaCallback);
          }
          var grid = GetFastValue(options, "gridAlign", false);
          if (grid) {
            Actions.GridAlign(entries, grid);
          }
          if (this.createMultipleCallback) {
            this.createMultipleCallback.call(this, entries);
          }
          return entries;
        },
        preUpdate: function(time, delta) {
          if (!this.runChildUpdate || this.children.size === 0) {
            return;
          }
          var temp = this.children.entries.slice();
          for (var i = 0; i < temp.length; i++) {
            var item = temp[i];
            if (item.active) {
              item.update(time, delta);
            }
          }
        },
        add: function(child, addToScene) {
          if (addToScene === void 0) {
            addToScene = false;
          }
          if (this.isFull()) {
            return this;
          }
          this.children.set(child);
          if (this.internalCreateCallback) {
            this.internalCreateCallback.call(this, child);
          }
          if (this.createCallback) {
            this.createCallback.call(this, child);
          }
          if (addToScene) {
            child.addToDisplayList(this.scene.sys.displayList);
            child.addToUpdateList();
          }
          child.on(Events.DESTROY, this.remove, this);
          return this;
        },
        addMultiple: function(children, addToScene) {
          if (addToScene === void 0) {
            addToScene = false;
          }
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              this.add(children[i], addToScene);
            }
          }
          return this;
        },
        remove: function(child, removeFromScene, destroyChild) {
          if (removeFromScene === void 0) {
            removeFromScene = false;
          }
          if (destroyChild === void 0) {
            destroyChild = false;
          }
          if (!this.children.contains(child)) {
            return this;
          }
          this.children.delete(child);
          if (this.internalRemoveCallback) {
            this.internalRemoveCallback.call(this, child);
          }
          if (this.removeCallback) {
            this.removeCallback.call(this, child);
          }
          child.off(Events.DESTROY, this.remove, this);
          if (destroyChild) {
            child.destroy();
          } else if (removeFromScene) {
            child.removeFromDisplayList();
            child.removeFromUpdateList();
          }
          return this;
        },
        clear: function(removeFromScene, destroyChild) {
          if (removeFromScene === void 0) {
            removeFromScene = false;
          }
          if (destroyChild === void 0) {
            destroyChild = false;
          }
          var children = this.children;
          for (var i = 0; i < children.size; i++) {
            var gameObject = children.entries[i];
            gameObject.off(Events.DESTROY, this.remove, this);
            if (destroyChild) {
              gameObject.destroy();
            } else if (removeFromScene) {
              gameObject.removeFromDisplayList();
              gameObject.removeFromUpdateList();
            }
          }
          this.children.clear();
          return this;
        },
        contains: function(child) {
          return this.children.contains(child);
        },
        getChildren: function() {
          return this.children.entries;
        },
        getLength: function() {
          return this.children.size;
        },
        getMatching: function(property, value, startIndex, endIndex) {
          return GetAll(this.children.entries, property, value, startIndex, endIndex);
        },
        getFirst: function(state, createIfNull, x, y, key, frame, visible) {
          return this.getHandler(true, 1, state, createIfNull, x, y, key, frame, visible);
        },
        getFirstNth: function(nth, state, createIfNull, x, y, key, frame, visible) {
          return this.getHandler(true, nth, state, createIfNull, x, y, key, frame, visible);
        },
        getLast: function(state, createIfNull, x, y, key, frame, visible) {
          return this.getHandler(false, 1, state, createIfNull, x, y, key, frame, visible);
        },
        getLastNth: function(nth, state, createIfNull, x, y, key, frame, visible) {
          return this.getHandler(false, nth, state, createIfNull, x, y, key, frame, visible);
        },
        getHandler: function(forwards, nth, state, createIfNull, x, y, key, frame, visible) {
          if (state === void 0) {
            state = false;
          }
          if (createIfNull === void 0) {
            createIfNull = false;
          }
          var gameObject;
          var i;
          var total = 0;
          var children = this.children.entries;
          if (forwards) {
            for (i = 0; i < children.length; i++) {
              gameObject = children[i];
              if (gameObject.active === state) {
                total++;
                if (total === nth) {
                  break;
                }
              } else {
                gameObject = null;
              }
            }
          } else {
            for (i = children.length - 1; i >= 0; i--) {
              gameObject = children[i];
              if (gameObject.active === state) {
                total++;
                if (total === nth) {
                  break;
                }
              } else {
                gameObject = null;
              }
            }
          }
          if (gameObject) {
            if (typeof x === "number") {
              gameObject.x = x;
            }
            if (typeof y === "number") {
              gameObject.y = y;
            }
            return gameObject;
          }
          if (createIfNull) {
            return this.create(x, y, key, frame, visible);
          } else {
            return null;
          }
        },
        get: function(x, y, key, frame, visible) {
          return this.getFirst(false, true, x, y, key, frame, visible);
        },
        getFirstAlive: function(createIfNull, x, y, key, frame, visible) {
          return this.getFirst(true, createIfNull, x, y, key, frame, visible);
        },
        getFirstDead: function(createIfNull, x, y, key, frame, visible) {
          return this.getFirst(false, createIfNull, x, y, key, frame, visible);
        },
        playAnimation: function(key, startFrame) {
          Actions.PlayAnimation(this.children.entries, key, startFrame);
          return this;
        },
        isFull: function() {
          if (this.maxSize === -1) {
            return false;
          } else {
            return this.children.size >= this.maxSize;
          }
        },
        countActive: function(value) {
          if (value === void 0) {
            value = true;
          }
          var total = 0;
          for (var i = 0; i < this.children.size; i++) {
            if (this.children.entries[i].active === value) {
              total++;
            }
          }
          return total;
        },
        getTotalUsed: function() {
          return this.countActive();
        },
        getTotalFree: function() {
          var used = this.getTotalUsed();
          var capacity = this.maxSize === -1 ? 999999999999 : this.maxSize;
          return capacity - used;
        },
        setActive: function(value) {
          this.active = value;
          return this;
        },
        setName: function(value) {
          this.name = value;
          return this;
        },
        propertyValueSet: function(key, value, step, index, direction) {
          Actions.PropertyValueSet(this.children.entries, key, value, step, index, direction);
          return this;
        },
        propertyValueInc: function(key, value, step, index, direction) {
          Actions.PropertyValueInc(this.children.entries, key, value, step, index, direction);
          return this;
        },
        setX: function(value, step) {
          Actions.SetX(this.children.entries, value, step);
          return this;
        },
        setY: function(value, step) {
          Actions.SetY(this.children.entries, value, step);
          return this;
        },
        setXY: function(x, y, stepX, stepY) {
          Actions.SetXY(this.children.entries, x, y, stepX, stepY);
          return this;
        },
        incX: function(value, step) {
          Actions.IncX(this.children.entries, value, step);
          return this;
        },
        incY: function(value, step) {
          Actions.IncY(this.children.entries, value, step);
          return this;
        },
        incXY: function(x, y, stepX, stepY) {
          Actions.IncXY(this.children.entries, x, y, stepX, stepY);
          return this;
        },
        shiftPosition: function(x, y, direction) {
          Actions.ShiftPosition(this.children.entries, x, y, direction);
          return this;
        },
        angle: function(value, step) {
          Actions.Angle(this.children.entries, value, step);
          return this;
        },
        rotate: function(value, step) {
          Actions.Rotate(this.children.entries, value, step);
          return this;
        },
        rotateAround: function(point, angle) {
          Actions.RotateAround(this.children.entries, point, angle);
          return this;
        },
        rotateAroundDistance: function(point, angle, distance) {
          Actions.RotateAroundDistance(this.children.entries, point, angle, distance);
          return this;
        },
        setAlpha: function(value, step) {
          Actions.SetAlpha(this.children.entries, value, step);
          return this;
        },
        setTint: function(topLeft, topRight, bottomLeft, bottomRight) {
          Actions.SetTint(this.children.entries, topLeft, topRight, bottomLeft, bottomRight);
          return this;
        },
        setOrigin: function(originX, originY, stepX, stepY) {
          Actions.SetOrigin(this.children.entries, originX, originY, stepX, stepY);
          return this;
        },
        scaleX: function(value, step) {
          Actions.ScaleX(this.children.entries, value, step);
          return this;
        },
        scaleY: function(value, step) {
          Actions.ScaleY(this.children.entries, value, step);
          return this;
        },
        scaleXY: function(scaleX, scaleY, stepX, stepY) {
          Actions.ScaleXY(this.children.entries, scaleX, scaleY, stepX, stepY);
          return this;
        },
        setDepth: function(value, step) {
          Actions.SetDepth(this.children.entries, value, step);
          return this;
        },
        setBlendMode: function(value) {
          Actions.SetBlendMode(this.children.entries, value);
          return this;
        },
        setHitArea: function(hitArea, hitAreaCallback) {
          Actions.SetHitArea(this.children.entries, hitArea, hitAreaCallback);
          return this;
        },
        shuffle: function() {
          Actions.Shuffle(this.children.entries);
          return this;
        },
        kill: function(gameObject) {
          if (this.children.contains(gameObject)) {
            gameObject.setActive(false);
          }
        },
        killAndHide: function(gameObject) {
          if (this.children.contains(gameObject)) {
            gameObject.setActive(false);
            gameObject.setVisible(false);
          }
        },
        setVisible: function(value, index, direction) {
          Actions.SetVisible(this.children.entries, value, index, direction);
          return this;
        },
        toggleVisible: function() {
          Actions.ToggleVisible(this.children.entries);
          return this;
        },
        destroy: function(destroyChildren, removeFromScene) {
          if (destroyChildren === void 0) {
            destroyChildren = false;
          }
          if (removeFromScene === void 0) {
            removeFromScene = false;
          }
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          this.emit(Events.DESTROY, this);
          this.removeAllListeners();
          this.scene.sys.updateList.remove(this);
          this.clear(removeFromScene, destroyChildren);
          this.scene = void 0;
          this.children = void 0;
        }
      });
      module.exports = Group;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/text/GetTextSize.js
  var require_GetTextSize = __commonJS({
    "../../node_modules/phaser/src/gameobjects/text/GetTextSize.js": function(exports, module) {
      var GetTextSize = function(text, size, lines) {
        var canvas = text.canvas;
        var context = text.context;
        var style = text.style;
        var lineWidths = [];
        var maxLineWidth = 0;
        var drawnLines = lines.length;
        if (style.maxLines > 0 && style.maxLines < lines.length) {
          drawnLines = style.maxLines;
        }
        style.syncFont(canvas, context);
        for (var i = 0; i < drawnLines; i++) {
          var lineWidth = style.strokeThickness;
          lineWidth += context.measureText(lines[i]).width;
          if (style.wordWrap) {
            lineWidth -= context.measureText(" ").width;
          }
          lineWidths[i] = Math.ceil(lineWidth);
          maxLineWidth = Math.max(maxLineWidth, lineWidths[i]);
        }
        var lineHeight = size.fontSize + style.strokeThickness;
        var height = lineHeight * drawnLines;
        var lineSpacing = text.lineSpacing;
        if (drawnLines > 1) {
          height += lineSpacing * (drawnLines - 1);
        }
        return {
          width: maxLineWidth,
          height: height,
          lines: drawnLines,
          lineWidths: lineWidths,
          lineSpacing: lineSpacing,
          lineHeight: lineHeight
        };
      };
      module.exports = GetTextSize;
    }
  });

  // ../../node_modules/phaser/src/dom/RemoveFromDOM.js
  var require_RemoveFromDOM = __commonJS({
    "../../node_modules/phaser/src/dom/RemoveFromDOM.js": function(exports, module) {
      var RemoveFromDOM = function(element) {
        if (element.parentNode) {
          element.parentNode.removeChild(element);
        }
      };
      module.exports = RemoveFromDOM;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/text/TextWebGLRenderer.js
  var require_TextWebGLRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/text/TextWebGLRenderer.js": function(exports, module) {
      var Utils = require_Utils();
      var TextWebGLRenderer = function(renderer, src, camera, parentMatrix) {
        if (src.width === 0 || src.height === 0) {
          return;
        }
        camera.addToRenderList(src);
        var frame = src.frame;
        var width = frame.width;
        var height = frame.height;
        var getTint = Utils.getTintAppendFloatAlpha;
        var pipeline = renderer.pipelines.set(src.pipeline, src);
        var textureUnit = pipeline.setTexture2D(frame.glTexture, src);
        pipeline.batchTexture(src, frame.glTexture, width, height, src.x, src.y, width / src.style.resolution, height / src.style.resolution, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.displayOriginX, src.displayOriginY, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, 0, 0, camera, parentMatrix, false, textureUnit);
      };
      module.exports = TextWebGLRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/text/TextCanvasRenderer.js
  var require_TextCanvasRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/text/TextCanvasRenderer.js": function(exports, module) {
      var TextCanvasRenderer = function(renderer, src, camera, parentMatrix) {
        if (src.width === 0 || src.height === 0) {
          return;
        }
        camera.addToRenderList(src);
        renderer.batchSprite(src, src.frame, camera, parentMatrix);
      };
      module.exports = TextCanvasRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/text/TextRender.js
  var require_TextRender = __commonJS({
    "../../node_modules/phaser/src/gameobjects/text/TextRender.js": function(exports, module) {
      var NOOP = require_NOOP();
      var renderWebGL = NOOP;
      var renderCanvas = NOOP;
      if (true) {
        renderWebGL = require_TextWebGLRenderer();
      }
      if (true) {
        renderCanvas = require_TextCanvasRenderer();
      }
      module.exports = {
        renderWebGL: renderWebGL,
        renderCanvas: renderCanvas
      };
    }
  });

  // ../../node_modules/phaser/src/gameobjects/text/MeasureText.js
  var require_MeasureText = __commonJS({
    "../../node_modules/phaser/src/gameobjects/text/MeasureText.js": function(exports, module) {
      var CanvasPool = require_CanvasPool();
      var MeasureText = function(textStyle) {
        var canvas = CanvasPool.create(this);
        var context = canvas.getContext("2d", { willReadFrequently: true });
        textStyle.syncFont(canvas, context);
        var metrics = context.measureText(textStyle.testString);
        if ("actualBoundingBoxAscent" in metrics) {
          var ascent = metrics.actualBoundingBoxAscent;
          var descent = metrics.actualBoundingBoxDescent;
          CanvasPool.remove(canvas);
          return {
            ascent: ascent,
            descent: descent,
            fontSize: ascent + descent
          };
        }
        var width = Math.ceil(metrics.width * textStyle.baselineX);
        var baseline = width;
        var height = 2 * baseline;
        baseline = baseline * textStyle.baselineY | 0;
        canvas.width = width;
        canvas.height = height;
        context.fillStyle = "#f00";
        context.fillRect(0, 0, width, height);
        context.font = textStyle._font;
        context.textBaseline = "alphabetic";
        context.fillStyle = "#000";
        context.fillText(textStyle.testString, 0, baseline);
        var output = {
          ascent: 0,
          descent: 0,
          fontSize: 0
        };
        var imagedata = context.getImageData(0, 0, width, height);
        if (!imagedata) {
          output.ascent = baseline;
          output.descent = baseline + 6;
          output.fontSize = output.ascent + output.descent;
          CanvasPool.remove(canvas);
          return output;
        }
        var pixels = imagedata.data;
        var numPixels = pixels.length;
        var line = width * 4;
        var i;
        var j;
        var idx = 0;
        var stop = false;
        for (i = 0; i < baseline; i++) {
          for (j = 0; j < line; j += 4) {
            if (pixels[idx + j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx += line;
          } else {
            break;
          }
        }
        output.ascent = baseline - i;
        idx = numPixels - line;
        stop = false;
        for (i = height; i > baseline; i--) {
          for (j = 0; j < line; j += 4) {
            if (pixels[idx + j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx -= line;
          } else {
            break;
          }
        }
        output.descent = i - baseline;
        output.fontSize = output.ascent + output.descent;
        CanvasPool.remove(canvas);
        return output;
      };
      module.exports = MeasureText;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/text/TextStyle.js
  var require_TextStyle = __commonJS({
    "../../node_modules/phaser/src/gameobjects/text/TextStyle.js": function(exports, module) {
      var Class = require_Class();
      var GetAdvancedValue = require_GetAdvancedValue();
      var GetValue = require_GetValue();
      var MeasureText = require_MeasureText();
      var propertyMap = {
        fontFamily: ["fontFamily", "Courier"],
        fontSize: ["fontSize", "16px"],
        fontStyle: ["fontStyle", ""],
        backgroundColor: ["backgroundColor", null],
        color: ["color", "#fff"],
        stroke: ["stroke", "#fff"],
        strokeThickness: ["strokeThickness", 0],
        shadowOffsetX: ["shadow.offsetX", 0],
        shadowOffsetY: ["shadow.offsetY", 0],
        shadowColor: ["shadow.color", "#000"],
        shadowBlur: ["shadow.blur", 0],
        shadowStroke: ["shadow.stroke", false],
        shadowFill: ["shadow.fill", false],
        align: ["align", "left"],
        maxLines: ["maxLines", 0],
        fixedWidth: ["fixedWidth", 0],
        fixedHeight: ["fixedHeight", 0],
        resolution: ["resolution", 0],
        rtl: ["rtl", false],
        testString: ["testString", "|M\xC3\u2030qgy"],
        baselineX: ["baselineX", 1.2],
        baselineY: ["baselineY", 1.4],
        wordWrapWidth: ["wordWrap.width", null],
        wordWrapCallback: ["wordWrap.callback", null],
        wordWrapCallbackScope: ["wordWrap.callbackScope", null],
        wordWrapUseAdvanced: ["wordWrap.useAdvancedWrap", false]
      };
      var TextStyle = new Class({
        initialize: function TextStyle2(text, style) {
          this.parent = text;
          this.fontFamily;
          this.fontSize;
          this.fontStyle;
          this.backgroundColor;
          this.color;
          this.stroke;
          this.strokeThickness;
          this.shadowOffsetX;
          this.shadowOffsetY;
          this.shadowColor;
          this.shadowBlur;
          this.shadowStroke;
          this.shadowFill;
          this.align;
          this.maxLines;
          this.fixedWidth;
          this.fixedHeight;
          this.resolution;
          this.rtl;
          this.testString;
          this.baselineX;
          this.baselineY;
          this.wordWrapWidth;
          this.wordWrapCallback;
          this.wordWrapCallbackScope;
          this.wordWrapUseAdvanced;
          this._font;
          this.setStyle(style, false, true);
        },
        setStyle: function(style, updateText, setDefaults) {
          if (updateText === void 0) {
            updateText = true;
          }
          if (setDefaults === void 0) {
            setDefaults = false;
          }
          if (style && style.hasOwnProperty("fontSize") && typeof style.fontSize === "number") {
            style.fontSize = style.fontSize.toString() + "px";
          }
          for (var key in propertyMap) {
            var value = setDefaults ? propertyMap[key][1] : this[key];
            if (key === "wordWrapCallback" || key === "wordWrapCallbackScope") {
              this[key] = GetValue(style, propertyMap[key][0], value);
            } else {
              this[key] = GetAdvancedValue(style, propertyMap[key][0], value);
            }
          }
          var font = GetValue(style, "font", null);
          if (font !== null) {
            this.setFont(font, false);
          }
          this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim();
          var fill = GetValue(style, "fill", null);
          if (fill !== null) {
            this.color = fill;
          }
          var metrics = GetValue(style, "metrics", false);
          if (metrics) {
            this.metrics = {
              ascent: GetValue(metrics, "ascent", 0),
              descent: GetValue(metrics, "descent", 0),
              fontSize: GetValue(metrics, "fontSize", 0)
            };
          } else if (updateText || !this.metrics) {
            this.metrics = MeasureText(this);
          }
          if (updateText) {
            return this.parent.updateText();
          } else {
            return this.parent;
          }
        },
        syncFont: function(canvas, context) {
          context.font = this._font;
        },
        syncStyle: function(canvas, context) {
          context.textBaseline = "alphabetic";
          context.fillStyle = this.color;
          context.strokeStyle = this.stroke;
          context.lineWidth = this.strokeThickness;
          context.lineCap = "round";
          context.lineJoin = "round";
        },
        syncShadow: function(context, enabled) {
          if (enabled) {
            context.shadowOffsetX = this.shadowOffsetX;
            context.shadowOffsetY = this.shadowOffsetY;
            context.shadowColor = this.shadowColor;
            context.shadowBlur = this.shadowBlur;
          } else {
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
            context.shadowColor = 0;
            context.shadowBlur = 0;
          }
        },
        update: function(recalculateMetrics) {
          if (recalculateMetrics) {
            this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim();
            this.metrics = MeasureText(this);
          }
          return this.parent.updateText();
        },
        setFont: function(font, updateText) {
          if (updateText === void 0) {
            updateText = true;
          }
          var fontFamily = font;
          var fontSize = "";
          var fontStyle = "";
          if (typeof font !== "string") {
            fontFamily = GetValue(font, "fontFamily", "Courier");
            fontSize = GetValue(font, "fontSize", "16px");
            fontStyle = GetValue(font, "fontStyle", "");
          } else {
            var fontSplit = font.split(" ");
            var i = 0;
            fontStyle = fontSplit.length > 2 ? fontSplit[i++] : "";
            fontSize = fontSplit[i++] || "16px";
            fontFamily = fontSplit[i++] || "Courier";
          }
          if (fontFamily !== this.fontFamily || fontSize !== this.fontSize || fontStyle !== this.fontStyle) {
            this.fontFamily = fontFamily;
            this.fontSize = fontSize;
            this.fontStyle = fontStyle;
            if (updateText) {
              this.update(true);
            }
          }
          return this.parent;
        },
        setFontFamily: function(family) {
          if (this.fontFamily !== family) {
            this.fontFamily = family;
            this.update(true);
          }
          return this.parent;
        },
        setFontStyle: function(style) {
          if (this.fontStyle !== style) {
            this.fontStyle = style;
            this.update(true);
          }
          return this.parent;
        },
        setFontSize: function(size) {
          if (typeof size === "number") {
            size = size.toString() + "px";
          }
          if (this.fontSize !== size) {
            this.fontSize = size;
            this.update(true);
          }
          return this.parent;
        },
        setTestString: function(string) {
          this.testString = string;
          return this.update(true);
        },
        setFixedSize: function(width, height) {
          this.fixedWidth = width;
          this.fixedHeight = height;
          if (width) {
            this.parent.width = width;
          }
          if (height) {
            this.parent.height = height;
          }
          return this.update(false);
        },
        setBackgroundColor: function(color) {
          this.backgroundColor = color;
          return this.update(false);
        },
        setFill: function(color) {
          this.color = color;
          return this.update(false);
        },
        setColor: function(color) {
          this.color = color;
          return this.update(false);
        },
        setResolution: function(value) {
          this.resolution = value;
          return this.update(false);
        },
        setStroke: function(color, thickness) {
          if (thickness === void 0) {
            thickness = this.strokeThickness;
          }
          if (color === void 0 && this.strokeThickness !== 0) {
            this.strokeThickness = 0;
            this.update(true);
          } else if (this.stroke !== color || this.strokeThickness !== thickness) {
            this.stroke = color;
            this.strokeThickness = thickness;
            this.update(true);
          }
          return this.parent;
        },
        setShadow: function(x, y, color, blur, shadowStroke, shadowFill) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (color === void 0) {
            color = "#000";
          }
          if (blur === void 0) {
            blur = 0;
          }
          if (shadowStroke === void 0) {
            shadowStroke = false;
          }
          if (shadowFill === void 0) {
            shadowFill = true;
          }
          this.shadowOffsetX = x;
          this.shadowOffsetY = y;
          this.shadowColor = color;
          this.shadowBlur = blur;
          this.shadowStroke = shadowStroke;
          this.shadowFill = shadowFill;
          return this.update(false);
        },
        setShadowOffset: function(x, y) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = x;
          }
          this.shadowOffsetX = x;
          this.shadowOffsetY = y;
          return this.update(false);
        },
        setShadowColor: function(color) {
          if (color === void 0) {
            color = "#000";
          }
          this.shadowColor = color;
          return this.update(false);
        },
        setShadowBlur: function(blur) {
          if (blur === void 0) {
            blur = 0;
          }
          this.shadowBlur = blur;
          return this.update(false);
        },
        setShadowStroke: function(enabled) {
          this.shadowStroke = enabled;
          return this.update(false);
        },
        setShadowFill: function(enabled) {
          this.shadowFill = enabled;
          return this.update(false);
        },
        setWordWrapWidth: function(width, useAdvancedWrap) {
          if (useAdvancedWrap === void 0) {
            useAdvancedWrap = false;
          }
          this.wordWrapWidth = width;
          this.wordWrapUseAdvanced = useAdvancedWrap;
          return this.update(false);
        },
        setWordWrapCallback: function(callback, scope) {
          if (scope === void 0) {
            scope = null;
          }
          this.wordWrapCallback = callback;
          this.wordWrapCallbackScope = scope;
          return this.update(false);
        },
        setAlign: function(align) {
          if (align === void 0) {
            align = "left";
          }
          this.align = align;
          return this.update(false);
        },
        setMaxLines: function(max) {
          if (max === void 0) {
            max = 0;
          }
          this.maxLines = max;
          return this.update(false);
        },
        getTextMetrics: function() {
          var metrics = this.metrics;
          return {
            ascent: metrics.ascent,
            descent: metrics.descent,
            fontSize: metrics.fontSize
          };
        },
        toJSON: function() {
          var output = {};
          for (var key in propertyMap) {
            output[key] = this[key];
          }
          output.metrics = this.getTextMetrics();
          return output;
        },
        destroy: function() {
          this.parent = void 0;
        }
      });
      module.exports = TextStyle;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/text/Text.js
  var require_Text = __commonJS({
    "../../node_modules/phaser/src/gameobjects/text/Text.js": function(exports, module) {
      var AddToDOM = require_AddToDOM();
      var CanvasPool = require_CanvasPool();
      var Class = require_Class();
      var Components = require_components();
      var GameObject = require_GameObject();
      var GetTextSize = require_GetTextSize();
      var GetValue = require_GetValue();
      var RemoveFromDOM = require_RemoveFromDOM();
      var TextRender = require_TextRender();
      var TextStyle = require_TextStyle();
      var Text = new Class({
        Extends: GameObject,
        Mixins: [
          Components.Alpha,
          Components.BlendMode,
          Components.ComputedSize,
          Components.Crop,
          Components.Depth,
          Components.Flip,
          Components.FX,
          Components.GetBounds,
          Components.Mask,
          Components.Origin,
          Components.Pipeline,
          Components.PostPipeline,
          Components.ScrollFactor,
          Components.Tint,
          Components.Transform,
          Components.Visible,
          TextRender
        ],
        initialize: function Text2(scene, x, y, text, style) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          GameObject.call(this, scene, "Text");
          this.renderer = scene.sys.renderer;
          this.setPosition(x, y);
          this.setOrigin(0, 0);
          this.initPipeline();
          this.initPostPipeline();
          this.canvas = CanvasPool.create(this);
          this.context = this.canvas.getContext("2d");
          this.style = new TextStyle(this, style);
          this.autoRound = true;
          this.splitRegExp = /(?:\r\n|\r|\n)/;
          this._text = void 0;
          this.padding = { left: 0, right: 0, top: 0, bottom: 0 };
          this.width = 1;
          this.height = 1;
          this.lineSpacing = 0;
          this.dirty = false;
          if (this.style.resolution === 0) {
            this.style.resolution = 1;
          }
          this._crop = this.resetCropObject();
          this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);
          this.frame = this.texture.get();
          this.frame.source.resolution = this.style.resolution;
          if (this.renderer && this.renderer.gl) {
            this.renderer.deleteTexture(this.frame.source.glTexture);
            this.frame.source.glTexture = null;
          }
          this.initRTL();
          this.setText(text);
          if (style && style.padding) {
            this.setPadding(style.padding);
          }
          if (style && style.lineSpacing) {
            this.setLineSpacing(style.lineSpacing);
          }
        },
        initRTL: function() {
          if (!this.style.rtl) {
            return;
          }
          this.canvas.dir = "rtl";
          this.context.direction = "rtl";
          this.canvas.style.display = "none";
          AddToDOM(this.canvas, this.scene.sys.canvas);
          this.originX = 1;
        },
        runWordWrap: function(text) {
          var style = this.style;
          if (style.wordWrapCallback) {
            var wrappedLines = style.wordWrapCallback.call(style.wordWrapCallbackScope, text, this);
            if (Array.isArray(wrappedLines)) {
              wrappedLines = wrappedLines.join("\n");
            }
            return wrappedLines;
          } else if (style.wordWrapWidth) {
            if (style.wordWrapUseAdvanced) {
              return this.advancedWordWrap(text, this.context, this.style.wordWrapWidth);
            } else {
              return this.basicWordWrap(text, this.context, this.style.wordWrapWidth);
            }
          } else {
            return text;
          }
        },
        advancedWordWrap: function(text, context, wordWrapWidth) {
          var output = "";
          var lines = text.replace(/ +/gi, " ").split(this.splitRegExp);
          var linesCount = lines.length;
          for (var i = 0; i < linesCount; i++) {
            var line = lines[i];
            var out = "";
            line = line.replace(/^ *|\s*$/gi, "");
            var lineWidth = context.measureText(line).width;
            if (lineWidth < wordWrapWidth) {
              output += line + "\n";
              continue;
            }
            var currentLineWidth = wordWrapWidth;
            var words = line.split(" ");
            for (var j = 0; j < words.length; j++) {
              var word = words[j];
              var wordWithSpace = word + " ";
              var wordWidth = context.measureText(wordWithSpace).width;
              if (wordWidth > currentLineWidth) {
                if (j === 0) {
                  var newWord = wordWithSpace;
                  while (newWord.length) {
                    newWord = newWord.slice(0, -1);
                    wordWidth = context.measureText(newWord).width;
                    if (wordWidth <= currentLineWidth) {
                      break;
                    }
                  }
                  if (!newWord.length) {
                    throw new Error("wordWrapWidth < a single character");
                  }
                  var secondPart = word.substr(newWord.length);
                  words[j] = secondPart;
                  out += newWord;
                }
                var offset = words[j].length ? j : j + 1;
                var remainder = words.slice(offset).join(" ").replace(/[ \n]*$/gi, "");
                lines.splice(i + 1, 0, remainder);
                linesCount = lines.length;
                break;
              } else {
                out += wordWithSpace;
                currentLineWidth -= wordWidth;
              }
            }
            output += out.replace(/[ \n]*$/gi, "") + "\n";
          }
          output = output.replace(/[\s|\n]*$/gi, "");
          return output;
        },
        basicWordWrap: function(text, context, wordWrapWidth) {
          var result = "";
          var lines = text.split(this.splitRegExp);
          var lastLineIndex = lines.length - 1;
          var whiteSpaceWidth = context.measureText(" ").width;
          for (var i = 0; i <= lastLineIndex; i++) {
            var spaceLeft = wordWrapWidth;
            var words = lines[i].split(" ");
            var lastWordIndex = words.length - 1;
            for (var j = 0; j <= lastWordIndex; j++) {
              var word = words[j];
              var wordWidth = context.measureText(word).width;
              var wordWidthWithSpace = wordWidth;
              if (j < lastWordIndex) {
                wordWidthWithSpace += whiteSpaceWidth;
              }
              if (wordWidthWithSpace > spaceLeft) {
                if (j > 0) {
                  result += "\n";
                  spaceLeft = wordWrapWidth;
                }
              }
              result += word;
              if (j < lastWordIndex) {
                result += " ";
                spaceLeft -= wordWidthWithSpace;
              } else {
                spaceLeft -= wordWidth;
              }
            }
            if (i < lastLineIndex) {
              result += "\n";
            }
          }
          return result;
        },
        getWrappedText: function(text) {
          if (text === void 0) {
            text = this._text;
          }
          this.style.syncFont(this.canvas, this.context);
          var wrappedLines = this.runWordWrap(text);
          return wrappedLines.split(this.splitRegExp);
        },
        setText: function(value) {
          if (!value && value !== 0) {
            value = "";
          }
          if (Array.isArray(value)) {
            value = value.join("\n");
          }
          if (value !== this._text) {
            this._text = value.toString();
            this.updateText();
          }
          return this;
        },
        appendText: function(value, addCR) {
          if (addCR === void 0) {
            addCR = true;
          }
          if (!value && value !== 0) {
            value = "";
          }
          if (Array.isArray(value)) {
            value = value.join("\n");
          }
          value = value.toString();
          var newText = this._text.concat(addCR ? "\n" + value : value);
          if (newText !== this._text) {
            this._text = newText;
            this.updateText();
          }
          return this;
        },
        setStyle: function(style) {
          return this.style.setStyle(style);
        },
        setFont: function(font) {
          return this.style.setFont(font);
        },
        setFontFamily: function(family) {
          return this.style.setFontFamily(family);
        },
        setFontSize: function(size) {
          return this.style.setFontSize(size);
        },
        setFontStyle: function(style) {
          return this.style.setFontStyle(style);
        },
        setFixedSize: function(width, height) {
          return this.style.setFixedSize(width, height);
        },
        setBackgroundColor: function(color) {
          return this.style.setBackgroundColor(color);
        },
        setFill: function(fillStyle) {
          return this.style.setFill(fillStyle);
        },
        setColor: function(color) {
          return this.style.setColor(color);
        },
        setStroke: function(color, thickness) {
          return this.style.setStroke(color, thickness);
        },
        setShadow: function(x, y, color, blur, shadowStroke, shadowFill) {
          return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
        },
        setShadowOffset: function(x, y) {
          return this.style.setShadowOffset(x, y);
        },
        setShadowColor: function(color) {
          return this.style.setShadowColor(color);
        },
        setShadowBlur: function(blur) {
          return this.style.setShadowBlur(blur);
        },
        setShadowStroke: function(enabled) {
          return this.style.setShadowStroke(enabled);
        },
        setShadowFill: function(enabled) {
          return this.style.setShadowFill(enabled);
        },
        setWordWrapWidth: function(width, useAdvancedWrap) {
          return this.style.setWordWrapWidth(width, useAdvancedWrap);
        },
        setWordWrapCallback: function(callback, scope) {
          return this.style.setWordWrapCallback(callback, scope);
        },
        setAlign: function(align) {
          return this.style.setAlign(align);
        },
        setResolution: function(value) {
          return this.style.setResolution(value);
        },
        setLineSpacing: function(value) {
          this.lineSpacing = value;
          return this.updateText();
        },
        setPadding: function(left, top, right, bottom) {
          if (typeof left === "object") {
            var config = left;
            var x = GetValue(config, "x", null);
            if (x !== null) {
              left = x;
              right = x;
            } else {
              left = GetValue(config, "left", 0);
              right = GetValue(config, "right", left);
            }
            var y = GetValue(config, "y", null);
            if (y !== null) {
              top = y;
              bottom = y;
            } else {
              top = GetValue(config, "top", 0);
              bottom = GetValue(config, "bottom", top);
            }
          } else {
            if (left === void 0) {
              left = 0;
            }
            if (top === void 0) {
              top = left;
            }
            if (right === void 0) {
              right = left;
            }
            if (bottom === void 0) {
              bottom = top;
            }
          }
          this.padding.left = left;
          this.padding.top = top;
          this.padding.right = right;
          this.padding.bottom = bottom;
          return this.updateText();
        },
        setMaxLines: function(max) {
          return this.style.setMaxLines(max);
        },
        updateText: function() {
          var canvas = this.canvas;
          var context = this.context;
          var style = this.style;
          var resolution = style.resolution;
          var size = style.metrics;
          style.syncFont(canvas, context);
          var outputText = this._text;
          if (style.wordWrapWidth || style.wordWrapCallback) {
            outputText = this.runWordWrap(this._text);
          }
          var lines = outputText.split(this.splitRegExp);
          var textSize = GetTextSize(this, size, lines);
          var padding = this.padding;
          var textWidth;
          if (style.fixedWidth === 0) {
            this.width = textSize.width + padding.left + padding.right;
            textWidth = textSize.width;
          } else {
            this.width = style.fixedWidth;
            textWidth = this.width - padding.left - padding.right;
            if (textWidth < textSize.width) {
              textWidth = textSize.width;
            }
          }
          if (style.fixedHeight === 0) {
            this.height = textSize.height + padding.top + padding.bottom;
          } else {
            this.height = style.fixedHeight;
          }
          var w = this.width;
          var h = this.height;
          this.updateDisplayOrigin();
          w *= resolution;
          h *= resolution;
          w = Math.max(w, 1);
          h = Math.max(h, 1);
          if (canvas.width !== w || canvas.height !== h) {
            canvas.width = w;
            canvas.height = h;
            this.frame.setSize(w, h);
            style.syncFont(canvas, context);
            if (style.rtl) {
              context.direction = "rtl";
            }
          } else {
            context.clearRect(0, 0, w, h);
          }
          context.save();
          context.scale(resolution, resolution);
          if (style.backgroundColor) {
            context.fillStyle = style.backgroundColor;
            context.fillRect(0, 0, w, h);
          }
          style.syncStyle(canvas, context);
          context.translate(padding.left, padding.top);
          var linePositionX;
          var linePositionY;
          for (var i = 0; i < textSize.lines; i++) {
            linePositionX = style.strokeThickness / 2;
            linePositionY = style.strokeThickness / 2 + i * textSize.lineHeight + size.ascent;
            if (i > 0) {
              linePositionY += textSize.lineSpacing * i;
            }
            if (style.rtl) {
              linePositionX = w - linePositionX - padding.left - padding.right;
            } else if (style.align === "right") {
              linePositionX += textWidth - textSize.lineWidths[i];
            } else if (style.align === "center") {
              linePositionX += (textWidth - textSize.lineWidths[i]) / 2;
            } else if (style.align === "justify") {
              var minimumLengthToApplyJustification = 0.85;
              if (textSize.lineWidths[i] / textSize.width >= minimumLengthToApplyJustification) {
                var extraSpace = textSize.width - textSize.lineWidths[i];
                var spaceSize = context.measureText(" ").width;
                var trimmedLine = lines[i].trim();
                var array = trimmedLine.split(" ");
                extraSpace += (lines[i].length - trimmedLine.length) * spaceSize;
                var extraSpaceCharacters = Math.floor(extraSpace / spaceSize);
                var idx = 0;
                while (extraSpaceCharacters > 0) {
                  array[idx] += " ";
                  idx = (idx + 1) % (array.length - 1 || 1);
                  --extraSpaceCharacters;
                }
                lines[i] = array.join(" ");
              }
            }
            if (this.autoRound) {
              linePositionX = Math.round(linePositionX);
              linePositionY = Math.round(linePositionY);
            }
            if (style.strokeThickness) {
              style.syncShadow(context, style.shadowStroke);
              context.strokeText(lines[i], linePositionX, linePositionY);
            }
            if (style.color) {
              style.syncShadow(context, style.shadowFill);
              context.fillText(lines[i], linePositionX, linePositionY);
            }
          }
          context.restore();
          if (this.renderer && this.renderer.gl) {
            this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);
            this.frame.glTexture = this.frame.source.glTexture;
            if (false) {
              this.frame.glTexture.__SPECTOR_Metadata = { textureKey: "Text Game Object" };
            }
          }
          this.dirty = true;
          var input = this.input;
          if (input && !input.customHitArea) {
            input.hitArea.width = this.width;
            input.hitArea.height = this.height;
          }
          return this;
        },
        getTextMetrics: function() {
          return this.style.getTextMetrics();
        },
        text: {
          get: function() {
            return this._text;
          },
          set: function(value) {
            this.setText(value);
          }
        },
        toJSON: function() {
          var out = Components.ToJSON(this);
          var data = {
            autoRound: this.autoRound,
            text: this._text,
            style: this.style.toJSON(),
            padding: {
              left: this.padding.left,
              right: this.padding.right,
              top: this.padding.top,
              bottom: this.padding.bottom
            }
          };
          out.data = data;
          return out;
        },
        preDestroy: function() {
          if (this.style.rtl) {
            RemoveFromDOM(this.canvas);
          }
          CanvasPool.remove(this.canvas);
          this.texture.destroy();
        }
      });
      module.exports = Text;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/bitmaptext/GetBitmapTextSize.js
  var require_GetBitmapTextSize = __commonJS({
    "../../node_modules/phaser/src/gameobjects/bitmaptext/GetBitmapTextSize.js": function(exports, module) {
      var GetBitmapTextSize = function(src, round, updateOrigin, out) {
        if (updateOrigin === void 0) {
          updateOrigin = false;
        }
        if (out === void 0) {
          out = {
            local: {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            },
            global: {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            },
            lines: {
              shortest: 0,
              longest: 0,
              lengths: null,
              height: 0
            },
            wrappedText: "",
            words: [],
            characters: [],
            scaleX: 0,
            scaleY: 0
          };
          return out;
        }
        var text = src.text;
        var textLength = text.length;
        var maxWidth = src.maxWidth;
        var wordWrapCharCode = src.wordWrapCharCode;
        var bx = Number.MAX_VALUE;
        var by = Number.MAX_VALUE;
        var bw = 0;
        var bh = 0;
        var chars = src.fontData.chars;
        var lineHeight = src.fontData.lineHeight;
        var letterSpacing = src.letterSpacing;
        var lineSpacing = src.lineSpacing;
        var xAdvance = 0;
        var yAdvance = 0;
        var charCode = 0;
        var glyph = null;
        var align = src._align;
        var x = 0;
        var y = 0;
        var scale = src.fontSize / src.fontData.size;
        var sx = scale * src.scaleX;
        var sy = scale * src.scaleY;
        var lastGlyph = null;
        var lastCharCode = 0;
        var lineWidths = [];
        var shortestLine = Number.MAX_VALUE;
        var longestLine = 0;
        var currentLine = 0;
        var currentLineWidth = 0;
        var i;
        var words = [];
        var characters = [];
        var current = null;
        if (maxWidth > 0) {
          for (i = 0; i < textLength; i++) {
            charCode = text.charCodeAt(i);
            if (charCode === 10) {
              if (current !== null) {
                words.push({
                  word: current.word,
                  i: current.i,
                  x: current.x * sx,
                  y: current.y * sy,
                  w: current.w * sx,
                  h: current.h * sy,
                  cr: true
                });
                current = null;
              }
              xAdvance = 0;
              yAdvance += lineHeight + lineSpacing;
              lastGlyph = null;
              continue;
            }
            glyph = chars[charCode];
            if (!glyph) {
              continue;
            }
            if (lastGlyph !== null) {
              var glyphKerningOffset = glyph.kerning[lastCharCode];
            }
            if (charCode === wordWrapCharCode) {
              if (current !== null) {
                words.push({
                  word: current.word,
                  i: current.i,
                  x: current.x * sx,
                  y: current.y * sy,
                  w: current.w * sx,
                  h: current.h * sy,
                  cr: false
                });
                current = null;
              }
            } else {
              if (current === null) {
                current = { word: "", i: i, x: xAdvance, y: yAdvance, w: 0, h: lineHeight, cr: false };
              }
              current.word = current.word.concat(text[i]);
              current.w += glyph.xOffset + glyph.xAdvance + (glyphKerningOffset !== void 0 ? glyphKerningOffset : 0);
            }
            xAdvance += glyph.xAdvance + letterSpacing;
            lastGlyph = glyph;
            lastCharCode = charCode;
          }
          if (current !== null) {
            words.push({
              word: current.word,
              i: current.i,
              x: current.x * sx,
              y: current.y * sy,
              w: current.w * sx,
              h: current.h * sy,
              cr: false
            });
          }
          xAdvance = 0;
          yAdvance = 0;
          lastGlyph = null;
          lastCharCode = 0;
          var prev;
          var offset = 0;
          var crs = [];
          for (i = 0; i < words.length; i++) {
            var entry = words[i];
            var left = entry.x;
            var right = entry.x + entry.w;
            if (prev) {
              var diff = left - (prev.x + prev.w);
              offset = left - (diff + prev.w);
              prev = null;
            }
            var checkLeft = left - offset;
            var checkRight = right - offset;
            if (checkLeft > maxWidth || checkRight > maxWidth) {
              crs.push(entry.i - 1);
              if (entry.cr) {
                crs.push(entry.i + entry.word.length);
                offset = 0;
                prev = null;
              } else {
                prev = entry;
              }
            } else if (entry.cr) {
              crs.push(entry.i + entry.word.length);
              offset = 0;
              prev = null;
            }
          }
          var stringInsert = function(str, index, value) {
            return str.substr(0, index) + value + str.substr(index + 1);
          };
          for (i = crs.length - 1; i >= 0; i--) {
            text = stringInsert(text, crs[i], "\n");
          }
          out.wrappedText = text;
          textLength = text.length;
          words = [];
          current = null;
        }
        var charIndex = 0;
        for (i = 0; i < textLength; i++) {
          charCode = text.charCodeAt(i);
          if (charCode === 10) {
            if (current !== null) {
              words.push({
                word: current.word,
                i: current.i,
                x: current.x * sx,
                y: current.y * sy,
                w: current.w * sx,
                h: current.h * sy
              });
              current = null;
            }
            xAdvance = 0;
            yAdvance += lineHeight + lineSpacing;
            lastGlyph = null;
            lineWidths[currentLine] = currentLineWidth;
            if (currentLineWidth > longestLine) {
              longestLine = currentLineWidth;
            }
            if (currentLineWidth < shortestLine) {
              shortestLine = currentLineWidth;
            }
            currentLine++;
            currentLineWidth = 0;
            continue;
          }
          glyph = chars[charCode];
          if (!glyph) {
            continue;
          }
          x = xAdvance;
          y = yAdvance;
          if (lastGlyph !== null) {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += kerningOffset !== void 0 ? kerningOffset : 0;
          }
          if (bx > x) {
            bx = x;
          }
          if (by > y) {
            by = y;
          }
          var gw = x + glyph.xAdvance;
          var gh = y + lineHeight;
          if (bw < gw) {
            bw = gw;
          }
          if (bh < gh) {
            bh = gh;
          }
          var charWidth = glyph.xOffset + glyph.xAdvance + (kerningOffset !== void 0 ? kerningOffset : 0);
          if (charCode === wordWrapCharCode) {
            if (current !== null) {
              words.push({
                word: current.word,
                i: current.i,
                x: current.x * sx,
                y: current.y * sy,
                w: current.w * sx,
                h: current.h * sy
              });
              current = null;
            }
          } else {
            if (current === null) {
              current = { word: "", i: charIndex, x: xAdvance, y: yAdvance, w: 0, h: lineHeight };
            }
            current.word = current.word.concat(text[i]);
            current.w += charWidth;
          }
          characters.push({
            i: charIndex,
            idx: i,
            char: text[i],
            code: charCode,
            x: (glyph.xOffset + x) * scale,
            y: (glyph.yOffset + yAdvance) * scale,
            w: glyph.width * scale,
            h: glyph.height * scale,
            t: yAdvance * scale,
            r: gw * scale,
            b: lineHeight * scale,
            line: currentLine,
            glyph: glyph
          });
          xAdvance += glyph.xAdvance + letterSpacing + (kerningOffset !== void 0 ? kerningOffset : 0);
          lastGlyph = glyph;
          lastCharCode = charCode;
          currentLineWidth = gw * scale;
          charIndex++;
        }
        if (current !== null) {
          words.push({
            word: current.word,
            i: current.i,
            x: current.x * sx,
            y: current.y * sy,
            w: current.w * sx,
            h: current.h * sy
          });
        }
        lineWidths[currentLine] = currentLineWidth;
        if (currentLineWidth > longestLine) {
          longestLine = currentLineWidth;
        }
        if (currentLineWidth < shortestLine) {
          shortestLine = currentLineWidth;
        }
        if (align > 0) {
          for (var c = 0; c < characters.length; c++) {
            var currentChar = characters[c];
            if (align === 1) {
              var ax1 = (longestLine - lineWidths[currentChar.line]) / 2;
              currentChar.x += ax1;
              currentChar.r += ax1;
            } else if (align === 2) {
              var ax2 = longestLine - lineWidths[currentChar.line];
              currentChar.x += ax2;
              currentChar.r += ax2;
            }
          }
        }
        var local = out.local;
        var global = out.global;
        var lines = out.lines;
        local.x = bx * scale;
        local.y = by * scale;
        local.width = bw * scale;
        local.height = bh * scale;
        global.x = src.x - src._displayOriginX + bx * sx;
        global.y = src.y - src._displayOriginY + by * sy;
        global.width = bw * sx;
        global.height = bh * sy;
        lines.shortest = shortestLine;
        lines.longest = longestLine;
        lines.lengths = lineWidths;
        if (round) {
          local.x = Math.ceil(local.x);
          local.y = Math.ceil(local.y);
          local.width = Math.ceil(local.width);
          local.height = Math.ceil(local.height);
          global.x = Math.ceil(global.x);
          global.y = Math.ceil(global.y);
          global.width = Math.ceil(global.width);
          global.height = Math.ceil(global.height);
          lines.shortest = Math.ceil(shortestLine);
          lines.longest = Math.ceil(longestLine);
        }
        if (updateOrigin) {
          src._displayOriginX = src.originX * local.width;
          src._displayOriginY = src.originY * local.height;
          global.x = src.x - src._displayOriginX * src.scaleX;
          global.y = src.y - src._displayOriginY * src.scaleY;
          if (round) {
            global.x = Math.ceil(global.x);
            global.y = Math.ceil(global.y);
          }
        }
        out.words = words;
        out.characters = characters;
        out.lines.height = lineHeight;
        out.scale = scale;
        out.scaleX = src.scaleX;
        out.scaleY = src.scaleY;
        return out;
      };
      module.exports = GetBitmapTextSize;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/bitmaptext/ParseXMLBitmapFont.js
  var require_ParseXMLBitmapFont = __commonJS({
    "../../node_modules/phaser/src/gameobjects/bitmaptext/ParseXMLBitmapFont.js": function(exports, module) {
      function getValue(node, attribute) {
        return parseInt(node.getAttribute(attribute), 10);
      }
      var ParseXMLBitmapFont = function(xml, frame, xSpacing, ySpacing, texture) {
        if (xSpacing === void 0) {
          xSpacing = 0;
        }
        if (ySpacing === void 0) {
          ySpacing = 0;
        }
        var textureX = frame.cutX;
        var textureY = frame.cutY;
        var textureWidth = frame.source.width;
        var textureHeight = frame.source.height;
        var sourceIndex = frame.sourceIndex;
        var data = {};
        var info = xml.getElementsByTagName("info")[0];
        var common = xml.getElementsByTagName("common")[0];
        data.font = info.getAttribute("face");
        data.size = getValue(info, "size");
        data.lineHeight = getValue(common, "lineHeight") + ySpacing;
        data.chars = {};
        var letters = xml.getElementsByTagName("char");
        var adjustForTrim = frame !== void 0 && frame.trimmed;
        if (adjustForTrim) {
          var top = frame.height;
          var left = frame.width;
        }
        for (var i = 0; i < letters.length; i++) {
          var node = letters[i];
          var charCode = getValue(node, "id");
          var letter = String.fromCharCode(charCode);
          var gx = getValue(node, "x");
          var gy = getValue(node, "y");
          var gw = getValue(node, "width");
          var gh = getValue(node, "height");
          if (adjustForTrim) {
            if (gx < left) {
              left = gx;
            }
            if (gy < top) {
              top = gy;
            }
          }
          if (adjustForTrim && top !== 0 && left !== 0) {
            gx -= frame.x;
            gy -= frame.y;
          }
          var u0 = (textureX + gx) / textureWidth;
          var v0 = (textureY + gy) / textureHeight;
          var u1 = (textureX + gx + gw) / textureWidth;
          var v1 = (textureY + gy + gh) / textureHeight;
          data.chars[charCode] = {
            x: gx,
            y: gy,
            width: gw,
            height: gh,
            centerX: Math.floor(gw / 2),
            centerY: Math.floor(gh / 2),
            xOffset: getValue(node, "xoffset"),
            yOffset: getValue(node, "yoffset"),
            xAdvance: getValue(node, "xadvance") + xSpacing,
            data: {},
            kerning: {},
            u0: u0,
            v0: v0,
            u1: u1,
            v1: v1
          };
          if (texture && gw !== 0 && gh !== 0) {
            var charFrame = texture.add(letter, sourceIndex, gx, gy, gw, gh);
            if (charFrame) {
              charFrame.setUVs(gw, gh, u0, v0, u1, v1);
            }
          }
        }
        var kernings = xml.getElementsByTagName("kerning");
        for (i = 0; i < kernings.length; i++) {
          var kern = kernings[i];
          var first = getValue(kern, "first");
          var second = getValue(kern, "second");
          var amount = getValue(kern, "amount");
          data.chars[second].kerning[first] = amount;
        }
        return data;
      };
      module.exports = ParseXMLBitmapFont;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/bitmaptext/ParseFromAtlas.js
  var require_ParseFromAtlas = __commonJS({
    "../../node_modules/phaser/src/gameobjects/bitmaptext/ParseFromAtlas.js": function(exports, module) {
      var ParseXMLBitmapFont = require_ParseXMLBitmapFont();
      var ParseFromAtlas = function(scene, fontName, textureKey, frameKey, xmlKey, xSpacing, ySpacing) {
        var texture = scene.sys.textures.get(textureKey);
        var frame = texture.get(frameKey);
        var xml = scene.sys.cache.xml.get(xmlKey);
        if (frame && xml) {
          var data = ParseXMLBitmapFont(xml, frame, xSpacing, ySpacing, texture);
          scene.sys.cache.bitmapFont.add(fontName, { data: data, texture: textureKey, frame: frameKey, fromAtlas: true });
          return true;
        } else {
          return false;
        }
      };
      module.exports = ParseFromAtlas;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/bitmaptext/BatchChar.js
  var require_BatchChar = __commonJS({
    "../../node_modules/phaser/src/gameobjects/bitmaptext/BatchChar.js": function(exports, module) {
      var BatchChar = function(pipeline, src, char, glyph, offsetX, offsetY, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit) {
        var x = char.x - src.displayOriginX + offsetX;
        var y = char.y - src.displayOriginY + offsetY;
        var xw = x + char.w;
        var yh = y + char.h;
        var tx0 = calcMatrix.getXRound(x, y, roundPixels);
        var ty0 = calcMatrix.getYRound(x, y, roundPixels);
        var tx1 = calcMatrix.getXRound(x, yh, roundPixels);
        var ty1 = calcMatrix.getYRound(x, yh, roundPixels);
        var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);
        var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);
        var tx3 = calcMatrix.getXRound(xw, y, roundPixels);
        var ty3 = calcMatrix.getYRound(xw, y, roundPixels);
        pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, glyph.u0, glyph.v0, glyph.u1, glyph.v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
      };
      module.exports = BatchChar;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextWebGLRenderer.js
  var require_BitmapTextWebGLRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextWebGLRenderer.js": function(exports, module) {
      var BatchChar = require_BatchChar();
      var GetCalcMatrix = require_GetCalcMatrix();
      var Utils = require_Utils();
      var BitmapTextWebGLRenderer = function(renderer, src, camera, parentMatrix) {
        var text = src._text;
        var textLength = text.length;
        if (textLength === 0) {
          return;
        }
        camera.addToRenderList(src);
        var pipeline = renderer.pipelines.set(src.pipeline, src);
        var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
        var roundPixels = camera.roundPixels;
        var cameraAlpha = camera.alpha;
        var charColors = src.charColors;
        var tintEffect = src.tintFill;
        var getTint = Utils.getTintAppendFloatAlpha;
        var tintTL = getTint(src.tintTopLeft, cameraAlpha * src._alphaTL);
        var tintTR = getTint(src.tintTopRight, cameraAlpha * src._alphaTR);
        var tintBL = getTint(src.tintBottomLeft, cameraAlpha * src._alphaBL);
        var tintBR = getTint(src.tintBottomRight, cameraAlpha * src._alphaBR);
        var texture = src.frame.glTexture;
        var textureUnit = pipeline.setGameObject(src);
        var bounds = src.getTextBounds(false);
        var i;
        var char;
        var glyph;
        var characters = bounds.characters;
        var dropShadowX = src.dropShadowX;
        var dropShadowY = src.dropShadowY;
        var dropShadow = dropShadowX !== 0 || dropShadowY !== 0;
        renderer.pipelines.preBatch(src);
        if (dropShadow) {
          var srcShadowColor = src.dropShadowColor;
          var srcShadowAlpha = src.dropShadowAlpha;
          var shadowTL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTL);
          var shadowTR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTR);
          var shadowBL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBL);
          var shadowBR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBR);
          for (i = 0; i < characters.length; i++) {
            char = characters[i];
            glyph = char.glyph;
            if (char.code === 32 || glyph.width === 0 || glyph.height === 0) {
              continue;
            }
            BatchChar(pipeline, src, char, glyph, dropShadowX, dropShadowY, calcMatrix, roundPixels, shadowTL, shadowTR, shadowBL, shadowBR, 1, texture, textureUnit);
          }
        }
        for (i = 0; i < characters.length; i++) {
          char = characters[i];
          glyph = char.glyph;
          if (char.code === 32 || glyph.width === 0 || glyph.height === 0) {
            continue;
          }
          if (charColors[char.i]) {
            var color = charColors[char.i];
            var charTintEffect = color.tintEffect;
            var charTintTL = getTint(color.tintTL, cameraAlpha * src._alphaTL);
            var charTintTR = getTint(color.tintTR, cameraAlpha * src._alphaTR);
            var charTintBL = getTint(color.tintBL, cameraAlpha * src._alphaBL);
            var charTintBR = getTint(color.tintBR, cameraAlpha * src._alphaBR);
            BatchChar(pipeline, src, char, glyph, 0, 0, calcMatrix, roundPixels, charTintTL, charTintTR, charTintBL, charTintBR, charTintEffect, texture, textureUnit);
          } else {
            BatchChar(pipeline, src, char, glyph, 0, 0, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
          }
        }
        renderer.pipelines.postBatch(src);
      };
      module.exports = BitmapTextWebGLRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextCanvasRenderer.js
  var require_BitmapTextCanvasRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextCanvasRenderer.js": function(exports, module) {
      var SetTransform = require_SetTransform();
      var BitmapTextCanvasRenderer = function(renderer, src, camera, parentMatrix) {
        var text = src._text;
        var textLength = text.length;
        var ctx = renderer.currentContext;
        if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {
          return;
        }
        camera.addToRenderList(src);
        var textureFrame = src.fromAtlas ? src.frame : src.texture.frames["__BASE"];
        var chars = src.fontData.chars;
        var lineHeight = src.fontData.lineHeight;
        var letterSpacing = src._letterSpacing;
        var lineSpacing = src._lineSpacing;
        var xAdvance = 0;
        var yAdvance = 0;
        var charCode = 0;
        var glyph = null;
        var glyphX = 0;
        var glyphY = 0;
        var glyphW = 0;
        var glyphH = 0;
        var x = 0;
        var y = 0;
        var lastGlyph = null;
        var lastCharCode = 0;
        var image = textureFrame.source.image;
        var textureX = textureFrame.cutX;
        var textureY = textureFrame.cutY;
        var scale = src._fontSize / src.fontData.size;
        var align = src._align;
        var currentLine = 0;
        var lineOffsetX = 0;
        var bounds = src.getTextBounds(false);
        if (src.maxWidth > 0) {
          text = bounds.wrappedText;
          textLength = text.length;
        }
        var lineData = src._bounds.lines;
        if (align === 1) {
          lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
        } else if (align === 2) {
          lineOffsetX = lineData.longest - lineData.lengths[0];
        }
        ctx.translate(-src.displayOriginX, -src.displayOriginY);
        var roundPixels = camera.roundPixels;
        for (var i = 0; i < textLength; i++) {
          charCode = text.charCodeAt(i);
          if (charCode === 10) {
            currentLine++;
            if (align === 1) {
              lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
            } else if (align === 2) {
              lineOffsetX = lineData.longest - lineData.lengths[currentLine];
            }
            xAdvance = 0;
            yAdvance += lineHeight + lineSpacing;
            lastGlyph = null;
            continue;
          }
          glyph = chars[charCode];
          if (!glyph) {
            continue;
          }
          glyphX = textureX + glyph.x;
          glyphY = textureY + glyph.y;
          glyphW = glyph.width;
          glyphH = glyph.height;
          x = glyph.xOffset + xAdvance;
          y = glyph.yOffset + yAdvance;
          if (lastGlyph !== null) {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += kerningOffset !== void 0 ? kerningOffset : 0;
          }
          x *= scale;
          y *= scale;
          x += lineOffsetX;
          xAdvance += glyph.xAdvance + letterSpacing + (kerningOffset !== void 0 ? kerningOffset : 0);
          lastGlyph = glyph;
          lastCharCode = charCode;
          if (glyphW === 0 || glyphH === 0 || charCode === 32) {
            continue;
          }
          if (roundPixels) {
            x = Math.round(x);
            y = Math.round(y);
          }
          ctx.save();
          ctx.translate(x, y);
          ctx.scale(scale, scale);
          ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);
          ctx.restore();
        }
        ctx.restore();
      };
      module.exports = BitmapTextCanvasRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextRender.js
  var require_BitmapTextRender = __commonJS({
    "../../node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextRender.js": function(exports, module) {
      var NOOP = require_NOOP();
      var renderWebGL = NOOP;
      var renderCanvas = NOOP;
      if (true) {
        renderWebGL = require_BitmapTextWebGLRenderer();
      }
      if (true) {
        renderCanvas = require_BitmapTextCanvasRenderer();
      }
      module.exports = {
        renderWebGL: renderWebGL,
        renderCanvas: renderCanvas
      };
    }
  });

  // ../../node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapText.js
  var require_BitmapText = __commonJS({
    "../../node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapText.js": function(exports, module) {
      var Class = require_Class();
      var Clamp = require_Clamp();
      var Components = require_components();
      var GameObject = require_GameObject();
      var GetBitmapTextSize = require_GetBitmapTextSize();
      var ParseFromAtlas = require_ParseFromAtlas();
      var ParseXMLBitmapFont = require_ParseXMLBitmapFont();
      var Rectangle = require_Rectangle();
      var Render = require_BitmapTextRender();
      var BitmapText = new Class({
        Extends: GameObject,
        Mixins: [
          Components.Alpha,
          Components.BlendMode,
          Components.Depth,
          Components.GetBounds,
          Components.Mask,
          Components.Origin,
          Components.Pipeline,
          Components.PostPipeline,
          Components.ScrollFactor,
          Components.Texture,
          Components.Tint,
          Components.Transform,
          Components.Visible,
          Render
        ],
        initialize: function BitmapText2(scene, x, y, font, text, size, align) {
          if (text === void 0) {
            text = "";
          }
          if (align === void 0) {
            align = 0;
          }
          GameObject.call(this, scene, "BitmapText");
          this.font = font;
          var entry = this.scene.sys.cache.bitmapFont.get(font);
          if (!entry) {
            console.warn("Invalid BitmapText key: " + font);
          }
          this.fontData = entry.data;
          this._text = "";
          this._fontSize = size || this.fontData.size;
          this._letterSpacing = 0;
          this._lineSpacing = 0;
          this._align = align;
          this._bounds = GetBitmapTextSize();
          this._dirty = true;
          this._maxWidth = 0;
          this.wordWrapCharCode = 32;
          this.charColors = [];
          this.dropShadowX = 0;
          this.dropShadowY = 0;
          this.dropShadowColor = 0;
          this.dropShadowAlpha = 0.5;
          this.fromAtlas = entry.fromAtlas;
          this.setTexture(entry.texture, entry.frame);
          this.setPosition(x, y);
          this.setOrigin(0, 0);
          this.initPipeline();
          this.initPostPipeline();
          this.setText(text);
        },
        setLeftAlign: function() {
          this._align = BitmapText.ALIGN_LEFT;
          this._dirty = true;
          return this;
        },
        setCenterAlign: function() {
          this._align = BitmapText.ALIGN_CENTER;
          this._dirty = true;
          return this;
        },
        setRightAlign: function() {
          this._align = BitmapText.ALIGN_RIGHT;
          this._dirty = true;
          return this;
        },
        setFontSize: function(size) {
          this._fontSize = size;
          this._dirty = true;
          return this;
        },
        setLetterSpacing: function(spacing) {
          if (spacing === void 0) {
            spacing = 0;
          }
          this._letterSpacing = spacing;
          this._dirty = true;
          return this;
        },
        setLineSpacing: function(spacing) {
          if (spacing === void 0) {
            spacing = 0;
          }
          this.lineSpacing = spacing;
          return this;
        },
        setText: function(value) {
          if (!value && value !== 0) {
            value = "";
          }
          if (Array.isArray(value)) {
            value = value.join("\n");
          }
          if (value !== this.text) {
            this._text = value.toString();
            this._dirty = true;
            this.updateDisplayOrigin();
          }
          return this;
        },
        setDropShadow: function(x, y, color, alpha) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (color === void 0) {
            color = 0;
          }
          if (alpha === void 0) {
            alpha = 0.5;
          }
          this.dropShadowX = x;
          this.dropShadowY = y;
          this.dropShadowColor = color;
          this.dropShadowAlpha = alpha;
          return this;
        },
        setCharacterTint: function(start, length, tintFill, topLeft, topRight, bottomLeft, bottomRight) {
          if (start === void 0) {
            start = 0;
          }
          if (length === void 0) {
            length = 1;
          }
          if (tintFill === void 0) {
            tintFill = false;
          }
          if (topLeft === void 0) {
            topLeft = -1;
          }
          if (topRight === void 0) {
            topRight = topLeft;
            bottomLeft = topLeft;
            bottomRight = topLeft;
          }
          var len = this.text.length;
          if (length === -1) {
            length = len;
          }
          if (start < 0) {
            start = len + start;
          }
          start = Clamp(start, 0, len - 1);
          var end = Clamp(start + length, start, len);
          var charColors = this.charColors;
          for (var i = start; i < end; i++) {
            var color = charColors[i];
            if (topLeft === -1) {
              charColors[i] = null;
            } else {
              var tintEffect = tintFill ? 1 : 0;
              if (color) {
                color.tintEffect = tintEffect;
                color.tintTL = topLeft;
                color.tintTR = topRight;
                color.tintBL = bottomLeft;
                color.tintBR = bottomRight;
              } else {
                charColors[i] = {
                  tintEffect: tintEffect,
                  tintTL: topLeft,
                  tintTR: topRight,
                  tintBL: bottomLeft,
                  tintBR: bottomRight
                };
              }
            }
          }
          return this;
        },
        setWordTint: function(word, count, tintFill, topLeft, topRight, bottomLeft, bottomRight) {
          if (count === void 0) {
            count = 1;
          }
          var bounds = this.getTextBounds();
          var words = bounds.words;
          var wordIsNumber = typeof word === "number";
          var total = 0;
          for (var i = 0; i < words.length; i++) {
            var lineword = words[i];
            if (wordIsNumber && i === word || !wordIsNumber && lineword.word === word) {
              this.setCharacterTint(lineword.i, lineword.word.length, tintFill, topLeft, topRight, bottomLeft, bottomRight);
              total++;
              if (total === count) {
                return this;
              }
            }
          }
          return this;
        },
        getTextBounds: function(round) {
          var bounds = this._bounds;
          if (this._dirty || round || this.scaleX !== bounds.scaleX || this.scaleY !== bounds.scaleY) {
            GetBitmapTextSize(this, round, true, bounds);
            this._dirty = false;
          }
          return bounds;
        },
        getCharacterAt: function(x, y, camera) {
          var point = this.getLocalPoint(x, y, null, camera);
          var bounds = this.getTextBounds();
          var chars = bounds.characters;
          var tempRect = new Rectangle();
          for (var i = 0; i < chars.length; i++) {
            var char = chars[i];
            tempRect.setTo(char.x, char.t, char.r - char.x, char.b);
            if (tempRect.contains(point.x, point.y)) {
              return char;
            }
          }
          return null;
        },
        updateDisplayOrigin: function() {
          this._dirty = true;
          this.getTextBounds(false);
          return this;
        },
        setFont: function(key, size, align) {
          if (size === void 0) {
            size = this._fontSize;
          }
          if (align === void 0) {
            align = this._align;
          }
          if (key !== this.font) {
            var entry = this.scene.sys.cache.bitmapFont.get(key);
            if (entry) {
              this.font = key;
              this.fontData = entry.data;
              this._fontSize = size;
              this._align = align;
              this.fromAtlas = entry.fromAtlas === true;
              this.setTexture(entry.texture, entry.frame);
              GetBitmapTextSize(this, false, true, this._bounds);
            }
          }
          return this;
        },
        setMaxWidth: function(value, wordWrapCharCode) {
          this._maxWidth = value;
          this._dirty = true;
          if (wordWrapCharCode !== void 0) {
            this.wordWrapCharCode = wordWrapCharCode;
          }
          return this;
        },
        align: {
          set: function(value) {
            this._align = value;
            this._dirty = true;
          },
          get: function() {
            return this._align;
          }
        },
        text: {
          set: function(value) {
            this.setText(value);
          },
          get: function() {
            return this._text;
          }
        },
        fontSize: {
          set: function(value) {
            this._fontSize = value;
            this._dirty = true;
          },
          get: function() {
            return this._fontSize;
          }
        },
        letterSpacing: {
          set: function(value) {
            this._letterSpacing = value;
            this._dirty = true;
          },
          get: function() {
            return this._letterSpacing;
          }
        },
        lineSpacing: {
          set: function(value) {
            this._lineSpacing = value;
            this._dirty = true;
          },
          get: function() {
            return this._lineSpacing;
          }
        },
        maxWidth: {
          set: function(value) {
            this._maxWidth = value;
            this._dirty = true;
          },
          get: function() {
            return this._maxWidth;
          }
        },
        width: {
          get: function() {
            this.getTextBounds(false);
            return this._bounds.global.width;
          }
        },
        height: {
          get: function() {
            this.getTextBounds(false);
            return this._bounds.global.height;
          }
        },
        displayWidth: {
          get: function() {
            return this.width;
          }
        },
        displayHeight: {
          get: function() {
            return this.height;
          }
        },
        toJSON: function() {
          var out = Components.ToJSON(this);
          var data = {
            font: this.font,
            text: this.text,
            fontSize: this.fontSize,
            letterSpacing: this.letterSpacing,
            lineSpacing: this.lineSpacing,
            align: this.align
          };
          out.data = data;
          return out;
        },
        preDestroy: function() {
          this.charColors.length = 0;
          this._bounds = null;
          this.fontData = null;
        }
      });
      BitmapText.ALIGN_LEFT = 0;
      BitmapText.ALIGN_CENTER = 1;
      BitmapText.ALIGN_RIGHT = 2;
      BitmapText.ParseFromAtlas = ParseFromAtlas;
      BitmapText.ParseXMLBitmapFont = ParseXMLBitmapFont;
      module.exports = BitmapText;
    }
  });

  // ../../node_modules/phaser/src/tweens/builders/GetEaseFunction.js
  var require_GetEaseFunction = __commonJS({
    "../../node_modules/phaser/src/tweens/builders/GetEaseFunction.js": function(exports, module) {
      var EaseMap = require_EaseMap();
      var UppercaseFirst = require_UppercaseFirst();
      var GetEaseFunction = function(ease, easeParams) {
        var easeFunction = EaseMap.Power0;
        if (typeof ease === "string") {
          if (EaseMap.hasOwnProperty(ease)) {
            easeFunction = EaseMap[ease];
          } else {
            var direction = "";
            if (ease.indexOf(".")) {
              direction = ease.substring(ease.indexOf(".") + 1);
              var directionLower = direction.toLowerCase();
              if (directionLower === "in") {
                direction = "easeIn";
              } else if (directionLower === "out") {
                direction = "easeOut";
              } else if (directionLower === "inout") {
                direction = "easeInOut";
              }
            }
            ease = UppercaseFirst(ease.substring(0, ease.indexOf(".") + 1) + direction);
            if (EaseMap.hasOwnProperty(ease)) {
              easeFunction = EaseMap[ease];
            }
          }
        } else if (typeof ease === "function") {
          easeFunction = ease;
        }
        if (!easeParams) {
          return easeFunction;
        }
        var cloneParams = easeParams.slice(0);
        cloneParams.unshift(0);
        return function(v) {
          cloneParams[0] = v;
          return easeFunction.apply(this, cloneParams);
        };
      };
      module.exports = GetEaseFunction;
    }
  });

  // ../../node_modules/phaser/src/tweens/builders/GetInterpolationFunction.js
  var require_GetInterpolationFunction = __commonJS({
    "../../node_modules/phaser/src/tweens/builders/GetInterpolationFunction.js": function(exports, module) {
      var Bezier = require_BezierInterpolation();
      var CatmullRom = require_CatmullRomInterpolation();
      var Linear = require_LinearInterpolation();
      var FuncMap = {
        bezier: Bezier,
        catmull: CatmullRom,
        catmullrom: CatmullRom,
        linear: Linear
      };
      var GetInterpolationFunction = function(interpolation) {
        if (interpolation === null) {
          return null;
        }
        var interpolationFunction = FuncMap.linear;
        if (typeof interpolation === "string") {
          if (FuncMap.hasOwnProperty(interpolation)) {
            interpolationFunction = FuncMap[interpolation];
          }
        } else if (typeof interpolation === "function") {
          interpolationFunction = interpolation;
        }
        return interpolationFunction;
      };
      module.exports = GetInterpolationFunction;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/EmitterOp.js
  var require_EmitterOp = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/EmitterOp.js": function(exports, module) {
      var Between = require_Between2();
      var Clamp = require_Clamp();
      var Class = require_Class();
      var FloatBetween = require_FloatBetween();
      var GetEaseFunction = require_GetEaseFunction();
      var GetFastValue = require_GetFastValue();
      var GetInterpolationFunction = require_GetInterpolationFunction();
      var SnapTo = require_SnapTo();
      var Wrap = require_Wrap();
      var EmitterOp = new Class({
        initialize: function EmitterOp2(key, defaultValue, emitOnly) {
          if (emitOnly === void 0) {
            emitOnly = false;
          }
          this.propertyKey = key;
          this.propertyValue = defaultValue;
          this.defaultValue = defaultValue;
          this.steps = 0;
          this.counter = 0;
          this.yoyo = false;
          this.direction = 0;
          this.start = 0;
          this.current = 0;
          this.end = 0;
          this.ease = null;
          this.interpolation = null;
          this.emitOnly = emitOnly;
          this.onEmit = this.defaultEmit;
          this.onUpdate = this.defaultUpdate;
          this.active = true;
          this.method = 0;
          this._onEmit;
          this._onUpdate;
        },
        loadConfig: function(config, newKey) {
          if (config === void 0) {
            config = {};
          }
          if (newKey) {
            this.propertyKey = newKey;
          }
          this.propertyValue = GetFastValue(config, this.propertyKey, this.defaultValue);
          this.method = this.getMethod();
          this.setMethods();
          if (this.emitOnly) {
            this.onUpdate = this.defaultUpdate;
          }
        },
        toJSON: function() {
          return JSON.stringify(this.propertyValue);
        },
        onChange: function(value) {
          var current;
          switch (this.method) {
            case 1:
            case 3:
            case 8:
              current = value;
              break;
            case 2:
              if (this.propertyValue.indexOf(value) >= 0) {
                current = value;
              }
              break;
            case 4:
              var step = (this.end - this.start) / this.steps;
              current = SnapTo(value, step);
              this.counter = current;
              break;
            case 5:
            case 6:
            case 7:
              current = Clamp(value, this.start, this.end);
              break;
            case 9:
              current = this.start[0];
              break;
          }
          this.current = current;
          return this;
        },
        getMethod: function() {
          var value = this.propertyValue;
          if (value === null) {
            return 0;
          }
          var t = typeof value;
          if (t === "number") {
            return 1;
          } else if (Array.isArray(value)) {
            return 2;
          } else if (t === "function") {
            return 3;
          } else if (t === "object") {
            if (this.hasBoth(value, "start", "end")) {
              if (this.has(value, "steps")) {
                return 4;
              } else {
                return 5;
              }
            } else if (this.hasBoth(value, "min", "max")) {
              return 6;
            } else if (this.has(value, "random")) {
              return 7;
            } else if (this.hasEither(value, "onEmit", "onUpdate")) {
              return 8;
            } else if (this.has(value, "interpolation")) {
              return 9;
            }
          }
          return 0;
        },
        setMethods: function() {
          var value = this.propertyValue;
          var current = value;
          var onEmit = this.defaultEmit;
          var onUpdate = this.defaultUpdate;
          switch (this.method) {
            case 1:
              onEmit = this.staticValueEmit;
              break;
            case 2:
              onEmit = this.randomStaticValueEmit;
              current = value[0];
              break;
            case 3:
              this._onEmit = value;
              onEmit = this.proxyEmit;
              break;
            case 4:
              this.start = value.start;
              this.end = value.end;
              this.steps = value.steps;
              this.counter = this.start;
              this.yoyo = this.has(value, "yoyo") ? value.yoyo : false;
              this.direction = 0;
              onEmit = this.steppedEmit;
              current = this.start;
              break;
            case 5:
              this.start = value.start;
              this.end = value.end;
              var easeType = this.has(value, "ease") ? value.ease : "Linear";
              this.ease = GetEaseFunction(easeType, value.easeParams);
              onEmit = this.has(value, "random") && value.random ? this.randomRangedValueEmit : this.easedValueEmit;
              onUpdate = this.easeValueUpdate;
              current = this.start;
              break;
            case 6:
              this.start = value.min;
              this.end = value.max;
              onEmit = this.has(value, "int") && value.int ? this.randomRangedIntEmit : this.randomRangedValueEmit;
              current = this.start;
              break;
            case 7:
              var rnd = value.random;
              if (Array.isArray(rnd)) {
                this.start = rnd[0];
                this.end = rnd[1];
              }
              onEmit = this.randomRangedIntEmit;
              current = this.start;
              break;
            case 8:
              this._onEmit = this.has(value, "onEmit") ? value.onEmit : this.defaultEmit;
              this._onUpdate = this.has(value, "onUpdate") ? value.onUpdate : this.defaultUpdate;
              onEmit = this.proxyEmit;
              onUpdate = this.proxyUpdate;
              break;
            case 9:
              this.start = value.values;
              var easeTypeI = this.has(value, "ease") ? value.ease : "Linear";
              this.ease = GetEaseFunction(easeTypeI, value.easeParams);
              this.interpolation = GetInterpolationFunction(value.interpolation);
              onEmit = this.easedValueEmit;
              onUpdate = this.easeValueUpdate;
              current = this.start[0];
              break;
          }
          this.onEmit = onEmit;
          this.onUpdate = onUpdate;
          this.current = current;
          return this;
        },
        has: function(object, key) {
          return object.hasOwnProperty(key);
        },
        hasBoth: function(object, key1, key2) {
          return object.hasOwnProperty(key1) && object.hasOwnProperty(key2);
        },
        hasEither: function(object, key1, key2) {
          return object.hasOwnProperty(key1) || object.hasOwnProperty(key2);
        },
        defaultEmit: function(particle, key, value) {
          return value;
        },
        defaultUpdate: function(particle, key, t, value) {
          return value;
        },
        proxyEmit: function(particle, key, value) {
          var result = this._onEmit(particle, key, value);
          this.current = result;
          return result;
        },
        proxyUpdate: function(particle, key, t, value) {
          var result = this._onUpdate(particle, key, t, value);
          this.current = result;
          return result;
        },
        staticValueEmit: function() {
          return this.current;
        },
        staticValueUpdate: function() {
          return this.current;
        },
        randomStaticValueEmit: function() {
          var randomIndex = Math.floor(Math.random() * this.propertyValue.length);
          this.current = this.propertyValue[randomIndex];
          return this.current;
        },
        randomRangedValueEmit: function(particle, key) {
          var value = FloatBetween(this.start, this.end);
          if (particle && particle.data[key]) {
            particle.data[key].min = value;
            particle.data[key].max = this.end;
          }
          this.current = value;
          return value;
        },
        randomRangedIntEmit: function(particle, key) {
          var value = Between(this.start, this.end);
          if (particle && particle.data[key]) {
            particle.data[key].min = value;
            particle.data[key].max = this.end;
          }
          this.current = value;
          return value;
        },
        steppedEmit: function() {
          var current = this.counter;
          var next = current;
          var step = (this.end - this.start) / this.steps;
          if (this.yoyo) {
            var over;
            if (this.direction === 0) {
              next += step;
              if (next >= this.end) {
                over = next - this.end;
                next = this.end - over;
                this.direction = 1;
              }
            } else {
              next -= step;
              if (next <= this.start) {
                over = this.start - next;
                next = this.start + over;
                this.direction = 0;
              }
            }
            this.counter = next;
          } else {
            this.counter = Wrap(next + step, this.start, this.end);
          }
          this.current = current;
          return current;
        },
        easedValueEmit: function(particle, key) {
          if (particle && particle.data[key]) {
            var data = particle.data[key];
            data.min = this.start;
            data.max = this.end;
          }
          this.current = this.start;
          return this.start;
        },
        easeValueUpdate: function(particle, key, t) {
          var data = particle.data[key];
          var current;
          var v = this.ease(t);
          if (this.interpolation) {
            current = this.interpolation(this.start, v);
          } else {
            current = (data.max - data.min) * v + data.min;
          }
          this.current = current;
          return current;
        },
        destroy: function() {
          this.propertyValue = null;
          this.defaultValue = null;
          this.ease = null;
          this.interpolation = null;
          this._onEmit = null;
          this._onUpdate = null;
        }
      });
      module.exports = EmitterOp;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/EmitterColorOp.js
  var require_EmitterColorOp = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/EmitterColorOp.js": function(exports, module) {
      var Class = require_Class();
      var EmitterOp = require_EmitterOp();
      var GetColor = require_GetColor();
      var GetEaseFunction = require_GetEaseFunction();
      var GetInterpolationFunction = require_GetInterpolationFunction();
      var IntegerToRGB = require_IntegerToRGB();
      var EmitterColorOp = new Class({
        Extends: EmitterOp,
        initialize: function EmitterColorOp2(key) {
          EmitterOp.call(this, key, null, false);
          this.active = false;
          this.easeName = "Linear";
          this.r = [];
          this.g = [];
          this.b = [];
        },
        getMethod: function() {
          return this.propertyValue === null ? 0 : 9;
        },
        setMethods: function() {
          var value = this.propertyValue;
          var current = value;
          var onEmit = this.defaultEmit;
          var onUpdate = this.defaultUpdate;
          if (this.method === 9) {
            this.start = value[0];
            this.ease = GetEaseFunction("Linear");
            this.interpolation = GetInterpolationFunction("linear");
            onEmit = this.easedValueEmit;
            onUpdate = this.easeValueUpdate;
            current = value[0];
            this.active = true;
            for (var i = 0; i < value.length; i++) {
              var color = IntegerToRGB(value[i]);
              this.r.push(color.r);
              this.g.push(color.g);
              this.b.push(color.b);
            }
          }
          this.onEmit = onEmit;
          this.onUpdate = onUpdate;
          this.current = current;
          return this;
        },
        setEase: function(value) {
          this.easeName = value;
          this.ease = GetEaseFunction(value);
        },
        easedValueEmit: function() {
          this.current = this.start;
          return this.start;
        },
        easeValueUpdate: function(particle, key, t) {
          var v = this.ease(t);
          var r = this.interpolation(this.r, v);
          var g = this.interpolation(this.g, v);
          var b = this.interpolation(this.b, v);
          var current = GetColor(r, g, b);
          this.current = current;
          return current;
        }
      });
      module.exports = EmitterColorOp;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/events/COMPLETE_EVENT.js
  var require_COMPLETE_EVENT3 = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/events/COMPLETE_EVENT.js": function(exports, module) {
      module.exports = "complete";
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/events/DEATH_ZONE_EVENT.js
  var require_DEATH_ZONE_EVENT = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/events/DEATH_ZONE_EVENT.js": function(exports, module) {
      module.exports = "deathzone";
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/events/EXPLODE_EVENT.js
  var require_EXPLODE_EVENT = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/events/EXPLODE_EVENT.js": function(exports, module) {
      module.exports = "explode";
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/events/START_EVENT.js
  var require_START_EVENT4 = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/events/START_EVENT.js": function(exports, module) {
      module.exports = "start";
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/events/STOP_EVENT.js
  var require_STOP_EVENT2 = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/events/STOP_EVENT.js": function(exports, module) {
      module.exports = "stop";
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/events/index.js
  var require_events17 = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/events/index.js": function(exports, module) {
      module.exports = {
        COMPLETE: require_COMPLETE_EVENT3(),
        DEATH_ZONE: require_DEATH_ZONE_EVENT(),
        EXPLODE: require_EXPLODE_EVENT(),
        START: require_START_EVENT4(),
        STOP: require_STOP_EVENT2()
      };
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/ParticleProcessor.js
  var require_ParticleProcessor = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/ParticleProcessor.js": function(exports, module) {
      var Class = require_Class();
      var ParticleProcessor = new Class({
        initialize: function ParticleProcessor2(x, y, active) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          if (active === void 0) {
            active = true;
          }
          this.emitter;
          this.x = x;
          this.y = y;
          this.active = active;
        },
        update: function() {
        },
        destroy: function() {
          this.emitter = null;
        }
      });
      module.exports = ParticleProcessor;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/GravityWell.js
  var require_GravityWell = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/GravityWell.js": function(exports, module) {
      var Class = require_Class();
      var GetFastValue = require_GetFastValue();
      var ParticleProcessor = require_ParticleProcessor();
      var GravityWell = new Class({
        Extends: ParticleProcessor,
        initialize: function GravityWell2(x, y, power, epsilon, gravity) {
          if (typeof x === "object") {
            var config = x;
            x = GetFastValue(config, "x", 0);
            y = GetFastValue(config, "y", 0);
            power = GetFastValue(config, "power", 0);
            epsilon = GetFastValue(config, "epsilon", 100);
            gravity = GetFastValue(config, "gravity", 50);
          } else {
            if (x === void 0) {
              x = 0;
            }
            if (y === void 0) {
              y = 0;
            }
            if (power === void 0) {
              power = 0;
            }
            if (epsilon === void 0) {
              epsilon = 100;
            }
            if (gravity === void 0) {
              gravity = 50;
            }
          }
          ParticleProcessor.call(this, x, y, true);
          this._gravity = gravity;
          this._power = power * gravity;
          this._epsilon = epsilon * epsilon;
        },
        update: function(particle, delta) {
          var x = this.x - particle.x;
          var y = this.y - particle.y;
          var dSq = x * x + y * y;
          if (dSq === 0) {
            return;
          }
          var d = Math.sqrt(dSq);
          if (dSq < this._epsilon) {
            dSq = this._epsilon;
          }
          var factor = this._power * delta / (dSq * d) * 100;
          particle.velocityX += x * factor;
          particle.velocityY += y * factor;
        },
        epsilon: {
          get: function() {
            return Math.sqrt(this._epsilon);
          },
          set: function(value) {
            this._epsilon = value * value;
          }
        },
        power: {
          get: function() {
            return this._power / this._gravity;
          },
          set: function(value) {
            this._power = value * this._gravity;
          }
        },
        gravity: {
          get: function() {
            return this._gravity;
          },
          set: function(value) {
            var pwr = this.power;
            this._gravity = value;
            this.power = pwr;
          }
        }
      });
      module.exports = GravityWell;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/Particle.js
  var require_Particle = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/Particle.js": function(exports, module) {
      var AnimationState = require_AnimationState();
      var Clamp = require_Clamp();
      var Class = require_Class();
      var DegToRad = require_DegToRad();
      var Rectangle = require_Rectangle();
      var RotateAround = require_RotateAround();
      var Vector2 = require_Vector2();
      var Particle = new Class({
        initialize: function Particle2(emitter) {
          this.emitter = emitter;
          this.texture = null;
          this.frame = null;
          this.x = 0;
          this.y = 0;
          this.worldPosition = new Vector2();
          this.velocityX = 0;
          this.velocityY = 0;
          this.accelerationX = 0;
          this.accelerationY = 0;
          this.maxVelocityX = 1e4;
          this.maxVelocityY = 1e4;
          this.bounce = 0;
          this.scaleX = 1;
          this.scaleY = 1;
          this.alpha = 1;
          this.angle = 0;
          this.rotation = 0;
          this.tint = 16777215;
          this.life = 1e3;
          this.lifeCurrent = 1e3;
          this.delayCurrent = 0;
          this.holdCurrent = 0;
          this.lifeT = 0;
          this.data = {
            tint: { min: 16777215, max: 16777215 },
            alpha: { min: 1, max: 1 },
            rotate: { min: 0, max: 0 },
            scaleX: { min: 1, max: 1 },
            scaleY: { min: 1, max: 1 },
            x: { min: 0, max: 0 },
            y: { min: 0, max: 0 },
            accelerationX: { min: 0, max: 0 },
            accelerationY: { min: 0, max: 0 },
            maxVelocityX: { min: 0, max: 0 },
            maxVelocityY: { min: 0, max: 0 },
            moveToX: { min: 0, max: 0 },
            moveToY: { min: 0, max: 0 },
            bounce: { min: 0, max: 0 }
          };
          this.isCropped = false;
          this.scene = emitter.scene;
          this.anims = new AnimationState(this);
          this.bounds = new Rectangle();
        },
        emit: function(event, a1, a2, a3, a4, a5) {
          return this.emitter.emit(event, a1, a2, a3, a4, a5);
        },
        isAlive: function() {
          return this.lifeCurrent > 0;
        },
        kill: function() {
          this.lifeCurrent = 0;
        },
        setPosition: function(x, y) {
          if (x === void 0) {
            x = 0;
          }
          if (y === void 0) {
            y = 0;
          }
          this.x = x;
          this.y = y;
        },
        fire: function(x, y) {
          var emitter = this.emitter;
          var ops = emitter.ops;
          var anim = emitter.getAnim();
          if (anim) {
            this.anims.play(anim);
          } else {
            this.frame = emitter.getFrame();
            this.texture = this.frame.texture;
          }
          if (!this.frame) {
            throw new Error("Particle has no texture frame");
          }
          emitter.getEmitZone(this);
          if (x === void 0) {
            this.x += ops.x.onEmit(this, "x");
          } else if (ops.x.steps > 0) {
            this.x += x + ops.x.onEmit(this, "x");
          } else {
            this.x += x;
          }
          if (y === void 0) {
            this.y += ops.y.onEmit(this, "y");
          } else if (ops.y.steps > 0) {
            this.y += y + ops.y.onEmit(this, "y");
          } else {
            this.y += y;
          }
          this.life = ops.lifespan.onEmit(this, "lifespan");
          this.lifeCurrent = this.life;
          this.lifeT = 0;
          this.delayCurrent = ops.delay.onEmit(this, "delay");
          this.holdCurrent = ops.hold.onEmit(this, "hold");
          this.scaleX = ops.scaleX.onEmit(this, "scaleX");
          this.scaleY = ops.scaleY.active ? ops.scaleY.onEmit(this, "scaleY") : this.scaleX;
          this.angle = ops.rotate.onEmit(this, "rotate");
          this.rotation = DegToRad(this.angle);
          emitter.worldMatrix.transformPoint(this.x, this.y, this.worldPosition);
          if (this.delayCurrent === 0 && emitter.getDeathZone(this)) {
            this.lifeCurrent = 0;
            return false;
          }
          var sx = ops.speedX.onEmit(this, "speedX");
          var sy = ops.speedY.active ? ops.speedY.onEmit(this, "speedY") : sx;
          if (emitter.radial) {
            var rad = DegToRad(ops.angle.onEmit(this, "angle"));
            this.velocityX = Math.cos(rad) * Math.abs(sx);
            this.velocityY = Math.sin(rad) * Math.abs(sy);
          } else if (emitter.moveTo) {
            var mx = ops.moveToX.onEmit(this, "moveToX");
            var my = ops.moveToY.onEmit(this, "moveToY");
            var lifeS = this.life / 1e3;
            this.velocityX = (mx - this.x) / lifeS;
            this.velocityY = (my - this.y) / lifeS;
          } else {
            this.velocityX = sx;
            this.velocityY = sy;
          }
          if (emitter.acceleration) {
            this.accelerationX = ops.accelerationX.onEmit(this, "accelerationX");
            this.accelerationY = ops.accelerationY.onEmit(this, "accelerationY");
          }
          this.maxVelocityX = ops.maxVelocityX.onEmit(this, "maxVelocityX");
          this.maxVelocityY = ops.maxVelocityY.onEmit(this, "maxVelocityY");
          this.bounce = ops.bounce.onEmit(this, "bounce");
          this.alpha = ops.alpha.onEmit(this, "alpha");
          if (ops.color.active) {
            this.tint = ops.color.onEmit(this, "tint");
          } else {
            this.tint = ops.tint.onEmit(this, "tint");
          }
          return true;
        },
        update: function(delta, step, processors) {
          if (this.lifeCurrent <= 0) {
            if (this.holdCurrent > 0) {
              this.holdCurrent -= delta;
              return this.holdCurrent <= 0;
            } else {
              return true;
            }
          }
          if (this.delayCurrent > 0) {
            this.delayCurrent -= delta;
            return false;
          }
          this.anims.update(0, delta);
          var emitter = this.emitter;
          var ops = emitter.ops;
          var t = 1 - this.lifeCurrent / this.life;
          this.lifeT = t;
          this.x = ops.x.onUpdate(this, "x", t, this.x);
          this.y = ops.y.onUpdate(this, "y", t, this.y);
          if (emitter.moveTo) {
            var mx = ops.moveToX.onUpdate(this, "moveToX", t, emitter.moveToX);
            var my = ops.moveToY.onUpdate(this, "moveToY", t, emitter.moveToY);
            var lifeS = this.lifeCurrent / 1e3;
            this.velocityX = (mx - this.x) / lifeS;
            this.velocityY = (my - this.y) / lifeS;
          }
          this.computeVelocity(emitter, delta, step, processors, t);
          this.scaleX = ops.scaleX.onUpdate(this, "scaleX", t, this.scaleX);
          this.scaleY = this.scaleX;
          if (ops.scaleY.active) {
            this.scaleY = ops.scaleY.onUpdate(this, "scaleY", t, this.scaleY);
          }
          this.angle = ops.rotate.onUpdate(this, "rotate", t, this.angle);
          this.rotation = DegToRad(this.angle);
          if (emitter.getDeathZone(this)) {
            this.lifeCurrent = 0;
            return true;
          }
          this.alpha = ops.alpha.onUpdate(this, "alpha", t, this.alpha);
          if (ops.color.active) {
            this.tint = ops.color.onUpdate(this, "color", t, this.tint);
          } else {
            this.tint = ops.tint.onUpdate(this, "tint", t, this.tint);
          }
          this.lifeCurrent -= delta;
          return this.lifeCurrent <= 0 && this.holdCurrent <= 0;
        },
        computeVelocity: function(emitter, delta, step, processors, t) {
          var ops = emitter.ops;
          var vx = this.velocityX;
          var vy = this.velocityY;
          var ax = ops.accelerationX.onUpdate(this, "accelerationX", t, this.accelerationX);
          var ay = ops.accelerationY.onUpdate(this, "accelerationY", t, this.accelerationY);
          var mx = ops.maxVelocityX.onUpdate(this, "maxVelocityX", t, this.maxVelocityX);
          var my = ops.maxVelocityY.onUpdate(this, "maxVelocityY", t, this.maxVelocityY);
          this.bounce = ops.bounce.onUpdate(this, "bounce", t, this.bounce);
          vx += emitter.gravityX * step + ax * step;
          vy += emitter.gravityY * step + ay * step;
          vx = Clamp(vx, -mx, mx);
          vy = Clamp(vy, -my, my);
          this.velocityX = vx;
          this.velocityY = vy;
          this.x += vx * step;
          this.y += vy * step;
          emitter.worldMatrix.transformPoint(this.x, this.y, this.worldPosition);
          for (var i = 0; i < processors.length; i++) {
            var processor = processors[i];
            if (processor.active) {
              processor.update(this, delta, step, t);
            }
          }
        },
        setSizeToFrame: function() {
        },
        getBounds: function(matrix) {
          if (matrix === void 0) {
            matrix = this.emitter.getWorldTransformMatrix();
          }
          var sx = Math.abs(matrix.scaleX) * this.scaleX;
          var sy = Math.abs(matrix.scaleY) * this.scaleY;
          var x = this.x;
          var y = this.y;
          var rotation = this.rotation;
          var width = this.frame.width * sx / 2;
          var height = this.frame.height * sy / 2;
          var bounds = this.bounds;
          var topLeft = new Vector2(x - width, y - height);
          var topRight = new Vector2(x + width, y - height);
          var bottomLeft = new Vector2(x - width, y + height);
          var bottomRight = new Vector2(x + width, y + height);
          if (rotation !== 0) {
            RotateAround(topLeft, x, y, rotation);
            RotateAround(topRight, x, y, rotation);
            RotateAround(bottomLeft, x, y, rotation);
            RotateAround(bottomRight, x, y, rotation);
          }
          matrix.transformPoint(topLeft.x, topLeft.y, topLeft);
          matrix.transformPoint(topRight.x, topRight.y, topRight);
          matrix.transformPoint(bottomLeft.x, bottomLeft.y, bottomLeft);
          matrix.transformPoint(bottomRight.x, bottomRight.y, bottomRight);
          bounds.x = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
          bounds.y = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
          bounds.width = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x) - bounds.x;
          bounds.height = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y) - bounds.y;
          return bounds;
        },
        destroy: function() {
          this.anims.destroy();
          this.anims = null;
          this.emitter = null;
          this.texture = null;
          this.frame = null;
          this.scene = null;
        }
      });
      module.exports = Particle;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/ParticleBounds.js
  var require_ParticleBounds = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/ParticleBounds.js": function(exports, module) {
      var Class = require_Class();
      var ParticleProcessor = require_ParticleProcessor();
      var Rectangle = require_Rectangle();
      var ParticleBounds = new Class({
        Extends: ParticleProcessor,
        initialize: function ParticleBounds2(x, y, width, height, collideLeft, collideRight, collideTop, collideBottom) {
          if (collideLeft === void 0) {
            collideLeft = true;
          }
          if (collideRight === void 0) {
            collideRight = true;
          }
          if (collideTop === void 0) {
            collideTop = true;
          }
          if (collideBottom === void 0) {
            collideBottom = true;
          }
          ParticleProcessor.call(this, x, y, true);
          this.bounds = new Rectangle(x, y, width, height);
          this.collideLeft = collideLeft;
          this.collideRight = collideRight;
          this.collideTop = collideTop;
          this.collideBottom = collideBottom;
        },
        update: function(particle) {
          var bounds = this.bounds;
          var bounce = -particle.bounce;
          var pos = particle.worldPosition;
          if (pos.x < bounds.x && this.collideLeft) {
            particle.x += bounds.x - pos.x;
            particle.velocityX *= bounce;
          } else if (pos.x > bounds.right && this.collideRight) {
            particle.x -= pos.x - bounds.right;
            particle.velocityX *= bounce;
          }
          if (pos.y < bounds.y && this.collideTop) {
            particle.y += bounds.y - pos.y;
            particle.velocityY *= bounce;
          } else if (pos.y > bounds.bottom && this.collideBottom) {
            particle.y -= pos.y - bounds.bottom;
            particle.velocityY *= bounce;
          }
        }
      });
      module.exports = ParticleBounds;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/CopyFrom.js
  var require_CopyFrom = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/CopyFrom.js": function(exports, module) {
      var CopyFrom = function(source, dest) {
        return dest.setTo(source.x, source.y, source.width, source.height);
      };
      module.exports = CopyFrom;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/zones/DeathZone.js
  var require_DeathZone = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/zones/DeathZone.js": function(exports, module) {
      var Class = require_Class();
      var DeathZone = new Class({
        initialize: function DeathZone2(source, killOnEnter) {
          this.source = source;
          this.killOnEnter = killOnEnter;
        },
        willKill: function(particle) {
          var pos = particle.worldPosition;
          var withinZone = this.source.contains(pos.x, pos.y);
          return withinZone && this.killOnEnter || !withinZone && !this.killOnEnter;
        }
      });
      module.exports = DeathZone;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/zones/EdgeZone.js
  var require_EdgeZone = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/zones/EdgeZone.js": function(exports, module) {
      var Class = require_Class();
      var EdgeZone = new Class({
        initialize: function EdgeZone2(source, quantity, stepRate, yoyo, seamless, total) {
          if (yoyo === void 0) {
            yoyo = false;
          }
          if (seamless === void 0) {
            seamless = true;
          }
          if (total === void 0) {
            total = -1;
          }
          this.source = source;
          this.points = [];
          this.quantity = quantity;
          this.stepRate = stepRate;
          this.yoyo = yoyo;
          this.counter = -1;
          this.seamless = seamless;
          this._length = 0;
          this._direction = 0;
          this.total = total;
          this.updateSource();
        },
        updateSource: function() {
          this.points = this.source.getPoints(this.quantity, this.stepRate);
          if (this.seamless) {
            var a = this.points[0];
            var b = this.points[this.points.length - 1];
            if (a.x === b.x && a.y === b.y) {
              this.points.pop();
            }
          }
          var oldLength = this._length;
          this._length = this.points.length;
          if (this._length < oldLength && this.counter > this._length) {
            this.counter = this._length - 1;
          }
          return this;
        },
        changeSource: function(source) {
          this.source = source;
          return this.updateSource();
        },
        getPoint: function(particle) {
          if (this._direction === 0) {
            this.counter++;
            if (this.counter >= this._length) {
              if (this.yoyo) {
                this._direction = 1;
                this.counter = this._length - 1;
              } else {
                this.counter = 0;
              }
            }
          } else {
            this.counter--;
            if (this.counter === -1) {
              if (this.yoyo) {
                this._direction = 0;
                this.counter = 0;
              } else {
                this.counter = this._length - 1;
              }
            }
          }
          var point = this.points[this.counter];
          if (point) {
            particle.x = point.x;
            particle.y = point.y;
          }
        }
      });
      module.exports = EdgeZone;
    }
  });

  // ../../node_modules/phaser/src/utils/object/HasAny.js
  var require_HasAny = __commonJS({
    "../../node_modules/phaser/src/utils/object/HasAny.js": function(exports, module) {
      var HasAny = function(source, keys) {
        for (var i = 0; i < keys.length; i++) {
          if (source.hasOwnProperty(keys[i])) {
            return true;
          }
        }
        return false;
      };
      module.exports = HasAny;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/Inflate.js
  var require_Inflate = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/Inflate.js": function(exports, module) {
      var CenterOn = require_CenterOn2();
      var Inflate = function(rect, x, y) {
        var cx = rect.centerX;
        var cy = rect.centerY;
        rect.setSize(rect.width + x * 2, rect.height + y * 2);
        return CenterOn(rect, cx, cy);
      };
      module.exports = Inflate;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/MergeRect.js
  var require_MergeRect = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/MergeRect.js": function(exports, module) {
      var MergeRect = function(target, source) {
        var minX = Math.min(target.x, source.x);
        var maxX = Math.max(target.right, source.right);
        target.x = minX;
        target.width = maxX - minX;
        var minY = Math.min(target.y, source.y);
        var maxY = Math.max(target.bottom, source.bottom);
        target.y = minY;
        target.height = maxY - minY;
        return target;
      };
      module.exports = MergeRect;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/zones/RandomZone.js
  var require_RandomZone = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/zones/RandomZone.js": function(exports, module) {
      var Class = require_Class();
      var Vector2 = require_Vector2();
      var RandomZone = new Class({
        initialize: function RandomZone2(source) {
          this.source = source;
          this._tempVec = new Vector2();
          this.total = -1;
        },
        getPoint: function(particle) {
          var vec = this._tempVec;
          this.source.getRandomPoint(vec);
          particle.x = vec.x;
          particle.y = vec.y;
        }
      });
      module.exports = RandomZone;
    }
  });

  // ../../node_modules/phaser/src/geom/intersects/RectangleToRectangle.js
  var require_RectangleToRectangle = __commonJS({
    "../../node_modules/phaser/src/geom/intersects/RectangleToRectangle.js": function(exports, module) {
      var RectangleToRectangle = function(rectA, rectB) {
        if (rectA.width <= 0 || rectA.height <= 0 || rectB.width <= 0 || rectB.height <= 0) {
          return false;
        }
        return !(rectA.right < rectB.x || rectA.bottom < rectB.y || rectA.x > rectB.right || rectA.y > rectB.bottom);
      };
      module.exports = RectangleToRectangle;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/ParticleEmitterWebGLRenderer.js
  var require_ParticleEmitterWebGLRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/ParticleEmitterWebGLRenderer.js": function(exports, module) {
      var RectangleToRectangle = require_RectangleToRectangle();
      var TransformMatrix = require_TransformMatrix();
      var Utils = require_Utils();
      var tempMatrix1 = new TransformMatrix();
      var tempMatrix2 = new TransformMatrix();
      var tempMatrix3 = new TransformMatrix();
      var tempMatrix4 = new TransformMatrix();
      var ParticleEmitterWebGLRenderer = function(renderer, emitter, camera, parentMatrix) {
        var pipeline = renderer.pipelines.set(emitter.pipeline);
        var camMatrix = tempMatrix1;
        var calcMatrix = tempMatrix2;
        var particleMatrix = tempMatrix3;
        var managerMatrix = tempMatrix4;
        if (parentMatrix) {
          managerMatrix.loadIdentity();
          managerMatrix.multiply(parentMatrix);
          managerMatrix.translate(emitter.x, emitter.y);
          managerMatrix.rotate(emitter.rotation);
          managerMatrix.scale(emitter.scaleX, emitter.scaleY);
        } else {
          managerMatrix.applyITRS(emitter.x, emitter.y, emitter.rotation, emitter.scaleX, emitter.scaleY);
        }
        var roundPixels = camera.roundPixels;
        var getTint = Utils.getTintAppendFloatAlpha;
        var camerAlpha = camera.alpha;
        var emitterAlpha = emitter.alpha;
        var texture = emitter.texture.glTexture;
        renderer.pipelines.preBatch(emitter);
        var particles = emitter.alive;
        var particleCount = particles.length;
        var viewBounds = emitter.viewBounds;
        if (!emitter.visible || particleCount === 0 || viewBounds && !RectangleToRectangle(viewBounds, camera.worldView)) {
          return;
        }
        if (emitter.sortCallback) {
          emitter.depthSort();
        }
        var textureUnit = pipeline.setGameObject(emitter, emitter.frame);
        camera.addToRenderList(emitter);
        camMatrix.copyFrom(camera.matrix);
        camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * emitter.scrollFactorX, -camera.scrollY * emitter.scrollFactorY);
        renderer.setBlendMode(emitter.blendMode);
        if (emitter.mask) {
          emitter.mask.preRenderWebGL(renderer, emitter, camera);
          renderer.pipelines.set(emitter.pipeline);
        }
        var tintEffect = emitter.tintFill;
        for (var i = 0; i < particleCount; i++) {
          var particle = particles[i];
          var alpha = particle.alpha * emitterAlpha * camerAlpha;
          if (alpha <= 0 || particle.scaleX === 0 || particle.scaleY === 0) {
            continue;
          }
          particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY);
          particleMatrix.e = particle.x;
          particleMatrix.f = particle.y;
          camMatrix.multiply(particleMatrix, calcMatrix);
          var frame = particle.frame;
          var x = -frame.halfWidth;
          var y = -frame.halfHeight;
          var quad = calcMatrix.setQuad(x, y, x + frame.width, y + frame.height, roundPixels);
          var tint = getTint(particle.tint, alpha);
          pipeline.batchQuad(emitter, quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7], frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, tintEffect, texture, textureUnit);
        }
        if (emitter.mask) {
          emitter.mask.postRenderWebGL(renderer, camera);
        }
        renderer.pipelines.postBatch(emitter);
      };
      module.exports = ParticleEmitterWebGLRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/ParticleEmitterCanvasRenderer.js
  var require_ParticleEmitterCanvasRenderer = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/ParticleEmitterCanvasRenderer.js": function(exports, module) {
      var RectangleToRectangle = require_RectangleToRectangle();
      var TransformMatrix = require_TransformMatrix();
      var tempMatrix1 = new TransformMatrix();
      var tempMatrix2 = new TransformMatrix();
      var tempMatrix3 = new TransformMatrix();
      var tempMatrix4 = new TransformMatrix();
      var ParticleEmitterCanvasRenderer = function(renderer, emitter, camera, parentMatrix) {
        var camMatrix = tempMatrix1;
        var calcMatrix = tempMatrix2;
        var particleMatrix = tempMatrix3;
        var managerMatrix = tempMatrix4;
        if (parentMatrix) {
          managerMatrix.loadIdentity();
          managerMatrix.multiply(parentMatrix);
          managerMatrix.translate(emitter.x, emitter.y);
          managerMatrix.rotate(emitter.rotation);
          managerMatrix.scale(emitter.scaleX, emitter.scaleY);
        } else {
          managerMatrix.applyITRS(emitter.x, emitter.y, emitter.rotation, emitter.scaleX, emitter.scaleY);
        }
        var ctx = renderer.currentContext;
        var roundPixels = camera.roundPixels;
        var camerAlpha = camera.alpha;
        var emitterAlpha = emitter.alpha;
        var particles = emitter.alive;
        var particleCount = particles.length;
        var viewBounds = emitter.viewBounds;
        if (!emitter.visible || particleCount === 0 || viewBounds && !RectangleToRectangle(viewBounds, camera.worldView)) {
          return;
        }
        if (emitter.sortCallback) {
          emitter.depthSort();
        }
        camera.addToRenderList(emitter);
        var scrollFactorX = emitter.scrollFactorX;
        var scrollFactorY = emitter.scrollFactorY;
        ctx.save();
        ctx.globalCompositeOperation = renderer.blendModes[emitter.blendMode];
        for (var i = 0; i < particleCount; i++) {
          var particle = particles[i];
          var alpha = particle.alpha * emitterAlpha * camerAlpha;
          if (alpha <= 0 || particle.scaleX === 0 || particle.scaleY === 0) {
            continue;
          }
          particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY);
          camMatrix.copyFrom(camera.matrix);
          camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);
          particleMatrix.e = particle.x;
          particleMatrix.f = particle.y;
          camMatrix.multiply(particleMatrix, calcMatrix);
          var frame = particle.frame;
          var cd = frame.canvasData;
          if (cd.width > 0 && cd.height > 0) {
            var x = -frame.halfWidth;
            var y = -frame.halfHeight;
            ctx.globalAlpha = alpha;
            ctx.save();
            calcMatrix.setToContext(ctx);
            if (roundPixels) {
              x = Math.round(x);
              y = Math.round(y);
            }
            ctx.imageSmoothingEnabled = !frame.source.scaleMode;
            ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);
            ctx.restore();
          }
        }
        ctx.restore();
      };
      module.exports = ParticleEmitterCanvasRenderer;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/ParticleEmitterRender.js
  var require_ParticleEmitterRender = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/ParticleEmitterRender.js": function(exports, module) {
      var NOOP = require_NOOP();
      var renderWebGL = NOOP;
      var renderCanvas = NOOP;
      if (true) {
        renderWebGL = require_ParticleEmitterWebGLRenderer();
      }
      if (true) {
        renderCanvas = require_ParticleEmitterCanvasRenderer();
      }
      module.exports = {
        renderWebGL: renderWebGL,
        renderCanvas: renderCanvas
      };
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/ParticleEmitter.js
  var require_ParticleEmitter = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/ParticleEmitter.js": function(exports, module) {
      var Add = require_Add();
      var Class = require_Class();
      var Components = require_components();
      var ComponentsToJSON = require_ToJSON();
      var CopyFrom = require_CopyFrom();
      var DeathZone = require_DeathZone();
      var EdgeZone = require_EdgeZone();
      var EmitterColorOp = require_EmitterColorOp();
      var EmitterOp = require_EmitterOp();
      var Events = require_events17();
      var GameObject = require_GameObject();
      var GetFastValue = require_GetFastValue();
      var GetRandom = require_GetRandom();
      var GravityWell = require_GravityWell();
      var HasAny = require_HasAny();
      var HasValue = require_HasValue();
      var Inflate = require_Inflate();
      var List = require_List();
      var MergeRect = require_MergeRect();
      var Particle = require_Particle();
      var RandomZone = require_RandomZone();
      var Rectangle = require_Rectangle();
      var RectangleToRectangle = require_RectangleToRectangle();
      var Remove = require_Remove();
      var Render = require_ParticleEmitterRender();
      var StableSort = require_StableSort();
      var TransformMatrix = require_TransformMatrix();
      var Vector2 = require_Vector2();
      var Wrap = require_Wrap();
      var ParticleBounds = require_ParticleBounds();
      var configFastMap = [
        "active",
        "advance",
        "blendMode",
        "colorEase",
        "deathCallback",
        "deathCallbackScope",
        "duration",
        "emitCallback",
        "emitCallbackScope",
        "follow",
        "frequency",
        "gravityX",
        "gravityY",
        "maxAliveParticles",
        "maxParticles",
        "name",
        "emitting",
        "particleBringToTop",
        "particleClass",
        "radial",
        "sortCallback",
        "sortOrderAsc",
        "sortProperty",
        "stopAfter",
        "tintFill",
        "timeScale",
        "trackVisible",
        "visible"
      ];
      var configOpMap = [
        "accelerationX",
        "accelerationY",
        "alpha",
        "angle",
        "bounce",
        "color",
        "delay",
        "hold",
        "lifespan",
        "maxVelocityX",
        "maxVelocityY",
        "moveToX",
        "moveToY",
        "quantity",
        "rotate",
        "scaleX",
        "scaleY",
        "speedX",
        "speedY",
        "tint",
        "x",
        "y"
      ];
      var ParticleEmitter = new Class({
        Extends: GameObject,
        Mixins: [
          Components.AlphaSingle,
          Components.BlendMode,
          Components.Depth,
          Components.FX,
          Components.Mask,
          Components.Pipeline,
          Components.PostPipeline,
          Components.ScrollFactor,
          Components.Texture,
          Components.Transform,
          Components.Visible,
          Render
        ],
        initialize: function ParticleEmitter2(scene, x, y, texture, config) {
          GameObject.call(this, scene, "ParticleEmitter");
          this.particleClass = Particle;
          this.ops = {
            accelerationX: new EmitterOp("accelerationX", 0),
            accelerationY: new EmitterOp("accelerationY", 0),
            alpha: new EmitterOp("alpha", 1),
            angle: new EmitterOp("angle", { min: 0, max: 360 }, true),
            bounce: new EmitterOp("bounce", 0),
            color: new EmitterColorOp("color"),
            delay: new EmitterOp("delay", 0, true),
            hold: new EmitterOp("hold", 0, true),
            lifespan: new EmitterOp("lifespan", 1e3, true),
            maxVelocityX: new EmitterOp("maxVelocityX", 1e4),
            maxVelocityY: new EmitterOp("maxVelocityY", 1e4),
            moveToX: new EmitterOp("moveToX", 0),
            moveToY: new EmitterOp("moveToY", 0),
            quantity: new EmitterOp("quantity", 1, true),
            rotate: new EmitterOp("rotate", 0),
            scaleX: new EmitterOp("scaleX", 1),
            scaleY: new EmitterOp("scaleY", 1),
            speedX: new EmitterOp("speedX", 0, true),
            speedY: new EmitterOp("speedY", 0, true),
            tint: new EmitterOp("tint", 16777215),
            x: new EmitterOp("x", 0),
            y: new EmitterOp("y", 0)
          };
          this.radial = true;
          this.gravityX = 0;
          this.gravityY = 0;
          this.acceleration = false;
          this.moveTo = false;
          this.emitCallback = null;
          this.emitCallbackScope = null;
          this.deathCallback = null;
          this.deathCallbackScope = null;
          this.maxParticles = 0;
          this.maxAliveParticles = 0;
          this.stopAfter = 0;
          this.duration = 0;
          this.frequency = 0;
          this.emitting = true;
          this.particleBringToTop = true;
          this.timeScale = 1;
          this.emitZones = [];
          this.deathZones = [];
          this.viewBounds = null;
          this.follow = null;
          this.followOffset = new Vector2();
          this.trackVisible = false;
          this.frames = [];
          this.randomFrame = true;
          this.frameQuantity = 1;
          this.anims = [];
          this.randomAnim = true;
          this.animQuantity = 1;
          this.dead = [];
          this.alive = [];
          this.counters = new Float32Array(10);
          this._frameLength = 0;
          this._animLength = 0;
          this.skipping = false;
          this.worldMatrix = new TransformMatrix();
          this.sortProperty = "";
          this.sortOrderAsc = true;
          this.sortCallback = this.depthSortCallback;
          this.processors = new List(this);
          this.tintFill = false;
          this.initPipeline();
          this.initPostPipeline();
          this.setPosition(x, y);
          this.setTexture(texture);
          if (config) {
            this.setConfig(config);
          }
        },
        addedToScene: function() {
          this.scene.sys.updateList.add(this);
        },
        removedFromScene: function() {
          this.scene.sys.updateList.remove(this);
        },
        setConfig: function(config) {
          if (!config) {
            return this;
          }
          var i = 0;
          var key = "";
          var ops = this.ops;
          for (i = 0; i < configOpMap.length; i++) {
            key = configOpMap[i];
            ops[key].loadConfig(config);
          }
          for (i = 0; i < configFastMap.length; i++) {
            key = configFastMap[i];
            if (HasValue(config, key)) {
              this[key] = GetFastValue(config, key);
            }
          }
          this.acceleration = this.accelerationX !== 0 || this.accelerationY !== 0;
          this.moveTo = this.moveToX !== 0 && this.moveToY !== 0;
          if (HasValue(config, "speed")) {
            ops.speedX.loadConfig(config, "speed");
            ops.speedY.active = false;
          }
          if (HasAny(config, ["speedX", "speedY"]) || this.moveTo) {
            this.radial = false;
          }
          if (HasValue(config, "scale")) {
            ops.scaleX.loadConfig(config, "scale");
            ops.scaleY.active = false;
          }
          if (HasValue(config, "callbackScope")) {
            var callbackScope = GetFastValue(config, "callbackScope", null);
            this.emitCallbackScope = callbackScope;
            this.deathCallbackScope = callbackScope;
          }
          if (HasValue(config, "emitZone")) {
            this.addEmitZone(config.emitZone);
          }
          if (HasValue(config, "deathZone")) {
            this.addDeathZone(config.deathZone);
          }
          if (HasValue(config, "bounds")) {
            var bounds = this.addParticleBounds(config.bounds);
            bounds.collideLeft = GetFastValue(config, "collideLeft", true);
            bounds.collideRight = GetFastValue(config, "collideRight", true);
            bounds.collideTop = GetFastValue(config, "collideTop", true);
            bounds.collideBottom = GetFastValue(config, "collideBottom", true);
          }
          if (HasValue(config, "followOffset")) {
            this.followOffset.setFromObject(GetFastValue(config, "followOffset", 0));
          }
          if (HasValue(config, "texture")) {
            this.setTexture(config.texture);
          }
          if (HasValue(config, "frame")) {
            this.setEmitterFrame(config.frame);
          } else if (HasValue(config, "anim")) {
            this.setAnim(config.anim);
          }
          if (HasValue(config, "reserve")) {
            this.reserve(config.reserve);
          }
          if (HasValue(config, "advance")) {
            this.fastForward(config.advance);
          }
          this.resetCounters(this.frequency, this.emitting);
          if (this.emitting) {
            this.emit(Events.START, this);
          }
          return this;
        },
        toJSON: function() {
          var output = ComponentsToJSON(this);
          var i = 0;
          var key = "";
          for (i = 0; i < configFastMap.length; i++) {
            key = configFastMap[i];
            output[key] = this[key];
          }
          var ops = this.ops;
          for (i = 0; i < configOpMap.length; i++) {
            key = configOpMap[i];
            if (ops[key]) {
              output[key] = ops[key].toJSON();
            }
          }
          if (!ops.speedY.active) {
            delete output.speedX;
            output.speed = ops.speedX.toJSON();
          }
          if (this.scaleX === this.scaleY) {
            delete output.scaleX;
            delete output.scaleY;
            output.scale = ops.scaleX.toJSON();
          }
          return output;
        },
        resetCounters: function(frequency, on) {
          var counters = this.counters;
          counters.fill(0);
          counters[0] = frequency;
          if (on) {
            counters[5] = 1;
          }
        },
        startFollow: function(target, offsetX, offsetY, trackVisible) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          if (trackVisible === void 0) {
            trackVisible = false;
          }
          this.follow = target;
          this.followOffset.set(offsetX, offsetY);
          this.trackVisible = trackVisible;
          return this;
        },
        stopFollow: function() {
          this.follow = null;
          this.followOffset.set(0, 0);
          this.trackVisible = false;
          return this;
        },
        getFrame: function() {
          var frames = this.frames;
          var current;
          if (frames.length === 1) {
            current = frames[0];
          } else if (this.randomFrame) {
            current = GetRandom(frames);
          } else {
            current = frames[this.currentFrame];
            this.frameCounter++;
            if (this.frameCounter >= this.frameQuantity) {
              this.frameCounter = 0;
              this.currentFrame = Wrap(this.currentFrame + 1, 0, this._frameLength);
            }
          }
          return this.texture.get(current);
        },
        setEmitterFrame: function(frames, pickRandom, quantity) {
          if (pickRandom === void 0) {
            pickRandom = true;
          }
          if (quantity === void 0) {
            quantity = 1;
          }
          this.randomFrame = pickRandom;
          this.frameQuantity = quantity;
          this.currentFrame = 0;
          var t = typeof frames;
          this.frames.length = 0;
          if (Array.isArray(frames)) {
            this.frames = this.frames.concat(frames);
          } else if (t === "string" || t === "number") {
            this.frames.push(frames);
          } else if (t === "object") {
            var frameConfig = frames;
            frames = GetFastValue(frameConfig, "frames", null);
            if (frames) {
              this.frames = this.frames.concat(frames);
            }
            var isCycle = GetFastValue(frameConfig, "cycle", false);
            this.randomFrame = isCycle ? false : true;
            this.frameQuantity = GetFastValue(frameConfig, "quantity", quantity);
          }
          this._frameLength = this.frames.length;
          if (this._frameLength === 1) {
            this.frameQuantity = 1;
            this.randomFrame = false;
          }
          return this;
        },
        getAnim: function() {
          var anims = this.anims;
          if (anims.length === 0) {
            return null;
          } else if (anims.length === 1) {
            return anims[0];
          } else if (this.randomAnim) {
            return GetRandom(anims);
          } else {
            var anim = anims[this.currentAnim];
            this.animCounter++;
            if (this.animCounter >= this.animQuantity) {
              this.animCounter = 0;
              this.currentAnim = Wrap(this.currentAnim + 1, 0, this._animLength);
            }
            return anim;
          }
        },
        setAnim: function(anims, pickRandom, quantity) {
          if (pickRandom === void 0) {
            pickRandom = true;
          }
          if (quantity === void 0) {
            quantity = 1;
          }
          this.randomAnim = pickRandom;
          this.animQuantity = quantity;
          this.currentAnim = 0;
          var t = typeof anims;
          this.anims.length = 0;
          if (Array.isArray(anims)) {
            this.anims = this.anims.concat(anims);
          } else if (t === "string") {
            this.anims.push(anims);
          } else if (t === "object") {
            var animConfig = anims;
            anims = GetFastValue(animConfig, "anims", null);
            if (anims) {
              this.anims = this.anims.concat(anims);
            }
            var isCycle = GetFastValue(animConfig, "cycle", false);
            this.randomAnim = isCycle ? false : true;
            this.animQuantity = GetFastValue(animConfig, "quantity", quantity);
          }
          this._animLength = this.anims.length;
          if (this._animLength === 1) {
            this.animQuantity = 1;
            this.randomAnim = false;
          }
          return this;
        },
        setRadial: function(value) {
          if (value === void 0) {
            value = true;
          }
          this.radial = value;
          return this;
        },
        addParticleBounds: function(x, y, width, height, collideLeft, collideRight, collideTop, collideBottom) {
          if (typeof x === "object") {
            var obj = x;
            x = obj.x;
            y = obj.y;
            width = HasValue(obj, "w") ? obj.w : obj.width;
            height = HasValue(obj, "h") ? obj.h : obj.height;
          }
          return this.addParticleProcessor(new ParticleBounds(x, y, width, height, collideLeft, collideRight, collideTop, collideBottom));
        },
        setParticleSpeed: function(x, y) {
          if (y === void 0) {
            y = x;
          }
          this.ops.speedX.onChange(x);
          if (x === y) {
            this.ops.speedY.active = false;
          } else {
            this.ops.speedY.onChange(y);
          }
          this.radial = true;
          return this;
        },
        setParticleScale: function(x, y) {
          if (x === void 0) {
            x = 1;
          }
          if (y === void 0) {
            y = x;
          }
          this.ops.scaleX.onChange(x);
          this.ops.scaleY.onChange(y);
          return this;
        },
        setParticleGravity: function(x, y) {
          this.gravityX = x;
          this.gravityY = y;
          return this;
        },
        setParticleAlpha: function(value) {
          this.ops.alpha.onChange(value);
          return this;
        },
        setParticleTint: function(value) {
          this.ops.tint.onChange(value);
          return this;
        },
        setEmitterAngle: function(value) {
          this.ops.angle.onChange(value);
          return this;
        },
        setParticleLifespan: function(value) {
          this.lifespan.onChange(value);
          return this;
        },
        setQuantity: function(quantity) {
          this.quantity = quantity;
          return this;
        },
        setFrequency: function(frequency, quantity) {
          this.frequency = frequency;
          this.flowCounter = frequency > 0 ? frequency : 0;
          if (quantity) {
            this.quantity = quantity;
          }
          return this;
        },
        addDeathZone: function(config) {
          if (!Array.isArray(config)) {
            config = [config];
          }
          var zone;
          for (var i = 0; i < config.length; i++) {
            zone = config[i];
            if (zone instanceof DeathZone) {
              Add(this.deathZones, zone);
            } else if (typeof zone.contains === "function") {
              zone = new DeathZone(zone, true);
              Add(this.deathZones, zone);
            } else {
              var type = GetFastValue(zone, "type", "onEnter");
              var source = GetFastValue(zone, "source", null);
              if (source && typeof source.contains === "function") {
                var killOnEnter = type === "onEnter" ? true : false;
                zone = new DeathZone(source, killOnEnter);
                Add(this.deathZones, zone);
              }
            }
          }
          return zone;
        },
        removeDeathZone: function(zone) {
          Remove(this.deathZones, zone);
          return this;
        },
        addEmitZone: function(config) {
          if (!Array.isArray(config)) {
            config = [config];
          }
          var zone;
          for (var i = 0; i < config.length; i++) {
            zone = config[i];
            if (zone instanceof RandomZone || zone instanceof EdgeZone) {
              Add(this.emitZones, zone);
            } else {
              var type = GetFastValue(zone, "type", "random");
              var source = GetFastValue(zone, "source", null);
              if (type === "random") {
                zone = new RandomZone(source);
              } else if (type === "edge") {
                var quantity = GetFastValue(zone, "quantity", 1);
                var stepRate = GetFastValue(zone, "stepRate", 0);
                var yoyo = GetFastValue(zone, "yoyo", false);
                var seamless = GetFastValue(zone, "seamless", true);
                var total = GetFastValue(zone, "total", -1);
                zone = new EdgeZone(source, quantity, stepRate, yoyo, seamless, total);
              }
              if (zone) {
                Add(this.emitZones, zone);
              }
            }
          }
          return zone;
        },
        removeEmitZone: function(zone) {
          Remove(this.emitZones, zone);
          this.zoneIndex = 0;
          return this;
        },
        getEmitZone: function(particle) {
          var zones = this.emitZones;
          var len = zones.length;
          if (len === 0) {
            return;
          } else {
            var zone = zones[this.zoneIndex];
            zone.getPoint(particle);
            if (zone.total > -1) {
              this.zoneTotal++;
              if (this.zoneTotal >= zone.total) {
                this.zoneTotal = 0;
                this.zoneIndex = Wrap(this.zoneIndex + 1, 0, len);
              }
            }
          }
        },
        getDeathZone: function(particle) {
          var zones = this.deathZones;
          for (var i = 0; i < zones.length; i++) {
            var zone = zones[i];
            if (zone.willKill(particle)) {
              this.emit(Events.DEATH_ZONE, this, particle, zone);
              return true;
            }
          }
          return false;
        },
        setEmitZone: function(zone) {
          var index;
          if (isFinite(zone)) {
            index = zone;
          } else {
            index = this.emitZones.indexOf(zone);
          }
          if (index >= 0) {
            this.zoneIndex = index;
          }
          return this;
        },
        addParticleProcessor: function(processor) {
          if (!this.processors.exists(processor)) {
            if (processor.emitter) {
              processor.emitter.removeParticleProcessor(processor);
            }
            this.processors.add(processor);
            processor.emitter = this;
          }
          return processor;
        },
        removeParticleProcessor: function(processor) {
          if (this.processors.exists(processor)) {
            this.processors.remove(processor, true);
            processor.emitter = null;
          }
          return processor;
        },
        getProcessors: function() {
          return this.processors.getAll("active", true);
        },
        createGravityWell: function(config) {
          return this.addParticleProcessor(new GravityWell(config));
        },
        reserve: function(count) {
          var dead = this.dead;
          if (this.maxParticles > 0) {
            var total = this.getParticleCount();
            if (total + count > this.maxParticles) {
              count = this.maxParticles - (total + count);
            }
          }
          for (var i = 0; i < count; i++) {
            dead.push(new this.particleClass(this));
          }
          return this;
        },
        getAliveParticleCount: function() {
          return this.alive.length;
        },
        getDeadParticleCount: function() {
          return this.dead.length;
        },
        getParticleCount: function() {
          return this.getAliveParticleCount() + this.getDeadParticleCount();
        },
        atLimit: function() {
          if (this.maxParticles > 0 && this.getParticleCount() >= this.maxParticles) {
            return true;
          }
          return this.maxAliveParticles > 0 && this.getAliveParticleCount() >= this.maxAliveParticles;
        },
        onParticleEmit: function(callback, context) {
          if (callback === void 0) {
            this.emitCallback = null;
            this.emitCallbackScope = null;
          } else if (typeof callback === "function") {
            this.emitCallback = callback;
            if (context) {
              this.emitCallbackScope = context;
            }
          }
          return this;
        },
        onParticleDeath: function(callback, context) {
          if (callback === void 0) {
            this.deathCallback = null;
            this.deathCallbackScope = null;
          } else if (typeof callback === "function") {
            this.deathCallback = callback;
            if (context) {
              this.deathCallbackScope = context;
            }
          }
          return this;
        },
        killAll: function() {
          var dead = this.dead;
          var alive = this.alive;
          while (alive.length > 0) {
            dead.push(alive.pop());
          }
          return this;
        },
        forEachAlive: function(callback, context) {
          var alive = this.alive;
          var length = alive.length;
          for (var i = 0; i < length; i++) {
            callback.call(context, alive[i], this);
          }
          return this;
        },
        forEachDead: function(callback, context) {
          var dead = this.dead;
          var length = dead.length;
          for (var i = 0; i < length; i++) {
            callback.call(context, dead[i], this);
          }
          return this;
        },
        start: function(advance, duration) {
          if (advance === void 0) {
            advance = 0;
          }
          if (!this.emitting) {
            if (advance > 0) {
              this.fastForward(advance);
            }
            this.emitting = true;
            this.resetCounters(this.frequency, true);
            if (duration !== void 0) {
              this.duration = Math.abs(duration);
            }
            this.emit(Events.START, this);
          }
          return this;
        },
        stop: function(kill) {
          if (kill === void 0) {
            kill = false;
          }
          if (this.emitting) {
            this.emitting = false;
            if (kill) {
              this.killAll();
            }
            this.emit(Events.STOP, this);
          }
          return this;
        },
        pause: function() {
          this.active = false;
          return this;
        },
        resume: function() {
          this.active = true;
          return this;
        },
        setSortProperty: function(property, ascending) {
          if (property === void 0) {
            property = "";
          }
          if (ascending === void 0) {
            ascending = this.true;
          }
          this.sortProperty = property;
          this.sortOrderAsc = ascending;
          this.sortCallback = this.depthSortCallback;
          return this;
        },
        setSortCallback: function(callback) {
          if (this.sortProperty !== "") {
            callback = this.depthSortCallback;
          } else {
            callback = null;
          }
          this.sortCallback = callback;
          return this;
        },
        depthSort: function() {
          StableSort(this.alive, this.sortCallback.bind(this));
          return this;
        },
        depthSortCallback: function(a, b) {
          var key = this.sortProperty;
          if (this.sortOrderAsc) {
            return a[key] - b[key];
          } else {
            return b[key] - a[key];
          }
        },
        flow: function(frequency, count, stopAfter) {
          if (count === void 0) {
            count = 1;
          }
          this.emitting = false;
          this.frequency = frequency;
          this.quantity = count;
          if (stopAfter !== void 0) {
            this.stopAfter = stopAfter;
          }
          return this.start();
        },
        explode: function(count, x, y) {
          this.frequency = -1;
          this.resetCounters(-1, true);
          var particle = this.emitParticle(count, x, y);
          this.emit(Events.EXPLODE, this, particle);
          return particle;
        },
        emitParticleAt: function(x, y, count) {
          return this.emitParticle(count, x, y);
        },
        emitParticle: function(count, x, y) {
          if (this.atLimit()) {
            return;
          }
          if (count === void 0) {
            count = this.ops.quantity.onEmit();
          }
          var dead = this.dead;
          var stopAfter = this.stopAfter;
          var followX = this.follow ? this.follow.x + this.followOffset.x : x;
          var followY = this.follow ? this.follow.y + this.followOffset.y : y;
          for (var i = 0; i < count; i++) {
            var particle = dead.pop();
            if (!particle) {
              particle = new this.particleClass(this);
            }
            if (particle.fire(followX, followY)) {
              if (this.particleBringToTop) {
                this.alive.push(particle);
              } else {
                this.alive.unshift(particle);
              }
              if (this.emitCallback) {
                this.emitCallback.call(this.emitCallbackScope, particle, this);
              }
            } else {
              this.dead.push(particle);
            }
            if (stopAfter > 0) {
              this.stopCounter++;
              if (this.stopCounter >= stopAfter) {
                break;
              }
            }
            if (this.atLimit()) {
              break;
            }
          }
          return particle;
        },
        fastForward: function(time, delta) {
          if (delta === void 0) {
            delta = 1e3 / 60;
          }
          var total = 0;
          this.skipping = true;
          while (total < Math.abs(time)) {
            this.preUpdate(0, delta);
            total += delta;
          }
          this.skipping = false;
          return this;
        },
        preUpdate: function(time, delta) {
          delta *= this.timeScale;
          var step = delta / 1e3;
          if (this.trackVisible) {
            this.visible = this.follow.visible;
          }
          this.getWorldTransformMatrix(this.worldMatrix);
          var processors = this.getProcessors();
          var particles = this.alive;
          var dead = this.dead;
          var i = 0;
          var rip = [];
          var length = particles.length;
          for (i = 0; i < length; i++) {
            var particle = particles[i];
            if (particle.update(delta, step, processors)) {
              rip.push({ index: i, particle: particle });
            }
          }
          length = rip.length;
          if (length > 0) {
            var deathCallback = this.deathCallback;
            var deathCallbackScope = this.deathCallbackScope;
            for (i = length - 1; i >= 0; i--) {
              var entry = rip[i];
              particles.splice(entry.index, 1);
              dead.push(entry.particle);
              if (deathCallback) {
                deathCallback.call(deathCallbackScope, entry.particle);
              }
              entry.particle.setPosition();
            }
          }
          if (!this.emitting && !this.skipping) {
            if (this.completeFlag === 1 && particles.length === 0) {
              this.completeFlag = 0;
              this.emit(Events.COMPLETE, this);
            }
            return;
          }
          if (this.frequency === 0) {
            this.emitParticle();
          } else if (this.frequency > 0) {
            this.flowCounter -= delta;
            while (this.flowCounter <= 0) {
              this.emitParticle();
              this.flowCounter += this.frequency;
            }
          }
          if (!this.skipping) {
            if (this.duration > 0) {
              this.elapsed += delta;
              if (this.elapsed >= this.duration) {
                this.stop();
              }
            }
            if (this.stopAfter > 0 && this.stopCounter >= this.stopAfter) {
              this.stop();
            }
          }
        },
        overlap: function(target) {
          var matrix = this.getWorldTransformMatrix();
          var alive = this.alive;
          var length = alive.length;
          var output = [];
          for (var i = 0; i < length; i++) {
            var particle = alive[i];
            if (RectangleToRectangle(target, particle.getBounds(matrix))) {
              output.push(particle);
            }
          }
          return output;
        },
        getBounds: function(padding, advance, delta, output) {
          if (padding === void 0) {
            padding = 0;
          }
          if (advance === void 0) {
            advance = 0;
          }
          if (delta === void 0) {
            delta = 1e3 / 60;
          }
          if (output === void 0) {
            output = new Rectangle();
          }
          var matrix = this.getWorldTransformMatrix();
          var i;
          var bounds;
          var alive = this.alive;
          var setFirst = false;
          output.setTo(0, 0, 0, 0);
          if (advance > 0) {
            var total = 0;
            this.skipping = true;
            while (total < Math.abs(advance)) {
              this.preUpdate(0, delta);
              for (i = 0; i < alive.length; i++) {
                bounds = alive[i].getBounds(matrix);
                if (!setFirst) {
                  setFirst = true;
                  CopyFrom(bounds, output);
                } else {
                  MergeRect(output, bounds);
                }
              }
              total += delta;
            }
            this.skipping = false;
          } else {
            for (i = 0; i < alive.length; i++) {
              bounds = alive[i].getBounds(matrix);
              if (!setFirst) {
                setFirst = true;
                CopyFrom(bounds, output);
              } else {
                MergeRect(output, bounds);
              }
            }
          }
          if (padding > 0) {
            Inflate(output, padding, padding);
          }
          return output;
        },
        createEmitter: function() {
          throw new Error("createEmitter removed. See ParticleEmitter docs for info");
        },
        particleX: {
          get: function() {
            return this.ops.x.current;
          },
          set: function(value) {
            this.ops.x.onChange(value);
          }
        },
        particleY: {
          get: function() {
            return this.ops.y.current;
          },
          set: function(value) {
            this.ops.y.onChange(value);
          }
        },
        accelerationX: {
          get: function() {
            return this.ops.accelerationX.current;
          },
          set: function(value) {
            this.ops.accelerationX.onChange(value);
          }
        },
        accelerationY: {
          get: function() {
            return this.ops.accelerationY.current;
          },
          set: function(value) {
            this.ops.accelerationY.onChange(value);
          }
        },
        maxVelocityX: {
          get: function() {
            return this.ops.maxVelocityX.current;
          },
          set: function(value) {
            this.ops.maxVelocityX.onChange(value);
          }
        },
        maxVelocityY: {
          get: function() {
            return this.ops.maxVelocityY.current;
          },
          set: function(value) {
            this.ops.maxVelocityY.onChange(value);
          }
        },
        speed: {
          get: function() {
            return this.ops.speedX.current;
          },
          set: function(value) {
            this.ops.speedX.onChange(value);
            this.ops.speedY.onChange(value);
          }
        },
        speedX: {
          get: function() {
            return this.ops.speedX.current;
          },
          set: function(value) {
            this.ops.speedX.onChange(value);
          }
        },
        speedY: {
          get: function() {
            return this.ops.speedY.current;
          },
          set: function(value) {
            this.ops.speedY.onChange(value);
          }
        },
        moveToX: {
          get: function() {
            return this.ops.moveToX.current;
          },
          set: function(value) {
            this.ops.moveToX.onChange(value);
          }
        },
        moveToY: {
          get: function() {
            return this.ops.moveToY.current;
          },
          set: function(value) {
            this.ops.moveToY.onChange(value);
          }
        },
        bounce: {
          get: function() {
            return this.ops.bounce.current;
          },
          set: function(value) {
            this.ops.bounce.onChange(value);
          }
        },
        particleScaleX: {
          get: function() {
            return this.ops.scaleX.current;
          },
          set: function(value) {
            this.ops.scaleX.onChange(value);
          }
        },
        particleScaleY: {
          get: function() {
            return this.ops.scaleY.current;
          },
          set: function(value) {
            this.ops.scaleY.onChange(value);
          }
        },
        particleColor: {
          get: function() {
            return this.ops.color.current;
          },
          set: function(value) {
            this.ops.color.onChange(value);
          }
        },
        colorEase: {
          get: function() {
            return this.ops.color.easeName;
          },
          set: function(value) {
            this.ops.color.setEase(value);
          }
        },
        particleTint: {
          get: function() {
            return this.ops.tint.current;
          },
          set: function(value) {
            this.ops.tint.onChange(value);
          }
        },
        particleAlpha: {
          get: function() {
            return this.ops.alpha.current;
          },
          set: function(value) {
            this.ops.alpha.onChange(value);
          }
        },
        lifespan: {
          get: function() {
            return this.ops.lifespan.current;
          },
          set: function(value) {
            this.ops.lifespan.onChange(value);
          }
        },
        particleAngle: {
          get: function() {
            return this.ops.angle.current;
          },
          set: function(value) {
            this.ops.angle.onChange(value);
          }
        },
        particleRotate: {
          get: function() {
            return this.ops.rotate.current;
          },
          set: function(value) {
            this.ops.rotate.onChange(value);
          }
        },
        quantity: {
          get: function() {
            return this.ops.quantity.current;
          },
          set: function(value) {
            this.ops.quantity.onChange(value);
          }
        },
        delay: {
          get: function() {
            return this.ops.delay.current;
          },
          set: function(value) {
            this.ops.delay.onChange(value);
          }
        },
        hold: {
          get: function() {
            return this.ops.hold.current;
          },
          set: function(value) {
            this.ops.hold.onChange(value);
          }
        },
        flowCounter: {
          get: function() {
            return this.counters[0];
          },
          set: function(value) {
            this.counters[0] = value;
          }
        },
        frameCounter: {
          get: function() {
            return this.counters[1];
          },
          set: function(value) {
            this.counters[1] = value;
          }
        },
        animCounter: {
          get: function() {
            return this.counters[2];
          },
          set: function(value) {
            this.counters[2] = value;
          }
        },
        elapsed: {
          get: function() {
            return this.counters[3];
          },
          set: function(value) {
            this.counters[3] = value;
          }
        },
        stopCounter: {
          get: function() {
            return this.counters[4];
          },
          set: function(value) {
            this.counters[4] = value;
          }
        },
        completeFlag: {
          get: function() {
            return this.counters[5];
          },
          set: function(value) {
            this.counters[5] = value;
          }
        },
        zoneIndex: {
          get: function() {
            return this.counters[6];
          },
          set: function(value) {
            this.counters[6] = value;
          }
        },
        zoneTotal: {
          get: function() {
            return this.counters[7];
          },
          set: function(value) {
            this.counters[7] = value;
          }
        },
        currentFrame: {
          get: function() {
            return this.counters[8];
          },
          set: function(value) {
            this.counters[8] = value;
          }
        },
        currentAnim: {
          get: function() {
            return this.counters[9];
          },
          set: function(value) {
            this.counters[9] = value;
          }
        },
        preDestroy: function() {
          this.texture = null;
          this.frames = null;
          this.anims = null;
          this.emitCallback = null;
          this.emitCallbackScope = null;
          this.deathCallback = null;
          this.deathCallbackScope = null;
          this.emitZones = null;
          this.deathZones = null;
          this.bounds = null;
          this.follow = null;
          this.counters = null;
          var i;
          var ops = this.ops;
          for (i = 0; i < configOpMap.length; i++) {
            var key = configOpMap[i];
            ops[key].destroy();
          }
          for (i = 0; i < this.alive.length; i++) {
            this.alive[i].destroy();
          }
          for (i = 0; i < this.dead.length; i++) {
            this.dead[i].destroy();
          }
          this.ops = null;
          this.alive = [];
          this.dead = [];
          this.worldMatrix.destroy();
        }
      });
      module.exports = ParticleEmitter;
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/zones/index.js
  var require_zones = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/zones/index.js": function(exports, module) {
      module.exports = {
        DeathZone: require_DeathZone(),
        EdgeZone: require_EdgeZone(),
        RandomZone: require_RandomZone()
      };
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/index.js
  var require_particles = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/index.js": function(exports, module) {
      module.exports = {
        EmitterColorOp: require_EmitterColorOp(),
        EmitterOp: require_EmitterOp(),
        Events: require_events17(),
        GravityWell: require_GravityWell(),
        Particle: require_Particle(),
        ParticleBounds: require_ParticleBounds(),
        ParticleEmitter: require_ParticleEmitter(),
        ParticleProcessor: require_ParticleProcessor(),
        Zones: require_zones()
      };
    }
  });

  // ../../node_modules/phaser/src/gameobjects/container/ContainerFactory.js
  var require_ContainerFactory = __commonJS({
    "../../node_modules/phaser/src/gameobjects/container/ContainerFactory.js": function() {
      var Container = require_Container();
      var GameObjectFactory = require_GameObjectFactory();
      GameObjectFactory.register("container", function(x, y, children) {
        return this.displayList.add(new Container(this.scene, x, y, children));
      });
    }
  });

  // ../../node_modules/phaser/src/gameobjects/graphics/GraphicsFactory.js
  var require_GraphicsFactory = __commonJS({
    "../../node_modules/phaser/src/gameobjects/graphics/GraphicsFactory.js": function() {
      var Graphics = require_Graphics();
      var GameObjectFactory = require_GameObjectFactory();
      GameObjectFactory.register("graphics", function(config) {
        return this.displayList.add(new Graphics(this.scene, config));
      });
    }
  });

  // ../../node_modules/phaser/src/gameobjects/group/GroupFactory.js
  var require_GroupFactory = __commonJS({
    "../../node_modules/phaser/src/gameobjects/group/GroupFactory.js": function() {
      var Group = require_Group();
      var GameObjectFactory = require_GameObjectFactory();
      GameObjectFactory.register("group", function(children, config) {
        return this.updateList.add(new Group(this.scene, children, config));
      });
    }
  });

  // ../../node_modules/phaser/src/gameobjects/image/ImageFactory.js
  var require_ImageFactory = __commonJS({
    "../../node_modules/phaser/src/gameobjects/image/ImageFactory.js": function() {
      var Image2 = require_Image();
      var GameObjectFactory = require_GameObjectFactory();
      GameObjectFactory.register("image", function(x, y, texture, frame) {
        return this.displayList.add(new Image2(this.scene, x, y, texture, frame));
      });
    }
  });

  // ../../node_modules/phaser/src/gameobjects/sprite/SpriteFactory.js
  var require_SpriteFactory = __commonJS({
    "../../node_modules/phaser/src/gameobjects/sprite/SpriteFactory.js": function() {
      var GameObjectFactory = require_GameObjectFactory();
      var Sprite = require_Sprite();
      GameObjectFactory.register("sprite", function(x, y, texture, frame) {
        return this.displayList.add(new Sprite(this.scene, x, y, texture, frame));
      });
    }
  });

  // ../../node_modules/phaser/src/gameobjects/text/TextFactory.js
  var require_TextFactory = __commonJS({
    "../../node_modules/phaser/src/gameobjects/text/TextFactory.js": function() {
      var Text = require_Text();
      var GameObjectFactory = require_GameObjectFactory();
      GameObjectFactory.register("text", function(x, y, text, style) {
        return this.displayList.add(new Text(this.scene, x, y, text, style));
      });
    }
  });

  // ../../node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextFactory.js
  var require_BitmapTextFactory = __commonJS({
    "../../node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextFactory.js": function() {
      var BitmapText = require_BitmapText();
      var GameObjectFactory = require_GameObjectFactory();
      GameObjectFactory.register("bitmapText", function(x, y, font, text, size, align) {
        return this.displayList.add(new BitmapText(this.scene, x, y, font, text, size, align));
      });
    }
  });

  // ../../node_modules/phaser/src/gameobjects/particles/ParticleEmitterFactory.js
  var require_ParticleEmitterFactory = __commonJS({
    "../../node_modules/phaser/src/gameobjects/particles/ParticleEmitterFactory.js": function() {
      var GameObjectFactory = require_GameObjectFactory();
      var ParticleEmitter = require_ParticleEmitter();
      GameObjectFactory.register("particles", function(x, y, texture, config) {
        if (x !== void 0 && typeof x === "string") {
          console.warn("ParticleEmitterManager was removed in Phaser 3.60. See documentation for details");
        }
        return this.displayList.add(new ParticleEmitter(this.scene, x, y, texture, config));
      });
    }
  });

  // ../../node_modules/phaser/src/gameobjects/rendertexture/RenderTextureFactory.js
  var require_RenderTextureFactory = __commonJS({
    "../../node_modules/phaser/src/gameobjects/rendertexture/RenderTextureFactory.js": function() {
      var GameObjectFactory = require_GameObjectFactory();
      var RenderTexture = require_RenderTexture();
      GameObjectFactory.register("renderTexture", function(x, y, width, height) {
        return this.displayList.add(new RenderTexture(this.scene, x, y, width, height));
      });
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/line/LineFactory.js
  var require_LineFactory = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/line/LineFactory.js": function() {
      var GameObjectFactory = require_GameObjectFactory();
      var Line = require_Line2();
      GameObjectFactory.register("line", function(x, y, x1, y1, x2, y2, strokeColor, strokeAlpha) {
        return this.displayList.add(new Line(this.scene, x, y, x1, y1, x2, y2, strokeColor, strokeAlpha));
      });
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/rectangle/RectangleFactory.js
  var require_RectangleFactory = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/rectangle/RectangleFactory.js": function() {
      var GameObjectFactory = require_GameObjectFactory();
      var Rectangle = require_Rectangle2();
      GameObjectFactory.register("rectangle", function(x, y, width, height, fillColor, fillAlpha) {
        return this.displayList.add(new Rectangle(this.scene, x, y, width, height, fillColor, fillAlpha));
      });
    }
  });

  // ../../node_modules/phaser/src/gameobjects/shape/ellipse/EllipseFactory.js
  var require_EllipseFactory = __commonJS({
    "../../node_modules/phaser/src/gameobjects/shape/ellipse/EllipseFactory.js": function() {
      var Ellipse = require_Ellipse2();
      var GameObjectFactory = require_GameObjectFactory();
      GameObjectFactory.register("ellipse", function(x, y, width, height, fillColor, fillAlpha) {
        return this.displayList.add(new Ellipse(this.scene, x, y, width, height, fillColor, fillAlpha));
      });
    }
  });

  // ../../node_modules/phaser/src/gameobjects/graphics/GraphicsCreator.js
  var require_GraphicsCreator = __commonJS({
    "../../node_modules/phaser/src/gameobjects/graphics/GraphicsCreator.js": function() {
      var GameObjectCreator = require_GameObjectCreator();
      var Graphics = require_Graphics();
      GameObjectCreator.register("graphics", function(config, addToScene) {
        if (config === void 0) {
          config = {};
        }
        if (addToScene !== void 0) {
          config.add = addToScene;
        }
        var graphics = new Graphics(this.scene, config);
        if (config.add) {
          this.scene.sys.displayList.add(graphics);
        }
        return graphics;
      });
    }
  });

  // ../../node_modules/phaser/src/gameobjects/image/ImageCreator.js
  var require_ImageCreator = __commonJS({
    "../../node_modules/phaser/src/gameobjects/image/ImageCreator.js": function() {
      var BuildGameObject = require_BuildGameObject();
      var GameObjectCreator = require_GameObjectCreator();
      var GetAdvancedValue = require_GetAdvancedValue();
      var Image2 = require_Image();
      GameObjectCreator.register("image", function(config, addToScene) {
        if (config === void 0) {
          config = {};
        }
        var key = GetAdvancedValue(config, "key", null);
        var frame = GetAdvancedValue(config, "frame", null);
        var image = new Image2(this.scene, 0, 0, key, frame);
        if (addToScene !== void 0) {
          config.add = addToScene;
        }
        BuildGameObject(this.scene, image, config);
        return image;
      });
    }
  });

  // ../../node_modules/phaser/src/gameobjects/text/TextCreator.js
  var require_TextCreator = __commonJS({
    "../../node_modules/phaser/src/gameobjects/text/TextCreator.js": function() {
      var BuildGameObject = require_BuildGameObject();
      var GameObjectCreator = require_GameObjectCreator();
      var GetAdvancedValue = require_GetAdvancedValue();
      var Text = require_Text();
      GameObjectCreator.register("text", function(config, addToScene) {
        if (config === void 0) {
          config = {};
        }
        var content = GetAdvancedValue(config, "text", "");
        var style = GetAdvancedValue(config, "style", null);
        var padding = GetAdvancedValue(config, "padding", null);
        if (padding !== null) {
          style.padding = padding;
        }
        var text = new Text(this.scene, 0, 0, content, style);
        if (addToScene !== void 0) {
          config.add = addToScene;
        }
        BuildGameObject(this.scene, text, config);
        text.autoRound = GetAdvancedValue(config, "autoRound", true);
        text.resolution = GetAdvancedValue(config, "resolution", 1);
        return text;
      });
    }
  });

  // ../../node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextCreator.js
  var require_BitmapTextCreator = __commonJS({
    "../../node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextCreator.js": function() {
      var BitmapText = require_BitmapText();
      var BuildGameObject = require_BuildGameObject();
      var GameObjectCreator = require_GameObjectCreator();
      var GetAdvancedValue = require_GetAdvancedValue();
      var GetValue = require_GetValue();
      GameObjectCreator.register("bitmapText", function(config, addToScene) {
        if (config === void 0) {
          config = {};
        }
        var font = GetValue(config, "font", "");
        var text = GetAdvancedValue(config, "text", "");
        var size = GetAdvancedValue(config, "size", false);
        var align = GetValue(config, "align", 0);
        var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size, align);
        if (addToScene !== void 0) {
          config.add = addToScene;
        }
        BuildGameObject(this.scene, bitmapText, config);
        return bitmapText;
      });
    }
  });

  // ../../node_modules/phaser/src/gameobjects/rendertexture/RenderTextureCreator.js
  var require_RenderTextureCreator = __commonJS({
    "../../node_modules/phaser/src/gameobjects/rendertexture/RenderTextureCreator.js": function() {
      var BuildGameObject = require_BuildGameObject();
      var GameObjectCreator = require_GameObjectCreator();
      var GetAdvancedValue = require_GetAdvancedValue();
      var RenderTexture = require_RenderTexture();
      GameObjectCreator.register("renderTexture", function(config, addToScene) {
        if (config === void 0) {
          config = {};
        }
        var x = GetAdvancedValue(config, "x", 0);
        var y = GetAdvancedValue(config, "y", 0);
        var width = GetAdvancedValue(config, "width", 32);
        var height = GetAdvancedValue(config, "height", 32);
        var renderTexture = new RenderTexture(this.scene, x, y, width, height);
        if (addToScene !== void 0) {
          config.add = addToScene;
        }
        BuildGameObject(this.scene, renderTexture, config);
        return renderTexture;
      });
    }
  });

  // ../../node_modules/phaser/src/geom/point/Ceil.js
  var require_Ceil2 = __commonJS({
    "../../node_modules/phaser/src/geom/point/Ceil.js": function(exports, module) {
      var Ceil = function(point) {
        return point.setTo(Math.ceil(point.x), Math.ceil(point.y));
      };
      module.exports = Ceil;
    }
  });

  // ../../node_modules/phaser/src/geom/point/Clone.js
  var require_Clone2 = __commonJS({
    "../../node_modules/phaser/src/geom/point/Clone.js": function(exports, module) {
      var Point = require_Point();
      var Clone = function(source) {
        return new Point(source.x, source.y);
      };
      module.exports = Clone;
    }
  });

  // ../../node_modules/phaser/src/geom/point/CopyFrom.js
  var require_CopyFrom2 = __commonJS({
    "../../node_modules/phaser/src/geom/point/CopyFrom.js": function(exports, module) {
      var CopyFrom = function(source, dest) {
        return dest.setTo(source.x, source.y);
      };
      module.exports = CopyFrom;
    }
  });

  // ../../node_modules/phaser/src/geom/point/Equals.js
  var require_Equals = __commonJS({
    "../../node_modules/phaser/src/geom/point/Equals.js": function(exports, module) {
      var Equals = function(point, toCompare) {
        return point.x === toCompare.x && point.y === toCompare.y;
      };
      module.exports = Equals;
    }
  });

  // ../../node_modules/phaser/src/geom/point/Floor.js
  var require_Floor2 = __commonJS({
    "../../node_modules/phaser/src/geom/point/Floor.js": function(exports, module) {
      var Floor = function(point) {
        return point.setTo(Math.floor(point.x), Math.floor(point.y));
      };
      module.exports = Floor;
    }
  });

  // ../../node_modules/phaser/src/geom/point/GetCentroid.js
  var require_GetCentroid = __commonJS({
    "../../node_modules/phaser/src/geom/point/GetCentroid.js": function(exports, module) {
      var Point = require_Point();
      var GetCentroid = function(points, out) {
        if (out === void 0) {
          out = new Point();
        }
        if (!Array.isArray(points)) {
          throw new Error("GetCentroid points argument must be an array");
        }
        var len = points.length;
        if (len < 1) {
          throw new Error("GetCentroid points array must not be empty");
        } else if (len === 1) {
          out.x = points[0].x;
          out.y = points[0].y;
        } else {
          for (var i = 0; i < len; i++) {
            out.x += points[i].x;
            out.y += points[i].y;
          }
          out.x /= len;
          out.y /= len;
        }
        return out;
      };
      module.exports = GetCentroid;
    }
  });

  // ../../node_modules/phaser/src/geom/point/GetMagnitude.js
  var require_GetMagnitude = __commonJS({
    "../../node_modules/phaser/src/geom/point/GetMagnitude.js": function(exports, module) {
      var GetMagnitude = function(point) {
        return Math.sqrt(point.x * point.x + point.y * point.y);
      };
      module.exports = GetMagnitude;
    }
  });

  // ../../node_modules/phaser/src/geom/point/GetMagnitudeSq.js
  var require_GetMagnitudeSq = __commonJS({
    "../../node_modules/phaser/src/geom/point/GetMagnitudeSq.js": function(exports, module) {
      var GetMagnitudeSq = function(point) {
        return point.x * point.x + point.y * point.y;
      };
      module.exports = GetMagnitudeSq;
    }
  });

  // ../../node_modules/phaser/src/geom/point/GetRectangleFromPoints.js
  var require_GetRectangleFromPoints = __commonJS({
    "../../node_modules/phaser/src/geom/point/GetRectangleFromPoints.js": function(exports, module) {
      var Rectangle = require_Rectangle();
      var GetRectangleFromPoints = function(points, out) {
        if (out === void 0) {
          out = new Rectangle();
        }
        var xMax = Number.NEGATIVE_INFINITY;
        var xMin = Number.POSITIVE_INFINITY;
        var yMax = Number.NEGATIVE_INFINITY;
        var yMin = Number.POSITIVE_INFINITY;
        for (var i = 0; i < points.length; i++) {
          var point = points[i];
          if (point.x > xMax) {
            xMax = point.x;
          }
          if (point.x < xMin) {
            xMin = point.x;
          }
          if (point.y > yMax) {
            yMax = point.y;
          }
          if (point.y < yMin) {
            yMin = point.y;
          }
        }
        out.x = xMin;
        out.y = yMin;
        out.width = xMax - xMin;
        out.height = yMax - yMin;
        return out;
      };
      module.exports = GetRectangleFromPoints;
    }
  });

  // ../../node_modules/phaser/src/geom/point/Interpolate.js
  var require_Interpolate2 = __commonJS({
    "../../node_modules/phaser/src/geom/point/Interpolate.js": function(exports, module) {
      var Point = require_Point();
      var Interpolate = function(pointA, pointB, t, out) {
        if (t === void 0) {
          t = 0;
        }
        if (out === void 0) {
          out = new Point();
        }
        out.x = pointA.x + (pointB.x - pointA.x) * t;
        out.y = pointA.y + (pointB.y - pointA.y) * t;
        return out;
      };
      module.exports = Interpolate;
    }
  });

  // ../../node_modules/phaser/src/geom/point/Invert.js
  var require_Invert = __commonJS({
    "../../node_modules/phaser/src/geom/point/Invert.js": function(exports, module) {
      var Invert = function(point) {
        return point.setTo(point.y, point.x);
      };
      module.exports = Invert;
    }
  });

  // ../../node_modules/phaser/src/geom/point/Negative.js
  var require_Negative = __commonJS({
    "../../node_modules/phaser/src/geom/point/Negative.js": function(exports, module) {
      var Point = require_Point();
      var Negative = function(point, out) {
        if (out === void 0) {
          out = new Point();
        }
        return out.setTo(-point.x, -point.y);
      };
      module.exports = Negative;
    }
  });

  // ../../node_modules/phaser/src/geom/point/Project.js
  var require_Project = __commonJS({
    "../../node_modules/phaser/src/geom/point/Project.js": function(exports, module) {
      var Point = require_Point();
      var GetMagnitudeSq = require_GetMagnitudeSq();
      var Project = function(pointA, pointB, out) {
        if (out === void 0) {
          out = new Point();
        }
        var dot = pointA.x * pointB.x + pointA.y * pointB.y;
        var amt = dot / GetMagnitudeSq(pointB);
        if (amt !== 0) {
          out.x = amt * pointB.x;
          out.y = amt * pointB.y;
        }
        return out;
      };
      module.exports = Project;
    }
  });

  // ../../node_modules/phaser/src/geom/point/ProjectUnit.js
  var require_ProjectUnit = __commonJS({
    "../../node_modules/phaser/src/geom/point/ProjectUnit.js": function(exports, module) {
      var Point = require_Point();
      var ProjectUnit = function(pointA, pointB, out) {
        if (out === void 0) {
          out = new Point();
        }
        var amt = pointA.x * pointB.x + pointA.y * pointB.y;
        if (amt !== 0) {
          out.x = amt * pointB.x;
          out.y = amt * pointB.y;
        }
        return out;
      };
      module.exports = ProjectUnit;
    }
  });

  // ../../node_modules/phaser/src/geom/point/SetMagnitude.js
  var require_SetMagnitude = __commonJS({
    "../../node_modules/phaser/src/geom/point/SetMagnitude.js": function(exports, module) {
      var GetMagnitude = require_GetMagnitude();
      var SetMagnitude = function(point, magnitude) {
        if (point.x !== 0 || point.y !== 0) {
          var m = GetMagnitude(point);
          point.x /= m;
          point.y /= m;
        }
        point.x *= magnitude;
        point.y *= magnitude;
        return point;
      };
      module.exports = SetMagnitude;
    }
  });

  // ../../node_modules/phaser/src/geom/point/index.js
  var require_point = __commonJS({
    "../../node_modules/phaser/src/geom/point/index.js": function(exports, module) {
      var Point = require_Point();
      Point.Ceil = require_Ceil2();
      Point.Clone = require_Clone2();
      Point.CopyFrom = require_CopyFrom2();
      Point.Equals = require_Equals();
      Point.Floor = require_Floor2();
      Point.GetCentroid = require_GetCentroid();
      Point.GetMagnitude = require_GetMagnitude();
      Point.GetMagnitudeSq = require_GetMagnitudeSq();
      Point.GetRectangleFromPoints = require_GetRectangleFromPoints();
      Point.Interpolate = require_Interpolate2();
      Point.Invert = require_Invert();
      Point.Negative = require_Negative();
      Point.Project = require_Project();
      Point.ProjectUnit = require_ProjectUnit();
      Point.SetMagnitude = require_SetMagnitude();
      module.exports = Point;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/Area.js
  var require_Area = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/Area.js": function(exports, module) {
      var Area = function(rect) {
        return rect.width * rect.height;
      };
      module.exports = Area;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/Ceil.js
  var require_Ceil3 = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/Ceil.js": function(exports, module) {
      var Ceil = function(rect) {
        rect.x = Math.ceil(rect.x);
        rect.y = Math.ceil(rect.y);
        return rect;
      };
      module.exports = Ceil;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/CeilAll.js
  var require_CeilAll = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/CeilAll.js": function(exports, module) {
      var CeilAll = function(rect) {
        rect.x = Math.ceil(rect.x);
        rect.y = Math.ceil(rect.y);
        rect.width = Math.ceil(rect.width);
        rect.height = Math.ceil(rect.height);
        return rect;
      };
      module.exports = CeilAll;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/Clone.js
  var require_Clone3 = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/Clone.js": function(exports, module) {
      var Rectangle = require_Rectangle();
      var Clone = function(source) {
        return new Rectangle(source.x, source.y, source.width, source.height);
      };
      module.exports = Clone;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/ContainsPoint.js
  var require_ContainsPoint = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/ContainsPoint.js": function(exports, module) {
      var Contains = require_Contains2();
      var ContainsPoint = function(rect, point) {
        return Contains(rect, point.x, point.y);
      };
      module.exports = ContainsPoint;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/ContainsRect.js
  var require_ContainsRect = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/ContainsRect.js": function(exports, module) {
      var ContainsRect = function(rectA, rectB) {
        if (rectB.width * rectB.height > rectA.width * rectA.height) {
          return false;
        }
        return rectB.x > rectA.x && rectB.x < rectA.right && (rectB.right > rectA.x && rectB.right < rectA.right) && (rectB.y > rectA.y && rectB.y < rectA.bottom) && (rectB.bottom > rectA.y && rectB.bottom < rectA.bottom);
      };
      module.exports = ContainsRect;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/Decompose.js
  var require_Decompose = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/Decompose.js": function(exports, module) {
      var Decompose = function(rect, out) {
        if (out === void 0) {
          out = [];
        }
        out.push({ x: rect.x, y: rect.y });
        out.push({ x: rect.right, y: rect.y });
        out.push({ x: rect.right, y: rect.bottom });
        out.push({ x: rect.x, y: rect.bottom });
        return out;
      };
      module.exports = Decompose;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/Equals.js
  var require_Equals2 = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/Equals.js": function(exports, module) {
      var Equals = function(rect, toCompare) {
        return rect.x === toCompare.x && rect.y === toCompare.y && rect.width === toCompare.width && rect.height === toCompare.height;
      };
      module.exports = Equals;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/GetAspectRatio.js
  var require_GetAspectRatio = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/GetAspectRatio.js": function(exports, module) {
      var GetAspectRatio = function(rect) {
        return rect.height === 0 ? NaN : rect.width / rect.height;
      };
      module.exports = GetAspectRatio;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/FitInside.js
  var require_FitInside = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/FitInside.js": function(exports, module) {
      var GetAspectRatio = require_GetAspectRatio();
      var FitInside = function(target, source) {
        var ratio = GetAspectRatio(target);
        if (ratio < GetAspectRatio(source)) {
          target.setSize(source.height * ratio, source.height);
        } else {
          target.setSize(source.width, source.width / ratio);
        }
        return target.setPosition(source.centerX - target.width / 2, source.centerY - target.height / 2);
      };
      module.exports = FitInside;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/FitOutside.js
  var require_FitOutside = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/FitOutside.js": function(exports, module) {
      var GetAspectRatio = require_GetAspectRatio();
      var FitOutside = function(target, source) {
        var ratio = GetAspectRatio(target);
        if (ratio > GetAspectRatio(source)) {
          target.setSize(source.height * ratio, source.height);
        } else {
          target.setSize(source.width, source.width / ratio);
        }
        return target.setPosition(source.centerX - target.width / 2, source.centerY - target.height / 2);
      };
      module.exports = FitOutside;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/Floor.js
  var require_Floor3 = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/Floor.js": function(exports, module) {
      var Floor = function(rect) {
        rect.x = Math.floor(rect.x);
        rect.y = Math.floor(rect.y);
        return rect;
      };
      module.exports = Floor;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/FloorAll.js
  var require_FloorAll = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/FloorAll.js": function(exports, module) {
      var FloorAll = function(rect) {
        rect.x = Math.floor(rect.x);
        rect.y = Math.floor(rect.y);
        rect.width = Math.floor(rect.width);
        rect.height = Math.floor(rect.height);
        return rect;
      };
      module.exports = FloorAll;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/FromXY.js
  var require_FromXY = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/FromXY.js": function(exports, module) {
      var Rectangle = require_Rectangle();
      var FromXY = function(x1, y1, x2, y2, out) {
        if (out === void 0) {
          out = new Rectangle();
        }
        return out.setTo(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x1 - x2), Math.abs(y1 - y2));
      };
      module.exports = FromXY;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/GetCenter.js
  var require_GetCenter = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/GetCenter.js": function(exports, module) {
      var Point = require_Point();
      var GetCenter = function(rect, out) {
        if (out === void 0) {
          out = new Point();
        }
        out.x = rect.centerX;
        out.y = rect.centerY;
        return out;
      };
      module.exports = GetCenter;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/GetSize.js
  var require_GetSize = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/GetSize.js": function(exports, module) {
      var Point = require_Point();
      var GetSize = function(rect, out) {
        if (out === void 0) {
          out = new Point();
        }
        out.x = rect.width;
        out.y = rect.height;
        return out;
      };
      module.exports = GetSize;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/Intersection.js
  var require_Intersection = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/Intersection.js": function(exports, module) {
      var Rectangle = require_Rectangle();
      var Intersects = require_RectangleToRectangle();
      var Intersection = function(rectA, rectB, out) {
        if (out === void 0) {
          out = new Rectangle();
        }
        if (Intersects(rectA, rectB)) {
          out.x = Math.max(rectA.x, rectB.x);
          out.y = Math.max(rectA.y, rectB.y);
          out.width = Math.min(rectA.right, rectB.right) - out.x;
          out.height = Math.min(rectA.bottom, rectB.bottom) - out.y;
        } else {
          out.setEmpty();
        }
        return out;
      };
      module.exports = Intersection;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/MergePoints.js
  var require_MergePoints = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/MergePoints.js": function(exports, module) {
      var MergePoints = function(target, points) {
        var minX = target.x;
        var maxX = target.right;
        var minY = target.y;
        var maxY = target.bottom;
        for (var i = 0; i < points.length; i++) {
          minX = Math.min(minX, points[i].x);
          maxX = Math.max(maxX, points[i].x);
          minY = Math.min(minY, points[i].y);
          maxY = Math.max(maxY, points[i].y);
        }
        target.x = minX;
        target.y = minY;
        target.width = maxX - minX;
        target.height = maxY - minY;
        return target;
      };
      module.exports = MergePoints;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/MergeXY.js
  var require_MergeXY = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/MergeXY.js": function(exports, module) {
      var MergeXY = function(target, x, y) {
        var minX = Math.min(target.x, x);
        var maxX = Math.max(target.right, x);
        target.x = minX;
        target.width = maxX - minX;
        var minY = Math.min(target.y, y);
        var maxY = Math.max(target.bottom, y);
        target.y = minY;
        target.height = maxY - minY;
        return target;
      };
      module.exports = MergeXY;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/Offset.js
  var require_Offset = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/Offset.js": function(exports, module) {
      var Offset = function(rect, x, y) {
        rect.x += x;
        rect.y += y;
        return rect;
      };
      module.exports = Offset;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/OffsetPoint.js
  var require_OffsetPoint = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/OffsetPoint.js": function(exports, module) {
      var OffsetPoint = function(rect, point) {
        rect.x += point.x;
        rect.y += point.y;
        return rect;
      };
      module.exports = OffsetPoint;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/Overlaps.js
  var require_Overlaps = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/Overlaps.js": function(exports, module) {
      var Overlaps = function(rectA, rectB) {
        return rectA.x < rectB.right && rectA.right > rectB.x && rectA.y < rectB.bottom && rectA.bottom > rectB.y;
      };
      module.exports = Overlaps;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/PerimeterPoint.js
  var require_PerimeterPoint = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/PerimeterPoint.js": function(exports, module) {
      var Point = require_Point();
      var DegToRad = require_DegToRad();
      var PerimeterPoint = function(rectangle, angle, out) {
        if (out === void 0) {
          out = new Point();
        }
        angle = DegToRad(angle);
        var s = Math.sin(angle);
        var c = Math.cos(angle);
        var dx = c > 0 ? rectangle.width / 2 : rectangle.width / -2;
        var dy = s > 0 ? rectangle.height / 2 : rectangle.height / -2;
        if (Math.abs(dx * s) < Math.abs(dy * c)) {
          dy = dx * s / c;
        } else {
          dx = dy * c / s;
        }
        out.x = dx + rectangle.centerX;
        out.y = dy + rectangle.centerY;
        return out;
      };
      module.exports = PerimeterPoint;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/RandomOutside.js
  var require_RandomOutside = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/RandomOutside.js": function(exports, module) {
      var Between = require_Between2();
      var ContainsRect = require_ContainsRect();
      var Point = require_Point();
      var RandomOutside = function(outer, inner, out) {
        if (out === void 0) {
          out = new Point();
        }
        if (ContainsRect(outer, inner)) {
          switch (Between(0, 3)) {
            case 0:
              out.x = outer.x + Math.random() * (inner.right - outer.x);
              out.y = outer.y + Math.random() * (inner.top - outer.y);
              break;
            case 1:
              out.x = inner.x + Math.random() * (outer.right - inner.x);
              out.y = inner.bottom + Math.random() * (outer.bottom - inner.bottom);
              break;
            case 2:
              out.x = outer.x + Math.random() * (inner.x - outer.x);
              out.y = inner.y + Math.random() * (outer.bottom - inner.y);
              break;
            case 3:
              out.x = inner.right + Math.random() * (outer.right - inner.right);
              out.y = outer.y + Math.random() * (inner.bottom - outer.y);
              break;
          }
        }
        return out;
      };
      module.exports = RandomOutside;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/SameDimensions.js
  var require_SameDimensions = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/SameDimensions.js": function(exports, module) {
      var SameDimensions = function(rect, toCompare) {
        return rect.width === toCompare.width && rect.height === toCompare.height;
      };
      module.exports = SameDimensions;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/Scale.js
  var require_Scale = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/Scale.js": function(exports, module) {
      var Scale = function(rect, x, y) {
        if (y === void 0) {
          y = x;
        }
        rect.width *= x;
        rect.height *= y;
        return rect;
      };
      module.exports = Scale;
    }
  });

  // ../../node_modules/phaser/src/geom/rectangle/index.js
  var require_rectangle = __commonJS({
    "../../node_modules/phaser/src/geom/rectangle/index.js": function(exports, module) {
      var Rectangle = require_Rectangle();
      Rectangle.Area = require_Area();
      Rectangle.Ceil = require_Ceil3();
      Rectangle.CeilAll = require_CeilAll();
      Rectangle.CenterOn = require_CenterOn2();
      Rectangle.Clone = require_Clone3();
      Rectangle.Contains = require_Contains2();
      Rectangle.ContainsPoint = require_ContainsPoint();
      Rectangle.ContainsRect = require_ContainsRect();
      Rectangle.CopyFrom = require_CopyFrom();
      Rectangle.Decompose = require_Decompose();
      Rectangle.Equals = require_Equals2();
      Rectangle.FitInside = require_FitInside();
      Rectangle.FitOutside = require_FitOutside();
      Rectangle.Floor = require_Floor3();
      Rectangle.FloorAll = require_FloorAll();
      Rectangle.FromPoints = require_FromPoints();
      Rectangle.FromXY = require_FromXY();
      Rectangle.GetAspectRatio = require_GetAspectRatio();
      Rectangle.GetCenter = require_GetCenter();
      Rectangle.GetPoint = require_GetPoint2();
      Rectangle.GetPoints = require_GetPoints2();
      Rectangle.GetSize = require_GetSize();
      Rectangle.Inflate = require_Inflate();
      Rectangle.Intersection = require_Intersection();
      Rectangle.MarchingAnts = require_MarchingAnts();
      Rectangle.MergePoints = require_MergePoints();
      Rectangle.MergeRect = require_MergeRect();
      Rectangle.MergeXY = require_MergeXY();
      Rectangle.Offset = require_Offset();
      Rectangle.OffsetPoint = require_OffsetPoint();
      Rectangle.Overlaps = require_Overlaps();
      Rectangle.Perimeter = require_Perimeter();
      Rectangle.PerimeterPoint = require_PerimeterPoint();
      Rectangle.Random = require_Random3();
      Rectangle.RandomOutside = require_RandomOutside();
      Rectangle.SameDimensions = require_SameDimensions();
      Rectangle.Scale = require_Scale();
      Rectangle.Union = require_Union();
      module.exports = Rectangle;
    }
  });

  // ../../node_modules/phaser/src/geom/circle/Area.js
  var require_Area2 = __commonJS({
    "../../node_modules/phaser/src/geom/circle/Area.js": function(exports, module) {
      var Area = function(circle) {
        return circle.radius > 0 ? Math.PI * circle.radius * circle.radius : 0;
      };
      module.exports = Area;
    }
  });

  // ../../node_modules/phaser/src/geom/circle/Clone.js
  var require_Clone4 = __commonJS({
    "../../node_modules/phaser/src/geom/circle/Clone.js": function(exports, module) {
      var Circle = require_Circle();
      var Clone = function(source) {
        return new Circle(source.x, source.y, source.radius);
      };
      module.exports = Clone;
    }
  });

  // ../../node_modules/phaser/src/geom/circle/ContainsPoint.js
  var require_ContainsPoint2 = __commonJS({
    "../../node_modules/phaser/src/geom/circle/ContainsPoint.js": function(exports, module) {
      var Contains = require_Contains();
      var ContainsPoint = function(circle, point) {
        return Contains(circle, point.x, point.y);
      };
      module.exports = ContainsPoint;
    }
  });

  // ../../node_modules/phaser/src/geom/circle/ContainsRect.js
  var require_ContainsRect2 = __commonJS({
    "../../node_modules/phaser/src/geom/circle/ContainsRect.js": function(exports, module) {
      var Contains = require_Contains();
      var ContainsRect = function(circle, rect) {
        return Contains(circle, rect.x, rect.y) && Contains(circle, rect.right, rect.y) && Contains(circle, rect.x, rect.bottom) && Contains(circle, rect.right, rect.bottom);
      };
      module.exports = ContainsRect;
    }
  });

  // ../../node_modules/phaser/src/geom/circle/CopyFrom.js
  var require_CopyFrom3 = __commonJS({
    "../../node_modules/phaser/src/geom/circle/CopyFrom.js": function(exports, module) {
      var CopyFrom = function(source, dest) {
        return dest.setTo(source.x, source.y, source.radius);
      };
      module.exports = CopyFrom;
    }
  });

  // ../../node_modules/phaser/src/geom/circle/Equals.js
  var require_Equals3 = __commonJS({
    "../../node_modules/phaser/src/geom/circle/Equals.js": function(exports, module) {
      var Equals = function(circle, toCompare) {
        return circle.x === toCompare.x && circle.y === toCompare.y && circle.radius === toCompare.radius;
      };
      module.exports = Equals;
    }
  });

  // ../../node_modules/phaser/src/geom/circle/GetBounds.js
  var require_GetBounds3 = __commonJS({
    "../../node_modules/phaser/src/geom/circle/GetBounds.js": function(exports, module) {
      var Rectangle = require_Rectangle();
      var GetBounds = function(circle, out) {
        if (out === void 0) {
          out = new Rectangle();
        }
        out.x = circle.left;
        out.y = circle.top;
        out.width = circle.diameter;
        out.height = circle.diameter;
        return out;
      };
      module.exports = GetBounds;
    }
  });

  // ../../node_modules/phaser/src/geom/circle/Offset.js
  var require_Offset2 = __commonJS({
    "../../node_modules/phaser/src/geom/circle/Offset.js": function(exports, module) {
      var Offset = function(circle, x, y) {
        circle.x += x;
        circle.y += y;
        return circle;
      };
      module.exports = Offset;
    }
  });

  // ../../node_modules/phaser/src/geom/circle/OffsetPoint.js
  var require_OffsetPoint2 = __commonJS({
    "../../node_modules/phaser/src/geom/circle/OffsetPoint.js": function(exports, module) {
      var OffsetPoint = function(circle, point) {
        circle.x += point.x;
        circle.y += point.y;
        return circle;
      };
      module.exports = OffsetPoint;
    }
  });

  // ../../node_modules/phaser/src/geom/circle/index.js
  var require_circle = __commonJS({
    "../../node_modules/phaser/src/geom/circle/index.js": function(exports, module) {
      var Circle = require_Circle();
      Circle.Area = require_Area2();
      Circle.Circumference = require_Circumference();
      Circle.CircumferencePoint = require_CircumferencePoint();
      Circle.Clone = require_Clone4();
      Circle.Contains = require_Contains();
      Circle.ContainsPoint = require_ContainsPoint2();
      Circle.ContainsRect = require_ContainsRect2();
      Circle.CopyFrom = require_CopyFrom3();
      Circle.Equals = require_Equals3();
      Circle.GetBounds = require_GetBounds3();
      Circle.GetPoint = require_GetPoint();
      Circle.GetPoints = require_GetPoints();
      Circle.Offset = require_Offset2();
      Circle.OffsetPoint = require_OffsetPoint2();
      Circle.Random = require_Random();
      module.exports = Circle;
    }
  });

  // ../../node_modules/phaser/src/input/CreatePixelPerfectHandler.js
  var require_CreatePixelPerfectHandler = __commonJS({
    "../../node_modules/phaser/src/input/CreatePixelPerfectHandler.js": function(exports, module) {
      var CreatePixelPerfectHandler = function(textureManager, alphaTolerance) {
        return function(hitArea, x, y, gameObject) {
          var alpha = textureManager.getPixelAlpha(x, y, gameObject.texture.key, gameObject.frame.name);
          return alpha && alpha >= alphaTolerance;
        };
      };
      module.exports = CreatePixelPerfectHandler;
    }
  });

  // ../../node_modules/phaser/src/input/CreateInteractiveObject.js
  var require_CreateInteractiveObject = __commonJS({
    "../../node_modules/phaser/src/input/CreateInteractiveObject.js": function(exports, module) {
      var CreateInteractiveObject = function(gameObject, hitArea, hitAreaCallback) {
        return {
          gameObject: gameObject,
          enabled: true,
          draggable: false,
          dropZone: false,
          cursor: false,
          target: null,
          camera: null,
          hitArea: hitArea,
          hitAreaCallback: hitAreaCallback,
          hitAreaDebug: null,
          customHitArea: false,
          localX: 0,
          localY: 0,
          dragState: 0,
          dragStartX: 0,
          dragStartY: 0,
          dragStartXGlobal: 0,
          dragStartYGlobal: 0,
          dragX: 0,
          dragY: 0
        };
      };
      module.exports = CreateInteractiveObject;
    }
  });

  // ../../node_modules/phaser/src/input/gamepad/Axis.js
  var require_Axis = __commonJS({
    "../../node_modules/phaser/src/input/gamepad/Axis.js": function(exports, module) {
      var Class = require_Class();
      var Axis = new Class({
        initialize: function Axis2(pad, index) {
          this.pad = pad;
          this.events = pad.events;
          this.index = index;
          this.value = 0;
          this.threshold = 0.1;
        },
        update: function(value) {
          this.value = value;
        },
        getValue: function() {
          return Math.abs(this.value) < this.threshold ? 0 : this.value;
        },
        destroy: function() {
          this.pad = null;
          this.events = null;
        }
      });
      module.exports = Axis;
    }
  });

  // ../../node_modules/phaser/src/input/gamepad/events/BUTTON_DOWN_EVENT.js
  var require_BUTTON_DOWN_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/gamepad/events/BUTTON_DOWN_EVENT.js": function(exports, module) {
      module.exports = "down";
    }
  });

  // ../../node_modules/phaser/src/input/gamepad/events/BUTTON_UP_EVENT.js
  var require_BUTTON_UP_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/gamepad/events/BUTTON_UP_EVENT.js": function(exports, module) {
      module.exports = "up";
    }
  });

  // ../../node_modules/phaser/src/input/gamepad/events/CONNECTED_EVENT.js
  var require_CONNECTED_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/gamepad/events/CONNECTED_EVENT.js": function(exports, module) {
      module.exports = "connected";
    }
  });

  // ../../node_modules/phaser/src/input/gamepad/events/DISCONNECTED_EVENT.js
  var require_DISCONNECTED_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/gamepad/events/DISCONNECTED_EVENT.js": function(exports, module) {
      module.exports = "disconnected";
    }
  });

  // ../../node_modules/phaser/src/input/gamepad/events/GAMEPAD_BUTTON_DOWN_EVENT.js
  var require_GAMEPAD_BUTTON_DOWN_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/gamepad/events/GAMEPAD_BUTTON_DOWN_EVENT.js": function(exports, module) {
      module.exports = "down";
    }
  });

  // ../../node_modules/phaser/src/input/gamepad/events/GAMEPAD_BUTTON_UP_EVENT.js
  var require_GAMEPAD_BUTTON_UP_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/gamepad/events/GAMEPAD_BUTTON_UP_EVENT.js": function(exports, module) {
      module.exports = "up";
    }
  });

  // ../../node_modules/phaser/src/input/gamepad/events/index.js
  var require_events18 = __commonJS({
    "../../node_modules/phaser/src/input/gamepad/events/index.js": function(exports, module) {
      module.exports = {
        BUTTON_DOWN: require_BUTTON_DOWN_EVENT(),
        BUTTON_UP: require_BUTTON_UP_EVENT(),
        CONNECTED: require_CONNECTED_EVENT(),
        DISCONNECTED: require_DISCONNECTED_EVENT(),
        GAMEPAD_BUTTON_DOWN: require_GAMEPAD_BUTTON_DOWN_EVENT(),
        GAMEPAD_BUTTON_UP: require_GAMEPAD_BUTTON_UP_EVENT()
      };
    }
  });

  // ../../node_modules/phaser/src/input/gamepad/Button.js
  var require_Button = __commonJS({
    "../../node_modules/phaser/src/input/gamepad/Button.js": function(exports, module) {
      var Class = require_Class();
      var Events = require_events18();
      var Button = new Class({
        initialize: function Button2(pad, index) {
          this.pad = pad;
          this.events = pad.manager;
          this.index = index;
          this.value = 0;
          this.threshold = 1;
          this.pressed = false;
        },
        update: function(value) {
          this.value = value;
          var pad = this.pad;
          var index = this.index;
          if (value >= this.threshold) {
            if (!this.pressed) {
              this.pressed = true;
              this.events.emit(Events.BUTTON_DOWN, pad, this, value);
              this.pad.emit(Events.GAMEPAD_BUTTON_DOWN, index, value, this);
            }
          } else if (this.pressed) {
            this.pressed = false;
            this.events.emit(Events.BUTTON_UP, pad, this, value);
            this.pad.emit(Events.GAMEPAD_BUTTON_UP, index, value, this);
          }
        },
        destroy: function() {
          this.pad = null;
          this.events = null;
        }
      });
      module.exports = Button;
    }
  });

  // ../../node_modules/phaser/src/input/gamepad/Gamepad.js
  var require_Gamepad = __commonJS({
    "../../node_modules/phaser/src/input/gamepad/Gamepad.js": function(exports, module) {
      var Axis = require_Axis();
      var Button = require_Button();
      var Class = require_Class();
      var EventEmitter = require_eventemitter3();
      var Vector2 = require_Vector2();
      var Gamepad = new Class({
        Extends: EventEmitter,
        initialize: function Gamepad2(manager, pad) {
          EventEmitter.call(this);
          this.manager = manager;
          this.pad = pad;
          this.id = pad.id;
          this.index = pad.index;
          var buttons = [];
          for (var i = 0; i < pad.buttons.length; i++) {
            buttons.push(new Button(this, i));
          }
          this.buttons = buttons;
          var axes = [];
          for (i = 0; i < pad.axes.length; i++) {
            axes.push(new Axis(this, i));
          }
          this.axes = axes;
          this.vibration = pad.vibrationActuator;
          var _noButton = { value: 0, pressed: false };
          this._LCLeft = buttons[14] ? buttons[14] : _noButton;
          this._LCRight = buttons[15] ? buttons[15] : _noButton;
          this._LCTop = buttons[12] ? buttons[12] : _noButton;
          this._LCBottom = buttons[13] ? buttons[13] : _noButton;
          this._RCLeft = buttons[2] ? buttons[2] : _noButton;
          this._RCRight = buttons[1] ? buttons[1] : _noButton;
          this._RCTop = buttons[3] ? buttons[3] : _noButton;
          this._RCBottom = buttons[0] ? buttons[0] : _noButton;
          this._FBLeftTop = buttons[4] ? buttons[4] : _noButton;
          this._FBLeftBottom = buttons[6] ? buttons[6] : _noButton;
          this._FBRightTop = buttons[5] ? buttons[5] : _noButton;
          this._FBRightBottom = buttons[7] ? buttons[7] : _noButton;
          var _noAxis = { value: 0 };
          this._HAxisLeft = axes[0] ? axes[0] : _noAxis;
          this._VAxisLeft = axes[1] ? axes[1] : _noAxis;
          this._HAxisRight = axes[2] ? axes[2] : _noAxis;
          this._VAxisRight = axes[3] ? axes[3] : _noAxis;
          this.leftStick = new Vector2();
          this.rightStick = new Vector2();
          this._created = performance.now();
        },
        getAxisTotal: function() {
          return this.axes.length;
        },
        getAxisValue: function(index) {
          return this.axes[index].getValue();
        },
        setAxisThreshold: function(value) {
          for (var i = 0; i < this.axes.length; i++) {
            this.axes[i].threshold = value;
          }
        },
        getButtonTotal: function() {
          return this.buttons.length;
        },
        getButtonValue: function(index) {
          return this.buttons[index].value;
        },
        isButtonDown: function(index) {
          return this.buttons[index].pressed;
        },
        update: function(pad) {
          if (pad.timestamp < this._created) {
            return;
          }
          var i;
          var localButtons = this.buttons;
          var gamepadButtons = pad.buttons;
          var len = localButtons.length;
          for (i = 0; i < len; i++) {
            localButtons[i].update(gamepadButtons[i].value);
          }
          var localAxes = this.axes;
          var gamepadAxes = pad.axes;
          len = localAxes.length;
          for (i = 0; i < len; i++) {
            localAxes[i].update(gamepadAxes[i]);
          }
          if (len >= 2) {
            this.leftStick.set(localAxes[0].getValue(), localAxes[1].getValue());
            if (len >= 4) {
              this.rightStick.set(localAxes[2].getValue(), localAxes[3].getValue());
            }
          }
        },
        destroy: function() {
          this.removeAllListeners();
          this.manager = null;
          this.pad = null;
          var i;
          for (i = 0; i < this.buttons.length; i++) {
            this.buttons[i].destroy();
          }
          for (i = 0; i < this.axes.length; i++) {
            this.axes[i].destroy();
          }
          this.buttons = [];
          this.axes = [];
        },
        connected: {
          get: function() {
            return this.pad.connected;
          }
        },
        timestamp: {
          get: function() {
            return this.pad.timestamp;
          }
        },
        left: {
          get: function() {
            return this._LCLeft.pressed;
          }
        },
        right: {
          get: function() {
            return this._LCRight.pressed;
          }
        },
        up: {
          get: function() {
            return this._LCTop.pressed;
          }
        },
        down: {
          get: function() {
            return this._LCBottom.pressed;
          }
        },
        A: {
          get: function() {
            return this._RCBottom.pressed;
          }
        },
        Y: {
          get: function() {
            return this._RCTop.pressed;
          }
        },
        X: {
          get: function() {
            return this._RCLeft.pressed;
          }
        },
        B: {
          get: function() {
            return this._RCRight.pressed;
          }
        },
        L1: {
          get: function() {
            return this._FBLeftTop.value;
          }
        },
        L2: {
          get: function() {
            return this._FBLeftBottom.value;
          }
        },
        R1: {
          get: function() {
            return this._FBRightTop.value;
          }
        },
        R2: {
          get: function() {
            return this._FBRightBottom.value;
          }
        }
      });
      module.exports = Gamepad;
    }
  });

  // ../../node_modules/phaser/src/input/InputPluginCache.js
  var require_InputPluginCache = __commonJS({
    "../../node_modules/phaser/src/input/InputPluginCache.js": function(exports, module) {
      var GetValue = require_GetValue();
      var inputPlugins = {};
      var InputPluginCache = {};
      InputPluginCache.register = function(key, plugin, mapping, settingsKey, configKey) {
        inputPlugins[key] = { plugin: plugin, mapping: mapping, settingsKey: settingsKey, configKey: configKey };
      };
      InputPluginCache.getPlugin = function(key) {
        return inputPlugins[key];
      };
      InputPluginCache.install = function(target) {
        var sys = target.scene.sys;
        var settings = sys.settings.input;
        var config = sys.game.config;
        for (var key in inputPlugins) {
          var source = inputPlugins[key].plugin;
          var mapping = inputPlugins[key].mapping;
          var settingsKey = inputPlugins[key].settingsKey;
          var configKey = inputPlugins[key].configKey;
          if (GetValue(settings, settingsKey, config[configKey])) {
            target[mapping] = new source(target);
          }
        }
      };
      InputPluginCache.remove = function(key) {
        if (inputPlugins.hasOwnProperty(key)) {
          delete inputPlugins[key];
        }
      };
      module.exports = InputPluginCache;
    }
  });

  // ../../node_modules/phaser/src/input/gamepad/GamepadPlugin.js
  var require_GamepadPlugin = __commonJS({
    "../../node_modules/phaser/src/input/gamepad/GamepadPlugin.js": function(exports, module) {
      var Class = require_Class();
      var EventEmitter = require_eventemitter3();
      var Events = require_events18();
      var Gamepad = require_Gamepad();
      var GetValue = require_GetValue();
      var InputPluginCache = require_InputPluginCache();
      var InputEvents = require_events13();
      var GamepadPlugin = new Class({
        Extends: EventEmitter,
        initialize: function GamepadPlugin2(sceneInputPlugin) {
          EventEmitter.call(this);
          this.scene = sceneInputPlugin.scene;
          this.settings = this.scene.sys.settings;
          this.sceneInputPlugin = sceneInputPlugin;
          this.enabled = true;
          this.target;
          this.gamepads = [];
          this.queue = [];
          this.onGamepadHandler;
          this._pad1;
          this._pad2;
          this._pad3;
          this._pad4;
          sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);
          sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);
        },
        boot: function() {
          var game = this.scene.sys.game;
          var settings = this.settings.input;
          var config = game.config;
          this.enabled = GetValue(settings, "gamepad", config.inputGamepad) && game.device.input.gamepads;
          this.target = GetValue(settings, "gamepad.target", config.inputGamepadEventTarget);
          this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);
        },
        start: function() {
          if (this.enabled) {
            this.startListeners();
            this.refreshPads();
          }
          this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);
        },
        isActive: function() {
          return this.enabled && this.scene.sys.isActive();
        },
        startListeners: function() {
          var _this = this;
          var target = this.target;
          var handler = function(event) {
            if (event.defaultPrevented || !_this.isActive()) {
              return;
            }
            _this.refreshPads();
            _this.queue.push(event);
          };
          this.onGamepadHandler = handler;
          target.addEventListener("gamepadconnected", handler, false);
          target.addEventListener("gamepaddisconnected", handler, false);
          this.sceneInputPlugin.pluginEvents.on(InputEvents.UPDATE, this.update, this);
        },
        stopListeners: function() {
          this.target.removeEventListener("gamepadconnected", this.onGamepadHandler);
          this.target.removeEventListener("gamepaddisconnected", this.onGamepadHandler);
          this.sceneInputPlugin.pluginEvents.off(InputEvents.UPDATE, this.update);
          for (var i = 0; i < this.gamepads.length; i++) {
            this.gamepads[i].removeAllListeners();
          }
        },
        disconnectAll: function() {
          for (var i = 0; i < this.gamepads.length; i++) {
            this.gamepads[i].pad.connected = false;
          }
        },
        refreshPads: function() {
          var connectedPads = navigator.getGamepads();
          if (!connectedPads) {
            this.disconnectAll();
          } else {
            var currentPads = this.gamepads;
            for (var i = 0; i < connectedPads.length; i++) {
              var livePad = connectedPads[i];
              if (!livePad) {
                continue;
              }
              var id = livePad.id;
              var index = livePad.index;
              var currentPad = currentPads[index];
              if (!currentPad) {
                var newPad = new Gamepad(this, livePad);
                currentPads[index] = newPad;
                if (!this._pad1) {
                  this._pad1 = newPad;
                } else if (!this._pad2) {
                  this._pad2 = newPad;
                } else if (!this._pad3) {
                  this._pad3 = newPad;
                } else if (!this._pad4) {
                  this._pad4 = newPad;
                }
              } else if (currentPad.id !== id) {
                currentPad.destroy();
                currentPads[index] = new Gamepad(this, livePad);
              } else {
                currentPad.update(livePad);
              }
            }
          }
        },
        getAll: function() {
          var out = [];
          var pads = this.gamepads;
          for (var i = 0; i < pads.length; i++) {
            if (pads[i]) {
              out.push(pads[i]);
            }
          }
          return out;
        },
        getPad: function(index) {
          var pads = this.gamepads;
          for (var i = 0; i < pads.length; i++) {
            if (pads[i] && pads[i].index === index) {
              return pads[i];
            }
          }
        },
        update: function() {
          if (!this.enabled) {
            return;
          }
          this.refreshPads();
          var len = this.queue.length;
          if (len === 0) {
            return;
          }
          var queue = this.queue.splice(0, len);
          for (var i = 0; i < len; i++) {
            var event = queue[i];
            var pad = this.getPad(event.gamepad.index);
            if (event.type === "gamepadconnected") {
              this.emit(Events.CONNECTED, pad, event);
            } else if (event.type === "gamepaddisconnected") {
              this.emit(Events.DISCONNECTED, pad, event);
            }
          }
        },
        shutdown: function() {
          this.stopListeners();
          this.removeAllListeners();
        },
        destroy: function() {
          this.shutdown();
          for (var i = 0; i < this.gamepads.length; i++) {
            if (this.gamepads[i]) {
              this.gamepads[i].destroy();
            }
          }
          this.gamepads = [];
          this.scene = null;
          this.settings = null;
          this.sceneInputPlugin = null;
          this.target = null;
        },
        total: {
          get: function() {
            return this.gamepads.length;
          }
        },
        pad1: {
          get: function() {
            return this._pad1;
          }
        },
        pad2: {
          get: function() {
            return this._pad2;
          }
        },
        pad3: {
          get: function() {
            return this._pad3;
          }
        },
        pad4: {
          get: function() {
            return this._pad4;
          }
        }
      });
      InputPluginCache.register("GamepadPlugin", GamepadPlugin, "gamepad", "gamepad", "inputGamepad");
      module.exports = GamepadPlugin;
    }
  });

  // ../../node_modules/phaser/src/input/gamepad/configs/Sony_PlayStation_DualShock_4.js
  var require_Sony_PlayStation_DualShock_4 = __commonJS({
    "../../node_modules/phaser/src/input/gamepad/configs/Sony_PlayStation_DualShock_4.js": function(exports, module) {
      module.exports = {
        UP: 12,
        DOWN: 13,
        LEFT: 14,
        RIGHT: 15,
        SHARE: 8,
        OPTIONS: 9,
        PS: 16,
        TOUCHBAR: 17,
        X: 0,
        CIRCLE: 1,
        SQUARE: 2,
        TRIANGLE: 3,
        L1: 4,
        R1: 5,
        L2: 6,
        R2: 7,
        L3: 10,
        R3: 11,
        LEFT_STICK_H: 0,
        LEFT_STICK_V: 1,
        RIGHT_STICK_H: 2,
        RIGHT_STICK_V: 3
      };
    }
  });

  // ../../node_modules/phaser/src/input/gamepad/configs/SNES_USB_Controller.js
  var require_SNES_USB_Controller = __commonJS({
    "../../node_modules/phaser/src/input/gamepad/configs/SNES_USB_Controller.js": function(exports, module) {
      module.exports = {
        UP: 12,
        DOWN: 13,
        LEFT: 14,
        RIGHT: 15,
        SELECT: 8,
        START: 9,
        B: 0,
        A: 1,
        Y: 2,
        X: 3,
        LEFT_SHOULDER: 4,
        RIGHT_SHOULDER: 5
      };
    }
  });

  // ../../node_modules/phaser/src/input/gamepad/configs/XBox360_Controller.js
  var require_XBox360_Controller = __commonJS({
    "../../node_modules/phaser/src/input/gamepad/configs/XBox360_Controller.js": function(exports, module) {
      module.exports = {
        UP: 12,
        DOWN: 13,
        LEFT: 14,
        RIGHT: 15,
        MENU: 16,
        A: 0,
        B: 1,
        X: 2,
        Y: 3,
        LB: 4,
        RB: 5,
        LT: 6,
        RT: 7,
        BACK: 8,
        START: 9,
        LS: 10,
        RS: 11,
        LEFT_STICK_H: 0,
        LEFT_STICK_V: 1,
        RIGHT_STICK_H: 2,
        RIGHT_STICK_V: 3
      };
    }
  });

  // ../../node_modules/phaser/src/input/gamepad/configs/index.js
  var require_configs = __commonJS({
    "../../node_modules/phaser/src/input/gamepad/configs/index.js": function(exports, module) {
      module.exports = {
        DUALSHOCK_4: require_Sony_PlayStation_DualShock_4(),
        SNES_USB: require_SNES_USB_Controller(),
        XBOX_360: require_XBox360_Controller()
      };
    }
  });

  // ../../node_modules/phaser/src/input/gamepad/index.js
  var require_gamepad = __commonJS({
    "../../node_modules/phaser/src/input/gamepad/index.js": function(exports, module) {
      module.exports = {
        Axis: require_Axis(),
        Button: require_Button(),
        Events: require_events18(),
        Gamepad: require_Gamepad(),
        GamepadPlugin: require_GamepadPlugin(),
        Configs: require_configs()
      };
    }
  });

  // ../../node_modules/phaser/src/geom/triangle/Contains.js
  var require_Contains4 = __commonJS({
    "../../node_modules/phaser/src/geom/triangle/Contains.js": function(exports, module) {
      var Contains = function(triangle, x, y) {
        var v0x = triangle.x3 - triangle.x1;
        var v0y = triangle.y3 - triangle.y1;
        var v1x = triangle.x2 - triangle.x1;
        var v1y = triangle.y2 - triangle.y1;
        var v2x = x - triangle.x1;
        var v2y = y - triangle.y1;
        var dot00 = v0x * v0x + v0y * v0y;
        var dot01 = v0x * v1x + v0y * v1y;
        var dot02 = v0x * v2x + v0y * v2y;
        var dot11 = v1x * v1x + v1y * v1y;
        var dot12 = v1x * v2x + v1y * v2y;
        var b = dot00 * dot11 - dot01 * dot01;
        var inv = b === 0 ? 0 : 1 / b;
        var u = (dot11 * dot02 - dot01 * dot12) * inv;
        var v = (dot00 * dot12 - dot01 * dot02) * inv;
        return u >= 0 && v >= 0 && u + v < 1;
      };
      module.exports = Contains;
    }
  });

  // ../../node_modules/phaser/src/geom/triangle/GetPoint.js
  var require_GetPoint5 = __commonJS({
    "../../node_modules/phaser/src/geom/triangle/GetPoint.js": function(exports, module) {
      var Point = require_Point();
      var Length = require_Length();
      var GetPoint = function(triangle, position, out) {
        if (out === void 0) {
          out = new Point();
        }
        var line1 = triangle.getLineA();
        var line2 = triangle.getLineB();
        var line3 = triangle.getLineC();
        if (position <= 0 || position >= 1) {
          out.x = line1.x1;
          out.y = line1.y1;
          return out;
        }
        var length1 = Length(line1);
        var length2 = Length(line2);
        var length3 = Length(line3);
        var perimeter = length1 + length2 + length3;
        var p = perimeter * position;
        var localPosition = 0;
        if (p < length1) {
          localPosition = p / length1;
          out.x = line1.x1 + (line1.x2 - line1.x1) * localPosition;
          out.y = line1.y1 + (line1.y2 - line1.y1) * localPosition;
        } else if (p > length1 + length2) {
          p -= length1 + length2;
          localPosition = p / length3;
          out.x = line3.x1 + (line3.x2 - line3.x1) * localPosition;
          out.y = line3.y1 + (line3.y2 - line3.y1) * localPosition;
        } else {
          p -= length1;
          localPosition = p / length2;
          out.x = line2.x1 + (line2.x2 - line2.x1) * localPosition;
          out.y = line2.y1 + (line2.y2 - line2.y1) * localPosition;
        }
        return out;
      };
      module.exports = GetPoint;
    }
  });

  // ../../node_modules/phaser/src/geom/triangle/GetPoints.js
  var require_GetPoints5 = __commonJS({
    "../../node_modules/phaser/src/geom/triangle/GetPoints.js": function(exports, module) {
      var Length = require_Length();
      var Point = require_Point();
      var GetPoints = function(triangle, quantity, stepRate, out) {
        if (out === void 0) {
          out = [];
        }
        var line1 = triangle.getLineA();
        var line2 = triangle.getLineB();
        var line3 = triangle.getLineC();
        var length1 = Length(line1);
        var length2 = Length(line2);
        var length3 = Length(line3);
        var perimeter = length1 + length2 + length3;
        if (!quantity && stepRate > 0) {
          quantity = perimeter / stepRate;
        }
        for (var i = 0; i < quantity; i++) {
          var p = perimeter * (i / quantity);
          var localPosition = 0;
          var point = new Point();
          if (p < length1) {
            localPosition = p / length1;
            point.x = line1.x1 + (line1.x2 - line1.x1) * localPosition;
            point.y = line1.y1 + (line1.y2 - line1.y1) * localPosition;
          } else if (p > length1 + length2) {
            p -= length1 + length2;
            localPosition = p / length3;
            point.x = line3.x1 + (line3.x2 - line3.x1) * localPosition;
            point.y = line3.y1 + (line3.y2 - line3.y1) * localPosition;
          } else {
            p -= length1;
            localPosition = p / length2;
            point.x = line2.x1 + (line2.x2 - line2.x1) * localPosition;
            point.y = line2.y1 + (line2.y2 - line2.y1) * localPosition;
          }
          out.push(point);
        }
        return out;
      };
      module.exports = GetPoints;
    }
  });

  // ../../node_modules/phaser/src/geom/triangle/Triangle.js
  var require_Triangle = __commonJS({
    "../../node_modules/phaser/src/geom/triangle/Triangle.js": function(exports, module) {
      var Class = require_Class();
      var Contains = require_Contains4();
      var GetPoint = require_GetPoint5();
      var GetPoints = require_GetPoints5();
      var GEOM_CONST = require_const3();
      var Line = require_Line();
      var Random = require_Random6();
      var Triangle = new Class({
        initialize: function Triangle2(x1, y1, x2, y2, x3, y3) {
          if (x1 === void 0) {
            x1 = 0;
          }
          if (y1 === void 0) {
            y1 = 0;
          }
          if (x2 === void 0) {
            x2 = 0;
          }
          if (y2 === void 0) {
            y2 = 0;
          }
          if (x3 === void 0) {
            x3 = 0;
          }
          if (y3 === void 0) {
            y3 = 0;
          }
          this.type = GEOM_CONST.TRIANGLE;
          this.x1 = x1;
          this.y1 = y1;
          this.x2 = x2;
          this.y2 = y2;
          this.x3 = x3;
          this.y3 = y3;
        },
        contains: function(x, y) {
          return Contains(this, x, y);
        },
        getPoint: function(position, output) {
          return GetPoint(this, position, output);
        },
        getPoints: function(quantity, stepRate, output) {
          return GetPoints(this, quantity, stepRate, output);
        },
        getRandomPoint: function(point) {
          return Random(this, point);
        },
        setTo: function(x1, y1, x2, y2, x3, y3) {
          if (x1 === void 0) {
            x1 = 0;
          }
          if (y1 === void 0) {
            y1 = 0;
          }
          if (x2 === void 0) {
            x2 = 0;
          }
          if (y2 === void 0) {
            y2 = 0;
          }
          if (x3 === void 0) {
            x3 = 0;
          }
          if (y3 === void 0) {
            y3 = 0;
          }
          this.x1 = x1;
          this.y1 = y1;
          this.x2 = x2;
          this.y2 = y2;
          this.x3 = x3;
          this.y3 = y3;
          return this;
        },
        getLineA: function(line) {
          if (line === void 0) {
            line = new Line();
          }
          line.setTo(this.x1, this.y1, this.x2, this.y2);
          return line;
        },
        getLineB: function(line) {
          if (line === void 0) {
            line = new Line();
          }
          line.setTo(this.x2, this.y2, this.x3, this.y3);
          return line;
        },
        getLineC: function(line) {
          if (line === void 0) {
            line = new Line();
          }
          line.setTo(this.x3, this.y3, this.x1, this.y1);
          return line;
        },
        left: {
          get: function() {
            return Math.min(this.x1, this.x2, this.x3);
          },
          set: function(value) {
            var diff = 0;
            if (this.x1 <= this.x2 && this.x1 <= this.x3) {
              diff = this.x1 - value;
            } else if (this.x2 <= this.x1 && this.x2 <= this.x3) {
              diff = this.x2 - value;
            } else {
              diff = this.x3 - value;
            }
            this.x1 -= diff;
            this.x2 -= diff;
            this.x3 -= diff;
          }
        },
        right: {
          get: function() {
            return Math.max(this.x1, this.x2, this.x3);
          },
          set: function(value) {
            var diff = 0;
            if (this.x1 >= this.x2 && this.x1 >= this.x3) {
              diff = this.x1 - value;
            } else if (this.x2 >= this.x1 && this.x2 >= this.x3) {
              diff = this.x2 - value;
            } else {
              diff = this.x3 - value;
            }
            this.x1 -= diff;
            this.x2 -= diff;
            this.x3 -= diff;
          }
        },
        top: {
          get: function() {
            return Math.min(this.y1, this.y2, this.y3);
          },
          set: function(value) {
            var diff = 0;
            if (this.y1 <= this.y2 && this.y1 <= this.y3) {
              diff = this.y1 - value;
            } else if (this.y2 <= this.y1 && this.y2 <= this.y3) {
              diff = this.y2 - value;
            } else {
              diff = this.y3 - value;
            }
            this.y1 -= diff;
            this.y2 -= diff;
            this.y3 -= diff;
          }
        },
        bottom: {
          get: function() {
            return Math.max(this.y1, this.y2, this.y3);
          },
          set: function(value) {
            var diff = 0;
            if (this.y1 >= this.y2 && this.y1 >= this.y3) {
              diff = this.y1 - value;
            } else if (this.y2 >= this.y1 && this.y2 >= this.y3) {
              diff = this.y2 - value;
            } else {
              diff = this.y3 - value;
            }
            this.y1 -= diff;
            this.y2 -= diff;
            this.y3 -= diff;
          }
        }
      });
      module.exports = Triangle;
    }
  });

  // ../../node_modules/phaser/src/input/InputPlugin.js
  var require_InputPlugin = __commonJS({
    "../../node_modules/phaser/src/input/InputPlugin.js": function(exports, module) {
      var Circle = require_Circle();
      var CircleContains = require_Contains();
      var Class = require_Class();
      var CONST = require_const8();
      var CreateInteractiveObject = require_CreateInteractiveObject();
      var CreatePixelPerfectHandler = require_CreatePixelPerfectHandler();
      var DistanceBetween = require_DistanceBetween();
      var Ellipse = require_Ellipse();
      var EllipseContains = require_Contains3();
      var Events = require_events13();
      var EventEmitter = require_eventemitter3();
      var GetFastValue = require_GetFastValue();
      var GEOM_CONST = require_const3();
      var InputPluginCache = require_InputPluginCache();
      var IsPlainObject = require_IsPlainObject();
      var PluginCache = require_PluginCache();
      var Rectangle = require_Rectangle();
      var RectangleContains = require_Contains2();
      var SceneEvents = require_events();
      var Triangle = require_Triangle();
      var TriangleContains = require_Contains4();
      var InputPlugin = new Class({
        Extends: EventEmitter,
        initialize: function InputPlugin2(scene) {
          EventEmitter.call(this);
          this.scene = scene;
          this.systems = scene.sys;
          this.settings = scene.sys.settings;
          this.manager = scene.sys.game.input;
          this.pluginEvents = new EventEmitter();
          this.enabled = true;
          this.displayList;
          this.cameras;
          InputPluginCache.install(this);
          this.mouse = this.manager.mouse;
          this.topOnly = true;
          this.pollRate = -1;
          this._pollTimer = 0;
          var _eventData = { cancelled: false };
          this._eventContainer = {
            stopPropagation: function() {
              _eventData.cancelled = true;
            }
          };
          this._eventData = _eventData;
          this.dragDistanceThreshold = 0;
          this.dragTimeThreshold = 0;
          this._temp = [];
          this._tempZones = [];
          this._list = [];
          this._pendingInsertion = [];
          this._pendingRemoval = [];
          this._draggable = [];
          this._drag = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] };
          this._dragState = [];
          this._over = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] };
          this._validTypes = ["onDown", "onUp", "onOver", "onOut", "onMove", "onDragStart", "onDrag", "onDragEnd", "onDragEnter", "onDragLeave", "onDragOver", "onDrop"];
          this._updatedThisFrame = false;
          scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
          scene.sys.events.on(SceneEvents.START, this.start, this);
        },
        boot: function() {
          this.cameras = this.systems.cameras;
          this.displayList = this.systems.displayList;
          this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
          this.pluginEvents.emit(Events.BOOT);
        },
        start: function() {
          var eventEmitter = this.systems.events;
          eventEmitter.on(SceneEvents.TRANSITION_START, this.transitionIn, this);
          eventEmitter.on(SceneEvents.TRANSITION_OUT, this.transitionOut, this);
          eventEmitter.on(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);
          eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
          eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
          this.manager.events.on(Events.GAME_OUT, this.onGameOut, this);
          this.manager.events.on(Events.GAME_OVER, this.onGameOver, this);
          this.enabled = true;
          this._dragState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          this.pluginEvents.emit(Events.START);
        },
        onGameOver: function(event) {
          if (this.isActive()) {
            this.emit(Events.GAME_OVER, event.timeStamp, event);
          }
        },
        onGameOut: function(event) {
          if (this.isActive()) {
            this.emit(Events.GAME_OUT, event.timeStamp, event);
          }
        },
        preUpdate: function() {
          this.pluginEvents.emit(Events.PRE_UPDATE);
          var removeList = this._pendingRemoval;
          var insertList = this._pendingInsertion;
          var toRemove = removeList.length;
          var toInsert = insertList.length;
          if (toRemove === 0 && toInsert === 0) {
            return;
          }
          var current = this._list;
          for (var i = 0; i < toRemove; i++) {
            var gameObject = removeList[i];
            var index = current.indexOf(gameObject);
            if (index > -1) {
              current.splice(index, 1);
              this.clear(gameObject, true);
            }
          }
          this._pendingRemoval.length = 0;
          this._list = current.concat(insertList.splice(0));
        },
        isActive: function() {
          return this.enabled && this.scene.sys.canInput();
        },
        updatePoll: function(time, delta) {
          if (!this.isActive()) {
            return false;
          }
          this.pluginEvents.emit(Events.UPDATE, time, delta);
          if (this._updatedThisFrame) {
            this._updatedThisFrame = false;
            return false;
          }
          var i;
          var manager = this.manager;
          var pointers = manager.pointers;
          var pointersTotal = manager.pointersTotal;
          for (i = 0; i < pointersTotal; i++) {
            pointers[i].updateMotion();
          }
          if (this._list.length === 0) {
            return false;
          }
          var rate = this.pollRate;
          if (rate === -1) {
            return false;
          } else if (rate > 0) {
            this._pollTimer -= delta;
            if (this._pollTimer < 0) {
              this._pollTimer = this.pollRate;
            } else {
              return false;
            }
          }
          var captured = false;
          for (i = 0; i < pointersTotal; i++) {
            var total = 0;
            var pointer = pointers[i];
            this._tempZones = [];
            this._temp = this.hitTestPointer(pointer);
            this.sortGameObjects(this._temp, pointer);
            this.sortDropZones(this._tempZones);
            if (this.topOnly) {
              if (this._temp.length) {
                this._temp.splice(1);
              }
              if (this._tempZones.length) {
                this._tempZones.splice(1);
              }
            }
            total += this.processOverOutEvents(pointer);
            if (this.getDragState(pointer) === 2) {
              this.processDragThresholdEvent(pointer, time);
            }
            if (total > 0) {
              captured = true;
            }
          }
          return captured;
        },
        update: function(type, pointers) {
          if (!this.isActive()) {
            return false;
          }
          var pointersTotal = pointers.length;
          var captured = false;
          for (var i = 0; i < pointersTotal; i++) {
            var total = 0;
            var pointer = pointers[i];
            this._tempZones = [];
            this._temp = this.hitTestPointer(pointer);
            this.sortGameObjects(this._temp, pointer);
            this.sortDropZones(this._tempZones);
            if (this.topOnly) {
              if (this._temp.length) {
                this._temp.splice(1);
              }
              if (this._tempZones.length) {
                this._tempZones.splice(1);
              }
            }
            switch (type) {
              case CONST.MOUSE_DOWN:
                total += this.processDragDownEvent(pointer);
                total += this.processDownEvents(pointer);
                total += this.processOverOutEvents(pointer);
                break;
              case CONST.MOUSE_UP:
                total += this.processDragUpEvent(pointer);
                total += this.processUpEvents(pointer);
                total += this.processOverOutEvents(pointer);
                break;
              case CONST.TOUCH_START:
                total += this.processDragDownEvent(pointer);
                total += this.processDownEvents(pointer);
                total += this.processOverEvents(pointer);
                break;
              case CONST.TOUCH_END:
              case CONST.TOUCH_CANCEL:
                total += this.processDragUpEvent(pointer);
                total += this.processUpEvents(pointer);
                total += this.processOutEvents(pointer);
                break;
              case CONST.MOUSE_MOVE:
              case CONST.TOUCH_MOVE:
                total += this.processDragMoveEvent(pointer);
                total += this.processMoveEvents(pointer);
                total += this.processOverOutEvents(pointer);
                break;
              case CONST.MOUSE_WHEEL:
                total += this.processWheelEvent(pointer);
                break;
            }
            if (total > 0) {
              captured = true;
            }
          }
          this._updatedThisFrame = true;
          return captured;
        },
        clear: function(gameObject, skipQueue) {
          if (skipQueue === void 0) {
            skipQueue = false;
          }
          this.disable(gameObject);
          var input = gameObject.input;
          if (input) {
            this.removeDebug(gameObject);
            input.gameObject = void 0;
            input.target = void 0;
            input.hitArea = void 0;
            input.hitAreaCallback = void 0;
            input.callbackContext = void 0;
            gameObject.input = null;
          }
          if (!skipQueue) {
            this.queueForRemoval(gameObject);
          }
          var index = this._draggable.indexOf(gameObject);
          if (index > -1) {
            this._draggable.splice(index, 1);
          }
          return gameObject;
        },
        disable: function(gameObject) {
          var input = gameObject.input;
          if (input) {
            input.enabled = false;
            input.dragState = 0;
          }
          var temp = this._temp;
          var drag = this._drag;
          var over = this._over;
          var manager = this.manager;
          var index = temp.indexOf(gameObject);
          if (index > -1) {
            temp.splice(index, 1);
          }
          for (var i = 0; i < manager.pointersTotal; i++) {
            index = drag[i].indexOf(gameObject);
            if (index > -1) {
              drag[i].splice(index, 1);
            }
            index = over[i].indexOf(gameObject);
            if (index > -1) {
              over[i].splice(index, 1);
              manager.resetCursor(input);
            }
          }
          return this;
        },
        enable: function(gameObject, hitArea, hitAreaCallback, dropZone) {
          if (dropZone === void 0) {
            dropZone = false;
          }
          if (gameObject.input) {
            gameObject.input.enabled = true;
          } else {
            this.setHitArea(gameObject, hitArea, hitAreaCallback);
          }
          if (gameObject.input && dropZone && !gameObject.input.dropZone) {
            gameObject.input.dropZone = dropZone;
          }
          return this;
        },
        hitTestPointer: function(pointer) {
          var cameras = this.cameras.getCamerasBelowPointer(pointer);
          for (var c = 0; c < cameras.length; c++) {
            var camera = cameras[c];
            var over = this.manager.hitTest(pointer, this._list, camera);
            for (var i = 0; i < over.length; i++) {
              var obj = over[i];
              if (obj.input.dropZone) {
                this._tempZones.push(obj);
              }
            }
            if (over.length > 0) {
              pointer.camera = camera;
              return over;
            }
          }
          pointer.camera = cameras[0];
          return [];
        },
        processDownEvents: function(pointer) {
          var total = 0;
          var currentlyOver = this._temp;
          var _eventData = this._eventData;
          var _eventContainer = this._eventContainer;
          _eventData.cancelled = false;
          var aborted = false;
          for (var i = 0; i < currentlyOver.length; i++) {
            var gameObject = currentlyOver[i];
            if (!gameObject.input || !gameObject.input.enabled) {
              continue;
            }
            total++;
            gameObject.emit(Events.GAMEOBJECT_POINTER_DOWN, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
            if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
              aborted = true;
              break;
            }
            this.emit(Events.GAMEOBJECT_DOWN, pointer, gameObject, _eventContainer);
            if (_eventData.cancelled || !gameObject.input) {
              aborted = true;
              break;
            }
          }
          if (!aborted && this.manager) {
            if (pointer.downElement === this.manager.game.canvas) {
              this.emit(Events.POINTER_DOWN, pointer, currentlyOver);
            } else {
              this.emit(Events.POINTER_DOWN_OUTSIDE, pointer);
            }
          }
          return total;
        },
        getDragState: function(pointer) {
          return this._dragState[pointer.id];
        },
        setDragState: function(pointer, state) {
          this._dragState[pointer.id] = state;
        },
        processDragThresholdEvent: function(pointer, time) {
          var passed = false;
          var timeThreshold = this.dragTimeThreshold;
          var distanceThreshold = this.dragDistanceThreshold;
          if (distanceThreshold > 0 && DistanceBetween(pointer.x, pointer.y, pointer.downX, pointer.downY) >= distanceThreshold) {
            passed = true;
          } else if (timeThreshold > 0 && time >= pointer.downTime + timeThreshold) {
            passed = true;
          }
          if (passed) {
            this.setDragState(pointer, 3);
            return this.processDragStartList(pointer);
          }
        },
        processDragStartList: function(pointer) {
          if (this.getDragState(pointer) !== 3) {
            return 0;
          }
          var list = this._drag[pointer.id];
          for (var i = 0; i < list.length; i++) {
            var gameObject = list[i];
            var input = gameObject.input;
            input.dragState = 2;
            input.dragStartX = gameObject.x;
            input.dragStartY = gameObject.y;
            input.dragStartXGlobal = pointer.worldX;
            input.dragStartYGlobal = pointer.worldY;
            input.dragX = input.dragStartXGlobal - input.dragStartX;
            input.dragY = input.dragStartYGlobal - input.dragStartY;
            gameObject.emit(Events.GAMEOBJECT_DRAG_START, pointer, input.dragX, input.dragY);
            this.emit(Events.DRAG_START, pointer, gameObject);
          }
          this.setDragState(pointer, 4);
          return list.length;
        },
        processDragDownEvent: function(pointer) {
          var currentlyOver = this._temp;
          if (this._draggable.length === 0 || currentlyOver.length === 0 || !pointer.primaryDown || this.getDragState(pointer) !== 0) {
            return 0;
          }
          this.setDragState(pointer, 1);
          var draglist = [];
          for (var i = 0; i < currentlyOver.length; i++) {
            var gameObject = currentlyOver[i];
            if (gameObject.input.draggable && gameObject.input.dragState === 0) {
              draglist.push(gameObject);
            }
          }
          if (draglist.length === 0) {
            this.setDragState(pointer, 0);
            return 0;
          } else if (draglist.length > 1) {
            this.sortGameObjects(draglist, pointer);
            if (this.topOnly) {
              draglist.splice(1);
            }
          }
          this._drag[pointer.id] = draglist;
          if (this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0) {
            this.setDragState(pointer, 3);
            return this.processDragStartList(pointer);
          } else {
            this.setDragState(pointer, 2);
            return 0;
          }
        },
        processDragMoveEvent: function(pointer) {
          if (this.getDragState(pointer) === 2) {
            this.processDragThresholdEvent(pointer, this.manager.game.loop.now);
          }
          if (this.getDragState(pointer) !== 4) {
            return 0;
          }
          var dropZones = this._tempZones;
          var list = this._drag[pointer.id];
          for (var i = 0; i < list.length; i++) {
            var gameObject = list[i];
            var input = gameObject.input;
            var target = input.target;
            if (target) {
              var index = dropZones.indexOf(target);
              if (index === 0) {
                gameObject.emit(Events.GAMEOBJECT_DRAG_OVER, pointer, target);
                this.emit(Events.DRAG_OVER, pointer, gameObject, target);
              } else if (index > 0) {
                gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);
                this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);
                input.target = dropZones[0];
                target = input.target;
                gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);
                this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
              } else {
                gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);
                this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);
                if (dropZones[0]) {
                  input.target = dropZones[0];
                  target = input.target;
                  gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);
                  this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
                } else {
                  input.target = null;
                }
              }
            } else if (!target && dropZones[0]) {
              input.target = dropZones[0];
              target = input.target;
              gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);
              this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
            }
            var dragX;
            var dragY;
            if (!gameObject.parentContainer) {
              dragX = pointer.worldX - input.dragX;
              dragY = pointer.worldY - input.dragY;
            } else {
              var dx = pointer.worldX - input.dragStartXGlobal;
              var dy = pointer.worldY - input.dragStartYGlobal;
              var rotation = gameObject.getParentRotation();
              var dxRotated = dx * Math.cos(rotation) + dy * Math.sin(rotation);
              var dyRotated = dy * Math.cos(rotation) - dx * Math.sin(rotation);
              dxRotated *= 1 / gameObject.parentContainer.scaleX;
              dyRotated *= 1 / gameObject.parentContainer.scaleY;
              dragX = dxRotated + input.dragStartX;
              dragY = dyRotated + input.dragStartY;
            }
            gameObject.emit(Events.GAMEOBJECT_DRAG, pointer, dragX, dragY);
            this.emit(Events.DRAG, pointer, gameObject, dragX, dragY);
          }
          return list.length;
        },
        processDragUpEvent: function(pointer) {
          var list = this._drag[pointer.id];
          for (var i = 0; i < list.length; i++) {
            var gameObject = list[i];
            var input = gameObject.input;
            if (input && input.dragState === 2) {
              input.dragState = 0;
              input.dragX = input.localX - gameObject.displayOriginX;
              input.dragY = input.localY - gameObject.displayOriginY;
              var dropped = false;
              var target = input.target;
              if (target) {
                gameObject.emit(Events.GAMEOBJECT_DROP, pointer, target);
                this.emit(Events.DROP, pointer, gameObject, target);
                input.target = null;
                dropped = true;
              }
              if (gameObject.input && gameObject.input.enabled) {
                gameObject.emit(Events.GAMEOBJECT_DRAG_END, pointer, input.dragX, input.dragY, dropped);
                this.emit(Events.DRAG_END, pointer, gameObject, dropped);
              }
            }
          }
          this.setDragState(pointer, 0);
          list.splice(0);
          return 0;
        },
        processMoveEvents: function(pointer) {
          var total = 0;
          var currentlyOver = this._temp;
          var _eventData = this._eventData;
          var _eventContainer = this._eventContainer;
          _eventData.cancelled = false;
          var aborted = false;
          for (var i = 0; i < currentlyOver.length; i++) {
            var gameObject = currentlyOver[i];
            if (!gameObject.input || !gameObject.input.enabled) {
              continue;
            }
            total++;
            gameObject.emit(Events.GAMEOBJECT_POINTER_MOVE, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
            if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
              aborted = true;
              break;
            }
            this.emit(Events.GAMEOBJECT_MOVE, pointer, gameObject, _eventContainer);
            if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
              aborted = true;
              break;
            }
            if (this.topOnly) {
              break;
            }
          }
          if (!aborted) {
            this.emit(Events.POINTER_MOVE, pointer, currentlyOver);
          }
          return total;
        },
        processWheelEvent: function(pointer) {
          var total = 0;
          var currentlyOver = this._temp;
          var _eventData = this._eventData;
          var _eventContainer = this._eventContainer;
          _eventData.cancelled = false;
          var aborted = false;
          var dx = pointer.deltaX;
          var dy = pointer.deltaY;
          var dz = pointer.deltaZ;
          for (var i = 0; i < currentlyOver.length; i++) {
            var gameObject = currentlyOver[i];
            if (!gameObject.input || !gameObject.input.enabled) {
              continue;
            }
            total++;
            gameObject.emit(Events.GAMEOBJECT_POINTER_WHEEL, pointer, dx, dy, dz, _eventContainer);
            if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
              aborted = true;
              break;
            }
            this.emit(Events.GAMEOBJECT_WHEEL, pointer, gameObject, dx, dy, dz, _eventContainer);
            if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
              aborted = true;
              break;
            }
          }
          if (!aborted) {
            this.emit(Events.POINTER_WHEEL, pointer, currentlyOver, dx, dy, dz);
          }
          return total;
        },
        processOverEvents: function(pointer) {
          var currentlyOver = this._temp;
          var totalInteracted = 0;
          var total = currentlyOver.length;
          var justOver = [];
          if (total > 0) {
            var manager = this.manager;
            var _eventData = this._eventData;
            var _eventContainer = this._eventContainer;
            _eventData.cancelled = false;
            var aborted = false;
            for (var i = 0; i < total; i++) {
              var gameObject = currentlyOver[i];
              if (!gameObject.input || !gameObject.input.enabled) {
                continue;
              }
              justOver.push(gameObject);
              manager.setCursor(gameObject.input);
              gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
              totalInteracted++;
              if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                aborted = true;
                break;
              }
              this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);
              if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                aborted = true;
                break;
              }
            }
            if (!aborted) {
              this.emit(Events.POINTER_OVER, pointer, justOver);
            }
          }
          this._over[pointer.id] = justOver;
          return totalInteracted;
        },
        processOutEvents: function(pointer) {
          var previouslyOver = this._over[pointer.id];
          var totalInteracted = 0;
          var total = previouslyOver.length;
          if (total > 0) {
            var manager = this.manager;
            var _eventData = this._eventData;
            var _eventContainer = this._eventContainer;
            _eventData.cancelled = false;
            var aborted = false;
            this.sortGameObjects(previouslyOver, pointer);
            for (var i = 0; i < total; i++) {
              var gameObject = previouslyOver[i];
              gameObject = previouslyOver[i];
              if (!gameObject.input || !gameObject.input.enabled) {
                continue;
              }
              manager.resetCursor(gameObject.input);
              gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);
              totalInteracted++;
              if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                aborted = true;
                break;
              }
              this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);
              if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                aborted = true;
                break;
              }
              if (!aborted) {
                this.emit(Events.POINTER_OUT, pointer, previouslyOver);
              }
            }
            this._over[pointer.id] = [];
          }
          return totalInteracted;
        },
        processOverOutEvents: function(pointer) {
          var currentlyOver = this._temp;
          var i;
          var gameObject;
          var justOut = [];
          var justOver = [];
          var stillOver = [];
          var previouslyOver = this._over[pointer.id];
          var currentlyDragging = this._drag[pointer.id];
          var manager = this.manager;
          for (i = 0; i < previouslyOver.length; i++) {
            gameObject = previouslyOver[i];
            if (currentlyOver.indexOf(gameObject) === -1 && currentlyDragging.indexOf(gameObject) === -1) {
              justOut.push(gameObject);
            } else {
              stillOver.push(gameObject);
            }
          }
          for (i = 0; i < currentlyOver.length; i++) {
            gameObject = currentlyOver[i];
            if (previouslyOver.indexOf(gameObject) === -1) {
              justOver.push(gameObject);
            }
          }
          var total = justOut.length;
          var totalInteracted = 0;
          var _eventData = this._eventData;
          var _eventContainer = this._eventContainer;
          _eventData.cancelled = false;
          var aborted = false;
          if (total > 0) {
            this.sortGameObjects(justOut, pointer);
            for (i = 0; i < total; i++) {
              gameObject = justOut[i];
              if (!gameObject.input || !gameObject.input.enabled) {
                continue;
              }
              manager.resetCursor(gameObject.input);
              gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);
              totalInteracted++;
              if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                aborted = true;
                break;
              }
              this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);
              if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                aborted = true;
                break;
              }
            }
            if (!aborted) {
              this.emit(Events.POINTER_OUT, pointer, justOut);
            }
          }
          total = justOver.length;
          _eventData.cancelled = false;
          aborted = false;
          if (total > 0) {
            this.sortGameObjects(justOver, pointer);
            for (i = 0; i < total; i++) {
              gameObject = justOver[i];
              if (!gameObject.input || !gameObject.input.enabled) {
                continue;
              }
              manager.setCursor(gameObject.input);
              gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
              totalInteracted++;
              if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                aborted = true;
                break;
              }
              this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);
              if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
                aborted = true;
                break;
              }
            }
            if (!aborted) {
              this.emit(Events.POINTER_OVER, pointer, justOver);
            }
          }
          previouslyOver = stillOver.concat(justOver);
          this._over[pointer.id] = this.sortGameObjects(previouslyOver, pointer);
          return totalInteracted;
        },
        processUpEvents: function(pointer) {
          var currentlyOver = this._temp;
          var _eventData = this._eventData;
          var _eventContainer = this._eventContainer;
          _eventData.cancelled = false;
          var aborted = false;
          for (var i = 0; i < currentlyOver.length; i++) {
            var gameObject = currentlyOver[i];
            if (!gameObject.input || !gameObject.input.enabled) {
              continue;
            }
            gameObject.emit(Events.GAMEOBJECT_POINTER_UP, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
            if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
              aborted = true;
              break;
            }
            this.emit(Events.GAMEOBJECT_UP, pointer, gameObject, _eventContainer);
            if (_eventData.cancelled || !gameObject.input || !gameObject.input.enabled) {
              aborted = true;
              break;
            }
          }
          if (!aborted && this.manager) {
            if (pointer.upElement === this.manager.game.canvas) {
              this.emit(Events.POINTER_UP, pointer, currentlyOver);
            } else {
              this.emit(Events.POINTER_UP_OUTSIDE, pointer);
            }
          }
          return currentlyOver.length;
        },
        queueForInsertion: function(child) {
          if (this._pendingInsertion.indexOf(child) === -1 && this._list.indexOf(child) === -1) {
            this._pendingInsertion.push(child);
          }
          return this;
        },
        queueForRemoval: function(child) {
          this._pendingRemoval.push(child);
          return this;
        },
        setDraggable: function(gameObjects, value) {
          if (value === void 0) {
            value = true;
          }
          if (!Array.isArray(gameObjects)) {
            gameObjects = [gameObjects];
          }
          for (var i = 0; i < gameObjects.length; i++) {
            var gameObject = gameObjects[i];
            gameObject.input.draggable = value;
            var index = this._draggable.indexOf(gameObject);
            if (value && index === -1) {
              this._draggable.push(gameObject);
            } else if (!value && index > -1) {
              this._draggable.splice(index, 1);
            }
          }
          return this;
        },
        makePixelPerfect: function(alphaTolerance) {
          if (alphaTolerance === void 0) {
            alphaTolerance = 1;
          }
          var textureManager = this.systems.textures;
          return CreatePixelPerfectHandler(textureManager, alphaTolerance);
        },
        setHitArea: function(gameObjects, hitArea, hitAreaCallback) {
          if (hitArea === void 0) {
            return this.setHitAreaFromTexture(gameObjects);
          }
          if (!Array.isArray(gameObjects)) {
            gameObjects = [gameObjects];
          }
          var draggable = false;
          var dropZone = false;
          var cursor = false;
          var useHandCursor = false;
          var pixelPerfect = false;
          var customHitArea = true;
          if (IsPlainObject(hitArea)) {
            var config = hitArea;
            hitArea = GetFastValue(config, "hitArea", null);
            hitAreaCallback = GetFastValue(config, "hitAreaCallback", null);
            draggable = GetFastValue(config, "draggable", false);
            dropZone = GetFastValue(config, "dropZone", false);
            cursor = GetFastValue(config, "cursor", false);
            useHandCursor = GetFastValue(config, "useHandCursor", false);
            pixelPerfect = GetFastValue(config, "pixelPerfect", false);
            var alphaTolerance = GetFastValue(config, "alphaTolerance", 1);
            if (pixelPerfect) {
              hitArea = {};
              hitAreaCallback = this.makePixelPerfect(alphaTolerance);
            }
            if (!hitArea || !hitAreaCallback) {
              this.setHitAreaFromTexture(gameObjects);
              customHitArea = false;
            }
          } else if (typeof hitArea === "function" && !hitAreaCallback) {
            hitAreaCallback = hitArea;
            hitArea = {};
          }
          for (var i = 0; i < gameObjects.length; i++) {
            var gameObject = gameObjects[i];
            if (pixelPerfect && gameObject.type === "Container") {
              console.warn("Cannot pixelPerfect test a Container. Use a custom callback.");
              continue;
            }
            var io = !gameObject.input ? CreateInteractiveObject(gameObject, hitArea, hitAreaCallback) : gameObject.input;
            io.customHitArea = customHitArea;
            io.dropZone = dropZone;
            io.cursor = useHandCursor ? "pointer" : cursor;
            gameObject.input = io;
            if (draggable) {
              this.setDraggable(gameObject);
            }
            this.queueForInsertion(gameObject);
          }
          return this;
        },
        setHitAreaCircle: function(gameObjects, x, y, radius, callback) {
          if (callback === void 0) {
            callback = CircleContains;
          }
          var shape = new Circle(x, y, radius);
          return this.setHitArea(gameObjects, shape, callback);
        },
        setHitAreaEllipse: function(gameObjects, x, y, width, height, callback) {
          if (callback === void 0) {
            callback = EllipseContains;
          }
          var shape = new Ellipse(x, y, width, height);
          return this.setHitArea(gameObjects, shape, callback);
        },
        setHitAreaFromTexture: function(gameObjects, callback) {
          if (callback === void 0) {
            callback = RectangleContains;
          }
          if (!Array.isArray(gameObjects)) {
            gameObjects = [gameObjects];
          }
          for (var i = 0; i < gameObjects.length; i++) {
            var gameObject = gameObjects[i];
            var frame = gameObject.frame;
            var width = 0;
            var height = 0;
            if (gameObject.width) {
              width = gameObject.width;
              height = gameObject.height;
            } else if (frame) {
              width = frame.realWidth;
              height = frame.realHeight;
            }
            if (gameObject.type === "Container" && (width === 0 || height === 0)) {
              console.warn("Container.setInteractive must specify a Shape or call setSize() first");
              continue;
            }
            if (width !== 0 && height !== 0) {
              gameObject.input = CreateInteractiveObject(gameObject, new Rectangle(0, 0, width, height), callback);
              this.queueForInsertion(gameObject);
            }
          }
          return this;
        },
        setHitAreaRectangle: function(gameObjects, x, y, width, height, callback) {
          if (callback === void 0) {
            callback = RectangleContains;
          }
          var shape = new Rectangle(x, y, width, height);
          return this.setHitArea(gameObjects, shape, callback);
        },
        setHitAreaTriangle: function(gameObjects, x1, y1, x2, y2, x3, y3, callback) {
          if (callback === void 0) {
            callback = TriangleContains;
          }
          var shape = new Triangle(x1, y1, x2, y2, x3, y3);
          return this.setHitArea(gameObjects, shape, callback);
        },
        enableDebug: function(gameObject, color) {
          if (color === void 0) {
            color = 65280;
          }
          var input = gameObject.input;
          if (!input || !input.hitArea) {
            return this;
          }
          var shape = input.hitArea;
          var shapeType = shape.type;
          var debug = input.hitAreaDebug;
          var factory = this.systems.add;
          var updateList = this.systems.updateList;
          if (debug) {
            updateList.remove(debug);
            debug.destroy();
            debug = null;
          }
          var offsetx = 0;
          var offsety = 0;
          switch (shapeType) {
            case GEOM_CONST.CIRCLE:
              debug = factory.arc(0, 0, shape.radius);
              offsetx = shape.x - shape.radius;
              offsety = shape.y - shape.radius;
              break;
            case GEOM_CONST.ELLIPSE:
              debug = factory.ellipse(0, 0, shape.width, shape.height);
              offsetx = shape.x - shape.width / 2;
              offsety = shape.y - shape.height / 2;
              break;
            case GEOM_CONST.LINE:
              debug = factory.line(0, 0, shape.x1, shape.y1, shape.x2, shape.y2);
              break;
            case GEOM_CONST.POLYGON:
              debug = factory.polygon(0, 0, shape.points);
              break;
            case GEOM_CONST.RECTANGLE:
              debug = factory.rectangle(0, 0, shape.width, shape.height);
              offsetx = shape.x;
              offsety = shape.y;
              break;
            case GEOM_CONST.TRIANGLE:
              debug = factory.triangle(0, 0, shape.x1, shape.y1, shape.x2, shape.y2, shape.x3, shape.y3);
              break;
          }
          if (debug) {
            debug.isFilled = false;
            debug.strokeColor = color;
            debug.preUpdate = function() {
              debug.setStrokeStyle(1 / gameObject.scale, debug.strokeColor);
              debug.setDisplayOrigin(gameObject.displayOriginX, gameObject.displayOriginY);
              var x = gameObject.x;
              var y = gameObject.y;
              var rotation = gameObject.rotation;
              var scaleX = gameObject.scaleX;
              var scaleY = gameObject.scaleY;
              if (gameObject.parentContainer) {
                var matrix = gameObject.getWorldTransformMatrix();
                x = matrix.tx;
                y = matrix.ty;
                rotation = matrix.rotation;
                scaleX = matrix.scaleX;
                scaleY = matrix.scaleY;
              }
              debug.setRotation(rotation);
              debug.setScale(scaleX, scaleY);
              debug.setPosition(x + offsetx * scaleX, y + offsety * scaleY);
              debug.setScrollFactor(gameObject.scrollFactorX, gameObject.scrollFactorY);
              debug.setDepth(gameObject.depth);
            };
            updateList.add(debug);
            input.hitAreaDebug = debug;
          }
          return this;
        },
        removeDebug: function(gameObject) {
          var input = gameObject.input;
          if (input && input.hitAreaDebug) {
            var debug = input.hitAreaDebug;
            this.systems.updateList.remove(debug);
            debug.destroy();
            input.hitAreaDebug = null;
          }
          return this;
        },
        setPollAlways: function() {
          return this.setPollRate(0);
        },
        setPollOnMove: function() {
          return this.setPollRate(-1);
        },
        setPollRate: function(value) {
          this.pollRate = value;
          this._pollTimer = 0;
          return this;
        },
        setGlobalTopOnly: function(value) {
          this.manager.globalTopOnly = value;
          return this;
        },
        setTopOnly: function(value) {
          this.topOnly = value;
          return this;
        },
        sortGameObjects: function(gameObjects, pointer) {
          if (gameObjects.length < 2 || !pointer.camera) {
            return gameObjects;
          }
          var list = pointer.camera.renderList;
          return gameObjects.sort(function(childA, childB) {
            var indexA = Math.max(list.indexOf(childA), 0);
            var indexB = Math.max(list.indexOf(childB), 0);
            return indexB - indexA;
          });
        },
        sortDropZones: function(gameObjects) {
          if (gameObjects.length < 2) {
            return gameObjects;
          }
          this.scene.sys.depthSort();
          return gameObjects.sort(this.sortDropZoneHandler.bind(this));
        },
        sortDropZoneHandler: function(childA, childB) {
          if (!childA.parentContainer && !childB.parentContainer) {
            return this.displayList.getIndex(childB) - this.displayList.getIndex(childA);
          } else if (childA.parentContainer === childB.parentContainer) {
            return childB.parentContainer.getIndex(childB) - childA.parentContainer.getIndex(childA);
          } else if (childA.parentContainer === childB) {
            return -1;
          } else if (childB.parentContainer === childA) {
            return 1;
          } else {
            var listA = childA.getIndexList();
            var listB = childB.getIndexList();
            var len = Math.min(listA.length, listB.length);
            for (var i = 0; i < len; i++) {
              var indexA = listA[i];
              var indexB = listB[i];
              if (indexA === indexB) {
                continue;
              } else {
                return indexB - indexA;
              }
            }
            return listB.length - listA.length;
          }
          return 0;
        },
        stopPropagation: function() {
          this.manager._tempSkip = true;
          return this;
        },
        addPointer: function(quantity) {
          return this.manager.addPointer(quantity);
        },
        setDefaultCursor: function(cursor) {
          this.manager.setDefaultCursor(cursor);
          return this;
        },
        transitionIn: function() {
          this.enabled = this.settings.transitionAllowInput;
        },
        transitionComplete: function() {
          if (!this.settings.transitionAllowInput) {
            this.enabled = true;
          }
        },
        transitionOut: function() {
          this.enabled = this.settings.transitionAllowInput;
        },
        shutdown: function() {
          this.pluginEvents.emit(Events.SHUTDOWN);
          this._temp.length = 0;
          this._list.length = 0;
          this._draggable.length = 0;
          this._pendingRemoval.length = 0;
          this._pendingInsertion.length = 0;
          this._dragState.length = 0;
          for (var i = 0; i < 10; i++) {
            this._drag[i] = [];
            this._over[i] = [];
          }
          this.removeAllListeners();
          var manager = this.manager;
          manager.canvas.style.cursor = manager.defaultCursor;
          var eventEmitter = this.systems.events;
          eventEmitter.off(SceneEvents.TRANSITION_START, this.transitionIn, this);
          eventEmitter.off(SceneEvents.TRANSITION_OUT, this.transitionOut, this);
          eventEmitter.off(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);
          eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
          manager.events.off(Events.GAME_OUT, this.onGameOut, this);
          manager.events.off(Events.GAME_OVER, this.onGameOver, this);
          eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        resetPointers: function() {
          var pointers = this.manager.pointers;
          for (var i = 0; i < pointers.length; i++) {
            pointers[i].reset();
          }
        },
        destroy: function() {
          this.shutdown();
          this.pluginEvents.emit(Events.DESTROY);
          this.pluginEvents.removeAllListeners();
          this.scene.sys.events.off(SceneEvents.START, this.start, this);
          this.scene = null;
          this.cameras = null;
          this.manager = null;
          this.events = null;
          this.mouse = null;
        },
        x: {
          get: function() {
            return this.manager.activePointer.x;
          }
        },
        y: {
          get: function() {
            return this.manager.activePointer.y;
          }
        },
        isOver: {
          get: function() {
            return this.manager.isOver;
          }
        },
        mousePointer: {
          get: function() {
            return this.manager.mousePointer;
          }
        },
        activePointer: {
          get: function() {
            return this.manager.activePointer;
          }
        },
        pointer1: {
          get: function() {
            return this.manager.pointers[1];
          }
        },
        pointer2: {
          get: function() {
            return this.manager.pointers[2];
          }
        },
        pointer3: {
          get: function() {
            return this.manager.pointers[3];
          }
        },
        pointer4: {
          get: function() {
            return this.manager.pointers[4];
          }
        },
        pointer5: {
          get: function() {
            return this.manager.pointers[5];
          }
        },
        pointer6: {
          get: function() {
            return this.manager.pointers[6];
          }
        },
        pointer7: {
          get: function() {
            return this.manager.pointers[7];
          }
        },
        pointer8: {
          get: function() {
            return this.manager.pointers[8];
          }
        },
        pointer9: {
          get: function() {
            return this.manager.pointers[9];
          }
        },
        pointer10: {
          get: function() {
            return this.manager.pointers[10];
          }
        }
      });
      PluginCache.register("InputPlugin", InputPlugin, "input");
      module.exports = InputPlugin;
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/events/ANY_KEY_DOWN_EVENT.js
  var require_ANY_KEY_DOWN_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/events/ANY_KEY_DOWN_EVENT.js": function(exports, module) {
      module.exports = "keydown";
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/events/ANY_KEY_UP_EVENT.js
  var require_ANY_KEY_UP_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/events/ANY_KEY_UP_EVENT.js": function(exports, module) {
      module.exports = "keyup";
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/events/COMBO_MATCH_EVENT.js
  var require_COMBO_MATCH_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/events/COMBO_MATCH_EVENT.js": function(exports, module) {
      module.exports = "keycombomatch";
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/events/DOWN_EVENT.js
  var require_DOWN_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/events/DOWN_EVENT.js": function(exports, module) {
      module.exports = "down";
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/events/KEY_DOWN_EVENT.js
  var require_KEY_DOWN_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/events/KEY_DOWN_EVENT.js": function(exports, module) {
      module.exports = "keydown-";
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/events/KEY_UP_EVENT.js
  var require_KEY_UP_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/events/KEY_UP_EVENT.js": function(exports, module) {
      module.exports = "keyup-";
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/events/UP_EVENT.js
  var require_UP_EVENT = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/events/UP_EVENT.js": function(exports, module) {
      module.exports = "up";
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/events/index.js
  var require_events19 = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/events/index.js": function(exports, module) {
      module.exports = {
        ANY_KEY_DOWN: require_ANY_KEY_DOWN_EVENT(),
        ANY_KEY_UP: require_ANY_KEY_UP_EVENT(),
        COMBO_MATCH: require_COMBO_MATCH_EVENT(),
        DOWN: require_DOWN_EVENT(),
        KEY_DOWN: require_KEY_DOWN_EVENT(),
        KEY_UP: require_KEY_UP_EVENT(),
        UP: require_UP_EVENT()
      };
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/keys/Key.js
  var require_Key = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/keys/Key.js": function(exports, module) {
      var Class = require_Class();
      var EventEmitter = require_eventemitter3();
      var Events = require_events19();
      var Key = new Class({
        Extends: EventEmitter,
        initialize: function Key2(plugin, keyCode) {
          EventEmitter.call(this);
          this.plugin = plugin;
          this.keyCode = keyCode;
          this.originalEvent = void 0;
          this.enabled = true;
          this.isDown = false;
          this.isUp = true;
          this.altKey = false;
          this.ctrlKey = false;
          this.shiftKey = false;
          this.metaKey = false;
          this.location = 0;
          this.timeDown = 0;
          this.duration = 0;
          this.timeUp = 0;
          this.emitOnRepeat = false;
          this.repeats = 0;
          this._justDown = false;
          this._justUp = false;
          this._tick = -1;
        },
        setEmitOnRepeat: function(value) {
          this.emitOnRepeat = value;
          return this;
        },
        onDown: function(event) {
          this.originalEvent = event;
          if (!this.enabled) {
            return;
          }
          this.altKey = event.altKey;
          this.ctrlKey = event.ctrlKey;
          this.shiftKey = event.shiftKey;
          this.metaKey = event.metaKey;
          this.location = event.location;
          this.repeats++;
          if (!this.isDown) {
            this.isDown = true;
            this.isUp = false;
            this.timeDown = event.timeStamp;
            this.duration = 0;
            this._justDown = true;
            this._justUp = false;
            this.emit(Events.DOWN, this, event);
          } else if (this.emitOnRepeat) {
            this.emit(Events.DOWN, this, event);
          }
        },
        onUp: function(event) {
          this.originalEvent = event;
          if (!this.enabled) {
            return;
          }
          this.isDown = false;
          this.isUp = true;
          this.timeUp = event.timeStamp;
          this.duration = this.timeUp - this.timeDown;
          this.repeats = 0;
          this._justDown = false;
          this._justUp = true;
          this._tick = -1;
          this.emit(Events.UP, this, event);
        },
        reset: function() {
          this.isDown = false;
          this.isUp = true;
          this.altKey = false;
          this.ctrlKey = false;
          this.shiftKey = false;
          this.metaKey = false;
          this.timeDown = 0;
          this.duration = 0;
          this.timeUp = 0;
          this.repeats = 0;
          this._justDown = false;
          this._justUp = false;
          this._tick = -1;
          return this;
        },
        getDuration: function() {
          if (this.isDown) {
            return this.plugin.game.loop.time - this.timeDown;
          } else {
            return 0;
          }
        },
        destroy: function() {
          this.removeAllListeners();
          this.originalEvent = null;
          this.plugin = null;
        }
      });
      module.exports = Key;
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/combo/AdvanceKeyCombo.js
  var require_AdvanceKeyCombo = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/combo/AdvanceKeyCombo.js": function(exports, module) {
      var AdvanceKeyCombo = function(event, combo) {
        combo.timeLastMatched = event.timeStamp;
        combo.index++;
        if (combo.index === combo.size) {
          return true;
        } else {
          combo.current = combo.keyCodes[combo.index];
          return false;
        }
      };
      module.exports = AdvanceKeyCombo;
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/combo/ProcessKeyCombo.js
  var require_ProcessKeyCombo = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/combo/ProcessKeyCombo.js": function(exports, module) {
      var AdvanceKeyCombo = require_AdvanceKeyCombo();
      var ProcessKeyCombo = function(event, combo) {
        if (combo.matched) {
          return true;
        }
        var comboMatched = false;
        var keyMatched = false;
        if (event.keyCode === combo.current) {
          if (combo.index > 0 && combo.maxKeyDelay > 0) {
            var timeLimit = combo.timeLastMatched + combo.maxKeyDelay;
            if (event.timeStamp <= timeLimit) {
              keyMatched = true;
              comboMatched = AdvanceKeyCombo(event, combo);
            }
          } else {
            keyMatched = true;
            comboMatched = AdvanceKeyCombo(event, combo);
          }
        }
        if (!keyMatched && combo.resetOnWrongKey) {
          combo.index = 0;
          combo.current = combo.keyCodes[0];
        }
        if (comboMatched) {
          combo.timeLastMatched = event.timeStamp;
          combo.matched = true;
          combo.timeMatched = event.timeStamp;
        }
        return comboMatched;
      };
      module.exports = ProcessKeyCombo;
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/combo/ResetKeyCombo.js
  var require_ResetKeyCombo = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/combo/ResetKeyCombo.js": function(exports, module) {
      var ResetKeyCombo = function(combo) {
        combo.current = combo.keyCodes[0];
        combo.index = 0;
        combo.timeLastMatched = 0;
        combo.matched = false;
        combo.timeMatched = 0;
        return combo;
      };
      module.exports = ResetKeyCombo;
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/combo/KeyCombo.js
  var require_KeyCombo = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/combo/KeyCombo.js": function(exports, module) {
      var Class = require_Class();
      var Events = require_events19();
      var GetFastValue = require_GetFastValue();
      var ProcessKeyCombo = require_ProcessKeyCombo();
      var ResetKeyCombo = require_ResetKeyCombo();
      var KeyCombo = new Class({
        initialize: function KeyCombo2(keyboardPlugin, keys, config) {
          if (config === void 0) {
            config = {};
          }
          if (keys.length < 2) {
            return false;
          }
          this.manager = keyboardPlugin;
          this.enabled = true;
          this.keyCodes = [];
          for (var i = 0; i < keys.length; i++) {
            var char = keys[i];
            if (typeof char === "string") {
              this.keyCodes.push(char.toUpperCase().charCodeAt(0));
            } else if (typeof char === "number") {
              this.keyCodes.push(char);
            } else if (char.hasOwnProperty("keyCode")) {
              this.keyCodes.push(char.keyCode);
            }
          }
          this.current = this.keyCodes[0];
          this.index = 0;
          this.size = this.keyCodes.length;
          this.timeLastMatched = 0;
          this.matched = false;
          this.timeMatched = 0;
          this.resetOnWrongKey = GetFastValue(config, "resetOnWrongKey", true);
          this.maxKeyDelay = GetFastValue(config, "maxKeyDelay", 0);
          this.resetOnMatch = GetFastValue(config, "resetOnMatch", false);
          this.deleteOnMatch = GetFastValue(config, "deleteOnMatch", false);
          var _this = this;
          var onKeyDownHandler = function(event) {
            if (_this.matched || !_this.enabled) {
              return;
            }
            var matched = ProcessKeyCombo(event, _this);
            if (matched) {
              _this.manager.emit(Events.COMBO_MATCH, _this, event);
              if (_this.resetOnMatch) {
                ResetKeyCombo(_this);
              } else if (_this.deleteOnMatch) {
                _this.destroy();
              }
            }
          };
          this.onKeyDown = onKeyDownHandler;
          this.manager.on(Events.ANY_KEY_DOWN, this.onKeyDown);
        },
        progress: {
          get: function() {
            return this.index / this.size;
          }
        },
        destroy: function() {
          this.enabled = false;
          this.keyCodes = [];
          this.manager.off(Events.ANY_KEY_DOWN, this.onKeyDown);
          this.manager = null;
        }
      });
      module.exports = KeyCombo;
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/keys/KeyMap.js
  var require_KeyMap = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/keys/KeyMap.js": function(exports, module) {
      var KeyCodes = require_KeyCodes();
      var KeyMap = {};
      for (key in KeyCodes) {
        KeyMap[KeyCodes[key]] = key;
      }
      var key;
      module.exports = KeyMap;
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/KeyboardPlugin.js
  var require_KeyboardPlugin = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/KeyboardPlugin.js": function(exports, module) {
      var Class = require_Class();
      var EventEmitter = require_eventemitter3();
      var Events = require_events19();
      var GameEvents = require_events5();
      var GetValue = require_GetValue();
      var InputEvents = require_events13();
      var InputPluginCache = require_InputPluginCache();
      var Key = require_Key();
      var KeyCodes = require_KeyCodes();
      var KeyCombo = require_KeyCombo();
      var KeyMap = require_KeyMap();
      var SceneEvents = require_events();
      var SnapFloor = require_SnapFloor();
      var KeyboardPlugin = new Class({
        Extends: EventEmitter,
        initialize: function KeyboardPlugin2(sceneInputPlugin) {
          EventEmitter.call(this);
          this.game = sceneInputPlugin.systems.game;
          this.scene = sceneInputPlugin.scene;
          this.settings = this.scene.sys.settings;
          this.sceneInputPlugin = sceneInputPlugin;
          this.manager = sceneInputPlugin.manager.keyboard;
          this.enabled = true;
          this.keys = [];
          this.combos = [];
          this.prevCode = null;
          this.prevTime = 0;
          this.prevType = null;
          sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);
          sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);
        },
        boot: function() {
          var settings = this.settings.input;
          this.enabled = GetValue(settings, "keyboard", true);
          var captures = GetValue(settings, "keyboard.capture", null);
          if (captures) {
            this.addCaptures(captures);
          }
          this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);
        },
        start: function() {
          this.sceneInputPlugin.manager.events.on(InputEvents.MANAGER_PROCESS, this.update, this);
          this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);
          this.game.events.on(GameEvents.BLUR, this.resetKeys, this);
          this.scene.sys.events.on(SceneEvents.PAUSE, this.resetKeys, this);
          this.scene.sys.events.on(SceneEvents.SLEEP, this.resetKeys, this);
        },
        isActive: function() {
          return this.enabled && this.scene.sys.canInput();
        },
        addCapture: function(keycode) {
          this.manager.addCapture(keycode);
          return this;
        },
        removeCapture: function(keycode) {
          this.manager.removeCapture(keycode);
          return this;
        },
        getCaptures: function() {
          return this.manager.captures;
        },
        enableGlobalCapture: function() {
          this.manager.preventDefault = true;
          return this;
        },
        disableGlobalCapture: function() {
          this.manager.preventDefault = false;
          return this;
        },
        clearCaptures: function() {
          this.manager.clearCaptures();
          return this;
        },
        createCursorKeys: function() {
          return this.addKeys({
            up: KeyCodes.UP,
            down: KeyCodes.DOWN,
            left: KeyCodes.LEFT,
            right: KeyCodes.RIGHT,
            space: KeyCodes.SPACE,
            shift: KeyCodes.SHIFT
          });
        },
        addKeys: function(keys, enableCapture, emitOnRepeat) {
          if (enableCapture === void 0) {
            enableCapture = true;
          }
          if (emitOnRepeat === void 0) {
            emitOnRepeat = false;
          }
          var output = {};
          if (typeof keys === "string") {
            keys = keys.split(",");
            for (var i = 0; i < keys.length; i++) {
              var currentKey = keys[i].trim();
              if (currentKey) {
                output[currentKey] = this.addKey(currentKey, enableCapture, emitOnRepeat);
              }
            }
          } else {
            for (var key in keys) {
              output[key] = this.addKey(keys[key], enableCapture, emitOnRepeat);
            }
          }
          return output;
        },
        addKey: function(key, enableCapture, emitOnRepeat) {
          if (enableCapture === void 0) {
            enableCapture = true;
          }
          if (emitOnRepeat === void 0) {
            emitOnRepeat = false;
          }
          var keys = this.keys;
          if (key instanceof Key) {
            var idx = keys.indexOf(key);
            if (idx > -1) {
              keys[idx] = key;
            } else {
              keys[key.keyCode] = key;
            }
            if (enableCapture) {
              this.addCapture(key.keyCode);
            }
            key.setEmitOnRepeat(emitOnRepeat);
            return key;
          }
          if (typeof key === "string") {
            key = KeyCodes[key.toUpperCase()];
          }
          if (!keys[key]) {
            keys[key] = new Key(this, key);
            if (enableCapture) {
              this.addCapture(key);
            }
            keys[key].setEmitOnRepeat(emitOnRepeat);
          }
          return keys[key];
        },
        removeKey: function(key, destroy, removeCapture) {
          if (destroy === void 0) {
            destroy = false;
          }
          if (removeCapture === void 0) {
            removeCapture = false;
          }
          var keys = this.keys;
          var ref;
          if (key instanceof Key) {
            var idx = keys.indexOf(key);
            if (idx > -1) {
              ref = this.keys[idx];
              this.keys[idx] = void 0;
            }
          } else if (typeof key === "string") {
            key = KeyCodes[key.toUpperCase()];
          }
          if (keys[key]) {
            ref = keys[key];
            keys[key] = void 0;
          }
          if (ref) {
            ref.plugin = null;
            if (removeCapture) {
              this.removeCapture(ref.keyCode);
            }
            if (destroy) {
              ref.destroy();
            }
          }
          return this;
        },
        removeAllKeys: function(destroy, removeCapture) {
          if (destroy === void 0) {
            destroy = false;
          }
          if (removeCapture === void 0) {
            removeCapture = false;
          }
          var keys = this.keys;
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (key) {
              keys[i] = void 0;
              if (removeCapture) {
                this.removeCapture(key.keyCode);
              }
              if (destroy) {
                key.destroy();
              }
            }
          }
          return this;
        },
        createCombo: function(keys, config) {
          return new KeyCombo(this, keys, config);
        },
        checkDown: function(key, duration) {
          if (duration === void 0) {
            duration = 0;
          }
          if (this.enabled && key.isDown) {
            var t = SnapFloor(this.time - key.timeDown, duration);
            if (t > key._tick) {
              key._tick = t;
              return true;
            }
          }
          return false;
        },
        update: function() {
          var queue = this.manager.queue;
          var len = queue.length;
          if (!this.isActive() || len === 0) {
            return;
          }
          var keys = this.keys;
          for (var i = 0; i < len; i++) {
            var event = queue[i];
            var code = event.keyCode;
            var key = keys[code];
            var repeat = false;
            if (event.cancelled === void 0) {
              event.cancelled = 0;
              event.stopImmediatePropagation = function() {
                event.cancelled = 1;
              };
              event.stopPropagation = function() {
                event.cancelled = -1;
              };
            }
            if (event.cancelled === -1) {
              continue;
            }
            if (code === this.prevCode && event.timeStamp === this.prevTime && event.type === this.prevType) {
              continue;
            }
            this.prevCode = code;
            this.prevTime = event.timeStamp;
            this.prevType = event.type;
            if (event.type === "keydown") {
              if (key) {
                repeat = key.isDown;
                key.onDown(event);
              }
              if (!event.cancelled && (!key || !repeat)) {
                if (KeyMap[code]) {
                  this.emit(Events.KEY_DOWN + KeyMap[code], event);
                }
                if (!event.cancelled) {
                  this.emit(Events.ANY_KEY_DOWN, event);
                }
              }
            } else {
              if (key) {
                key.onUp(event);
              }
              if (!event.cancelled) {
                if (KeyMap[code]) {
                  this.emit(Events.KEY_UP + KeyMap[code], event);
                }
                if (!event.cancelled) {
                  this.emit(Events.ANY_KEY_UP, event);
                }
              }
            }
            if (event.cancelled === 1) {
              event.cancelled = 0;
            }
          }
        },
        resetKeys: function() {
          var keys = this.keys;
          for (var i = 0; i < keys.length; i++) {
            if (keys[i]) {
              keys[i].reset();
            }
          }
          return this;
        },
        shutdown: function() {
          this.removeAllKeys(true);
          this.removeAllListeners();
          this.sceneInputPlugin.manager.events.off(InputEvents.MANAGER_PROCESS, this.update, this);
          this.game.events.off(GameEvents.BLUR, this.resetKeys);
          this.scene.sys.events.off(SceneEvents.PAUSE, this.resetKeys, this);
          this.scene.sys.events.off(SceneEvents.SLEEP, this.resetKeys, this);
          this.queue = [];
        },
        destroy: function() {
          this.shutdown();
          var keys = this.keys;
          for (var i = 0; i < keys.length; i++) {
            if (keys[i]) {
              keys[i].destroy();
            }
          }
          this.keys = [];
          this.combos = [];
          this.queue = [];
          this.scene = null;
          this.settings = null;
          this.sceneInputPlugin = null;
          this.manager = null;
        },
        time: {
          get: function() {
            return this.sceneInputPlugin.manager.time;
          }
        }
      });
      InputPluginCache.register("KeyboardPlugin", KeyboardPlugin, "keyboard", "keyboard", "inputKeyboard");
      module.exports = KeyboardPlugin;
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/keys/JustDown.js
  var require_JustDown = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/keys/JustDown.js": function(exports, module) {
      var JustDown = function(key) {
        if (key._justDown) {
          key._justDown = false;
          return true;
        } else {
          return false;
        }
      };
      module.exports = JustDown;
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/keys/JustUp.js
  var require_JustUp = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/keys/JustUp.js": function(exports, module) {
      var JustUp = function(key) {
        if (key._justUp) {
          key._justUp = false;
          return true;
        } else {
          return false;
        }
      };
      module.exports = JustUp;
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/keys/DownDuration.js
  var require_DownDuration = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/keys/DownDuration.js": function(exports, module) {
      var DownDuration = function(key, duration) {
        if (duration === void 0) {
          duration = 50;
        }
        var current = key.plugin.game.loop.time - key.timeDown;
        return key.isDown && current < duration;
      };
      module.exports = DownDuration;
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/keys/UpDuration.js
  var require_UpDuration = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/keys/UpDuration.js": function(exports, module) {
      var UpDuration = function(key, duration) {
        if (duration === void 0) {
          duration = 50;
        }
        var current = key.plugin.game.loop.time - key.timeUp;
        return key.isUp && current < duration;
      };
      module.exports = UpDuration;
    }
  });

  // ../../node_modules/phaser/src/input/keyboard/index.js
  var require_keyboard = __commonJS({
    "../../node_modules/phaser/src/input/keyboard/index.js": function(exports, module) {
      module.exports = {
        Events: require_events19(),
        KeyboardManager: require_KeyboardManager(),
        KeyboardPlugin: require_KeyboardPlugin(),
        Key: require_Key(),
        KeyCodes: require_KeyCodes(),
        KeyCombo: require_KeyCombo(),
        AdvanceKeyCombo: require_AdvanceKeyCombo(),
        ProcessKeyCombo: require_ProcessKeyCombo(),
        ResetKeyCombo: require_ResetKeyCombo(),
        JustDown: require_JustDown(),
        JustUp: require_JustUp(),
        DownDuration: require_DownDuration(),
        UpDuration: require_UpDuration()
      };
    }
  });

  // ../../node_modules/phaser/src/input/mouse/index.js
  var require_mouse = __commonJS({
    "../../node_modules/phaser/src/input/mouse/index.js": function(exports, module) {
      module.exports = {
        MouseManager: require_MouseManager()
      };
    }
  });

  // ../../node_modules/phaser/src/input/touch/index.js
  var require_touch = __commonJS({
    "../../node_modules/phaser/src/input/touch/index.js": function(exports, module) {
      module.exports = {
        TouchManager: require_TouchManager()
      };
    }
  });

  // ../../node_modules/phaser/src/input/index.js
  var require_input = __commonJS({
    "../../node_modules/phaser/src/input/index.js": function(exports, module) {
      var CONST = require_const8();
      var Extend = require_Extend();
      var Input = {
        CreatePixelPerfectHandler: require_CreatePixelPerfectHandler(),
        CreateInteractiveObject: require_CreateInteractiveObject(),
        Events: require_events13(),
        Gamepad: require_gamepad(),
        InputManager: require_InputManager(),
        InputPlugin: require_InputPlugin(),
        InputPluginCache: require_InputPluginCache(),
        Keyboard: require_keyboard(),
        Mouse: require_mouse(),
        Pointer: require_Pointer(),
        Touch: require_touch()
      };
      Input = Extend(false, Input, CONST);
      module.exports = Input;
    }
  });

  // ../../node_modules/phaser/src/loader/const.js
  var require_const11 = __commonJS({
    "../../node_modules/phaser/src/loader/const.js": function(exports, module) {
      var FILE_CONST = {
        LOADER_IDLE: 0,
        LOADER_LOADING: 1,
        LOADER_PROCESSING: 2,
        LOADER_COMPLETE: 3,
        LOADER_SHUTDOWN: 4,
        LOADER_DESTROYED: 5,
        FILE_PENDING: 10,
        FILE_LOADING: 11,
        FILE_LOADED: 12,
        FILE_FAILED: 13,
        FILE_PROCESSING: 14,
        FILE_ERRORED: 16,
        FILE_COMPLETE: 17,
        FILE_DESTROYED: 18,
        FILE_POPULATED: 19,
        FILE_PENDING_DESTROY: 20
      };
      module.exports = FILE_CONST;
    }
  });

  // ../../node_modules/phaser/src/loader/GetURL.js
  var require_GetURL = __commonJS({
    "../../node_modules/phaser/src/loader/GetURL.js": function(exports, module) {
      var GetURL = function(file, baseURL) {
        if (!file.url) {
          return false;
        }
        if (file.url.match(/^(?:blob:|data:|capacitor:\/\/|http:\/\/|https:\/\/|\/\/)/)) {
          return file.url;
        } else {
          return baseURL + file.url;
        }
      };
      module.exports = GetURL;
    }
  });

  // ../../node_modules/phaser/src/loader/XHRSettings.js
  var require_XHRSettings = __commonJS({
    "../../node_modules/phaser/src/loader/XHRSettings.js": function(exports, module) {
      var XHRSettings = function(responseType, async, user, password, timeout, withCredentials) {
        if (responseType === void 0) {
          responseType = "";
        }
        if (async === void 0) {
          async = true;
        }
        if (user === void 0) {
          user = "";
        }
        if (password === void 0) {
          password = "";
        }
        if (timeout === void 0) {
          timeout = 0;
        }
        if (withCredentials === void 0) {
          withCredentials = false;
        }
        return {
          responseType: responseType,
          async: async,
          user: user,
          password: password,
          timeout: timeout,
          headers: void 0,
          header: void 0,
          headerValue: void 0,
          requestedWith: false,
          overrideMimeType: void 0,
          withCredentials: withCredentials
        };
      };
      module.exports = XHRSettings;
    }
  });

  // ../../node_modules/phaser/src/loader/MergeXHRSettings.js
  var require_MergeXHRSettings = __commonJS({
    "../../node_modules/phaser/src/loader/MergeXHRSettings.js": function(exports, module) {
      var Extend = require_Extend();
      var XHRSettings = require_XHRSettings();
      var MergeXHRSettings = function(global, local) {
        var output = global === void 0 ? XHRSettings() : Extend({}, global);
        if (local) {
          for (var setting in local) {
            if (local[setting] !== void 0) {
              output[setting] = local[setting];
            }
          }
        }
        return output;
      };
      module.exports = MergeXHRSettings;
    }
  });

  // ../../node_modules/phaser/src/loader/XHRLoader.js
  var require_XHRLoader = __commonJS({
    "../../node_modules/phaser/src/loader/XHRLoader.js": function(exports, module) {
      var MergeXHRSettings = require_MergeXHRSettings();
      var XHRLoader = function(file, globalXHRSettings) {
        var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings);
        var xhr = new XMLHttpRequest();
        xhr.open("GET", file.src, config.async, config.user, config.password);
        xhr.responseType = file.xhrSettings.responseType;
        xhr.timeout = config.timeout;
        if (config.headers) {
          for (var key in config.headers) {
            xhr.setRequestHeader(key, config.headers[key]);
          }
        }
        if (config.header && config.headerValue) {
          xhr.setRequestHeader(config.header, config.headerValue);
        }
        if (config.requestedWith) {
          xhr.setRequestHeader("X-Requested-With", config.requestedWith);
        }
        if (config.overrideMimeType) {
          xhr.overrideMimeType(config.overrideMimeType);
        }
        if (config.withCredentials) {
          xhr.withCredentials = true;
        }
        xhr.onload = file.onLoad.bind(file, xhr);
        xhr.onerror = file.onError.bind(file, xhr);
        xhr.onprogress = file.onProgress.bind(file);
        xhr.send();
        return xhr;
      };
      module.exports = XHRLoader;
    }
  });

  // ../../node_modules/phaser/src/loader/File.js
  var require_File = __commonJS({
    "../../node_modules/phaser/src/loader/File.js": function(exports, module) {
      var Class = require_Class();
      var CONST = require_const11();
      var Events = require_events14();
      var GetFastValue = require_GetFastValue();
      var GetURL = require_GetURL();
      var MergeXHRSettings = require_MergeXHRSettings();
      var XHRLoader = require_XHRLoader();
      var XHRSettings = require_XHRSettings();
      var File = new Class({
        initialize: function File2(loader, fileConfig) {
          this.loader = loader;
          this.cache = GetFastValue(fileConfig, "cache", false);
          this.type = GetFastValue(fileConfig, "type", false);
          if (!this.type) {
            throw new Error("Invalid File type: " + this.type);
          }
          this.key = GetFastValue(fileConfig, "key", false);
          var loadKey = this.key;
          if (loader.prefix && loader.prefix !== "") {
            this.key = loader.prefix + loadKey;
          }
          if (!this.key) {
            throw new Error("Invalid File key: " + this.key);
          }
          var url = GetFastValue(fileConfig, "url");
          if (url === void 0) {
            url = loader.path + loadKey + "." + GetFastValue(fileConfig, "extension", "");
          } else if (typeof url === "string" && !url.match(/^(?:blob:|data:|capacitor:\/\/|http:\/\/|https:\/\/|\/\/)/)) {
            url = loader.path + url;
          }
          this.url = url;
          this.src = "";
          this.xhrSettings = XHRSettings(GetFastValue(fileConfig, "responseType", void 0));
          if (GetFastValue(fileConfig, "xhrSettings", false)) {
            this.xhrSettings = MergeXHRSettings(this.xhrSettings, GetFastValue(fileConfig, "xhrSettings", {}));
          }
          this.xhrLoader = null;
          this.state = typeof this.url === "function" ? CONST.FILE_POPULATED : CONST.FILE_PENDING;
          this.bytesTotal = 0;
          this.bytesLoaded = -1;
          this.percentComplete = -1;
          this.crossOrigin = void 0;
          this.data = void 0;
          this.config = GetFastValue(fileConfig, "config", {});
          this.multiFile;
          this.linkFile;
        },
        setLink: function(fileB) {
          this.linkFile = fileB;
          fileB.linkFile = this;
        },
        resetXHR: function() {
          if (this.xhrLoader) {
            this.xhrLoader.onload = void 0;
            this.xhrLoader.onerror = void 0;
            this.xhrLoader.onprogress = void 0;
          }
        },
        load: function() {
          if (this.state === CONST.FILE_POPULATED) {
            this.loader.nextFile(this, true);
          } else {
            this.state = CONST.FILE_LOADING;
            this.src = GetURL(this, this.loader.baseURL);
            if (this.src.indexOf("data:") === 0) {
              console.warn("Local data URIs are not supported: " + this.key);
            } else {
              this.xhrLoader = XHRLoader(this, this.loader.xhr);
            }
          }
        },
        onLoad: function(xhr, event) {
          var isLocalFile = xhr.responseURL && this.loader.localSchemes.some(function(scheme) {
            return xhr.responseURL.indexOf(scheme) === 0;
          });
          var localFileOk = isLocalFile && event.target.status === 0;
          var success = !(event.target && event.target.status !== 200) || localFileOk;
          if (xhr.readyState === 4 && xhr.status >= 400 && xhr.status <= 599) {
            success = false;
          }
          this.state = CONST.FILE_LOADED;
          this.resetXHR();
          this.loader.nextFile(this, success);
        },
        onError: function() {
          this.resetXHR();
          this.loader.nextFile(this, false);
        },
        onProgress: function(event) {
          if (event.lengthComputable) {
            this.bytesLoaded = event.loaded;
            this.bytesTotal = event.total;
            this.percentComplete = Math.min(this.bytesLoaded / this.bytesTotal, 1);
            this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);
          }
        },
        onProcess: function() {
          this.state = CONST.FILE_PROCESSING;
          this.onProcessComplete();
        },
        onProcessComplete: function() {
          this.state = CONST.FILE_COMPLETE;
          if (this.multiFile) {
            this.multiFile.onFileComplete(this);
          }
          this.loader.fileProcessComplete(this);
        },
        onProcessError: function() {
          console.error('Failed to process file: %s "%s"', this.type, this.key);
          this.state = CONST.FILE_ERRORED;
          if (this.multiFile) {
            this.multiFile.onFileFailed(this);
          }
          this.loader.fileProcessComplete(this);
        },
        hasCacheConflict: function() {
          return this.cache && this.cache.exists(this.key);
        },
        addToCache: function() {
          if (this.cache && this.data) {
            this.cache.add(this.key, this.data);
          }
        },
        pendingDestroy: function(data) {
          if (this.state === CONST.FILE_PENDING_DESTROY) {
            return;
          }
          if (data === void 0) {
            data = this.data;
          }
          var key = this.key;
          var type = this.type;
          this.loader.emit(Events.FILE_COMPLETE, key, type, data);
          this.loader.emit(Events.FILE_KEY_COMPLETE + type + "-" + key, key, type, data);
          this.loader.flagForRemoval(this);
          this.state = CONST.FILE_PENDING_DESTROY;
        },
        destroy: function() {
          this.loader = null;
          this.cache = null;
          this.xhrSettings = null;
          this.multiFile = null;
          this.linkFile = null;
          this.data = null;
        }
      });
      File.createObjectURL = function(image, blob, defaultType) {
        if (typeof URL === "function") {
          image.src = URL.createObjectURL(blob);
        } else {
          var reader = new FileReader();
          reader.onload = function() {
            image.removeAttribute("crossOrigin");
            image.src = "data:" + (blob.type || defaultType) + ";base64," + reader.result.split(",")[1];
          };
          reader.onerror = image.onerror;
          reader.readAsDataURL(blob);
        }
      };
      File.revokeObjectURL = function(image) {
        if (typeof URL === "function") {
          URL.revokeObjectURL(image.src);
        }
      };
      module.exports = File;
    }
  });

  // ../../node_modules/phaser/src/loader/filetypes/ImageFile.js
  var require_ImageFile = __commonJS({
    "../../node_modules/phaser/src/loader/filetypes/ImageFile.js": function(exports, module) {
      var Class = require_Class();
      var CONST = require_const11();
      var File = require_File();
      var FileTypesManager = require_FileTypesManager();
      var GetFastValue = require_GetFastValue();
      var IsPlainObject = require_IsPlainObject();
      var GetURL = require_GetURL();
      var ImageFile = new Class({
        Extends: File,
        initialize: function ImageFile2(loader, key, url, xhrSettings, frameConfig) {
          var extension = "png";
          var normalMapURL;
          if (IsPlainObject(key)) {
            var config = key;
            key = GetFastValue(config, "key");
            url = GetFastValue(config, "url");
            normalMapURL = GetFastValue(config, "normalMap");
            xhrSettings = GetFastValue(config, "xhrSettings");
            extension = GetFastValue(config, "extension", extension);
            frameConfig = GetFastValue(config, "frameConfig");
          }
          if (Array.isArray(url)) {
            normalMapURL = url[1];
            url = url[0];
          }
          var fileConfig = {
            type: "image",
            cache: loader.textureManager,
            extension: extension,
            responseType: "blob",
            key: key,
            url: url,
            xhrSettings: xhrSettings,
            config: frameConfig
          };
          File.call(this, loader, fileConfig);
          if (normalMapURL) {
            var normalMap = new ImageFile2(loader, this.key, normalMapURL, xhrSettings, frameConfig);
            normalMap.type = "normalMap";
            this.setLink(normalMap);
            loader.addFile(normalMap);
          }
          this.useImageElementLoad = loader.imageLoadType === "HTMLImageElement";
          if (this.useImageElementLoad) {
            this.load = this.loadImage;
            this.onProcess = this.onProcessImage;
          }
        },
        onProcess: function() {
          this.state = CONST.FILE_PROCESSING;
          this.data = new Image();
          this.data.crossOrigin = this.crossOrigin;
          var _this = this;
          this.data.onload = function() {
            File.revokeObjectURL(_this.data);
            _this.onProcessComplete();
          };
          this.data.onerror = function() {
            File.revokeObjectURL(_this.data);
            _this.onProcessError();
          };
          File.createObjectURL(this.data, this.xhrLoader.response, "image/png");
        },
        onProcessImage: function() {
          var result = this.state;
          this.state = CONST.FILE_PROCESSING;
          if (result === CONST.FILE_LOADED) {
            this.onProcessComplete();
          } else {
            this.onProcessError();
          }
        },
        loadImage: function() {
          this.state = CONST.FILE_LOADING;
          this.src = GetURL(this, this.loader.baseURL);
          if (this.src.indexOf("data:") === 0) {
            console.warn("Local data URIs are not supported: " + this.key);
          } else {
            this.data = new Image();
            this.data.crossOrigin = this.crossOrigin;
            var _this = this;
            this.data.onload = function() {
              _this.state = CONST.FILE_LOADED;
              _this.loader.nextFile(_this, true);
            };
            this.data.onerror = function() {
              _this.loader.nextFile(_this, false);
            };
            this.data.src = this.src;
          }
        },
        addToCache: function() {
          var linkFile = this.linkFile;
          if (linkFile) {
            if (linkFile.state >= CONST.FILE_COMPLETE) {
              if (this.type === "normalMap") {
                this.cache.addImage(this.key, linkFile.data, this.data);
              } else {
                this.cache.addImage(this.key, this.data, linkFile.data);
              }
            }
          } else {
            this.cache.addImage(this.key, this.data);
          }
        }
      });
      FileTypesManager.register("image", function(key, url, xhrSettings) {
        if (Array.isArray(key)) {
          for (var i = 0; i < key.length; i++) {
            this.addFile(new ImageFile(this, key[i]));
          }
        } else {
          this.addFile(new ImageFile(this, key, url, xhrSettings));
        }
        return this;
      });
      module.exports = ImageFile;
    }
  });

  // ../../node_modules/phaser/src/loader/filetypes/JSONFile.js
  var require_JSONFile = __commonJS({
    "../../node_modules/phaser/src/loader/filetypes/JSONFile.js": function(exports, module) {
      var Class = require_Class();
      var CONST = require_const11();
      var File = require_File();
      var FileTypesManager = require_FileTypesManager();
      var GetFastValue = require_GetFastValue();
      var GetValue = require_GetValue();
      var IsPlainObject = require_IsPlainObject();
      var JSONFile = new Class({
        Extends: File,
        initialize: function JSONFile2(loader, key, url, xhrSettings, dataKey) {
          var extension = "json";
          if (IsPlainObject(key)) {
            var config = key;
            key = GetFastValue(config, "key");
            url = GetFastValue(config, "url");
            xhrSettings = GetFastValue(config, "xhrSettings");
            extension = GetFastValue(config, "extension", extension);
            dataKey = GetFastValue(config, "dataKey", dataKey);
          }
          var fileConfig = {
            type: "json",
            cache: loader.cacheManager.json,
            extension: extension,
            responseType: "text",
            key: key,
            url: url,
            xhrSettings: xhrSettings,
            config: dataKey
          };
          File.call(this, loader, fileConfig);
          if (IsPlainObject(url)) {
            if (dataKey) {
              this.data = GetValue(url, dataKey);
            } else {
              this.data = url;
            }
            this.state = CONST.FILE_POPULATED;
          }
        },
        onProcess: function() {
          if (this.state !== CONST.FILE_POPULATED) {
            this.state = CONST.FILE_PROCESSING;
            try {
              var json = JSON.parse(this.xhrLoader.responseText);
            } catch (e) {
              this.onProcessError();
              throw e;
            }
            var key = this.config;
            if (typeof key === "string") {
              this.data = GetValue(json, key, json);
            } else {
              this.data = json;
            }
          }
          this.onProcessComplete();
        }
      });
      FileTypesManager.register("json", function(key, url, dataKey, xhrSettings) {
        if (Array.isArray(key)) {
          for (var i = 0; i < key.length; i++) {
            this.addFile(new JSONFile(this, key[i]));
          }
        } else {
          this.addFile(new JSONFile(this, key, url, xhrSettings, dataKey));
        }
        return this;
      });
      module.exports = JSONFile;
    }
  });

  // ../../node_modules/phaser/src/loader/MultiFile.js
  var require_MultiFile = __commonJS({
    "../../node_modules/phaser/src/loader/MultiFile.js": function(exports, module) {
      var Class = require_Class();
      var CONST = require_const11();
      var Events = require_events14();
      var MultiFile = new Class({
        initialize: function MultiFile2(loader, type, key, files) {
          var finalFiles = [];
          files.forEach(function(file) {
            if (file) {
              finalFiles.push(file);
            }
          });
          this.loader = loader;
          this.type = type;
          this.key = key;
          this.multiKeyIndex = loader.multiKeyIndex++;
          this.files = finalFiles;
          this.state = CONST.FILE_PENDING;
          this.complete = false;
          this.pending = finalFiles.length;
          this.failed = 0;
          this.config = {};
          this.baseURL = loader.baseURL;
          this.path = loader.path;
          this.prefix = loader.prefix;
          for (var i = 0; i < finalFiles.length; i++) {
            finalFiles[i].multiFile = this;
          }
        },
        isReadyToProcess: function() {
          return this.pending === 0 && this.failed === 0 && !this.complete;
        },
        addToMultiFile: function(file) {
          this.files.push(file);
          file.multiFile = this;
          this.pending++;
          this.complete = false;
          return this;
        },
        onFileComplete: function(file) {
          var index = this.files.indexOf(file);
          if (index !== -1) {
            this.pending--;
          }
        },
        onFileFailed: function(file) {
          var index = this.files.indexOf(file);
          if (index !== -1) {
            this.failed++;
            console.error('File failed: %s "%s" (via %s "%s")', this.type, this.key, file.type, file.key);
          }
        },
        pendingDestroy: function() {
          if (this.state === CONST.FILE_PENDING_DESTROY) {
            return;
          }
          var key = this.key;
          var type = this.type;
          this.loader.emit(Events.FILE_COMPLETE, key, type);
          this.loader.emit(Events.FILE_KEY_COMPLETE + type + "-" + key, key, type);
          this.loader.flagForRemoval(this);
          for (var i = 0; i < this.files.length; i++) {
            this.files[i].pendingDestroy();
          }
          this.state = CONST.FILE_PENDING_DESTROY;
        },
        destroy: function() {
          this.loader = null;
          this.files = null;
          this.config = null;
        }
      });
      module.exports = MultiFile;
    }
  });

  // ../../node_modules/phaser/src/loader/filetypes/AtlasJSONFile.js
  var require_AtlasJSONFile = __commonJS({
    "../../node_modules/phaser/src/loader/filetypes/AtlasJSONFile.js": function(exports, module) {
      var Class = require_Class();
      var FileTypesManager = require_FileTypesManager();
      var GetFastValue = require_GetFastValue();
      var ImageFile = require_ImageFile();
      var IsPlainObject = require_IsPlainObject();
      var JSONFile = require_JSONFile();
      var MultiFile = require_MultiFile();
      var AtlasJSONFile = new Class({
        Extends: MultiFile,
        initialize: function AtlasJSONFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
          var image;
          var data;
          if (IsPlainObject(key)) {
            var config = key;
            key = GetFastValue(config, "key");
            image = new ImageFile(loader, {
              key: key,
              url: GetFastValue(config, "textureURL"),
              extension: GetFastValue(config, "textureExtension", "png"),
              normalMap: GetFastValue(config, "normalMap"),
              xhrSettings: GetFastValue(config, "textureXhrSettings")
            });
            data = new JSONFile(loader, {
              key: key,
              url: GetFastValue(config, "atlasURL"),
              extension: GetFastValue(config, "atlasExtension", "json"),
              xhrSettings: GetFastValue(config, "atlasXhrSettings")
            });
          } else {
            image = new ImageFile(loader, key, textureURL, textureXhrSettings);
            data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);
          }
          if (image.linkFile) {
            MultiFile.call(this, loader, "atlasjson", key, [image, data, image.linkFile]);
          } else {
            MultiFile.call(this, loader, "atlasjson", key, [image, data]);
          }
        },
        addToCache: function() {
          if (this.isReadyToProcess()) {
            var image = this.files[0];
            var json = this.files[1];
            var normalMap = this.files[2] ? this.files[2].data : null;
            this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);
            this.complete = true;
          }
        }
      });
      FileTypesManager.register("atlas", function(key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
        var multifile;
        if (Array.isArray(key)) {
          for (var i = 0; i < key.length; i++) {
            multifile = new AtlasJSONFile(this, key[i]);
            this.addFile(multifile.files);
          }
        } else {
          multifile = new AtlasJSONFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
          this.addFile(multifile.files);
        }
        return this;
      });
      module.exports = AtlasJSONFile;
    }
  });

  // ../../node_modules/phaser/src/dom/ParseXML.js
  var require_ParseXML = __commonJS({
    "../../node_modules/phaser/src/dom/ParseXML.js": function(exports, module) {
      var ParseXML = function(data) {
        var xml = "";
        try {
          if (window["DOMParser"]) {
            var domparser = new DOMParser();
            xml = domparser.parseFromString(data, "text/xml");
          } else {
            xml = new ActiveXObject("Microsoft.XMLDOM");
            xml.loadXML(data);
          }
        } catch (e) {
          xml = null;
        }
        if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
          return null;
        } else {
          return xml;
        }
      };
      module.exports = ParseXML;
    }
  });

  // ../../node_modules/phaser/src/loader/filetypes/XMLFile.js
  var require_XMLFile = __commonJS({
    "../../node_modules/phaser/src/loader/filetypes/XMLFile.js": function(exports, module) {
      var Class = require_Class();
      var CONST = require_const11();
      var File = require_File();
      var FileTypesManager = require_FileTypesManager();
      var GetFastValue = require_GetFastValue();
      var IsPlainObject = require_IsPlainObject();
      var ParseXML = require_ParseXML();
      var XMLFile = new Class({
        Extends: File,
        initialize: function XMLFile2(loader, key, url, xhrSettings) {
          var extension = "xml";
          if (IsPlainObject(key)) {
            var config = key;
            key = GetFastValue(config, "key");
            url = GetFastValue(config, "url");
            xhrSettings = GetFastValue(config, "xhrSettings");
            extension = GetFastValue(config, "extension", extension);
          }
          var fileConfig = {
            type: "xml",
            cache: loader.cacheManager.xml,
            extension: extension,
            responseType: "text",
            key: key,
            url: url,
            xhrSettings: xhrSettings
          };
          File.call(this, loader, fileConfig);
        },
        onProcess: function() {
          this.state = CONST.FILE_PROCESSING;
          this.data = ParseXML(this.xhrLoader.responseText);
          if (this.data) {
            this.onProcessComplete();
          } else {
            this.onProcessError();
          }
        }
      });
      FileTypesManager.register("xml", function(key, url, xhrSettings) {
        if (Array.isArray(key)) {
          for (var i = 0; i < key.length; i++) {
            this.addFile(new XMLFile(this, key[i]));
          }
        } else {
          this.addFile(new XMLFile(this, key, url, xhrSettings));
        }
        return this;
      });
      module.exports = XMLFile;
    }
  });

  // ../../node_modules/phaser/src/loader/filetypes/BitmapFontFile.js
  var require_BitmapFontFile = __commonJS({
    "../../node_modules/phaser/src/loader/filetypes/BitmapFontFile.js": function(exports, module) {
      var Class = require_Class();
      var FileTypesManager = require_FileTypesManager();
      var GetFastValue = require_GetFastValue();
      var ImageFile = require_ImageFile();
      var IsPlainObject = require_IsPlainObject();
      var MultiFile = require_MultiFile();
      var ParseXMLBitmapFont = require_ParseXMLBitmapFont();
      var XMLFile = require_XMLFile();
      var BitmapFontFile = new Class({
        Extends: MultiFile,
        initialize: function BitmapFontFile2(loader, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings) {
          var image;
          var data;
          if (IsPlainObject(key)) {
            var config = key;
            key = GetFastValue(config, "key");
            image = new ImageFile(loader, {
              key: key,
              url: GetFastValue(config, "textureURL"),
              extension: GetFastValue(config, "textureExtension", "png"),
              normalMap: GetFastValue(config, "normalMap"),
              xhrSettings: GetFastValue(config, "textureXhrSettings")
            });
            data = new XMLFile(loader, {
              key: key,
              url: GetFastValue(config, "fontDataURL"),
              extension: GetFastValue(config, "fontDataExtension", "xml"),
              xhrSettings: GetFastValue(config, "fontDataXhrSettings")
            });
          } else {
            image = new ImageFile(loader, key, textureURL, textureXhrSettings);
            data = new XMLFile(loader, key, fontDataURL, fontDataXhrSettings);
          }
          if (image.linkFile) {
            MultiFile.call(this, loader, "bitmapfont", key, [image, data, image.linkFile]);
          } else {
            MultiFile.call(this, loader, "bitmapfont", key, [image, data]);
          }
        },
        addToCache: function() {
          if (this.isReadyToProcess()) {
            var image = this.files[0];
            var xml = this.files[1];
            image.addToCache();
            var texture = image.cache.get(image.key);
            var data = ParseXMLBitmapFont(xml.data, image.cache.getFrame(image.key), 0, 0, texture);
            this.loader.cacheManager.bitmapFont.add(image.key, { data: data, texture: image.key, frame: null });
            this.complete = true;
          }
        }
      });
      FileTypesManager.register("bitmapFont", function(key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings) {
        var multifile;
        if (Array.isArray(key)) {
          for (var i = 0; i < key.length; i++) {
            multifile = new BitmapFontFile(this, key[i]);
            this.addFile(multifile.files);
          }
        } else {
          multifile = new BitmapFontFile(this, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings);
          this.addFile(multifile.files);
        }
        return this;
      });
      module.exports = BitmapFontFile;
    }
  });

  // ../../node_modules/phaser/src/loader/filetypes/CSSFile.js
  var require_CSSFile = __commonJS({
    "../../node_modules/phaser/src/loader/filetypes/CSSFile.js": function(exports, module) {
      var Class = require_Class();
      var CONST = require_const11();
      var File = require_File();
      var FileTypesManager = require_FileTypesManager();
      var GetFastValue = require_GetFastValue();
      var IsPlainObject = require_IsPlainObject();
      var CSSFile = new Class({
        Extends: File,
        initialize: function CSSFile2(loader, key, url, xhrSettings) {
          var extension = "css";
          if (IsPlainObject(key)) {
            var config = key;
            key = GetFastValue(config, "key");
            url = GetFastValue(config, "url");
            xhrSettings = GetFastValue(config, "xhrSettings");
            extension = GetFastValue(config, "extension", extension);
          }
          var fileConfig = {
            type: "script",
            cache: false,
            extension: extension,
            responseType: "text",
            key: key,
            url: url,
            xhrSettings: xhrSettings
          };
          File.call(this, loader, fileConfig);
        },
        onProcess: function() {
          this.state = CONST.FILE_PROCESSING;
          this.data = document.createElement("style");
          this.data.defer = false;
          this.data.innerHTML = this.xhrLoader.responseText;
          document.head.appendChild(this.data);
          this.onProcessComplete();
        }
      });
      FileTypesManager.register("css", function(key, url, xhrSettings) {
        if (Array.isArray(key)) {
          for (var i = 0; i < key.length; i++) {
            this.addFile(new CSSFile(this, key[i]));
          }
        } else {
          this.addFile(new CSSFile(this, key, url, xhrSettings));
        }
        return this;
      });
      module.exports = CSSFile;
    }
  });

  // ../../node_modules/phaser/src/loader/filetypes/ScriptFile.js
  var require_ScriptFile = __commonJS({
    "../../node_modules/phaser/src/loader/filetypes/ScriptFile.js": function(exports, module) {
      var Class = require_Class();
      var CONST = require_const11();
      var File = require_File();
      var FileTypesManager = require_FileTypesManager();
      var GetFastValue = require_GetFastValue();
      var IsPlainObject = require_IsPlainObject();
      var ScriptFile = new Class({
        Extends: File,
        initialize: function ScriptFile2(loader, key, url, type, xhrSettings) {
          var extension = "js";
          if (IsPlainObject(key)) {
            var config = key;
            key = GetFastValue(config, "key");
            url = GetFastValue(config, "url");
            type = GetFastValue(config, "type", "script");
            xhrSettings = GetFastValue(config, "xhrSettings");
            extension = GetFastValue(config, "extension", extension);
          } else if (type === void 0) {
            type = "script";
          }
          var fileConfig = {
            type: type,
            cache: false,
            extension: extension,
            responseType: "text",
            key: key,
            url: url,
            xhrSettings: xhrSettings
          };
          File.call(this, loader, fileConfig);
        },
        onProcess: function() {
          this.state = CONST.FILE_PROCESSING;
          this.data = document.createElement("script");
          this.data.language = "javascript";
          this.data.type = "text/javascript";
          this.data.defer = false;
          this.data.text = this.xhrLoader.responseText;
          document.head.appendChild(this.data);
          this.onProcessComplete();
        }
      });
      FileTypesManager.register("script", function(key, url, type, xhrSettings) {
        if (Array.isArray(key)) {
          for (var i = 0; i < key.length; i++) {
            this.addFile(new ScriptFile(this, key[i]));
          }
        } else {
          this.addFile(new ScriptFile(this, key, url, type, xhrSettings));
        }
        return this;
      });
      module.exports = ScriptFile;
    }
  });

  // ../../node_modules/phaser/src/loader/LoaderPlugin.js
  var require_LoaderPlugin = __commonJS({
    "../../node_modules/phaser/src/loader/LoaderPlugin.js": function(exports, module) {
      var Class = require_Class();
      var CONST = require_const11();
      var CustomSet = require_Set();
      var EventEmitter = require_eventemitter3();
      var Events = require_events14();
      var FileTypesManager = require_FileTypesManager();
      var GetFastValue = require_GetFastValue();
      var GetValue = require_GetValue();
      var PluginCache = require_PluginCache();
      var SceneEvents = require_events();
      var XHRSettings = require_XHRSettings();
      var LoaderPlugin = new Class({
        Extends: EventEmitter,
        initialize: function LoaderPlugin2(scene) {
          EventEmitter.call(this);
          var gameConfig = scene.sys.game.config;
          var sceneConfig = scene.sys.settings.loader;
          this.scene = scene;
          this.systems = scene.sys;
          this.cacheManager = scene.sys.cache;
          this.textureManager = scene.sys.textures;
          this.sceneManager = scene.sys.game.scene;
          FileTypesManager.install(this);
          this.prefix = "";
          this.path = "";
          this.baseURL = "";
          this.setBaseURL(GetFastValue(sceneConfig, "baseURL", gameConfig.loaderBaseURL));
          this.setPath(GetFastValue(sceneConfig, "path", gameConfig.loaderPath));
          this.setPrefix(GetFastValue(sceneConfig, "prefix", gameConfig.loaderPrefix));
          this.maxParallelDownloads = GetFastValue(sceneConfig, "maxParallelDownloads", gameConfig.loaderMaxParallelDownloads);
          this.xhr = XHRSettings(GetFastValue(sceneConfig, "responseType", gameConfig.loaderResponseType), GetFastValue(sceneConfig, "async", gameConfig.loaderAsync), GetFastValue(sceneConfig, "user", gameConfig.loaderUser), GetFastValue(sceneConfig, "password", gameConfig.loaderPassword), GetFastValue(sceneConfig, "timeout", gameConfig.loaderTimeout), GetFastValue(sceneConfig, "withCredentials", gameConfig.loaderWithCredentials));
          this.crossOrigin = GetFastValue(sceneConfig, "crossOrigin", gameConfig.loaderCrossOrigin);
          this.imageLoadType = GetFastValue(sceneConfig, "imageLoadType", gameConfig.loaderImageLoadType);
          this.localSchemes = GetFastValue(sceneConfig, "localScheme", gameConfig.loaderLocalScheme);
          this.totalToLoad = 0;
          this.progress = 0;
          this.list = new CustomSet();
          this.inflight = new CustomSet();
          this.queue = new CustomSet();
          this._deleteQueue = new CustomSet();
          this.totalFailed = 0;
          this.totalComplete = 0;
          this.state = CONST.LOADER_IDLE;
          this.multiKeyIndex = 0;
          scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
          scene.sys.events.on(SceneEvents.START, this.pluginStart, this);
        },
        boot: function() {
          this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
        },
        pluginStart: function() {
          this.systems.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        setBaseURL: function(url) {
          if (url === void 0) {
            url = "";
          }
          if (url !== "" && url.substr(-1) !== "/") {
            url = url.concat("/");
          }
          this.baseURL = url;
          return this;
        },
        setPath: function(path) {
          if (path === void 0) {
            path = "";
          }
          if (path !== "" && path.substr(-1) !== "/") {
            path = path.concat("/");
          }
          this.path = path;
          return this;
        },
        setPrefix: function(prefix) {
          if (prefix === void 0) {
            prefix = "";
          }
          this.prefix = prefix;
          return this;
        },
        setCORS: function(crossOrigin) {
          this.crossOrigin = crossOrigin;
          return this;
        },
        addFile: function(file) {
          if (!Array.isArray(file)) {
            file = [file];
          }
          for (var i = 0; i < file.length; i++) {
            var item = file[i];
            if (!this.keyExists(item)) {
              this.list.set(item);
              this.emit(Events.ADD, item.key, item.type, this, item);
              if (this.isLoading()) {
                this.totalToLoad++;
                this.updateProgress();
              }
            }
          }
        },
        keyExists: function(file) {
          var keyConflict = file.hasCacheConflict();
          if (!keyConflict) {
            this.list.iterate(function(item) {
              if (item.type === file.type && item.key === file.key) {
                keyConflict = true;
                return false;
              }
            });
          }
          if (!keyConflict && this.isLoading()) {
            this.inflight.iterate(function(item) {
              if (item.type === file.type && item.key === file.key) {
                keyConflict = true;
                return false;
              }
            });
            this.queue.iterate(function(item) {
              if (item.type === file.type && item.key === file.key) {
                keyConflict = true;
                return false;
              }
            });
          }
          return keyConflict;
        },
        addPack: function(pack, packKey) {
          if (typeof packKey === "string") {
            var subPack = GetValue(pack, packKey);
            if (subPack) {
              pack = { packKey: subPack };
            }
          }
          var total = 0;
          var currentBaseURL = this.baseURL;
          var currentPath = this.path;
          var currentPrefix = this.prefix;
          for (var key in pack) {
            if (!Object.prototype.hasOwnProperty.call(pack, key)) {
              continue;
            }
            var config = pack[key];
            var baseURL = GetFastValue(config, "baseURL", currentBaseURL);
            var path = GetFastValue(config, "path", currentPath);
            var prefix = GetFastValue(config, "prefix", currentPrefix);
            var files = GetFastValue(config, "files", null);
            var defaultType = GetFastValue(config, "defaultType", "void");
            if (Array.isArray(files)) {
              this.setBaseURL(baseURL);
              this.setPath(path);
              this.setPrefix(prefix);
              for (var i = 0; i < files.length; i++) {
                var file = files[i];
                var type = file.hasOwnProperty("type") ? file.type : defaultType;
                if (this[type]) {
                  this[type](file);
                  total++;
                }
              }
            }
          }
          this.setBaseURL(currentBaseURL);
          this.setPath(currentPath);
          this.setPrefix(currentPrefix);
          return total > 0;
        },
        isLoading: function() {
          return this.state === CONST.LOADER_LOADING || this.state === CONST.LOADER_PROCESSING;
        },
        isReady: function() {
          return this.state === CONST.LOADER_IDLE || this.state === CONST.LOADER_COMPLETE;
        },
        start: function() {
          if (!this.isReady()) {
            return;
          }
          this.progress = 0;
          this.totalFailed = 0;
          this.totalComplete = 0;
          this.totalToLoad = this.list.size;
          this.emit(Events.START, this);
          if (this.list.size === 0) {
            this.loadComplete();
          } else {
            this.state = CONST.LOADER_LOADING;
            this.inflight.clear();
            this.queue.clear();
            this.updateProgress();
            this.checkLoadQueue();
            this.systems.events.on(SceneEvents.UPDATE, this.update, this);
          }
        },
        updateProgress: function() {
          this.progress = 1 - (this.list.size + this.inflight.size) / this.totalToLoad;
          this.emit(Events.PROGRESS, this.progress);
        },
        update: function() {
          if (this.state === CONST.LOADER_LOADING && this.list.size > 0 && this.inflight.size < this.maxParallelDownloads) {
            this.checkLoadQueue();
          }
        },
        checkLoadQueue: function() {
          this.list.each(function(file) {
            if (file.state === CONST.FILE_POPULATED || file.state === CONST.FILE_PENDING && this.inflight.size < this.maxParallelDownloads) {
              this.inflight.set(file);
              this.list.delete(file);
              if (!file.crossOrigin) {
                file.crossOrigin = this.crossOrigin;
              }
              file.load();
            }
            if (this.inflight.size === this.maxParallelDownloads) {
              return false;
            }
          }, this);
        },
        nextFile: function(file, success) {
          if (!this.inflight) {
            return;
          }
          this.inflight.delete(file);
          this.updateProgress();
          if (success) {
            this.totalComplete++;
            this.queue.set(file);
            this.emit(Events.FILE_LOAD, file);
            file.onProcess();
          } else {
            this.totalFailed++;
            this._deleteQueue.set(file);
            this.emit(Events.FILE_LOAD_ERROR, file);
            this.fileProcessComplete(file);
          }
        },
        fileProcessComplete: function(file) {
          if (!this.scene || !this.systems || !this.systems.game || this.systems.game.pendingDestroy) {
            return;
          }
          if (file.state === CONST.FILE_ERRORED) {
            if (file.multiFile) {
              file.multiFile.onFileFailed(file);
            }
          } else if (file.state === CONST.FILE_COMPLETE) {
            if (file.multiFile) {
              if (file.multiFile.isReadyToProcess()) {
                file.multiFile.addToCache();
                file.multiFile.pendingDestroy();
              }
            } else {
              file.addToCache();
              file.pendingDestroy();
            }
          }
          this.queue.delete(file);
          if (this.list.size === 0 && this.inflight.size === 0 && this.queue.size === 0) {
            this.loadComplete();
          }
        },
        loadComplete: function() {
          this.emit(Events.POST_PROCESS, this);
          this.list.clear();
          this.inflight.clear();
          this.queue.clear();
          this.progress = 1;
          this.state = CONST.LOADER_COMPLETE;
          this.systems.events.off(SceneEvents.UPDATE, this.update, this);
          this._deleteQueue.iterateLocal("destroy");
          this._deleteQueue.clear();
          this.emit(Events.COMPLETE, this, this.totalComplete, this.totalFailed);
        },
        flagForRemoval: function(file) {
          this._deleteQueue.set(file);
        },
        saveJSON: function(data, filename) {
          return this.save(JSON.stringify(data), filename);
        },
        save: function(data, filename, filetype) {
          if (filename === void 0) {
            filename = "file.json";
          }
          if (filetype === void 0) {
            filetype = "application/json";
          }
          var blob = new Blob([data], { type: filetype });
          var url = URL.createObjectURL(blob);
          var a = document.createElement("a");
          a.download = filename;
          a.textContent = "Download " + filename;
          a.href = url;
          a.click();
          return this;
        },
        reset: function() {
          this.list.clear();
          this.inflight.clear();
          this.queue.clear();
          var gameConfig = this.systems.game.config;
          var sceneConfig = this.systems.settings.loader;
          this.setBaseURL(GetFastValue(sceneConfig, "baseURL", gameConfig.loaderBaseURL));
          this.setPath(GetFastValue(sceneConfig, "path", gameConfig.loaderPath));
          this.setPrefix(GetFastValue(sceneConfig, "prefix", gameConfig.loaderPrefix));
          this.state = CONST.LOADER_IDLE;
        },
        shutdown: function() {
          this.reset();
          this.state = CONST.LOADER_SHUTDOWN;
          this.systems.events.off(SceneEvents.UPDATE, this.update, this);
          this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        destroy: function() {
          this.shutdown();
          this.state = CONST.LOADER_DESTROYED;
          this.systems.events.off(SceneEvents.UPDATE, this.update, this);
          this.systems.events.off(SceneEvents.START, this.pluginStart, this);
          this.list = null;
          this.inflight = null;
          this.queue = null;
          this.scene = null;
          this.systems = null;
          this.textureManager = null;
          this.cacheManager = null;
          this.sceneManager = null;
        }
      });
      PluginCache.register("Loader", LoaderPlugin, "load");
      module.exports = LoaderPlugin;
    }
  });

  // ../../node_modules/phaser/src/plugins/BasePlugin.js
  var require_BasePlugin = __commonJS({
    "../../node_modules/phaser/src/plugins/BasePlugin.js": function(exports, module) {
      var Class = require_Class();
      var BasePlugin = new Class({
        initialize: function BasePlugin2(pluginManager) {
          this.pluginManager = pluginManager;
          this.game = pluginManager.game;
        },
        init: function() {
        },
        start: function() {
        },
        stop: function() {
        },
        destroy: function() {
          this.pluginManager = null;
          this.game = null;
          this.scene = null;
          this.systems = null;
        }
      });
      module.exports = BasePlugin;
    }
  });

  // ../../node_modules/phaser/src/plugins/ScenePlugin.js
  var require_ScenePlugin = __commonJS({
    "../../node_modules/phaser/src/plugins/ScenePlugin.js": function(exports, module) {
      var BasePlugin = require_BasePlugin();
      var Class = require_Class();
      var SceneEvents = require_events();
      var ScenePlugin = new Class({
        Extends: BasePlugin,
        initialize: function ScenePlugin2(scene, pluginManager, pluginKey) {
          BasePlugin.call(this, pluginManager);
          this.scene = scene;
          this.systems = scene.sys;
          this.pluginKey = pluginKey;
          scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
        },
        boot: function() {
        },
        destroy: function() {
          this.pluginManager = null;
          this.game = null;
          this.scene = null;
          this.systems = null;
        }
      });
      module.exports = ScenePlugin;
    }
  });

  // ../../node_modules/phaser/src/plugins/index.js
  var require_plugins = __commonJS({
    "../../node_modules/phaser/src/plugins/index.js": function(exports, module) {
      module.exports = {
        BasePlugin: require_BasePlugin(),
        DefaultPlugins: require_DefaultPlugins(),
        PluginCache: require_PluginCache(),
        PluginManager: require_PluginManager(),
        ScenePlugin: require_ScenePlugin()
      };
    }
  });

  // ../../node_modules/phaser/src/renderer/canvas/index.js
  var require_canvas2 = __commonJS({
    "../../node_modules/phaser/src/renderer/canvas/index.js": function(exports, module) {
      module.exports = {
        CanvasRenderer: require_CanvasRenderer(),
        GetBlendModes: require_GetBlendModes(),
        SetTransform: require_SetTransform()
      };
    }
  });

  // ../../node_modules/phaser/src/renderer/snapshot/index.js
  var require_snapshot = __commonJS({
    "../../node_modules/phaser/src/renderer/snapshot/index.js": function(exports, module) {
      module.exports = {
        Canvas: require_CanvasSnapshot(),
        WebGL: require_WebGLSnapshot()
      };
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/shaders/PostFX-frag.js
  var require_PostFX_frag = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/shaders/PostFX-frag.js": function(exports, module) {
      module.exports = [
        "#define SHADER_NAME PHASER_POSTFX_FS",
        "",
        "precision mediump float;",
        "",
        "uniform sampler2D uMainSampler;",
        "",
        "varying vec2 outTexCoord;",
        "",
        "void main ()",
        "{",
        "    gl_FragColor = texture2D(uMainSampler, outTexCoord);",
        "}",
        ""
      ].join("\n");
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/PostFXPipeline.js
  var require_PostFXPipeline = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/PostFXPipeline.js": function(exports, module) {
      var Class = require_Class();
      var ColorMatrix = require_ColorMatrix();
      var GetFastValue = require_GetFastValue();
      var ShaderSourceFS = require_PostFX_frag();
      var ShaderSourceVS = require_Quad_vert();
      var WebGLPipeline = require_WebGLPipeline();
      var PostFXPipeline = new Class({
        Extends: WebGLPipeline,
        initialize: function PostFXPipeline2(config) {
          config.renderTarget = GetFastValue(config, "renderTarget", 1);
          config.fragShader = GetFastValue(config, "fragShader", ShaderSourceFS);
          config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS);
          config.attributes = GetFastValue(config, "attributes", [
            {
              name: "inPosition",
              size: 2
            },
            {
              name: "inTexCoord",
              size: 2
            }
          ]);
          config.batchSize = 1;
          config.vertices = [
            -1,
            -1,
            0,
            0,
            -1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            -1,
            -1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            -1,
            1,
            0
          ];
          WebGLPipeline.call(this, config);
          this.isPostFX = true;
          this.gameObject;
          this.colorMatrix = new ColorMatrix();
          this.fullFrame1;
          this.fullFrame2;
          this.halfFrame1;
          this.halfFrame2;
          if (this.renderer.isBooted) {
            this.manager = this.renderer.pipelines;
            this.boot();
          }
        },
        boot: function() {
          WebGLPipeline.prototype.boot.call(this);
          var utility = this.manager.UTILITY_PIPELINE;
          this.fullFrame1 = utility.fullFrame1;
          this.fullFrame2 = utility.fullFrame2;
          this.halfFrame1 = utility.halfFrame1;
          this.halfFrame2 = utility.halfFrame2;
          this.set1i("uMainSampler", 0);
        },
        onDraw: function(renderTarget) {
          this.bindAndDraw(renderTarget);
        },
        copyFrame: function(source, target, brightness, clear, clearAlpha) {
          this.manager.copyFrame(source, target, brightness, clear, clearAlpha);
        },
        copyToGame: function(source) {
          this.manager.copyToGame(source);
        },
        drawFrame: function(source, target, clearAlpha) {
          this.manager.drawFrame(source, target, clearAlpha, this.colorMatrix);
        },
        blendFrames: function(source1, source2, target, strength, clearAlpha) {
          this.manager.blendFrames(source1, source2, target, strength, clearAlpha);
        },
        blendFramesAdditive: function(source1, source2, target, strength, clearAlpha) {
          this.manager.blendFramesAdditive(source1, source2, target, strength, clearAlpha);
        },
        clearFrame: function(target, clearAlpha) {
          this.manager.clearFrame(target, clearAlpha);
        },
        blitFrame: function(source, target, brightness, clear, clearAlpha, eraseMode) {
          this.manager.blitFrame(source, target, brightness, clear, clearAlpha, eraseMode);
        },
        copyFrameRect: function(source, target, x, y, width, height, clear, clearAlpha) {
          this.manager.copyFrameRect(source, target, x, y, width, height, clear, clearAlpha);
        },
        bindAndDraw: function(source, target, clear, clearAlpha, currentShader) {
          if (clear === void 0) {
            clear = true;
          }
          if (clearAlpha === void 0) {
            clearAlpha = true;
          }
          var gl = this.gl;
          var renderer = this.renderer;
          this.bind(currentShader);
          this.set1i("uMainSampler", 0);
          if (target) {
            gl.viewport(0, 0, target.width, target.height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
            if (clear) {
              if (clearAlpha) {
                gl.clearColor(0, 0, 0, 0);
              } else {
                gl.clearColor(0, 0, 0, 1);
              }
              gl.clear(gl.COLOR_BUFFER_BIT);
            }
          } else {
            renderer.popFramebuffer(false, false, false);
            if (!renderer.currentFramebuffer) {
              gl.viewport(0, 0, renderer.width, renderer.height);
            }
          }
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, source.texture);
          gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
          gl.drawArrays(gl.TRIANGLES, 0, 6);
          if (target) {
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          }
        }
      });
      module.exports = PostFXPipeline;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/SpriteFXPipeline.js
  var require_SpriteFXPipeline = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/SpriteFXPipeline.js": function(exports, module) {
      var BlendModes = require_BlendModes();
      var CenterOn = require_CenterOn2();
      var Class = require_Class();
      var ColorMatrixFS = require_ColorMatrix_frag();
      var GetFastValue = require_GetFastValue();
      var MultiPipeline = require_MultiPipeline();
      var PostFXFS = require_PostFX_frag();
      var Rectangle = require_Rectangle();
      var RenderTarget = require_RenderTarget();
      var SingleQuadFS = require_Single_frag();
      var SingleQuadVS = require_Single_vert();
      var WebGLPipeline = require_WebGLPipeline();
      var SpriteFXPipeline = new Class({
        Extends: MultiPipeline,
        initialize: function SpriteFXPipeline2(config) {
          var fragShader = GetFastValue(config, "fragShader", PostFXFS);
          var vertShader = GetFastValue(config, "vertShader", SingleQuadVS);
          var drawShader = GetFastValue(config, "drawShader", PostFXFS);
          var defaultShaders = [
            {
              name: "DrawSprite",
              fragShader: SingleQuadFS,
              vertShader: SingleQuadVS
            },
            {
              name: "CopySprite",
              fragShader: fragShader,
              vertShader: vertShader
            },
            {
              name: "DrawGame",
              fragShader: drawShader,
              vertShader: SingleQuadVS
            },
            {
              name: "ColorMatrix",
              fragShader: ColorMatrixFS
            }
          ];
          var configShaders = GetFastValue(config, "shaders", []);
          config.shaders = defaultShaders.concat(configShaders);
          if (!config.vertShader) {
            config.vertShader = vertShader;
          }
          config.batchSize = 1;
          MultiPipeline.call(this, config);
          this.isSpriteFX = true;
          this.customMainSampler = null;
          this.drawSpriteShader;
          this.copyShader;
          this.gameShader;
          this.colorMatrixShader;
          this.quadVertexData;
          this.quadVertexBuffer;
          this.quadVertexViewF32;
          this.spriteBounds = new Rectangle();
          this.targetBounds = new Rectangle();
          this.fsTarget;
          this.tempSprite;
          if (this.renderer.isBooted) {
            this.manager = this.renderer.pipelines;
            this.boot();
          }
        },
        boot: function() {
          WebGLPipeline.prototype.boot.call(this);
          var shaders = this.shaders;
          var renderer = this.renderer;
          this.drawSpriteShader = shaders[0];
          this.copyShader = shaders[1];
          this.gameShader = shaders[2];
          this.colorMatrixShader = shaders[3];
          this.fsTarget = new RenderTarget(renderer, renderer.width, renderer.height, 1, 0, true, true);
          this.renderTargets = this.manager.renderTargets.concat(this.fsTarget);
          var data = new ArrayBuffer(168);
          this.quadVertexData = data;
          this.quadVertexViewF32 = new Float32Array(data);
          this.quadVertexBuffer = renderer.createVertexBuffer(data, this.gl.STATIC_DRAW);
          this.onResize(renderer.width, renderer.height);
          this.currentShader = this.copyShader;
        },
        onResize: function(width, height) {
          var vertexViewF32 = this.quadVertexViewF32;
          vertexViewF32[1] = height;
          vertexViewF32[22] = height;
          vertexViewF32[14] = width;
          vertexViewF32[28] = width;
          vertexViewF32[35] = width;
          vertexViewF32[36] = height;
        },
        batchQuad: function(gameObject, x0, y0, x1, y1, x2, y2, x3, y3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture) {
          var bx = Math.min(x0, x1, x2, x3);
          var by = Math.min(y0, y1, y2, y3);
          var br = Math.max(x0, x1, x2, x3);
          var bb = Math.max(y0, y1, y2, y3);
          var bw = br - bx;
          var bh = bb - by;
          var bounds = this.spriteBounds.setTo(bx, by, bw, bh);
          var padding = gameObject ? gameObject.fxPadding : 0;
          var width = bw + padding * 2;
          var height = bh + padding * 2;
          var maxDimension = Math.abs(Math.max(width, height));
          var target = this.manager.getRenderTarget(maxDimension);
          var targetBounds = this.targetBounds.setTo(0, 0, target.width, target.height);
          CenterOn(targetBounds, bounds.centerX, bounds.centerY);
          this.tempSprite = gameObject;
          var gl = this.gl;
          var renderer = this.renderer;
          this.setShader(this.drawSpriteShader);
          this.set1i("uMainSampler", 0);
          this.flipProjectionMatrix(true);
          if (gameObject) {
            this.onDrawSprite(gameObject, target);
            gameObject.onFX(this);
          }
          var fsTarget = this.fsTarget;
          this.flush();
          gl.viewport(0, 0, renderer.width, renderer.height);
          gl.bindFramebuffer(gl.FRAMEBUFFER, fsTarget.framebuffer);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fsTarget.texture, 0);
          gl.clearColor(0, 0, 0, 0);
          gl.clear(gl.COLOR_BUFFER_BIT);
          this.setTexture2D(texture);
          this.batchVert(x0, y0, u0, v0, 0, tintEffect, tintTL);
          this.batchVert(x1, y1, u0, v1, 0, tintEffect, tintBL);
          this.batchVert(x2, y2, u1, v1, 0, tintEffect, tintBR);
          this.batchVert(x0, y0, u0, v0, 0, tintEffect, tintTL);
          this.batchVert(x2, y2, u1, v1, 0, tintEffect, tintBR);
          this.batchVert(x3, y3, u1, v0, 0, tintEffect, tintTR);
          this.flush();
          this.flipProjectionMatrix(false);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, target.texture);
          gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, targetBounds.x, targetBounds.y, targetBounds.width, targetBounds.height);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.bindTexture(gl.TEXTURE_2D, null);
          this.onBatch(gameObject);
          this.currentShader = this.copyShader;
          this.onDraw(target, this.manager.getSwapRenderTarget(), this.manager.getAltSwapRenderTarget());
          return true;
        },
        onDrawSprite: function() {
        },
        onCopySprite: function() {
        },
        copySprite: function(source, target, clear, clearAlpha, eraseMode, colorMatrix, shader) {
          if (clear === void 0) {
            clear = true;
          }
          if (clearAlpha === void 0) {
            clearAlpha = true;
          }
          if (eraseMode === void 0) {
            eraseMode = false;
          }
          if (shader === void 0) {
            shader = this.copyShader;
          }
          var gl = this.gl;
          var sprite = this.tempSprite;
          if (colorMatrix) {
            shader = this.colorMatrixShader;
          }
          this.currentShader = shader;
          var wasBound = this.setVertexBuffer(this.quadVertexBuffer);
          shader.bind(wasBound, false);
          this.set1i("uMainSampler", 0);
          sprite.onFXCopy(this);
          this.onCopySprite(source, target, sprite);
          if (colorMatrix) {
            this.set1fv("uColorMatrix", colorMatrix.getData());
            this.set1f("uAlpha", colorMatrix.alpha);
          }
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, source.texture);
          if (source.height > target.height) {
            gl.viewport(0, 0, source.width, source.height);
            this.setTargetUVs(source, target);
          } else {
            var diff = target.height - source.height;
            gl.viewport(0, diff, source.width, source.height);
            this.resetUVs();
          }
          gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
          if (clear) {
            gl.clearColor(0, 0, 0, Number(!clearAlpha));
            gl.clear(gl.COLOR_BUFFER_BIT);
          }
          if (eraseMode) {
            var blendMode = this.renderer.currentBlendMode;
            this.renderer.setBlendMode(BlendModes.ERASE);
          }
          gl.bufferData(gl.ARRAY_BUFFER, this.quadVertexData, gl.STATIC_DRAW);
          gl.drawArrays(gl.TRIANGLES, 0, 6);
          if (eraseMode) {
            this.renderer.setBlendMode(blendMode);
          }
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        },
        blendFrames: function(source1, source2, target, strength, clearAlpha) {
          this.manager.blendFrames(source1, source2, target, strength, clearAlpha);
        },
        blendFramesAdditive: function(source1, source2, target, strength, clearAlpha) {
          this.manager.blendFramesAdditive(source1, source2, target, strength, clearAlpha);
        },
        drawToGame: function(source) {
          this.currentShader = null;
          this.setShader(this.copyShader);
          this.bindAndDraw(source);
        },
        copyToGame: function(source) {
          this.currentShader = null;
          this.setShader(this.gameShader);
          this.bindAndDraw(source);
        },
        bindAndDraw: function(source) {
          var gl = this.gl;
          var renderer = this.renderer;
          this.set1i("uMainSampler", 0);
          renderer.popFramebuffer(false, false, false);
          if (!renderer.currentFramebuffer) {
            gl.viewport(0, 0, renderer.width, renderer.height);
          }
          if (this.customMainSampler) {
            this.setTexture2D(this.customMainSampler);
          } else {
            this.setTexture2D(source.texture);
          }
          var matrix = this._tempMatrix1.loadIdentity();
          var x = this.targetBounds.x;
          var y = this.targetBounds.y;
          var xw = x + source.width;
          var yh = y + source.height;
          var x0 = matrix.getX(x, y);
          var x1 = matrix.getX(x, yh);
          var x2 = matrix.getX(xw, yh);
          var x3 = matrix.getX(xw, y);
          var y0 = matrix.getY(x, y);
          var y1 = matrix.getY(x, yh);
          var y2 = matrix.getY(xw, yh);
          var y3 = matrix.getY(xw, y);
          this.batchVert(x0, y0, 0, 0, 0, 0, 16777215);
          this.batchVert(x1, y1, 0, 1, 0, 0, 16777215);
          this.batchVert(x2, y2, 1, 1, 0, 0, 16777215);
          this.batchVert(x0, y0, 0, 0, 0, 0, 16777215);
          this.batchVert(x2, y2, 1, 1, 0, 0, 16777215);
          this.batchVert(x3, y3, 1, 0, 0, 0, 16777215);
          this.flush();
          this.tempSprite = null;
        },
        onDraw: function(target) {
          this.drawToGame(target);
        },
        setUVs: function(uA, vA, uB, vB, uC, vC, uD, vD) {
          var vertexViewF32 = this.quadVertexViewF32;
          vertexViewF32[2] = uA;
          vertexViewF32[3] = vA;
          vertexViewF32[9] = uB;
          vertexViewF32[10] = vB;
          vertexViewF32[16] = uC;
          vertexViewF32[17] = vC;
          vertexViewF32[23] = uA;
          vertexViewF32[24] = vA;
          vertexViewF32[30] = uC;
          vertexViewF32[31] = vC;
          vertexViewF32[37] = uD;
          vertexViewF32[38] = vD;
        },
        setTargetUVs: function(source, target) {
          var diff = target.height / source.height;
          if (diff > 0.5) {
            diff = 0.5 - (diff - 0.5);
          } else {
            diff = 0.5 + (0.5 - diff);
          }
          this.setUVs(0, diff, 0, 1 + diff, 1, 1 + diff, 1, diff);
        },
        resetUVs: function() {
          this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);
        },
        destroy: function() {
          this.gl.deleteBuffer(this.quadVertexBuffer);
          this.drawSpriteShader = null;
          this.copyShader = null;
          this.gameShader = null;
          this.colorMatrixShader = null;
          this.quadVertexData = null;
          this.quadVertexBuffer = null;
          this.quadVertexViewF32 = null;
          this.fsTarget = null;
          this.tempSprite = null;
          MultiPipeline.prototype.destroy.call(this);
          return this;
        }
      });
      module.exports = SpriteFXPipeline;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/pipelines/index.js
  var require_pipelines = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/pipelines/index.js": function(exports, module) {
      var CONST = require_const6();
      var Extend = require_Extend();
      var Pipelines = {
        BitmapMaskPipeline: require_BitmapMaskPipeline(),
        Events: require_events10(),
        LightPipeline: require_LightPipeline(),
        MobilePipeline: require_MobilePipeline(),
        MultiPipeline: require_MultiPipeline(),
        PointLightPipeline: require_PointLightPipeline(),
        PostFXPipeline: require_PostFXPipeline(),
        RopePipeline: require_RopePipeline(),
        SinglePipeline: require_SinglePipeline(),
        SpriteFXPipeline: require_SpriteFXPipeline(),
        UtilityPipeline: require_UtilityPipeline()
      };
      Pipelines = Extend(false, Pipelines, CONST);
      module.exports = Pipelines;
    }
  });

  // ../../node_modules/phaser/src/renderer/webgl/index.js
  var require_webgl = __commonJS({
    "../../node_modules/phaser/src/renderer/webgl/index.js": function(exports, module) {
      var WEBGL_CONST = require_const7();
      var Extend = require_Extend();
      var WebGL = {
        PipelineManager: require_PipelineManager(),
        Pipelines: require_pipelines(),
        RenderTarget: require_RenderTarget(),
        Utils: require_Utils(),
        WebGLPipeline: require_WebGLPipeline(),
        WebGLRenderer: require_WebGLRenderer(),
        WebGLShader: require_WebGLShader()
      };
      WebGL = Extend(false, WebGL, WEBGL_CONST);
      module.exports = WebGL;
    }
  });

  // ../../node_modules/phaser/src/renderer/index.js
  var require_renderer = __commonJS({
    "../../node_modules/phaser/src/renderer/index.js": function(exports, module) {
      module.exports = {
        Canvas: require_canvas2(),
        Events: require_events8(),
        Snapshot: require_snapshot(),
        WebGL: require_webgl()
      };
    }
  });

  // ../../node_modules/phaser/src/scale/index.js
  var require_scale = __commonJS({
    "../../node_modules/phaser/src/scale/index.js": function(exports, module) {
      var Extend = require_Extend();
      var CONST = require_const9();
      var Scale = {
        Center: require_CENTER_CONST(),
        Events: require_events7(),
        Orientation: require_ORIENTATION_CONST(),
        ScaleManager: require_ScaleManager(),
        ScaleModes: require_SCALE_MODE_CONST(),
        Zoom: require_ZOOM_CONST()
      };
      Scale = Extend(false, Scale, CONST.CENTER);
      Scale = Extend(false, Scale, CONST.ORIENTATION);
      Scale = Extend(false, Scale, CONST.SCALE_MODE);
      Scale = Extend(false, Scale, CONST.ZOOM);
      module.exports = Scale;
    }
  });

  // ../../node_modules/phaser/src/scene/ScenePlugin.js
  var require_ScenePlugin2 = __commonJS({
    "../../node_modules/phaser/src/scene/ScenePlugin.js": function(exports, module) {
      var Clamp = require_Clamp();
      var Class = require_Class();
      var Events = require_events();
      var GetFastValue = require_GetFastValue();
      var PluginCache = require_PluginCache();
      var ScenePlugin = new Class({
        initialize: function ScenePlugin2(scene) {
          this.scene = scene;
          this.systems = scene.sys;
          this.settings = scene.sys.settings;
          this.key = scene.sys.settings.key;
          this.manager = scene.sys.game.scene;
          this.transitionProgress = 0;
          this._elapsed = 0;
          this._target = null;
          this._duration = 0;
          this._onUpdate;
          this._onUpdateScope;
          this._willSleep = false;
          this._willRemove = false;
          scene.sys.events.once(Events.BOOT, this.boot, this);
          scene.sys.events.on(Events.START, this.pluginStart, this);
        },
        boot: function() {
          this.systems.events.once(Events.DESTROY, this.destroy, this);
        },
        pluginStart: function() {
          this._target = null;
          this.systems.events.once(Events.SHUTDOWN, this.shutdown, this);
        },
        start: function(key, data) {
          if (key === void 0) {
            key = this.key;
          }
          this.manager.queueOp("stop", this.key);
          this.manager.queueOp("start", key, data);
          return this;
        },
        restart: function(data) {
          var key = this.key;
          this.manager.queueOp("stop", key);
          this.manager.queueOp("start", key, data);
          return this;
        },
        transition: function(config) {
          if (config === void 0) {
            config = {};
          }
          var key = GetFastValue(config, "target", false);
          var target = this.manager.getScene(key);
          if (!key || !this.checkValidTransition(target)) {
            return false;
          }
          var duration = GetFastValue(config, "duration", 1e3);
          this._elapsed = 0;
          this._target = target;
          this._duration = duration;
          this._willSleep = GetFastValue(config, "sleep", false);
          this._willRemove = GetFastValue(config, "remove", false);
          var callback = GetFastValue(config, "onUpdate", null);
          if (callback) {
            this._onUpdate = callback;
            this._onUpdateScope = GetFastValue(config, "onUpdateScope", this.scene);
          }
          var allowInput = GetFastValue(config, "allowInput", false);
          this.settings.transitionAllowInput = allowInput;
          var targetSettings = target.sys.settings;
          targetSettings.isTransition = true;
          targetSettings.transitionFrom = this.scene;
          targetSettings.transitionDuration = duration;
          targetSettings.transitionAllowInput = allowInput;
          if (GetFastValue(config, "moveAbove", false)) {
            this.manager.moveAbove(this.key, key);
          } else if (GetFastValue(config, "moveBelow", false)) {
            this.manager.moveBelow(this.key, key);
          }
          if (target.sys.isSleeping()) {
            target.sys.wake(GetFastValue(config, "data"));
          } else {
            this.manager.start(key, GetFastValue(config, "data"));
          }
          var onStartCallback = GetFastValue(config, "onStart", null);
          var onStartScope = GetFastValue(config, "onStartScope", this.scene);
          if (onStartCallback) {
            onStartCallback.call(onStartScope, this.scene, target, duration);
          }
          this.systems.events.emit(Events.TRANSITION_OUT, target, duration);
          return true;
        },
        checkValidTransition: function(target) {
          if (!target || target.sys.isActive() || target.sys.isTransitioning() || target === this.scene || this.systems.isTransitioning()) {
            return false;
          }
          return true;
        },
        step: function(time, delta) {
          this._elapsed += delta;
          this.transitionProgress = Clamp(this._elapsed / this._duration, 0, 1);
          if (this._onUpdate) {
            this._onUpdate.call(this._onUpdateScope, this.transitionProgress);
          }
          if (this._elapsed >= this._duration) {
            this.transitionComplete();
          }
        },
        transitionComplete: function() {
          var targetSys = this._target.sys;
          var targetSettings = this._target.sys.settings;
          targetSys.events.emit(Events.TRANSITION_COMPLETE, this.scene);
          targetSettings.isTransition = false;
          targetSettings.transitionFrom = null;
          this._duration = 0;
          this._target = null;
          this._onUpdate = null;
          this._onUpdateScope = null;
          if (this._willRemove) {
            this.manager.remove(this.key);
          } else if (this._willSleep) {
            this.systems.sleep();
          } else {
            this.manager.stop(this.key);
          }
        },
        add: function(key, sceneConfig, autoStart, data) {
          return this.manager.add(key, sceneConfig, autoStart, data);
        },
        launch: function(key, data) {
          if (key && key !== this.key) {
            this.manager.queueOp("start", key, data);
          }
          return this;
        },
        run: function(key, data) {
          if (key && key !== this.key) {
            this.manager.queueOp("run", key, data);
          }
          return this;
        },
        pause: function(key, data) {
          if (key === void 0) {
            key = this.key;
          }
          this.manager.queueOp("pause", key, data);
          return this;
        },
        resume: function(key, data) {
          if (key === void 0) {
            key = this.key;
          }
          this.manager.queueOp("resume", key, data);
          return this;
        },
        sleep: function(key, data) {
          if (key === void 0) {
            key = this.key;
          }
          this.manager.queueOp("sleep", key, data);
          return this;
        },
        wake: function(key, data) {
          if (key === void 0) {
            key = this.key;
          }
          this.manager.queueOp("wake", key, data);
          return this;
        },
        switch: function(key) {
          if (key !== this.key) {
            this.manager.queueOp("switch", this.key, key);
          }
          return this;
        },
        stop: function(key, data) {
          if (key === void 0) {
            key = this.key;
          }
          this.manager.queueOp("stop", key, data);
          return this;
        },
        setActive: function(value, key, data) {
          if (key === void 0) {
            key = this.key;
          }
          var scene = this.manager.getScene(key);
          if (scene) {
            scene.sys.setActive(value, data);
          }
          return this;
        },
        setVisible: function(value, key) {
          if (key === void 0) {
            key = this.key;
          }
          var scene = this.manager.getScene(key);
          if (scene) {
            scene.sys.setVisible(value);
          }
          return this;
        },
        isSleeping: function(key) {
          if (key === void 0) {
            key = this.key;
          }
          return this.manager.isSleeping(key);
        },
        isActive: function(key) {
          if (key === void 0) {
            key = this.key;
          }
          return this.manager.isActive(key);
        },
        isPaused: function(key) {
          if (key === void 0) {
            key = this.key;
          }
          return this.manager.isPaused(key);
        },
        isVisible: function(key) {
          if (key === void 0) {
            key = this.key;
          }
          return this.manager.isVisible(key);
        },
        swapPosition: function(keyA, keyB) {
          if (keyB === void 0) {
            keyB = this.key;
          }
          if (keyA !== keyB) {
            this.manager.swapPosition(keyA, keyB);
          }
          return this;
        },
        moveAbove: function(keyA, keyB) {
          if (keyB === void 0) {
            keyB = this.key;
          }
          if (keyA !== keyB) {
            this.manager.moveAbove(keyA, keyB);
          }
          return this;
        },
        moveBelow: function(keyA, keyB) {
          if (keyB === void 0) {
            keyB = this.key;
          }
          if (keyA !== keyB) {
            this.manager.moveBelow(keyA, keyB);
          }
          return this;
        },
        remove: function(key) {
          if (key === void 0) {
            key = this.key;
          }
          this.manager.remove(key);
          return this;
        },
        moveUp: function(key) {
          if (key === void 0) {
            key = this.key;
          }
          this.manager.moveUp(key);
          return this;
        },
        moveDown: function(key) {
          if (key === void 0) {
            key = this.key;
          }
          this.manager.moveDown(key);
          return this;
        },
        bringToTop: function(key) {
          if (key === void 0) {
            key = this.key;
          }
          this.manager.bringToTop(key);
          return this;
        },
        sendToBack: function(key) {
          if (key === void 0) {
            key = this.key;
          }
          this.manager.sendToBack(key);
          return this;
        },
        get: function(key) {
          return this.manager.getScene(key);
        },
        getStatus: function(key) {
          var scene = this.manager.getScene(key);
          if (scene) {
            return scene.sys.getStatus();
          }
        },
        getIndex: function(key) {
          if (key === void 0) {
            key = this.key;
          }
          return this.manager.getIndex(key);
        },
        shutdown: function() {
          var eventEmitter = this.systems.events;
          eventEmitter.off(Events.SHUTDOWN, this.shutdown, this);
          eventEmitter.off(Events.TRANSITION_OUT);
        },
        destroy: function() {
          this.shutdown();
          this.scene.sys.events.off(Events.START, this.start, this);
          this.scene = null;
          this.systems = null;
          this.settings = null;
          this.manager = null;
        }
      });
      PluginCache.register("ScenePlugin", ScenePlugin, "scenePlugin");
      module.exports = ScenePlugin;
    }
  });

  // ../../node_modules/phaser/src/scene/index.js
  var require_scene = __commonJS({
    "../../node_modules/phaser/src/scene/index.js": function(exports, module) {
      var CONST = require_const10();
      var Extend = require_Extend();
      var Scene = {
        Events: require_events(),
        GetPhysicsPlugins: require_GetPhysicsPlugins(),
        GetScenePlugins: require_GetScenePlugins(),
        SceneManager: require_SceneManager(),
        ScenePlugin: require_ScenePlugin2(),
        Settings: require_Settings(),
        Systems: require_Systems()
      };
      Scene = Extend(false, Scene, CONST);
      module.exports = Scene;
    }
  });

  // ../../node_modules/phaser/src/textures/const.js
  var require_const12 = __commonJS({
    "../../node_modules/phaser/src/textures/const.js": function(exports, module) {
      var CONST = {
        LINEAR: 0,
        NEAREST: 1
      };
      module.exports = CONST;
    }
  });

  // ../../node_modules/phaser/src/textures/index.js
  var require_textures = __commonJS({
    "../../node_modules/phaser/src/textures/index.js": function(exports, module) {
      var Extend = require_Extend();
      var FilterMode = require_const12();
      var Textures = {
        CanvasTexture: require_CanvasTexture(),
        DynamicTexture: require_DynamicTexture(),
        Events: require_events9(),
        FilterMode: FilterMode,
        Frame: require_Frame(),
        Parsers: require_parsers(),
        Texture: require_Texture2(),
        TextureManager: require_TextureManager(),
        TextureSource: require_TextureSource()
      };
      Textures = Extend(false, Textures, FilterMode);
      module.exports = Textures;
    }
  });

  // ../../node_modules/phaser/src/time/TimerEvent.js
  var require_TimerEvent = __commonJS({
    "../../node_modules/phaser/src/time/TimerEvent.js": function(exports, module) {
      var Class = require_Class();
      var GetFastValue = require_GetFastValue();
      var TimerEvent = new Class({
        initialize: function TimerEvent2(config) {
          this.delay = 0;
          this.repeat = 0;
          this.repeatCount = 0;
          this.loop = false;
          this.callback;
          this.callbackScope;
          this.args;
          this.timeScale = 1;
          this.startAt = 0;
          this.elapsed = 0;
          this.paused = false;
          this.hasDispatched = false;
          this.reset(config);
        },
        reset: function(config) {
          this.delay = GetFastValue(config, "delay", 0);
          this.repeat = GetFastValue(config, "repeat", 0);
          this.loop = GetFastValue(config, "loop", false);
          this.callback = GetFastValue(config, "callback", void 0);
          this.callbackScope = GetFastValue(config, "callbackScope", this.callback);
          this.args = GetFastValue(config, "args", []);
          this.timeScale = GetFastValue(config, "timeScale", 1);
          this.startAt = GetFastValue(config, "startAt", 0);
          this.paused = GetFastValue(config, "paused", false);
          this.elapsed = this.startAt;
          this.hasDispatched = false;
          this.repeatCount = this.repeat === -1 || this.loop ? 999999999999 : this.repeat;
          if (this.delay === 0 && (this.repeat > 0 || this.loop)) {
            throw new Error("TimerEvent infinite loop created via zero delay");
          }
          return this;
        },
        getProgress: function() {
          return this.elapsed / this.delay;
        },
        getOverallProgress: function() {
          if (this.repeat > 0) {
            var totalDuration = this.delay + this.delay * this.repeat;
            var totalElapsed = this.elapsed + this.delay * (this.repeat - this.repeatCount);
            return totalElapsed / totalDuration;
          } else {
            return this.getProgress();
          }
        },
        getRepeatCount: function() {
          return this.repeatCount;
        },
        getElapsed: function() {
          return this.elapsed;
        },
        getElapsedSeconds: function() {
          return this.elapsed * 1e-3;
        },
        getRemaining: function() {
          return this.delay - this.elapsed;
        },
        getRemainingSeconds: function() {
          return this.getRemaining() * 1e-3;
        },
        getOverallRemaining: function() {
          return this.delay * (1 + this.repeatCount) - this.elapsed;
        },
        getOverallRemainingSeconds: function() {
          return this.getOverallRemaining() * 1e-3;
        },
        remove: function(dispatchCallback) {
          if (dispatchCallback === void 0) {
            dispatchCallback = false;
          }
          this.elapsed = this.delay;
          this.hasDispatched = !dispatchCallback;
          this.repeatCount = 0;
        },
        destroy: function() {
          this.callback = void 0;
          this.callbackScope = void 0;
          this.args = [];
        }
      });
      module.exports = TimerEvent;
    }
  });

  // ../../node_modules/phaser/src/time/Clock.js
  var require_Clock = __commonJS({
    "../../node_modules/phaser/src/time/Clock.js": function(exports, module) {
      var Class = require_Class();
      var PluginCache = require_PluginCache();
      var SceneEvents = require_events();
      var TimerEvent = require_TimerEvent();
      var Remove = require_Remove();
      var Clock = new Class({
        initialize: function Clock2(scene) {
          this.scene = scene;
          this.systems = scene.sys;
          this.now = 0;
          this.startTime = 0;
          this.timeScale = 1;
          this.paused = false;
          this._active = [];
          this._pendingInsertion = [];
          this._pendingRemoval = [];
          scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
          scene.sys.events.on(SceneEvents.START, this.start, this);
        },
        boot: function() {
          this.now = this.systems.game.loop.time;
          this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
        },
        start: function() {
          this.startTime = this.systems.game.loop.time;
          var eventEmitter = this.systems.events;
          eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
          eventEmitter.on(SceneEvents.UPDATE, this.update, this);
          eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        addEvent: function(config) {
          var event;
          if (config instanceof TimerEvent) {
            event = config;
            this.removeEvent(event);
            event.elapsed = event.startAt;
            event.hasDispatched = false;
            event.repeatCount = event.repeat === -1 || event.loop ? 999999999999 : event.repeat;
          } else {
            event = new TimerEvent(config);
          }
          this._pendingInsertion.push(event);
          return event;
        },
        delayedCall: function(delay, callback, args, callbackScope) {
          return this.addEvent({ delay: delay, callback: callback, args: args, callbackScope: callbackScope });
        },
        clearPendingEvents: function() {
          this._pendingInsertion = [];
          return this;
        },
        removeEvent: function(events) {
          if (!Array.isArray(events)) {
            events = [events];
          }
          for (var i = 0; i < events.length; i++) {
            var event = events[i];
            Remove(this._pendingRemoval, event);
            Remove(this._pendingInsertion, event);
            Remove(this._active, event);
          }
          return this;
        },
        removeAllEvents: function() {
          this._pendingRemoval = this._pendingRemoval.concat(this._active);
          return this;
        },
        preUpdate: function() {
          var toRemove = this._pendingRemoval.length;
          var toInsert = this._pendingInsertion.length;
          if (toRemove === 0 && toInsert === 0) {
            return;
          }
          var i;
          var event;
          for (i = 0; i < toRemove; i++) {
            event = this._pendingRemoval[i];
            var index = this._active.indexOf(event);
            if (index > -1) {
              this._active.splice(index, 1);
            }
            event.destroy();
          }
          for (i = 0; i < toInsert; i++) {
            event = this._pendingInsertion[i];
            this._active.push(event);
          }
          this._pendingRemoval.length = 0;
          this._pendingInsertion.length = 0;
        },
        update: function(time, delta) {
          this.now = time;
          if (this.paused) {
            return;
          }
          delta *= this.timeScale;
          for (var i = 0; i < this._active.length; i++) {
            var event = this._active[i];
            if (event.paused) {
              continue;
            }
            event.elapsed += delta * event.timeScale;
            if (event.elapsed >= event.delay) {
              var remainder = event.elapsed - event.delay;
              event.elapsed = event.delay;
              if (!event.hasDispatched && event.callback) {
                event.hasDispatched = true;
                event.callback.apply(event.callbackScope, event.args);
              }
              if (event.repeatCount > 0) {
                event.repeatCount--;
                if (remainder >= event.delay) {
                  while (remainder >= event.delay && event.repeatCount > 0) {
                    if (event.callback) {
                      event.callback.apply(event.callbackScope, event.args);
                    }
                    remainder -= event.delay;
                    event.repeatCount--;
                  }
                }
                event.elapsed = remainder;
                event.hasDispatched = false;
              } else if (event.hasDispatched) {
                this._pendingRemoval.push(event);
              }
            }
          }
        },
        shutdown: function() {
          var i;
          for (i = 0; i < this._pendingInsertion.length; i++) {
            this._pendingInsertion[i].destroy();
          }
          for (i = 0; i < this._active.length; i++) {
            this._active[i].destroy();
          }
          for (i = 0; i < this._pendingRemoval.length; i++) {
            this._pendingRemoval[i].destroy();
          }
          this._active.length = 0;
          this._pendingRemoval.length = 0;
          this._pendingInsertion.length = 0;
          var eventEmitter = this.systems.events;
          eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
          eventEmitter.off(SceneEvents.UPDATE, this.update, this);
          eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        destroy: function() {
          this.shutdown();
          this.scene.sys.events.off(SceneEvents.START, this.start, this);
          this.scene = null;
          this.systems = null;
        }
      });
      PluginCache.register("Clock", Clock, "time");
      module.exports = Clock;
    }
  });

  // ../../node_modules/phaser/src/time/index.js
  var require_time = __commonJS({
    "../../node_modules/phaser/src/time/index.js": function(exports, module) {
      module.exports = {
        Clock: require_Clock(),
        TimerEvent: require_TimerEvent()
      };
    }
  });

  // ../../node_modules/phaser/src/tweens/builders/GetNewValue.js
  var require_GetNewValue = __commonJS({
    "../../node_modules/phaser/src/tweens/builders/GetNewValue.js": function(exports, module) {
      var GetNewValue = function(source, key, defaultValue) {
        var valueCallback;
        if (source.hasOwnProperty(key)) {
          var t = typeof source[key];
          if (t === "function") {
            valueCallback = function(target, targetKey, value, targetIndex, totalTargets, tween) {
              return source[key](target, targetKey, value, targetIndex, totalTargets, tween);
            };
          } else {
            valueCallback = function() {
              return source[key];
            };
          }
        } else if (typeof defaultValue === "function") {
          valueCallback = defaultValue;
        } else {
          valueCallback = function() {
            return defaultValue;
          };
        }
        return valueCallback;
      };
      module.exports = GetNewValue;
    }
  });

  // ../../node_modules/phaser/src/tweens/tween/ReservedProps.js
  var require_ReservedProps = __commonJS({
    "../../node_modules/phaser/src/tweens/tween/ReservedProps.js": function(exports, module) {
      module.exports = [
        "callbackScope",
        "completeDelay",
        "delay",
        "duration",
        "ease",
        "easeParams",
        "flipX",
        "flipY",
        "hold",
        "interpolation",
        "loop",
        "loopDelay",
        "onActive",
        "onActiveParams",
        "onComplete",
        "onCompleteParams",
        "onLoop",
        "onLoopParams",
        "onPause",
        "onPauseParams",
        "onRepeat",
        "onRepeatParams",
        "onResume",
        "onResumeParams",
        "onStart",
        "onStartParams",
        "onStop",
        "onStopParams",
        "onUpdate",
        "onUpdateParams",
        "onYoyo",
        "onYoyoParams",
        "paused",
        "persist",
        "props",
        "repeat",
        "repeatDelay",
        "targets",
        "yoyo"
      ];
    }
  });

  // ../../node_modules/phaser/src/tweens/builders/GetProps.js
  var require_GetProps = __commonJS({
    "../../node_modules/phaser/src/tweens/builders/GetProps.js": function(exports, module) {
      var RESERVED = require_ReservedProps();
      var GetProps = function(config) {
        var key;
        var keys = [];
        if (config.hasOwnProperty("props")) {
          for (key in config.props) {
            if (key.substring(0, 1) !== "_") {
              keys.push({ key: key, value: config.props[key] });
            }
          }
        } else {
          for (key in config) {
            if (RESERVED.indexOf(key) === -1 && key.substring(0, 1) !== "_") {
              keys.push({ key: key, value: config[key] });
            }
          }
        }
        return keys;
      };
      module.exports = GetProps;
    }
  });

  // ../../node_modules/phaser/src/tweens/builders/GetTargets.js
  var require_GetTargets = __commonJS({
    "../../node_modules/phaser/src/tweens/builders/GetTargets.js": function(exports, module) {
      var GetValue = require_GetValue();
      var GetTargets = function(config) {
        var targets = GetValue(config, "targets", null);
        if (targets === null) {
          return targets;
        }
        if (typeof targets === "function") {
          targets = targets.call();
        }
        if (!Array.isArray(targets)) {
          targets = [targets];
        }
        return targets;
      };
      module.exports = GetTargets;
    }
  });

  // ../../node_modules/phaser/src/tweens/builders/GetValueOp.js
  var require_GetValueOp = __commonJS({
    "../../node_modules/phaser/src/tweens/builders/GetValueOp.js": function(exports, module) {
      var Between = require_Between2();
      var FloatBetween = require_FloatBetween();
      function hasGetActive(def) {
        return !!def.getActive && typeof def.getActive === "function";
      }
      function hasGetStart(def) {
        return !!def.getStart && typeof def.getStart === "function";
      }
      function hasGetEnd(def) {
        return !!def.getEnd && typeof def.getEnd === "function";
      }
      function hasGetters(def) {
        return hasGetStart(def) || hasGetEnd(def) || hasGetActive(def);
      }
      var GetValueOp = function(key, propertyValue) {
        var callbacks;
        var getEnd = function(target, key2, value) {
          return value;
        };
        var getStart = function(target, key2, value) {
          return value;
        };
        var getActive = null;
        var t = typeof propertyValue;
        if (t === "number") {
          getEnd = function() {
            return propertyValue;
          };
        } else if (Array.isArray(propertyValue)) {
          getStart = function() {
            return propertyValue[0];
          };
          getEnd = function() {
            return propertyValue[propertyValue.length - 1];
          };
        } else if (t === "string") {
          var op = propertyValue.toLowerCase();
          var isRandom = op.substring(0, 6) === "random";
          var isInt = op.substring(0, 3) === "int";
          if (isRandom || isInt) {
            var brace1 = op.indexOf("(");
            var brace2 = op.indexOf(")");
            var comma = op.indexOf(",");
            if (brace1 && brace2 && comma) {
              var value1 = parseFloat(op.substring(brace1 + 1, comma));
              var value2 = parseFloat(op.substring(comma + 1, brace2));
              if (isRandom) {
                getEnd = function() {
                  return FloatBetween(value1, value2);
                };
              } else {
                getEnd = function() {
                  return Between(value1, value2);
                };
              }
            } else {
              throw new Error("invalid random() format");
            }
          } else {
            op = op[0];
            var num = parseFloat(propertyValue.substr(2));
            switch (op) {
              case "+":
                getEnd = function(target, key2, value) {
                  return value + num;
                };
                break;
              case "-":
                getEnd = function(target, key2, value) {
                  return value - num;
                };
                break;
              case "*":
                getEnd = function(target, key2, value) {
                  return value * num;
                };
                break;
              case "/":
                getEnd = function(target, key2, value) {
                  return value / num;
                };
                break;
              default:
                getEnd = function() {
                  return parseFloat(propertyValue);
                };
            }
          }
        } else if (t === "function") {
          getEnd = propertyValue;
        } else if (t === "object") {
          if (hasGetters(propertyValue)) {
            if (hasGetActive(propertyValue)) {
              getActive = propertyValue.getActive;
            }
            if (hasGetEnd(propertyValue)) {
              getEnd = propertyValue.getEnd;
            }
            if (hasGetStart(propertyValue)) {
              getStart = propertyValue.getStart;
            }
          } else if (propertyValue.hasOwnProperty("value")) {
            callbacks = GetValueOp(key, propertyValue.value);
          } else {
            var hasTo = propertyValue.hasOwnProperty("to");
            var hasFrom = propertyValue.hasOwnProperty("from");
            var hasStart = propertyValue.hasOwnProperty("start");
            if (hasTo && (hasFrom || hasStart)) {
              callbacks = GetValueOp(key, propertyValue.to);
              if (hasStart) {
                var startCallbacks = GetValueOp(key, propertyValue.start);
                callbacks.getActive = startCallbacks.getEnd;
              }
              if (hasFrom) {
                var fromCallbacks = GetValueOp(key, propertyValue.from);
                callbacks.getStart = fromCallbacks.getEnd;
              }
            }
          }
        }
        if (!callbacks) {
          callbacks = {
            getActive: getActive,
            getEnd: getEnd,
            getStart: getStart
          };
        }
        return callbacks;
      };
      module.exports = GetValueOp;
    }
  });

  // ../../node_modules/phaser/src/tweens/events/TWEEN_ACTIVE_EVENT.js
  var require_TWEEN_ACTIVE_EVENT = __commonJS({
    "../../node_modules/phaser/src/tweens/events/TWEEN_ACTIVE_EVENT.js": function(exports, module) {
      module.exports = "active";
    }
  });

  // ../../node_modules/phaser/src/tweens/events/TWEEN_COMPLETE_EVENT.js
  var require_TWEEN_COMPLETE_EVENT = __commonJS({
    "../../node_modules/phaser/src/tweens/events/TWEEN_COMPLETE_EVENT.js": function(exports, module) {
      module.exports = "complete";
    }
  });

  // ../../node_modules/phaser/src/tweens/events/TWEEN_LOOP_EVENT.js
  var require_TWEEN_LOOP_EVENT = __commonJS({
    "../../node_modules/phaser/src/tweens/events/TWEEN_LOOP_EVENT.js": function(exports, module) {
      module.exports = "loop";
    }
  });

  // ../../node_modules/phaser/src/tweens/events/TWEEN_PAUSE_EVENT.js
  var require_TWEEN_PAUSE_EVENT = __commonJS({
    "../../node_modules/phaser/src/tweens/events/TWEEN_PAUSE_EVENT.js": function(exports, module) {
      module.exports = "pause";
    }
  });

  // ../../node_modules/phaser/src/tweens/events/TWEEN_RESUME_EVENT.js
  var require_TWEEN_RESUME_EVENT = __commonJS({
    "../../node_modules/phaser/src/tweens/events/TWEEN_RESUME_EVENT.js": function(exports, module) {
      module.exports = "resume";
    }
  });

  // ../../node_modules/phaser/src/tweens/events/TWEEN_REPEAT_EVENT.js
  var require_TWEEN_REPEAT_EVENT = __commonJS({
    "../../node_modules/phaser/src/tweens/events/TWEEN_REPEAT_EVENT.js": function(exports, module) {
      module.exports = "repeat";
    }
  });

  // ../../node_modules/phaser/src/tweens/events/TWEEN_START_EVENT.js
  var require_TWEEN_START_EVENT = __commonJS({
    "../../node_modules/phaser/src/tweens/events/TWEEN_START_EVENT.js": function(exports, module) {
      module.exports = "start";
    }
  });

  // ../../node_modules/phaser/src/tweens/events/TWEEN_STOP_EVENT.js
  var require_TWEEN_STOP_EVENT = __commonJS({
    "../../node_modules/phaser/src/tweens/events/TWEEN_STOP_EVENT.js": function(exports, module) {
      module.exports = "stop";
    }
  });

  // ../../node_modules/phaser/src/tweens/events/TWEEN_UPDATE_EVENT.js
  var require_TWEEN_UPDATE_EVENT = __commonJS({
    "../../node_modules/phaser/src/tweens/events/TWEEN_UPDATE_EVENT.js": function(exports, module) {
      module.exports = "update";
    }
  });

  // ../../node_modules/phaser/src/tweens/events/TWEEN_YOYO_EVENT.js
  var require_TWEEN_YOYO_EVENT = __commonJS({
    "../../node_modules/phaser/src/tweens/events/TWEEN_YOYO_EVENT.js": function(exports, module) {
      module.exports = "yoyo";
    }
  });

  // ../../node_modules/phaser/src/tweens/events/index.js
  var require_events20 = __commonJS({
    "../../node_modules/phaser/src/tweens/events/index.js": function(exports, module) {
      module.exports = {
        TWEEN_ACTIVE: require_TWEEN_ACTIVE_EVENT(),
        TWEEN_COMPLETE: require_TWEEN_COMPLETE_EVENT(),
        TWEEN_LOOP: require_TWEEN_LOOP_EVENT(),
        TWEEN_PAUSE: require_TWEEN_PAUSE_EVENT(),
        TWEEN_RESUME: require_TWEEN_RESUME_EVENT(),
        TWEEN_REPEAT: require_TWEEN_REPEAT_EVENT(),
        TWEEN_START: require_TWEEN_START_EVENT(),
        TWEEN_STOP: require_TWEEN_STOP_EVENT(),
        TWEEN_UPDATE: require_TWEEN_UPDATE_EVENT(),
        TWEEN_YOYO: require_TWEEN_YOYO_EVENT()
      };
    }
  });

  // ../../node_modules/phaser/src/tweens/tween/BaseTween.js
  var require_BaseTween = __commonJS({
    "../../node_modules/phaser/src/tweens/tween/BaseTween.js": function(exports, module) {
      var Class = require_Class();
      var EventEmitter = require_eventemitter3();
      var Events = require_events20();
      var TWEEN_CONST = require_const5();
      var BaseTween = new Class({
        Extends: EventEmitter,
        initialize: function BaseTween2(parent) {
          EventEmitter.call(this);
          this.parent = parent;
          this.data = [];
          this.totalData = 0;
          this.startDelay = 0;
          this.hasStarted = false;
          this.timeScale = 1;
          this.loop = 0;
          this.loopDelay = 0;
          this.loopCounter = 0;
          this.completeDelay = 0;
          this.countdown = 0;
          this.state = TWEEN_CONST.PENDING;
          this.paused = false;
          this.callbacks = {
            onActive: null,
            onComplete: null,
            onLoop: null,
            onPause: null,
            onRepeat: null,
            onResume: null,
            onStart: null,
            onStop: null,
            onUpdate: null,
            onYoyo: null
          };
          this.callbackScope;
          this.persist = false;
        },
        setTimeScale: function(value) {
          this.timeScale = value;
          return this;
        },
        getTimeScale: function() {
          return this.timeScale;
        },
        isPlaying: function() {
          return !this.paused && this.isActive();
        },
        isPaused: function() {
          return this.paused;
        },
        pause: function() {
          if (!this.paused) {
            this.paused = true;
            this.dispatchEvent(Events.TWEEN_PAUSE, "onPause");
          }
          return this;
        },
        resume: function() {
          if (this.paused) {
            this.paused = false;
            this.dispatchEvent(Events.TWEEN_RESUME, "onResume");
          }
          return this;
        },
        makeActive: function() {
          this.parent.makeActive(this);
          this.dispatchEvent(Events.TWEEN_ACTIVE, "onActive");
        },
        onCompleteHandler: function() {
          this.setPendingRemoveState();
          this.dispatchEvent(Events.TWEEN_COMPLETE, "onComplete");
        },
        complete: function(delay) {
          if (delay === void 0) {
            delay = 0;
          }
          if (delay) {
            this.setCompleteDelayState();
            this.countdown = delay;
          } else {
            this.onCompleteHandler();
          }
          return this;
        },
        completeAfterLoop: function(loops) {
          if (loops === void 0) {
            loops = 0;
          }
          if (this.loopCounter > loops) {
            this.loopCounter = loops;
          }
          return this;
        },
        remove: function() {
          this.parent.remove(this);
          return this;
        },
        stop: function() {
          if (!this.isRemoved() && !this.isPendingRemove() && !this.isDestroyed()) {
            this.dispatchEvent(Events.TWEEN_STOP, "onStop");
            this.setPendingRemoveState();
          }
          return this;
        },
        updateLoopCountdown: function(delta) {
          this.countdown -= delta;
          if (this.countdown <= 0) {
            this.setActiveState();
            this.dispatchEvent(Events.TWEEN_LOOP, "onLoop");
          }
        },
        updateStartCountdown: function(delta) {
          this.countdown -= delta;
          if (this.countdown <= 0) {
            this.hasStarted = true;
            this.setActiveState();
            this.dispatchEvent(Events.TWEEN_START, "onStart");
            delta = 0;
          }
          return delta;
        },
        updateCompleteDelay: function(delta) {
          this.countdown -= delta;
          if (this.countdown <= 0) {
            this.onCompleteHandler();
          }
        },
        setCallback: function(type, callback, params) {
          if (params === void 0) {
            params = [];
          }
          if (this.callbacks.hasOwnProperty(type)) {
            this.callbacks[type] = { func: callback, params: params };
          }
          return this;
        },
        setPendingState: function() {
          this.state = TWEEN_CONST.PENDING;
        },
        setActiveState: function() {
          this.state = TWEEN_CONST.ACTIVE;
        },
        setLoopDelayState: function() {
          this.state = TWEEN_CONST.LOOP_DELAY;
        },
        setCompleteDelayState: function() {
          this.state = TWEEN_CONST.COMPLETE_DELAY;
        },
        setStartDelayState: function() {
          this.state = TWEEN_CONST.START_DELAY;
          this.countdown = this.startDelay;
          this.hasStarted = false;
        },
        setPendingRemoveState: function() {
          this.state = TWEEN_CONST.PENDING_REMOVE;
        },
        setRemovedState: function() {
          this.state = TWEEN_CONST.REMOVED;
        },
        setFinishedState: function() {
          this.state = TWEEN_CONST.FINISHED;
        },
        setDestroyedState: function() {
          this.state = TWEEN_CONST.DESTROYED;
        },
        isPending: function() {
          return this.state === TWEEN_CONST.PENDING;
        },
        isActive: function() {
          return this.state === TWEEN_CONST.ACTIVE;
        },
        isLoopDelayed: function() {
          return this.state === TWEEN_CONST.LOOP_DELAY;
        },
        isCompleteDelayed: function() {
          return this.state === TWEEN_CONST.COMPLETE_DELAY;
        },
        isStartDelayed: function() {
          return this.state === TWEEN_CONST.START_DELAY;
        },
        isPendingRemove: function() {
          return this.state === TWEEN_CONST.PENDING_REMOVE;
        },
        isRemoved: function() {
          return this.state === TWEEN_CONST.REMOVED;
        },
        isFinished: function() {
          return this.state === TWEEN_CONST.FINISHED;
        },
        isDestroyed: function() {
          return this.state === TWEEN_CONST.DESTROYED;
        },
        destroy: function() {
          if (this.data) {
            this.data.forEach(function(tweenData) {
              tweenData.destroy();
            });
          }
          this.removeAllListeners();
          this.callbacks = null;
          this.data = null;
          this.parent = null;
          this.setDestroyedState();
        }
      });
      BaseTween.TYPES = [
        "onActive",
        "onComplete",
        "onLoop",
        "onPause",
        "onRepeat",
        "onResume",
        "onStart",
        "onStop",
        "onUpdate",
        "onYoyo"
      ];
      module.exports = BaseTween;
    }
  });

  // ../../node_modules/phaser/src/tweens/tween/Defaults.js
  var require_Defaults = __commonJS({
    "../../node_modules/phaser/src/tweens/tween/Defaults.js": function(exports, module) {
      var TWEEN_DEFAULTS = {
        targets: null,
        delay: 0,
        duration: 1e3,
        ease: "Power0",
        easeParams: null,
        hold: 0,
        repeat: 0,
        repeatDelay: 0,
        yoyo: false,
        flipX: false,
        flipY: false,
        persist: false,
        interpolation: null
      };
      module.exports = TWEEN_DEFAULTS;
    }
  });

  // ../../node_modules/phaser/src/utils/object/MergeRight.js
  var require_MergeRight = __commonJS({
    "../../node_modules/phaser/src/utils/object/MergeRight.js": function(exports, module) {
      var Clone = require_Clone();
      var MergeRight = function(obj1, obj2) {
        var clone = Clone(obj1);
        for (var key in obj2) {
          if (clone.hasOwnProperty(key)) {
            clone[key] = obj2[key];
          }
        }
        return clone;
      };
      module.exports = MergeRight;
    }
  });

  // ../../node_modules/phaser/src/tweens/tween/BaseTweenData.js
  var require_BaseTweenData = __commonJS({
    "../../node_modules/phaser/src/tweens/tween/BaseTweenData.js": function(exports, module) {
      var Class = require_Class();
      var Events = require_events20();
      var TWEEN_CONST = require_const5();
      var BaseTweenData = new Class({
        initialize: function BaseTweenData2(tween, targetIndex, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY) {
          this.tween = tween;
          this.targetIndex = targetIndex;
          this.duration = duration;
          this.totalDuration = 0;
          this.delay = 0;
          this.getDelay = delay;
          this.yoyo = yoyo;
          this.hold = hold;
          this.repeat = repeat;
          this.repeatDelay = repeatDelay;
          this.repeatCounter = 0;
          this.flipX = flipX;
          this.flipY = flipY;
          this.progress = 0;
          this.elapsed = 0;
          this.state = 0;
          this.isCountdown = false;
        },
        getTarget: function() {
          return this.tween.targets[this.targetIndex];
        },
        setTargetValue: function(value) {
          if (value === void 0) {
            value = this.current;
          }
          this.tween.targets[this.targetIndex][this.key] = value;
        },
        setCreatedState: function() {
          this.state = TWEEN_CONST.CREATED;
          this.isCountdown = false;
        },
        setDelayState: function() {
          this.state = TWEEN_CONST.DELAY;
          this.isCountdown = true;
        },
        setPendingRenderState: function() {
          this.state = TWEEN_CONST.PENDING_RENDER;
          this.isCountdown = false;
        },
        setPlayingForwardState: function() {
          this.state = TWEEN_CONST.PLAYING_FORWARD;
          this.isCountdown = false;
        },
        setPlayingBackwardState: function() {
          this.state = TWEEN_CONST.PLAYING_BACKWARD;
          this.isCountdown = false;
        },
        setHoldState: function() {
          this.state = TWEEN_CONST.HOLD_DELAY;
          this.isCountdown = true;
        },
        setRepeatState: function() {
          this.state = TWEEN_CONST.REPEAT_DELAY;
          this.isCountdown = true;
        },
        setCompleteState: function() {
          this.state = TWEEN_CONST.COMPLETE;
          this.isCountdown = false;
        },
        isCreated: function() {
          return this.state === TWEEN_CONST.CREATED;
        },
        isDelayed: function() {
          return this.state === TWEEN_CONST.DELAY;
        },
        isPendingRender: function() {
          return this.state === TWEEN_CONST.PENDING_RENDER;
        },
        isPlayingForward: function() {
          return this.state === TWEEN_CONST.PLAYING_FORWARD;
        },
        isPlayingBackward: function() {
          return this.state === TWEEN_CONST.PLAYING_BACKWARD;
        },
        isHolding: function() {
          return this.state === TWEEN_CONST.HOLD_DELAY;
        },
        isRepeating: function() {
          return this.state === TWEEN_CONST.REPEAT_DELAY;
        },
        isComplete: function() {
          return this.state === TWEEN_CONST.COMPLETE;
        },
        setStateFromEnd: function(diff) {
          if (this.yoyo) {
            this.onRepeat(diff, true, true);
          } else if (this.repeatCounter > 0) {
            this.onRepeat(diff, true, false);
          } else {
            this.setCompleteState();
          }
        },
        setStateFromStart: function(diff) {
          if (this.repeatCounter > 0) {
            this.onRepeat(diff, false);
          } else {
            this.setCompleteState();
          }
        },
        reset: function() {
          var tween = this.tween;
          var totalTargets = tween.totalTargets;
          var targetIndex = this.targetIndex;
          var target = tween.targets[targetIndex];
          var key = this.key;
          this.progress = 0;
          this.elapsed = 0;
          this.delay = this.getDelay(target, key, 0, targetIndex, totalTargets, tween);
          this.repeatCounter = this.repeat === -1 ? TWEEN_CONST.MAX : this.repeat;
          this.setPendingRenderState();
          var t1 = this.duration + this.hold;
          if (this.yoyo) {
            t1 += this.duration;
          }
          var t2 = t1 + this.repeatDelay;
          this.totalDuration = this.delay + t1;
          if (this.repeat === -1) {
            this.totalDuration += t2 * TWEEN_CONST.MAX;
            tween.isInfinite = true;
          } else if (this.repeat > 0) {
            this.totalDuration += t2 * this.repeat;
          }
          if (this.totalDuration > tween.duration) {
            tween.duration = this.totalDuration;
          }
          if (this.delay < tween.startDelay) {
            tween.startDelay = this.delay;
          }
          if (this.delay > 0) {
            this.elapsed = this.delay;
            this.setDelayState();
          }
        },
        onRepeat: function(diff, setStart, isYoyo) {
          var tween = this.tween;
          var totalTargets = tween.totalTargets;
          var targetIndex = this.targetIndex;
          var target = tween.targets[targetIndex];
          var key = this.key;
          var isTweenData = key !== "texture";
          this.elapsed = diff;
          this.progress = diff / this.duration;
          if (this.flipX) {
            target.toggleFlipX();
          }
          if (this.flipY) {
            target.toggleFlipY();
          }
          if (isTweenData && (setStart || isYoyo)) {
            this.start = this.getStartValue(target, key, this.start, targetIndex, totalTargets, tween);
          }
          if (isYoyo) {
            this.setPlayingBackwardState();
            this.dispatchEvent(Events.TWEEN_YOYO, "onYoyo");
            return;
          }
          this.repeatCounter--;
          if (isTweenData) {
            this.end = this.getEndValue(target, key, this.start, targetIndex, totalTargets, tween);
          }
          if (this.repeatDelay > 0) {
            this.elapsed = this.repeatDelay - diff;
            if (isTweenData) {
              this.current = this.start;
              target[key] = this.current;
            }
            this.setRepeatState();
          } else {
            this.setPlayingForwardState();
            this.dispatchEvent(Events.TWEEN_REPEAT, "onRepeat");
          }
        },
        destroy: function() {
          this.tween = null;
          this.getDelay = null;
          this.setCompleteState();
        }
      });
      module.exports = BaseTweenData;
    }
  });

  // ../../node_modules/phaser/src/tweens/tween/TweenData.js
  var require_TweenData = __commonJS({
    "../../node_modules/phaser/src/tweens/tween/TweenData.js": function(exports, module) {
      var BaseTweenData = require_BaseTweenData();
      var Clamp = require_Clamp();
      var Class = require_Class();
      var Events = require_events20();
      var TweenData = new Class({
        Extends: BaseTweenData,
        initialize: function TweenData2(tween, targetIndex, key, getEnd, getStart, getActive, ease, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY, interpolation, interpolationData) {
          BaseTweenData.call(this, tween, targetIndex, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY);
          this.key = key;
          this.getActiveValue = getActive;
          this.getEndValue = getEnd;
          this.getStartValue = getStart;
          this.ease = ease;
          this.start = 0;
          this.previous = 0;
          this.current = 0;
          this.end = 0;
          this.interpolation = interpolation;
          this.interpolationData = interpolationData;
        },
        reset: function(isSeeking) {
          BaseTweenData.prototype.reset.call(this);
          var target = this.tween.targets[this.targetIndex];
          var key = this.key;
          if (isSeeking) {
            target[key] = this.start;
          }
          this.start = 0;
          this.previous = 0;
          this.current = 0;
          this.end = 0;
          if (this.getActiveValue) {
            target[key] = this.getActiveValue(target, key, 0);
          }
        },
        update: function(delta) {
          var tween = this.tween;
          var totalTargets = tween.totalTargets;
          var targetIndex = this.targetIndex;
          var target = tween.targets[targetIndex];
          var key = this.key;
          if (!target) {
            this.setCompleteState();
            return false;
          }
          if (this.isCountdown) {
            this.elapsed -= delta;
            if (this.elapsed <= 0) {
              this.elapsed = 0;
              delta = 0;
              if (this.isDelayed()) {
                this.setPendingRenderState();
              } else if (this.isRepeating()) {
                this.setPlayingForwardState();
                this.dispatchEvent(Events.TWEEN_REPEAT, "onRepeat");
              } else if (this.isHolding()) {
                this.setStateFromEnd(0);
              }
            }
          }
          if (this.isPendingRender()) {
            this.start = this.getStartValue(target, key, target[key], targetIndex, totalTargets, tween);
            this.end = this.getEndValue(target, key, this.start, targetIndex, totalTargets, tween);
            this.current = this.start;
            target[key] = this.start;
            this.setPlayingForwardState();
            return true;
          }
          var forward = this.isPlayingForward();
          var backward = this.isPlayingBackward();
          if (forward || backward) {
            var elapsed = this.elapsed;
            var duration = this.duration;
            var diff = 0;
            var complete = false;
            elapsed += delta;
            if (elapsed >= duration) {
              diff = elapsed - duration;
              elapsed = duration;
              complete = true;
            } else if (elapsed < 0) {
              elapsed = 0;
            }
            var progress = Clamp(elapsed / duration, 0, 1);
            this.elapsed = elapsed;
            this.progress = progress;
            this.previous = this.current;
            if (complete) {
              if (forward) {
                this.current = this.end;
                target[key] = this.end;
                if (this.hold > 0) {
                  this.elapsed = this.hold;
                  this.setHoldState();
                } else {
                  this.setStateFromEnd(diff);
                }
              } else {
                this.current = this.start;
                target[key] = this.start;
                this.setStateFromStart(diff);
              }
            } else {
              if (!forward) {
                progress = 1 - progress;
              }
              var v = this.ease(progress);
              if (this.interpolation) {
                this.current = this.interpolation(this.interpolationData, v);
              } else {
                this.current = this.start + (this.end - this.start) * v;
              }
              target[key] = this.current;
            }
            this.dispatchEvent(Events.TWEEN_UPDATE, "onUpdate");
          }
          return !this.isComplete();
        },
        dispatchEvent: function(event, callback) {
          var tween = this.tween;
          if (!tween.isSeeking) {
            var target = tween.targets[this.targetIndex];
            var key = this.key;
            var current = this.current;
            var previous = this.previous;
            tween.emit(event, tween, key, target, current, previous);
            var handler = tween.callbacks[callback];
            if (handler) {
              handler.func.apply(tween.callbackScope, [tween, target, key, current, previous].concat(handler.params));
            }
          }
        },
        destroy: function() {
          BaseTweenData.prototype.destroy.call(this);
          this.getActiveValue = null;
          this.getEndValue = null;
          this.getStartValue = null;
          this.ease = null;
        }
      });
      module.exports = TweenData;
    }
  });

  // ../../node_modules/phaser/src/tweens/tween/TweenFrameData.js
  var require_TweenFrameData = __commonJS({
    "../../node_modules/phaser/src/tweens/tween/TweenFrameData.js": function(exports, module) {
      var BaseTweenData = require_BaseTweenData();
      var Clamp = require_Clamp();
      var Class = require_Class();
      var Events = require_events20();
      var TweenFrameData = new Class({
        Extends: BaseTweenData,
        initialize: function TweenFrameData2(tween, targetIndex, texture, frame, delay, duration, hold, repeat, repeatDelay, flipX, flipY) {
          BaseTweenData.call(this, tween, targetIndex, delay, duration, false, hold, repeat, repeatDelay, flipX, flipY);
          this.key = "texture";
          this.startTexture = null;
          this.endTexture = texture;
          this.startFrame = null;
          this.endFrame = frame;
          this.yoyo = repeat !== 0 ? true : false;
        },
        reset: function(isSeeking) {
          BaseTweenData.prototype.reset.call(this);
          var target = this.tween.targets[this.targetIndex];
          if (!this.startTexture) {
            this.startTexture = target.texture.key;
            this.startFrame = target.frame.name;
          }
          if (isSeeking) {
            target.setTexture(this.startTexture, this.startFrame);
          }
        },
        update: function(delta) {
          var tween = this.tween;
          var targetIndex = this.targetIndex;
          var target = tween.targets[targetIndex];
          if (!target) {
            this.setCompleteState();
            return false;
          }
          if (this.isCountdown) {
            this.elapsed -= delta;
            if (this.elapsed <= 0) {
              this.elapsed = 0;
              delta = 0;
              if (this.isDelayed()) {
                this.setPendingRenderState();
              } else if (this.isRepeating()) {
                this.setPlayingForwardState();
                this.dispatchEvent(Events.TWEEN_REPEAT, "onRepeat");
              } else if (this.isHolding()) {
                this.setStateFromEnd(0);
              }
            }
          }
          if (this.isPendingRender()) {
            if (this.startTexture) {
              target.setTexture(this.startTexture, this.startFrame);
            }
            this.setPlayingForwardState();
            return true;
          }
          var forward = this.isPlayingForward();
          var backward = this.isPlayingBackward();
          if (forward || backward) {
            var elapsed = this.elapsed;
            var duration = this.duration;
            var diff = 0;
            var complete = false;
            elapsed += delta;
            if (elapsed >= duration) {
              diff = elapsed - duration;
              elapsed = duration;
              complete = true;
            } else if (elapsed < 0) {
              elapsed = 0;
            }
            var progress = Clamp(elapsed / duration, 0, 1);
            this.elapsed = elapsed;
            this.progress = progress;
            if (complete) {
              if (forward) {
                target.setTexture(this.endTexture, this.endFrame);
                if (this.hold > 0) {
                  this.elapsed = this.hold;
                  this.setHoldState();
                } else {
                  this.setStateFromEnd(diff);
                }
              } else {
                target.setTexture(this.startTexture, this.startFrame);
                this.setStateFromStart(diff);
              }
            }
            this.dispatchEvent(Events.TWEEN_UPDATE, "onUpdate");
          }
          return !this.isComplete();
        },
        dispatchEvent: function(event, callback) {
          var tween = this.tween;
          if (!tween.isSeeking) {
            var target = tween.targets[this.targetIndex];
            var key = this.key;
            tween.emit(event, tween, key, target);
            var handler = tween.callbacks[callback];
            if (handler) {
              handler.func.apply(tween.callbackScope, [tween, target, key].concat(handler.params));
            }
          }
        },
        destroy: function() {
          BaseTweenData.prototype.destroy.call(this);
          this.startTexture = null;
          this.endTexture = null;
          this.startFrame = null;
          this.endFrame = null;
        }
      });
      module.exports = TweenFrameData;
    }
  });

  // ../../node_modules/phaser/src/tweens/tween/Tween.js
  var require_Tween = __commonJS({
    "../../node_modules/phaser/src/tweens/tween/Tween.js": function(exports, module) {
      var BaseTween = require_BaseTween();
      var Class = require_Class();
      var Events = require_events20();
      var GameObjectCreator = require_GameObjectCreator();
      var GameObjectFactory = require_GameObjectFactory();
      var MATH_CONST = require_const4();
      var TWEEN_CONST = require_const5();
      var TweenData = require_TweenData();
      var TweenFrameData = require_TweenFrameData();
      var Tween = new Class({
        Extends: BaseTween,
        initialize: function Tween2(parent, targets) {
          BaseTween.call(this, parent);
          this.targets = targets;
          this.totalTargets = targets.length;
          this.isSeeking = false;
          this.isInfinite = false;
          this.elapsed = 0;
          this.totalElapsed = 0;
          this.duration = 0;
          this.progress = 0;
          this.totalDuration = 0;
          this.totalProgress = 0;
        },
        add: function(targetIndex, key, getEnd, getStart, getActive, ease, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY, interpolation, interpolationData) {
          var tweenData = new TweenData(this, targetIndex, key, getEnd, getStart, getActive, ease, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY, interpolation, interpolationData);
          this.totalData = this.data.push(tweenData);
          return tweenData;
        },
        addFrame: function(targetIndex, texture, frame, delay, duration, hold, repeat, repeatDelay, flipX, flipY) {
          var tweenData = new TweenFrameData(this, targetIndex, texture, frame, delay, duration, hold, repeat, repeatDelay, flipX, flipY);
          this.totalData = this.data.push(tweenData);
          return tweenData;
        },
        getValue: function(index) {
          if (index === void 0) {
            index = 0;
          }
          var value = null;
          if (this.data) {
            value = this.data[index].current;
          }
          return value;
        },
        hasTarget: function(target) {
          return this.targets && this.targets.indexOf(target) !== -1;
        },
        updateTo: function(key, value, startToCurrent) {
          if (startToCurrent === void 0) {
            startToCurrent = false;
          }
          if (key !== "texture") {
            for (var i = 0; i < this.totalData; i++) {
              var tweenData = this.data[i];
              if (tweenData.key === key && (tweenData.isPlayingForward() || tweenData.isPlayingBackward())) {
                tweenData.end = value;
                if (startToCurrent) {
                  tweenData.start = tweenData.current;
                }
              }
            }
          }
          return this;
        },
        restart: function() {
          switch (this.state) {
            case TWEEN_CONST.REMOVED:
            case TWEEN_CONST.FINISHED:
              this.seek();
              this.parent.makeActive(this);
              break;
            case TWEEN_CONST.PENDING:
            case TWEEN_CONST.PENDING_REMOVE:
              this.parent.reset(this);
              break;
            case TWEEN_CONST.DESTROYED:
              console.warn("Cannot restart destroyed Tween", this);
              break;
            default:
              this.seek();
              break;
          }
          this.paused = false;
          this.hasStarted = false;
          return this;
        },
        nextState: function() {
          if (this.loopCounter > 0) {
            this.elapsed = 0;
            this.progress = 0;
            this.loopCounter--;
            this.initTweenData(true);
            if (this.loopDelay > 0) {
              this.countdown = this.loopDelay;
              this.setLoopDelayState();
            } else {
              this.setActiveState();
              this.dispatchEvent(Events.TWEEN_LOOP, "onLoop");
            }
          } else if (this.completeDelay > 0) {
            this.countdown = this.completeDelay;
            this.setCompleteDelayState();
          } else {
            this.onCompleteHandler();
            return true;
          }
          return false;
        },
        onCompleteHandler: function() {
          this.progress = 1;
          this.totalProgress = 1;
          BaseTween.prototype.onCompleteHandler.call(this);
        },
        play: function() {
          if (this.isDestroyed()) {
            console.warn("Cannot play destroyed Tween", this);
            return this;
          }
          if (this.isPendingRemove() || this.isFinished()) {
            this.seek();
          }
          this.paused = false;
          this.setActiveState();
          return this;
        },
        seek: function(amount, delta, emit) {
          if (amount === void 0) {
            amount = 0;
          }
          if (delta === void 0) {
            delta = 16.6;
          }
          if (emit === void 0) {
            emit = false;
          }
          if (this.isDestroyed()) {
            console.warn("Cannot seek destroyed Tween", this);
            return this;
          }
          if (!emit) {
            this.isSeeking = true;
          }
          this.reset(true);
          this.initTweenData(true);
          this.setActiveState();
          this.dispatchEvent(Events.TWEEN_ACTIVE, "onActive");
          var isPaused = this.paused;
          this.paused = false;
          if (amount > 0) {
            var iterations = Math.floor(amount / delta);
            var remainder = amount - iterations * delta;
            for (var i = 0; i < iterations; i++) {
              this.update(delta);
            }
            if (remainder > 0) {
              this.update(remainder);
            }
          }
          this.paused = isPaused;
          this.isSeeking = false;
          return this;
        },
        initTweenData: function(isSeeking) {
          if (isSeeking === void 0) {
            isSeeking = false;
          }
          this.duration = 0;
          this.startDelay = MATH_CONST.MAX_SAFE_INTEGER;
          var data = this.data;
          for (var i = 0; i < this.totalData; i++) {
            data[i].reset(isSeeking);
          }
          this.duration = Math.max(this.duration, 0.01);
          var duration = this.duration;
          var completeDelay = this.completeDelay;
          var loopCounter = this.loopCounter;
          var loopDelay = this.loopDelay;
          if (loopCounter > 0) {
            this.totalDuration = duration + completeDelay + (duration + loopDelay) * loopCounter;
          } else {
            this.totalDuration = duration + completeDelay;
          }
        },
        reset: function(skipInit) {
          if (skipInit === void 0) {
            skipInit = false;
          }
          this.elapsed = 0;
          this.totalElapsed = 0;
          this.progress = 0;
          this.totalProgress = 0;
          this.loopCounter = this.loop;
          if (this.loop === -1) {
            this.isInfinite = true;
            this.loopCounter = TWEEN_CONST.MAX;
          }
          if (!skipInit) {
            this.initTweenData();
            this.setActiveState();
            this.dispatchEvent(Events.TWEEN_ACTIVE, "onActive");
          }
          return this;
        },
        update: function(delta) {
          if (this.isPendingRemove() || this.isDestroyed()) {
            return true;
          } else if (this.paused || this.isFinished()) {
            return false;
          }
          delta *= this.timeScale * this.parent.timeScale;
          if (this.isLoopDelayed()) {
            this.updateLoopCountdown(delta);
            return false;
          } else if (this.isCompleteDelayed()) {
            this.updateCompleteDelay(delta);
            return false;
          } else if (!this.hasStarted) {
            this.startDelay -= delta;
            if (this.startDelay <= 0) {
              this.hasStarted = true;
              this.dispatchEvent(Events.TWEEN_START, "onStart");
              delta = 0;
            }
          }
          var stillRunning = false;
          if (this.isActive()) {
            var data = this.data;
            for (var i = 0; i < this.totalData; i++) {
              if (data[i].update(delta)) {
                stillRunning = true;
              }
            }
          }
          this.elapsed += delta;
          this.progress = Math.min(this.elapsed / this.duration, 1);
          this.totalElapsed += delta;
          this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1);
          if (!stillRunning) {
            this.nextState();
          }
          var remove = this.isPendingRemove();
          if (remove && this.persist) {
            this.setFinishedState();
            remove = false;
          }
          return remove;
        },
        forward: function(ms) {
          this.update(ms);
          return this;
        },
        rewind: function(ms) {
          this.update(-ms);
          return this;
        },
        dispatchEvent: function(event, callback) {
          if (!this.isSeeking) {
            this.emit(event, this, this.targets);
            var handler = this.callbacks[callback];
            if (handler) {
              handler.func.apply(this.callbackScope, [this, this.targets].concat(handler.params));
            }
          }
        },
        destroy: function() {
          BaseTween.prototype.destroy.call(this);
          this.targets = null;
        }
      });
      GameObjectFactory.register("tween", function(config) {
        return this.scene.sys.tweens.add(config);
      });
      GameObjectCreator.register("tween", function(config) {
        return this.scene.sys.tweens.create(config);
      });
      module.exports = Tween;
    }
  });

  // ../../node_modules/phaser/src/tweens/builders/NumberTweenBuilder.js
  var require_NumberTweenBuilder = __commonJS({
    "../../node_modules/phaser/src/tweens/builders/NumberTweenBuilder.js": function(exports, module) {
      var BaseTween = require_BaseTween();
      var Defaults = require_Defaults();
      var GetAdvancedValue = require_GetAdvancedValue();
      var GetBoolean = require_GetBoolean();
      var GetEaseFunction = require_GetEaseFunction();
      var GetNewValue = require_GetNewValue();
      var GetValue = require_GetValue();
      var GetValueOp = require_GetValueOp();
      var MergeRight = require_MergeRight();
      var Tween = require_Tween();
      var NumberTweenBuilder = function(parent, config, defaults) {
        if (config instanceof Tween) {
          config.parent = parent;
          return config;
        }
        if (defaults === void 0) {
          defaults = Defaults;
        } else {
          defaults = MergeRight(Defaults, defaults);
        }
        var from = GetValue(config, "from", 0);
        var to = GetValue(config, "to", 1);
        var targets = [{ value: from }];
        var delay = GetValue(config, "delay", defaults.delay);
        var easeParams = GetValue(config, "easeParams", defaults.easeParams);
        var ease = GetValue(config, "ease", defaults.ease);
        var ops = GetValueOp("value", to);
        var tween = new Tween(parent, targets);
        var tweenData = tween.add(0, "value", ops.getEnd, ops.getStart, ops.getActive, GetEaseFunction(GetValue(config, "ease", ease), GetValue(config, "easeParams", easeParams)), GetNewValue(config, "delay", delay), GetValue(config, "duration", defaults.duration), GetBoolean(config, "yoyo", defaults.yoyo), GetValue(config, "hold", defaults.hold), GetValue(config, "repeat", defaults.repeat), GetValue(config, "repeatDelay", defaults.repeatDelay), false, false);
        tweenData.start = from;
        tweenData.current = from;
        tween.completeDelay = GetAdvancedValue(config, "completeDelay", 0);
        tween.loop = Math.round(GetAdvancedValue(config, "loop", 0));
        tween.loopDelay = Math.round(GetAdvancedValue(config, "loopDelay", 0));
        tween.paused = GetBoolean(config, "paused", false);
        tween.persist = GetBoolean(config, "persist", false);
        tween.callbackScope = GetValue(config, "callbackScope", tween);
        var callbacks = BaseTween.TYPES;
        for (var i = 0; i < callbacks.length; i++) {
          var type = callbacks[i];
          var callback = GetValue(config, type, false);
          if (callback) {
            var callbackParams = GetValue(config, type + "Params", []);
            tween.setCallback(type, callback, callbackParams);
          }
        }
        return tween;
      };
      module.exports = NumberTweenBuilder;
    }
  });

  // ../../node_modules/phaser/src/tweens/builders/StaggerBuilder.js
  var require_StaggerBuilder = __commonJS({
    "../../node_modules/phaser/src/tweens/builders/StaggerBuilder.js": function(exports, module) {
      var GetEaseFunction = require_GetEaseFunction();
      var GetValue = require_GetValue();
      var MATH_CONST = require_const4();
      var StaggerBuilder = function(value, options) {
        if (options === void 0) {
          options = {};
        }
        var result;
        var start = GetValue(options, "start", 0);
        var ease = GetValue(options, "ease", null);
        var grid = GetValue(options, "grid", null);
        var from = GetValue(options, "from", 0);
        var fromFirst = from === "first";
        var fromCenter = from === "center";
        var fromLast = from === "last";
        var fromValue = typeof from === "number";
        var isRange = Array.isArray(value);
        var value1 = isRange ? parseFloat(value[0]) : parseFloat(value);
        var value2 = isRange ? parseFloat(value[1]) : 0;
        var maxValue = Math.max(value1, value2);
        if (isRange) {
          start += value1;
        }
        if (grid) {
          var gridWidth = grid[0];
          var gridHeight = grid[1];
          var fromX = 0;
          var fromY = 0;
          var distanceX = 0;
          var distanceY = 0;
          var gridValues = [];
          if (fromLast) {
            fromX = gridWidth - 1;
            fromY = gridHeight - 1;
          } else if (fromValue) {
            fromX = from % gridWidth;
            fromY = Math.floor(from / gridWidth);
          } else if (fromCenter) {
            fromX = (gridWidth - 1) / 2;
            fromY = (gridHeight - 1) / 2;
          }
          var gridMax = MATH_CONST.MIN_SAFE_INTEGER;
          for (var toY = 0; toY < gridHeight; toY++) {
            gridValues[toY] = [];
            for (var toX = 0; toX < gridWidth; toX++) {
              distanceX = fromX - toX;
              distanceY = fromY - toY;
              var dist = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
              if (dist > gridMax) {
                gridMax = dist;
              }
              gridValues[toY][toX] = dist;
            }
          }
        }
        var easeFunction = ease ? GetEaseFunction(ease) : null;
        if (grid) {
          result = function(target, key, value3, index) {
            var gridSpace = 0;
            var toX2 = index % gridWidth;
            var toY2 = Math.floor(index / gridWidth);
            if (toX2 >= 0 && toX2 < gridWidth && toY2 >= 0 && toY2 < gridHeight) {
              gridSpace = gridValues[toY2][toX2];
            }
            var output;
            if (isRange) {
              var diff = value2 - value1;
              if (easeFunction) {
                output = gridSpace / gridMax * diff * easeFunction(gridSpace / gridMax);
              } else {
                output = gridSpace / gridMax * diff;
              }
            } else if (easeFunction) {
              output = gridSpace * value1 * easeFunction(gridSpace / gridMax);
            } else {
              output = gridSpace * value1;
            }
            return output + start;
          };
        } else {
          result = function(target, key, value3, index, total) {
            total--;
            var fromIndex;
            if (fromFirst) {
              fromIndex = index;
            } else if (fromCenter) {
              fromIndex = Math.abs(total / 2 - index);
            } else if (fromLast) {
              fromIndex = total - index;
            } else if (fromValue) {
              fromIndex = Math.abs(from - index);
            }
            var output;
            if (isRange) {
              var spacing;
              if (fromCenter) {
                spacing = (value2 - value1) / total * (fromIndex * 2);
              } else {
                spacing = (value2 - value1) / total * fromIndex;
              }
              if (easeFunction) {
                output = spacing * easeFunction(fromIndex / total);
              } else {
                output = spacing;
              }
            } else if (easeFunction) {
              output = total * maxValue * easeFunction(fromIndex / total);
            } else {
              output = fromIndex * value1;
            }
            return output + start;
          };
        }
        return result;
      };
      module.exports = StaggerBuilder;
    }
  });

  // ../../node_modules/phaser/src/tweens/builders/TweenBuilder.js
  var require_TweenBuilder = __commonJS({
    "../../node_modules/phaser/src/tweens/builders/TweenBuilder.js": function(exports, module) {
      var BaseTween = require_BaseTween();
      var Defaults = require_Defaults();
      var GetAdvancedValue = require_GetAdvancedValue();
      var GetBoolean = require_GetBoolean();
      var GetEaseFunction = require_GetEaseFunction();
      var GetInterpolationFunction = require_GetInterpolationFunction();
      var GetNewValue = require_GetNewValue();
      var GetProps = require_GetProps();
      var GetTargets = require_GetTargets();
      var GetValue = require_GetValue();
      var GetValueOp = require_GetValueOp();
      var MergeRight = require_MergeRight();
      var Tween = require_Tween();
      var TweenBuilder = function(parent, config, defaults) {
        if (config instanceof Tween) {
          config.parent = parent;
          return config;
        }
        if (defaults === void 0) {
          defaults = Defaults;
        } else {
          defaults = MergeRight(Defaults, defaults);
        }
        var targets = GetTargets(config);
        if (!targets && defaults.targets) {
          targets = defaults.targets;
        }
        var props = GetProps(config);
        var delay = GetValue(config, "delay", defaults.delay);
        var duration = GetValue(config, "duration", defaults.duration);
        var easeParams = GetValue(config, "easeParams", defaults.easeParams);
        var ease = GetValue(config, "ease", defaults.ease);
        var hold = GetValue(config, "hold", defaults.hold);
        var repeat = GetValue(config, "repeat", defaults.repeat);
        var repeatDelay = GetValue(config, "repeatDelay", defaults.repeatDelay);
        var yoyo = GetBoolean(config, "yoyo", defaults.yoyo);
        var flipX = GetBoolean(config, "flipX", defaults.flipX);
        var flipY = GetBoolean(config, "flipY", defaults.flipY);
        var interpolation = GetValue(config, "interpolation", defaults.interpolation);
        var addTarget = function(tween2, targetIndex2, key2, value2) {
          if (key2 === "texture") {
            var texture = value2;
            var frame = void 0;
            if (Array.isArray(value2)) {
              texture = value2[0];
              frame = value2[1];
            } else if (value2.hasOwnProperty("value")) {
              texture = value2.value;
              if (Array.isArray(value2.value)) {
                texture = value2.value[0];
                frame = value2.value[1];
              } else if (typeof value2.value === "string") {
                texture = value2.value;
              }
            } else if (typeof value2 === "string") {
              texture = value2;
            }
            tween2.addFrame(targetIndex2, texture, frame, GetNewValue(value2, "delay", delay), GetValue(value2, "duration", duration), GetValue(value2, "hold", hold), GetValue(value2, "repeat", repeat), GetValue(value2, "repeatDelay", repeatDelay), GetBoolean(value2, "flipX", flipX), GetBoolean(value2, "flipY", flipY));
          } else {
            var ops = GetValueOp(key2, value2);
            var interpolationFunc = GetInterpolationFunction(GetValue(value2, "interpolation", interpolation));
            tween2.add(targetIndex2, key2, ops.getEnd, ops.getStart, ops.getActive, GetEaseFunction(GetValue(value2, "ease", ease), GetValue(value2, "easeParams", easeParams)), GetNewValue(value2, "delay", delay), GetValue(value2, "duration", duration), GetBoolean(value2, "yoyo", yoyo), GetValue(value2, "hold", hold), GetValue(value2, "repeat", repeat), GetValue(value2, "repeatDelay", repeatDelay), GetBoolean(value2, "flipX", flipX), GetBoolean(value2, "flipY", flipY), interpolationFunc, interpolationFunc ? value2 : null);
          }
        };
        var tween = new Tween(parent, targets);
        for (var p = 0; p < props.length; p++) {
          var key = props[p].key;
          var value = props[p].value;
          for (var targetIndex = 0; targetIndex < targets.length; targetIndex++) {
            if (key === "scale" && !targets[targetIndex].hasOwnProperty("scale")) {
              addTarget(tween, targetIndex, "scaleX", value);
              addTarget(tween, targetIndex, "scaleY", value);
            } else {
              addTarget(tween, targetIndex, key, value);
            }
          }
        }
        tween.completeDelay = GetAdvancedValue(config, "completeDelay", 0);
        tween.loop = Math.round(GetAdvancedValue(config, "loop", 0));
        tween.loopDelay = Math.round(GetAdvancedValue(config, "loopDelay", 0));
        tween.paused = GetBoolean(config, "paused", false);
        tween.persist = GetBoolean(config, "persist", false);
        tween.callbackScope = GetValue(config, "callbackScope", tween);
        var callbacks = BaseTween.TYPES;
        for (var i = 0; i < callbacks.length; i++) {
          var type = callbacks[i];
          var callback = GetValue(config, type, false);
          if (callback) {
            var callbackParams = GetValue(config, type + "Params", []);
            tween.setCallback(type, callback, callbackParams);
          }
        }
        return tween;
      };
      module.exports = TweenBuilder;
    }
  });

  // ../../node_modules/phaser/src/tweens/builders/index.js
  var require_builders = __commonJS({
    "../../node_modules/phaser/src/tweens/builders/index.js": function(exports, module) {
      module.exports = {
        GetBoolean: require_GetBoolean(),
        GetEaseFunction: require_GetEaseFunction(),
        GetInterpolationFunction: require_GetInterpolationFunction(),
        GetNewValue: require_GetNewValue(),
        GetProps: require_GetProps(),
        GetTargets: require_GetTargets(),
        GetValueOp: require_GetValueOp(),
        NumberTweenBuilder: require_NumberTweenBuilder(),
        StaggerBuilder: require_StaggerBuilder(),
        TweenBuilder: require_TweenBuilder()
      };
    }
  });

  // ../../node_modules/phaser/src/tweens/tween/TweenChain.js
  var require_TweenChain = __commonJS({
    "../../node_modules/phaser/src/tweens/tween/TweenChain.js": function(exports, module) {
      var ArrayRemove = require_Remove();
      var BaseTween = require_BaseTween();
      var Class = require_Class();
      var Events = require_events20();
      var GameObjectCreator = require_GameObjectCreator();
      var GameObjectFactory = require_GameObjectFactory();
      var TWEEN_CONST = require_const5();
      var TweenChain = new Class({
        Extends: BaseTween,
        initialize: function TweenChain2(parent) {
          BaseTween.call(this, parent);
          this.currentTween = null;
          this.currentIndex = 0;
        },
        init: function() {
          this.loopCounter = this.loop === -1 ? TWEEN_CONST.MAX : this.loop;
          this.setCurrentTween(0);
          if (this.startDelay > 0 && !this.isStartDelayed()) {
            this.setStartDelayState();
          } else {
            this.setActiveState();
          }
          this.dispatchEvent(Events.TWEEN_ACTIVE, "onActive");
          return this;
        },
        add: function(tweens) {
          var newTweens = this.parent.create(tweens);
          if (!Array.isArray(newTweens)) {
            newTweens = [newTweens];
          }
          var data = this.data;
          for (var i = 0; i < newTweens.length; i++) {
            var tween = newTweens[i];
            tween.parent = this;
            data.push(tween.reset());
          }
          this.totalData = data.length;
          return this;
        },
        remove: function(tween) {
          ArrayRemove(this.data, tween);
          tween.setRemovedState();
          if (tween === this.currentTween) {
            this.nextTween();
          }
          this.totalData = this.data.length;
          return this;
        },
        hasTarget: function(target) {
          var data = this.data;
          for (var i = 0; i < this.totalData; i++) {
            if (data[i].hasTarget(target)) {
              return true;
            }
          }
          return false;
        },
        restart: function() {
          if (this.isDestroyed()) {
            console.warn("Cannot restart destroyed TweenChain", this);
            return this;
          }
          if (this.isRemoved()) {
            this.parent.makeActive(this);
          }
          this.resetTweens();
          this.paused = false;
          return this.init();
        },
        reset: function(tween) {
          tween.seek();
          tween.setActiveState();
          return this;
        },
        makeActive: function(tween) {
          tween.reset();
          tween.setActiveState();
          return this;
        },
        nextState: function() {
          if (this.loopCounter > 0) {
            this.loopCounter--;
            this.resetTweens();
            if (this.loopDelay > 0) {
              this.countdown = this.loopDelay;
              this.setLoopDelayState();
            } else {
              this.setActiveState();
              this.dispatchEvent(Events.TWEEN_LOOP, "onLoop");
            }
          } else if (this.completeDelay > 0) {
            this.countdown = this.completeDelay;
            this.setCompleteDelayState();
          } else {
            this.onCompleteHandler();
            return true;
          }
          return false;
        },
        play: function() {
          if (this.isDestroyed()) {
            console.warn("Cannot play destroyed TweenChain", this);
            return this;
          }
          if (this.isPendingRemove() || this.isPending()) {
            this.resetTweens();
          }
          this.paused = false;
          if (this.startDelay > 0 && !this.isStartDelayed()) {
            this.setStartDelayState();
          } else {
            this.setActiveState();
          }
          return this;
        },
        resetTweens: function() {
          var data = this.data;
          var total = this.totalData;
          for (var i = 0; i < total; i++) {
            data[i].reset(false);
          }
          this.currentIndex = 0;
          this.currentTween = data[0];
        },
        update: function(delta) {
          if (this.isPendingRemove() || this.isDestroyed()) {
            return true;
          } else if (this.isFinished() || this.paused) {
            return false;
          }
          delta *= this.parent.timeScale;
          if (this.isLoopDelayed()) {
            this.updateLoopCountdown(delta);
          } else if (this.isCompleteDelayed()) {
            this.updateCompleteDelay(delta);
          } else if (this.isStartDelayed()) {
            delta = this.updateStartCountdown(delta);
          }
          var remove = false;
          if (this.isActive() && this.currentTween) {
            if (this.currentTween.update(delta)) {
              if (this.nextTween()) {
                this.nextState();
              }
            }
            remove = this.isPendingRemove();
            if (remove && this.persist) {
              this.setFinishedState();
              remove = false;
            }
          }
          return remove;
        },
        nextTween: function() {
          this.currentIndex++;
          if (this.currentIndex === this.totalData) {
            return true;
          } else {
            this.setCurrentTween(this.currentIndex);
          }
          return false;
        },
        setCurrentTween: function(index) {
          this.currentIndex = index;
          this.currentTween = this.data[index];
          this.currentTween.setActiveState();
          this.currentTween.dispatchEvent(Events.TWEEN_ACTIVE, "onActive");
        },
        dispatchEvent: function(event, callback) {
          this.emit(event, this);
          var handler = this.callbacks[callback];
          if (handler) {
            handler.func.apply(this.callbackScope, [this].concat(handler.params));
          }
        },
        destroy: function() {
          BaseTween.prototype.destroy.call(this);
          this.currentTween = null;
        }
      });
      GameObjectFactory.register("tweenchain", function(config) {
        return this.scene.sys.tweens.chain(config);
      });
      GameObjectCreator.register("tweenchain", function(config) {
        return this.scene.sys.tweens.create(config);
      });
      module.exports = TweenChain;
    }
  });

  // ../../node_modules/phaser/src/tweens/builders/TweenChainBuilder.js
  var require_TweenChainBuilder = __commonJS({
    "../../node_modules/phaser/src/tweens/builders/TweenChainBuilder.js": function(exports, module) {
      var BaseTween = require_BaseTween();
      var GetAdvancedValue = require_GetAdvancedValue();
      var GetBoolean = require_GetBoolean();
      var GetTargets = require_GetTargets();
      var GetValue = require_GetValue();
      var TweenBuilder = require_TweenBuilder();
      var TweenChain = require_TweenChain();
      var TweenChainBuilder = function(parent, config) {
        if (config instanceof TweenChain) {
          config.parent = parent;
          return config;
        }
        var chain = new TweenChain(parent);
        chain.startDelay = GetValue(config, "delay", 0);
        chain.completeDelay = GetAdvancedValue(config, "completeDelay", 0);
        chain.loop = Math.round(GetAdvancedValue(config, "loop", GetValue(config, "repeat", 0)));
        chain.loopDelay = Math.round(GetAdvancedValue(config, "loopDelay", GetValue(config, "repeatDelay", 0)));
        chain.paused = GetBoolean(config, "paused", false);
        chain.persist = GetBoolean(config, "persist", true);
        chain.callbackScope = GetValue(config, "callbackScope", chain);
        var i;
        var callbacks = BaseTween.TYPES;
        for (i = 0; i < callbacks.length; i++) {
          var type = callbacks[i];
          var callback = GetValue(config, type, false);
          if (callback) {
            var callbackParams = GetValue(config, type + "Params", []);
            chain.setCallback(type, callback, callbackParams);
          }
        }
        var tweens = GetValue(config, "tweens", null);
        if (Array.isArray(tweens)) {
          var chainedTweens = [];
          var targets = GetTargets(config);
          var defaults = void 0;
          if (targets) {
            defaults = { targets: targets };
          }
          for (i = 0; i < tweens.length; i++) {
            chainedTweens.push(TweenBuilder(chain, tweens[i], defaults));
          }
          chain.add(chainedTweens);
        }
        return chain;
      };
      module.exports = TweenChainBuilder;
    }
  });

  // ../../node_modules/phaser/src/tweens/TweenManager.js
  var require_TweenManager = __commonJS({
    "../../node_modules/phaser/src/tweens/TweenManager.js": function(exports, module) {
      var ArrayRemove = require_Remove();
      var Class = require_Class();
      var Flatten = require_Flatten();
      var NumberTweenBuilder = require_NumberTweenBuilder();
      var PluginCache = require_PluginCache();
      var SceneEvents = require_events();
      var StaggerBuilder = require_StaggerBuilder();
      var Tween = require_Tween();
      var TweenBuilder = require_TweenBuilder();
      var TweenChain = require_TweenChain();
      var TweenChainBuilder = require_TweenChainBuilder();
      var TweenManager = new Class({
        initialize: function TweenManager2(scene) {
          this.scene = scene;
          this.events = scene.sys.events;
          this.timeScale = 1;
          this.paused = false;
          this.processing = false;
          this.tweens = [];
          this.time = 0;
          this.startTime = 0;
          this.nextTime = 0;
          this.prevTime = 0;
          this.maxLag = 500;
          this.lagSkip = 33;
          this.gap = 1e3 / 240;
          this.events.once(SceneEvents.BOOT, this.boot, this);
          this.events.on(SceneEvents.START, this.start, this);
        },
        boot: function() {
          this.events.once(SceneEvents.DESTROY, this.destroy, this);
        },
        start: function() {
          this.timeScale = 1;
          this.paused = false;
          this.startTime = Date.now();
          this.prevTime = this.startTime;
          this.nextTime = this.gap;
          this.events.on(SceneEvents.UPDATE, this.update, this);
          this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        create: function(config) {
          if (!Array.isArray(config)) {
            config = [config];
          }
          var result = [];
          for (var i = 0; i < config.length; i++) {
            var tween = config[i];
            if (tween instanceof Tween || tween instanceof TweenChain) {
              result.push(tween);
            } else if (Array.isArray(tween.tweens)) {
              result.push(TweenChainBuilder(this, tween));
            } else {
              result.push(TweenBuilder(this, tween));
            }
          }
          return result.length === 1 ? result[0] : result;
        },
        add: function(config) {
          var tween = config;
          var tweens = this.tweens;
          if (tween instanceof Tween || tween instanceof TweenChain) {
            tweens.push(tween.reset());
          } else {
            if (Array.isArray(tween.tweens)) {
              tween = TweenChainBuilder(this, tween);
            } else {
              tween = TweenBuilder(this, tween);
            }
            tweens.push(tween.reset());
          }
          return tween;
        },
        addMultiple: function(configs) {
          var tween;
          var result = [];
          var tweens = this.tweens;
          for (var i = 0; i < configs.length; i++) {
            tween = configs[i];
            if (tween instanceof Tween || tween instanceof TweenChain) {
              tweens.push(tween.reset());
            } else {
              if (Array.isArray(tween.tweens)) {
                tween = TweenChainBuilder(this, tween);
              } else {
                tween = TweenBuilder(this, tween);
              }
              tweens.push(tween.reset());
            }
            result.push(tween);
          }
          return result;
        },
        chain: function(config) {
          var chain = TweenChainBuilder(this, config);
          this.tweens.push(chain.init());
          return chain;
        },
        getChainedTweens: function(tween) {
          return tween.getChainedTweens();
        },
        has: function(tween) {
          return this.tweens.indexOf(tween) > -1;
        },
        existing: function(tween) {
          if (!this.has(tween)) {
            this.tweens.push(tween.reset());
          }
          return this;
        },
        addCounter: function(config) {
          var tween = NumberTweenBuilder(this, config);
          this.tweens.push(tween.reset());
          return tween;
        },
        stagger: function(value, options) {
          return StaggerBuilder(value, options);
        },
        setLagSmooth: function(limit, skip) {
          if (limit === void 0) {
            limit = 1 / 1e-8;
          }
          if (skip === void 0) {
            skip = 0;
          }
          this.maxLag = limit;
          this.lagSkip = Math.min(skip, this.maxLag);
          return this;
        },
        setFps: function(fps) {
          if (fps === void 0) {
            fps = 240;
          }
          this.gap = 1e3 / fps;
          this.nextTime = this.time * 1e3 + this.gap;
          return this;
        },
        getDelta: function(tick) {
          var elapsed = Date.now() - this.prevTime;
          if (elapsed > this.maxLag) {
            this.startTime += elapsed - this.lagSkip;
          }
          this.prevTime += elapsed;
          var time = this.prevTime - this.startTime;
          var overlap = time - this.nextTime;
          var delta = time - this.time * 1e3;
          if (overlap > 0 || tick) {
            time /= 1e3;
            this.time = time;
            this.nextTime += overlap + (overlap >= this.gap ? 4 : this.gap - overlap);
          } else {
            delta = 0;
          }
          return delta;
        },
        tick: function() {
          this.step(true);
          return this;
        },
        update: function() {
          if (!this.paused) {
            this.step(false);
          }
        },
        step: function(tick) {
          if (tick === void 0) {
            tick = false;
          }
          var delta = this.getDelta(tick);
          if (delta <= 0) {
            return;
          }
          this.processing = true;
          var i;
          var tween;
          var toDestroy = [];
          var list = this.tweens;
          for (i = 0; i < list.length; i++) {
            tween = list[i];
            if (tween.update(delta)) {
              toDestroy.push(tween);
            }
          }
          var count = toDestroy.length;
          if (count && list.length > 0) {
            for (i = 0; i < count; i++) {
              tween = toDestroy[i];
              var idx = list.indexOf(tween);
              if (idx > -1 && (tween.isPendingRemove() || tween.isDestroyed())) {
                list.splice(idx, 1);
                tween.destroy();
              }
            }
            toDestroy.length = 0;
          }
          this.processing = false;
        },
        remove: function(tween) {
          if (this.processing) {
            tween.setPendingRemoveState();
          } else {
            ArrayRemove(this.tweens, tween);
            tween.setRemovedState();
          }
          return this;
        },
        reset: function(tween) {
          this.existing(tween);
          tween.seek();
          tween.setActiveState();
          return this;
        },
        makeActive: function(tween) {
          this.existing(tween);
          tween.setActiveState();
          return this;
        },
        each: function(callback, scope) {
          var i;
          var args = [null];
          for (i = 1; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          this.tweens.forEach(function(tween) {
            args[0] = tween;
            callback.apply(scope, args);
          });
          return this;
        },
        getTweens: function() {
          return this.tweens.slice();
        },
        getTweensOf: function(target) {
          var output = [];
          var list = this.tweens;
          if (!Array.isArray(target)) {
            target = [target];
          } else {
            target = Flatten(target);
          }
          var targetLen = target.length;
          for (var i = 0; i < list.length; i++) {
            var tween = list[i];
            for (var t = 0; t < targetLen; t++) {
              if (!tween.isDestroyed() && tween.hasTarget(target[t])) {
                output.push(tween);
              }
            }
          }
          return output;
        },
        getGlobalTimeScale: function() {
          return this.timeScale;
        },
        setGlobalTimeScale: function(value) {
          this.timeScale = value;
          return this;
        },
        isTweening: function(target) {
          var list = this.tweens;
          var tween;
          for (var i = 0; i < list.length; i++) {
            tween = list[i];
            if (tween.isPlaying() && tween.hasTarget(target)) {
              return true;
            }
          }
          return false;
        },
        killAll: function() {
          var tweens = this.processing ? this.getTweens() : this.tweens;
          for (var i = 0; i < tweens.length; i++) {
            tweens[i].destroy();
          }
          if (!this.processing) {
            tweens.length = 0;
          }
          return this;
        },
        killTweensOf: function(target) {
          var tweens = this.getTweensOf(target);
          for (var i = 0; i < tweens.length; i++) {
            tweens[i].destroy();
          }
          return this;
        },
        pauseAll: function() {
          this.paused = true;
          return this;
        },
        resumeAll: function() {
          this.paused = false;
          return this;
        },
        shutdown: function() {
          this.killAll();
          this.tweens = [];
          this.events.off(SceneEvents.UPDATE, this.update, this);
          this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
        },
        destroy: function() {
          this.shutdown();
          this.events.off(SceneEvents.START, this.start, this);
          this.scene = null;
          this.events = null;
        }
      });
      PluginCache.register("TweenManager", TweenManager, "tweens");
      module.exports = TweenManager;
    }
  });

  // ../../node_modules/phaser/src/tweens/index.js
  var require_tweens = __commonJS({
    "../../node_modules/phaser/src/tweens/index.js": function(exports, module) {
      var Tweens = {
        States: require_const5(),
        Builders: require_builders(),
        Events: require_events20(),
        TweenManager: require_TweenManager(),
        Tween: require_Tween(),
        TweenData: require_TweenData(),
        TweenFrameData: require_TweenFrameData(),
        BaseTween: require_BaseTween(),
        TweenChain: require_TweenChain()
      };
      module.exports = Tweens;
    }
  });

  // ../../node_modules/phaser/src/utils/object/GetMinMaxValue.js
  var require_GetMinMaxValue = __commonJS({
    "../../node_modules/phaser/src/utils/object/GetMinMaxValue.js": function(exports, module) {
      var GetValue = require_GetValue();
      var Clamp = require_Clamp();
      var GetMinMaxValue = function(source, key, min, max, defaultValue) {
        if (defaultValue === void 0) {
          defaultValue = min;
        }
        var value = GetValue(source, key, defaultValue);
        return Clamp(value, min, max);
      };
      module.exports = GetMinMaxValue;
    }
  });

  // ../../node_modules/phaser/src/utils/object/HasAll.js
  var require_HasAll = __commonJS({
    "../../node_modules/phaser/src/utils/object/HasAll.js": function(exports, module) {
      var HasAll = function(source, keys) {
        for (var i = 0; i < keys.length; i++) {
          if (!source.hasOwnProperty(keys[i])) {
            return false;
          }
        }
        return true;
      };
      module.exports = HasAll;
    }
  });

  // ../../node_modules/phaser/src/utils/object/Pick.js
  var require_Pick = __commonJS({
    "../../node_modules/phaser/src/utils/object/Pick.js": function(exports, module) {
      var HasValue = require_HasValue();
      var Pick = function(object, keys) {
        var obj = {};
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (HasValue(object, key)) {
            obj[key] = object[key];
          }
        }
        return obj;
      };
      module.exports = Pick;
    }
  });

  // ../../node_modules/phaser/src/utils/object/SetValue.js
  var require_SetValue = __commonJS({
    "../../node_modules/phaser/src/utils/object/SetValue.js": function(exports, module) {
      var SetValue = function(source, key, value) {
        if (!source || typeof source === "number") {
          return false;
        } else if (source.hasOwnProperty(key)) {
          source[key] = value;
          return true;
        } else if (key.indexOf(".") !== -1) {
          var keys = key.split(".");
          var parent = source;
          var prev = source;
          for (var i = 0; i < keys.length; i++) {
            if (parent.hasOwnProperty(keys[i])) {
              prev = parent;
              parent = parent[keys[i]];
            } else {
              return false;
            }
          }
          prev[keys[keys.length - 1]] = value;
          return true;
        }
        return false;
      };
      module.exports = SetValue;
    }
  });

  // ../../node_modules/phaser/src/utils/object/index.js
  var require_object = __commonJS({
    "../../node_modules/phaser/src/utils/object/index.js": function(exports, module) {
      module.exports = {
        Clone: require_Clone(),
        DeepCopy: require_DeepCopy(),
        Extend: require_Extend(),
        GetAdvancedValue: require_GetAdvancedValue(),
        GetFastValue: require_GetFastValue(),
        GetMinMaxValue: require_GetMinMaxValue(),
        GetValue: require_GetValue(),
        HasAll: require_HasAll(),
        HasAny: require_HasAny(),
        HasValue: require_HasValue(),
        IsPlainObject: require_IsPlainObject(),
        Merge: require_Merge(),
        MergeRight: require_MergeRight(),
        Pick: require_Pick(),
        SetValue: require_SetValue()
      };
    }
  });

  // ../../node_modules/phaser/src/utils/string/UUID.js
  var require_UUID = __commonJS({
    "../../node_modules/phaser/src/utils/string/UUID.js": function(exports, module) {
      var UUID = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
          var r = Math.random() * 16 | 0;
          var v = c === "x" ? r : r & 3 | 8;
          return v.toString(16);
        });
      };
      module.exports = UUID;
    }
  });

  // phaser.custom.config.js
  var require_phaser_custom_config = __commonJS({
    "phaser.custom.config.js": function(exports, module) {
      require_polyfills();
      var CONST = require_const();
      var Extend = require_Extend();
      var Phaser = {
        Actions: {
          GridAlign: require_GridAlign()
        },
        Cache: require_cache(),
        Cameras: require_cameras(),
        Core: require_core(),
        Curves: {
          Spline: require_SplineCurve(),
          Ellipse: require_EllipseCurve()
        },
        Data: require_data(),
        Display: {
          Align: require_align(),
          Bounds: require_bounds(),
          Masks: require_mask(),
          Canvas: require_canvas(),
          Color: require_color()
        },
        Events: require_events11(),
        Game: require_Game(),
        GameObjects: {
          Events: require_events3(),
          RenderTexture: require_RenderTexture(),
          Container: require_Container(),
          DisplayList: require_DisplayList(),
          GameObjectCreator: require_GameObjectCreator(),
          GameObjectFactory: require_GameObjectFactory(),
          UpdateList: require_UpdateList(),
          Components: require_components(),
          BuildGameObject: require_BuildGameObject(),
          BuildGameObjectAnimation: require_BuildGameObjectAnimation(),
          GameObject: require_GameObject(),
          Graphics: require_Graphics(),
          Image: require_Image(),
          Shape: require_Shape(),
          Ellipse: require_Ellipse2(),
          Line: require_Line2(),
          Rectangle: require_Rectangle2(),
          Group: require_Group(),
          Sprite: require_Sprite(),
          Text: require_Text(),
          BitmapText: require_BitmapText(),
          Particles: require_particles(),
          Factories: {
            Container: require_ContainerFactory(),
            Graphics: require_GraphicsFactory(),
            Group: require_GroupFactory(),
            Image: require_ImageFactory(),
            Sprite: require_SpriteFactory(),
            Text: require_TextFactory(),
            BitmapText: require_BitmapTextFactory(),
            Particles: require_ParticleEmitterFactory(),
            RenderTexture: require_RenderTextureFactory(),
            Line: require_LineFactory(),
            Rectangle: require_RectangleFactory(),
            Ellipse: require_EllipseFactory()
          },
          Creators: {
            Graphics: require_GraphicsCreator(),
            Image: require_ImageCreator(),
            Text: require_TextCreator(),
            BitmapText: require_BitmapTextCreator(),
            RenderTexture: require_RenderTextureCreator()
          }
        },
        Geom: {
          Point: require_point(),
          Rectangle: require_rectangle(),
          Circle: require_circle()
        },
        Input: require_input(),
        Loader: {
          Events: require_events14(),
          FileTypes: {
            AtlasJSONFile: require_AtlasJSONFile(),
            BitmapFontFile: require_BitmapFontFile(),
            CSSFile: require_CSSFile(),
            ImageFile: require_ImageFile(),
            JSONFile: require_JSONFile(),
            ScriptFile: require_ScriptFile(),
            XMLFile: require_XMLFile()
          },
          File: require_File(),
          FileTypesManager: require_FileTypesManager(),
          GetURL: require_GetURL(),
          LoaderPlugin: require_LoaderPlugin(),
          MergeXHRSettings: require_MergeXHRSettings(),
          MultiFile: require_MultiFile(),
          XHRLoader: require_XHRLoader(),
          XHRSettings: require_XHRSettings()
        },
        Math: require_math(),
        Physics: {},
        Plugins: require_plugins(),
        Renderer: require_renderer(),
        Scale: require_scale(),
        Scene: require_Scene(),
        Scenes: require_scene(),
        Structs: {
          Events: require_events16(),
          List: require_List(),
          Map: require_Map(),
          ProcessQueue: require_ProcessQueue(),
          Set: require_Set(),
          Size: require_Size2()
        },
        Textures: require_textures(),
        Time: require_time(),
        Tweens: require_tweens(),
        Utils: {
          Array: require_array(),
          Class: require_Class(),
          Objects: require_object(),
          String: {
            UUID: require_UUID()
          }
        }
      };
      Phaser = Extend(false, Phaser, CONST);
      module.exports = Phaser;
    }
  });
  return require_phaser_custom_config();
})();
